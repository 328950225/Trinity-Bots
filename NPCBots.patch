From 0d15ba8855dda9ebef280b737b1afb0f83b8d1f2 Mon Sep 17 00:00:00 2001
From: trickerer <onlysuffering@gmail.com>
Date: Fri, 14 Jun 2019 15:24:07 +0700
Subject: [PATCH] NpcBots full 190614

---
 cmake/macros/FindGit.cmake                         |     2 +-
 sql/Bots/character_bots.sql                        |    26 +
 sql/Bots/world_bots.sql                            |   632 ++
 src/server/game/AI/NpcBots/bot_Events.h            |    55 +
 src/server/game/AI/NpcBots/bot_GridNotifiers.h     |  1055 ++
 src/server/game/AI/NpcBots/bot_ai.cpp              | 10915 +++++++++++++++++++
 src/server/game/AI/NpcBots/bot_ai.h                |   543 +
 src/server/game/AI/NpcBots/bot_bm_ai.cpp           |   974 ++
 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp |  1588 +++
 src/server/game/AI/NpcBots/bot_druid_ai.cpp        |  2625 +++++
 src/server/game/AI/NpcBots/bot_hunter_ai.cpp       |  2065 ++++
 src/server/game/AI/NpcBots/bot_mage_ai.cpp         |  1470 +++
 src/server/game/AI/NpcBots/bot_paladin_ai.cpp      |  2623 +++++
 src/server/game/AI/NpcBots/bot_priest_ai.cpp       |  1455 +++
 src/server/game/AI/NpcBots/bot_rogue_ai.cpp        |  1967 ++++
 src/server/game/AI/NpcBots/bot_shaman_ai.cpp       |  2495 +++++
 src/server/game/AI/NpcBots/bot_warlock_ai.cpp      |  1506 +++
 src/server/game/AI/NpcBots/bot_warrior_ai.cpp      |  1980 ++++
 src/server/game/AI/NpcBots/botcommands.cpp         |   940 ++
 src/server/game/AI/NpcBots/botcommon.h             |   401 +
 src/server/game/AI/NpcBots/botdatamgr.cpp          |   294 +
 src/server/game/AI/NpcBots/botdatamgr.h            |    49 +
 src/server/game/AI/NpcBots/botmgr.cpp              |   877 ++
 src/server/game/AI/NpcBots/botmgr.h                |   119 +
 src/server/game/CMakeLists.txt                     |     1 +
 src/server/game/DataStores/DBCStores.cpp           |     4 +-
 src/server/game/DataStores/DBCStores.h             |     2 +-
 src/server/game/DataStores/DBCStructure.h          |     2 +-
 src/server/game/DataStores/DBCfmt.h                |     2 +-
 src/server/game/DungeonFinding/LFGMgr.cpp          |   161 +
 src/server/game/Entities/Creature/Creature.cpp     |   497 +-
 src/server/game/Entities/Creature/Creature.h       |    92 +
 .../game/Entities/Creature/TemporarySummon.cpp     |    25 +
 src/server/game/Entities/Object/Object.cpp         |    20 +
 src/server/game/Entities/Player/Player.cpp         |   123 +
 src/server/game/Entities/Player/Player.h           |    26 +
 src/server/game/Entities/Totem/Totem.cpp           |     7 +
 src/server/game/Entities/Unit/StatSystem.cpp       |    33 +-
 src/server/game/Entities/Unit/Unit.cpp             |   762 ++
 src/server/game/Entities/Unit/Unit.h               |     3 +
 src/server/game/Globals/ObjectMgr.cpp              |    76 +
 src/server/game/Globals/ObjectMgr.h                |    20 +
 src/server/game/Groups/Group.cpp                   |    53 +
 src/server/game/Groups/Group.h                     |     3 +
 src/server/game/Handlers/SpellHandler.cpp          |    30 +
 src/server/game/Maps/Map.cpp                       |    27 +
 src/server/game/Maps/MapManager.cpp                |     8 +
 src/server/game/Movement/MotionMaster.cpp          |    14 +
 src/server/game/OutdoorPvP/OutdoorPvP.cpp          |    17 +
 src/server/game/Scripting/ScriptLoader.cpp         |    32 +
 src/server/game/Server/WorldSession.cpp            |     4 +
 src/server/game/Spells/Auras/SpellAuraEffects.cpp  |    24 +
 src/server/game/Spells/Auras/SpellAuras.cpp        |     8 +
 src/server/game/Spells/Spell.cpp                   |    74 +
 src/server/game/Spells/Spell.h                     |     1 +
 src/server/game/Spells/SpellEffects.cpp            |    96 +
 src/server/game/Spells/SpellInfo.cpp               |    17 +
 src/server/game/World/World.cpp                    |     3 +
 src/server/scripts/Spells/spell_hunter.cpp         |    16 +
 src/server/scripts/Spells/spell_paladin.cpp        |    86 +
 src/server/scripts/Spells/spell_priest.cpp         |     4 +
 src/server/scripts/Spells/spell_rogue.cpp          |    40 +
 src/server/scripts/Spells/spell_shaman.cpp         |    10 +
 .../Database/Implementation/CharacterDatabase.cpp  |    15 +
 .../Database/Implementation/CharacterDatabase.h    |    11 +
 src/server/worldserver/worldserver.conf.dist       |   115 +
 66 files changed, 39211 insertions(+), 9 deletions(-)
 create mode 100644 sql/Bots/character_bots.sql
 create mode 100644 sql/Bots/world_bots.sql
 create mode 100644 src/server/game/AI/NpcBots/bot_Events.h
 create mode 100644 src/server/game/AI/NpcBots/bot_GridNotifiers.h
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bot_bm_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_druid_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_hunter_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_mage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_paladin_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_priest_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_rogue_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_shaman_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warlock_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warrior_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommands.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommon.h
 create mode 100644 src/server/game/AI/NpcBots/botdatamgr.cpp
 create mode 100644 src/server/game/AI/NpcBots/botdatamgr.h
 create mode 100644 src/server/game/AI/NpcBots/botmgr.cpp
 create mode 100644 src/server/game/AI/NpcBots/botmgr.h

diff --git a/cmake/macros/FindGit.cmake b/cmake/macros/FindGit.cmake
index c23601d..e394741 100644
--- a/cmake/macros/FindGit.cmake
+++ b/cmake/macros/FindGit.cmake
@@ -13,7 +13,7 @@ set(_REQUIRED_GIT_VERSION "1.7")
 
 find_program(GIT_EXECUTABLE
   NAMES
-    git git.cmd
+    git git.exe
   HINTS
     ENV PATH
   DOC "Full path to git commandline client"
diff --git a/sql/Bots/character_bots.sql b/sql/Bots/character_bots.sql
new file mode 100644
index 0000000..f590d45
--- /dev/null
+++ b/sql/Bots/character_bots.sql
@@ -0,0 +1,26 @@
+DROP TABLE IF EXISTS `characters_npcbot`;
+CREATE TABLE `characters_npcbot` (
+  `entry` int(10) unsigned NOT NULL COMMENT 'creature_template.entry',
+  `owner` int(10) unsigned NOT NULL DEFAULT '0' COMMENT 'characters.guid (lowguid)',
+  `roles` smallint(5) unsigned NOT NULL COMMENT 'bitmask: tank(1),dps(2),heal(4),ranged(8)',
+  `faction` int(10) unsigned NOT NULL DEFAULT '35',
+  `equipMhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipOhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipRhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipHead` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipShoulders` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipChest` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipWaist` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipLegs` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFeet` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipWrist` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipHands` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipBack` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipBody` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFinger1` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFinger2` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipTrinket1` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipTrinket2` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipNeck` int(10) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/Bots/world_bots.sql b/sql/Bots/world_bots.sql
new file mode 100644
index 0000000..c414c5c
--- /dev/null
+++ b/sql/Bots/world_bots.sql
@@ -0,0 +1,632 @@
+
+-- GENERAL --
+
+SET @BOT_START = 70001;
+SET @BOT_END   = 71000;
+
+delete from `creature_template` where entry between @BOT_START and @BOT_END;
+
+insert into `creature_template`
+(`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`,
+`minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`,
+`rangeattacktime`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`,
+`type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`,
+`spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`,
+`questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`)
+values
+('70001','0','0','0','0','0','5001','0','5001','0','Khelden','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70002','0','0','0','0','0','1294','0','1294','0','Zaldimar','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70003','0','0','0','0','0','1484','0','1484','0','Maginor','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70004','0','0','0','0','0','3344','0','3344','0','Anetta','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70005','0','0','0','0','0','1495','0','1495','0','Laurena','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70006','0','0','0','0','0','1295','0','1295','0','Josetta','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70007','0','0','0','0','0','3345','0','3345','0','Drusilla','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70008','0','0','0','0','0','1930','0','1930','0','Alamar','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70009','0','0','0','0','0','1469','0','1469','0','Demisette','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70010','0','0','0','0','0','12749','0','12749','0','Nalesette','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70011','0','0','0','0','0','3401','0','3401','0','Branstock','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70012','0','0','0','0','0','3395','0','3395','0','Thorgas','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70013','0','0','0','0','0','3343','0','3343','0','Llane','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70014','0','0','0','0','0','3399','0','3399','0','Thran','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70015','0','0','0','0','0','1300','0','1300','0','Lyria','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70016','0','0','0','0','0','3351','0','3351','0','Jorik','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70017','0','0','0','0','0','3407','0','3407','0','Solm','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70018','0','0','0','0','0','1297','0','1297','0','Keryn','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70019','0','0','0','0','0','1507','0','1507','0','Osborne','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70020','0','0','0','0','0','3346','0','3346','0','Sammuel','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70021','0','0','0','0','0','3393','0','3393','0','Bob','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70022','0','0','0','0','0','1299','0','1299','0','Wilhelm','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70023','0','0','0','0','0','1499','0','1499','0','Brisombre','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70024','0','0','0','0','0','10216','0','10216','0','Marry','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70025','0','0','0','0','0','4552','0','4552','0','Haromm','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70026','0','0','0','0','0','4567','0','4567','0','Kartosh','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70027','0','0','0','0','0','3429','0','3429','0','MaxanAnvol','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70028','0','0','0','0','0','10215','0','10215','0','Magis','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70029','0','0','0','0','0','3431','0','3431','0','GranVivehache','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70030','0','0','0','0','0','1622','0','1622','0','Azar','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70031','0','0','0','0','0','3436','0','3436','0','Hogral','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70032','0','0','0','0','0','3053','0','3053','0','Kelstrum','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70033','0','0','0','0','0','1578','0','1578','0','Dannal','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70034','0','0','0','0','0','1579','0','1579','0','SombreDuesten','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70035','0','0','0','0','0','1592','0','1592','0','Isabella','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70036','0','0','0','0','0','1581','0','1581','0','Maximillion','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70037','0','0','0','0','0','1604','0','1604','0','Rupert','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70038','0','0','0','0','0','1600','0','1600','0','Cain','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70039','0','0','0','0','0','1602','0','1602','0','SombreBeryl','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+-- gap
+('70041','0','0','0','0','0','10548','0','10548','0','Milituus','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70042','0','0','0','0','0','2810','0','2810','0','Lexington','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70043','0','0','0','0','0','2123','0','2123','0','Siln','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70044','0','0','0','0','0','19598','0','19598','0','Umbrua','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70045','0','0','0','0','0','2102','0','2102','0','Tigor','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70046','0','0','0','0','0','2082','0','2082','0','Beram','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70047','0','0','0','0','0','2106','0','2106','0','Turak','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70048','0','0','0','0','0','2121','0','2121','0','Sheal','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70049','0','0','0','0','0','2115','0','2115','0','Kym','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70050','0','0','0','0','0','2112','0','2112','0','Kary','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70051','0','0','0','0','0','2087','0','2087','0','Holt','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70052','0','0','0','0','0','2105','0','2105','0','Urek','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70053','0','0','0','0','0','2103','0','2103','0','Torm','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70054','0','0','0','0','0','2096','0','2096','0','Sark','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70055','0','0','0','0','0','17211','0','17211','0','Kerra','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70056','0','0','0','0','0','2139','0','2139','0','Miles Welsh','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70057','0','0','0','0','0','2138','0','2138','0','Malakai','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70058','0','0','0','0','0','2137','0','2137','0','Cobb','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70059','0','0','0','0','0','2134','0','2134','0','Shymm','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','143','145','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70060','0','0','0','0','0','6058','0','6058','0','Ursyn','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70061','0','0','0','0','0','2135','0','2135','0','Thurston','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70062','0','0','0','0','0','3793','0','3793','0','Harutt','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70063','0','0','0','0','0','3819','0','3819','0','Gart','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70064','0','0','0','0','0','3810','0','3810','0','Lanka','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70065','0','0','0','0','0','10180','0','10180','0','Meela','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70066','0','0','0','0','0','3794','0','3794','0','Krang','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70067','0','0','0','0','0','10734','0','10734','0','Gennia','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70068','0','0','0','0','0','3811','0','3811','0','Yaw','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70069','0','0','0','0','0','3816','0','3816','0','Narm','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70070','0','0','0','0','0','1880','0','1880','0','Frang','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70071','0','0','0','0','0','1882','0','1882','0','Jenshan','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','8','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70072','0','0','0','0','0','1884','0','1884','0','Nartok','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70073','0','0','0','0','0','1878','0','1878','0','Shikrik','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70074','0','0','0','0','0','3743','0','3743','0','Tarshaw','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70075','0','0','0','0','0','3744','0','3744','0','Thotar','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','2','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70076','0','0','0','0','0','3745','0','3745','0','Dhugru','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70077','0','0','0','0','0','3746','0','3746','0','Swart','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70078','0','0','0','0','0','1324','0','1324','0','Groldar','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70079','0','0','0','0','0','1325','0','1325','0','Mirket','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70080','0','0','0','0','0','1326','0','1326','0','Zevrost','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70081','0','0','0','0','0','1360','0','1360','0','Kardris','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70082','0','0','0','0','0','1373','0','1373','0','Ormak','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','2','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70083','0','0','0','0','0','1374','0','1374','0','Grezz','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70084','0','0','0','0','0','1375','0','1375','0','Sorek','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70085','0','0','0','0','0','4231','0','4231','0','Siantsu','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70086','0','0','0','0','0','4239','0','4239','0','Xorjuul','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','8','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70087','0','0','0','0','0','4241','0','4241','0','Siandur','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','8','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70088','0','0','0','0','0','4242','0','4242','0','Zelmak','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70089','0','0','0','0','0','7915','0','7915','0','ClaudeErksine','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70090','0','0','0','0','0','1721','0','1721','0','Alyissia','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70091','0','0','0','0','0','1725','0','1725','0','FrahunMurmombre','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70092','0','0','0','0','0','1733','0','1733','0','Shanda','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70093','0','0','0','0','0','1732','0','1732','0','Mardant','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70094','0','0','0','0','0','1707','0','1707','0','Kyra','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70095','0','0','0','0','0','1704','0','1704','0','Jannok','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70096','0','0','0','0','0','1708','0','1708','0','Laurna','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70097','0','0','0','0','0','1706','0','1706','0','Kal','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70098','0','0','0','0','0','4296','0','4296','0','Harruk','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','2','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70099','0','0','0','0','0','4299','0','4299','0','Reban','Hunter bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70100','0','0','0','0','0','4304','0','4304','0','Bolyun','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70101','0','0','0','0','0','1897','0','1897','0','Taijin','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70102','0','0','0','0','0','4068','0','4068','0','Kenjai','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70103','0','0','0','0','0','2066','0','2066','0','Danlaar','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70104','0','0','0','0','0','2196','0','2196','0','Ariasta','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70105','0','0','0','0','0','2198','0','2198','0','Sildanair','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70106','0','0','0','0','0','2200','0','2200','0','Astarii','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70107','0','0','0','0','0','2201','0','2201','0','Jandria','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70108','0','0','0','0','0','2202','0','2202','0','Lariia','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70109','0','0','0','0','0','2231','0','2231','0','Syurna','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70110','0','0','0','0','0','7669','0','7669','0','Elissa','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70111','0','0','0','0','0','2252','0','2252','0','Erion','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70112','0','0','0','0','0','2243','0','2243','0','Anishar','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70113','0','0','0','0','0','2250','0','2250','0','Denatharion','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70114','0','0','0','0','0','2255','0','2255','0','Fylerian','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70115','0','0','0','0','0','2416','0','2416','0','Caelyb','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70116','0','0','0','0','0','2675','0','2675','0','Kaal','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70117','0','0','0','0','0','16800','0','16800','0','Lana','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70118','0','0','0','0','0','2646','0','2646','0','Richard','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70119','0','0','0','0','0','10214','0','10214','0','Kaelystia','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70120','0','0','0','0','0','2644','0','2644','0','Pierce','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70121','0','0','0','0','0','2657','0','2657','0','Anastasia','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70122','0','0','0','0','0','2620','0','2620','0','Chris','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70123','0','0','0','0','0','2658','0','2658','0','Angela','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70124','0','0','0','0','0','2614','0','2614','0','Baltus','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70125','0','0','0','0','0','3054','0','3054','0','Kelv','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70126','0','0','0','0','0','3055','0','3055','0','Bilban','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70127','0','0','0','0','0','3056','0','3056','0','Daera','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70128','0','0','0','0','0','3072','0','3072','0','Olmin','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70129','0','0','0','0','0','3073','0','3073','0','Regnus','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70130','0','0','0','0','0','3086','0','3086','0','Theodrus','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70131','0','0','0','0','0','3066','0','3066','0','Braenna','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70132','0','0','0','0','0','3085','0','3085','0','Toldren','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+-- gap
+('70134','0','0','0','0','0','3108','0','3108','0','Bink','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70135','0','0','0','0','0','10214','0','10214','0','Juli','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70136','0','0','0','0','0','3109','0','3109','0','Nittegousse','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70137','0','0','0','0','0','3089','0','3089','0','Valgar','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70138','0','0','0','0','0','3088','0','3088','0','Beldruk','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70139','0','0','0','0','0','3087','0','3087','0','Brandur','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70140','0','0','0','0','0','3101','0','3101','0','Hulfdan','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70141','0','0','0','0','0','3100','0','3100','0','Ormyr','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70142','0','0','0','0','0','3113','0','3113','0','Phenwick','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70143','0','0','0','0','0','3115','0','3115','0','Coeurdechardon','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70144','0','0','0','0','0','3116','0','3116','0','Eglantin','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70145','0','0','0','0','0','3122','0','3122','0','Alexander','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70146','0','0','0','0','0','3280','0','3280','0','Wu','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70147','0','0','0','0','0','3287','0','3287','0','Ilsa','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70148','0','0','0','0','0','3283','0','3283','0','Joshua','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70149','0','0','0','0','0','3284','0','3284','0','Arthur','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70150','0','0','0','0','0','3289','0','3289','0','Katherine','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70151','0','0','0','0','0','3291','0','3291','0','Deline','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70152','0','0','0','0','0','3286','0','3286','0','Sandahl','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70153','0','0','0','0','0','3292','0','3292','0','Jennea','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70154','0','0','0','0','0','19803','0','19803','0','Elsharin','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70155','0','0','0','0','0','3299','0','3299','0','Kaerbrus','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70156','0','0','0','0','0','3300','0','3300','0','Sheldras','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70157','0','0','0','0','0','3301','0','3301','0','Theridran','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70158','0','0','0','0','0','3312','0','3312','0','Einris','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70159','0','0','0','0','0','3309','0','3309','0','Ulfir','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70160','0','0','0','0','0','3310','0','3310','0','Thorfin','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70161','0','0','0','0','0','10171','0','10171','0','UnThuwa','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70162','0','0','0','0','0','4524','0','4524','0','Pephredo','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70163','0','0','0','0','0','4522','0','4522','0','Enyo','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70164','0','0','0','0','0','4526','0','4526','0','Mai','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70165','0','0','0','0','0','4523','0','4523','0','Deino','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70166','0','0','0','0','0','4665','0','4665','0','Birgitte','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70167','0','0','0','0','0','12849','0','12849','0','Thuul','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70168','0','0','0','0','0','4690','0','4690','0','Zayus','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70169','0','0','0','0','0','10473','0','10473','0','Xyera','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70170','0','0','0','0','0','4711','0','4711','0','Urkyo','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70171','0','0','0','0','0','6060','0','6060','0','Uthelnay','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70172','0','0','0','0','0','6072','0','6072','0','Dink','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70173','0','0','0','0','0','6071','0','6071','0','Darnath','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70174','0','0','0','0','0','7356','0','7356','0','Karman','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70175','0','0','0','0','0','11037','0','11037','0','Evencane','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70176','0','0','0','0','0','7357','0','7357','0','Jannos','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70177','0','0','0','0','0','7538','0','7538','0','Alenndaar','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70178','0','0','0','0','0','10738','0','10738','0','Golhine','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70179','0','0','0','0','0','9337','0','9337','0','Hesuwa','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70180','0','0','0','0','0','9336','0','9336','0','Xao\'tsu','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','8','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70181','0','0','0','0','0','9338','0','9338','0','Belia','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70182','0','0','0','0','0','10245','0','10245','0','Dargh','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70183','0','0','0','0','0','11044','0','11044','0','Meideros','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70184','0','0','0','0','0','11048','0','11048','0','Presse','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70185','0','0','0','0','0','11053','0','11053','0','Rohan','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70186','0','0','0','0','0','12053','0','12053','0','Loganaar','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70187','0','0','0','0','0','13171','0','13171','0','Romano','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70188','0','0','0','0','0','13341','0','13341','0','Sagorne','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70189','0','0','0','0','0','15522','0','15522','0','Julia','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70190','0','0','0','0','0','16811','0','16811','0','Ithelis','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70191','0','0','0','0','0','15524','0','15524','0','Invocateur','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70192','0','0','0','0','0','15518','0','15518','0','Matrone','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70193','0','0','0','0','0','2659','0','2659','0','Eclaireur','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70194','0','0','0','0','0','15520','0','15520','0','Sallina','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','10','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70195','0','0','0','0','0','16685','0','16685','0','Noellene','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70196','0','0','0','0','0','16707','0','16707','0','Ponaris','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70197','0','0','0','0','0','16222','0','16222','0','Keilnei','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','11','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70198','0','0','0','0','0','16223','0','16223','0','Valaatu','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70199','0','0','0','0','0','16224','0','16224','0','Aurelon','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70200','0','0','0','0','0','16225','0','16225','0','Zalduun','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70201','0','0','0','0','0','16226','0','16226','0','Kore','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70202','0','0','0','0','0','16787','0','16787','0','Alamma','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70203','0','0','0','0','0','16800','0','16800','0','Talionia','Warlock Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70204','0','0','0','0','0','16831','0','16831','0','Zanien','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','2','0','16384','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70205','0','0','0','0','0','16781','0','16781','0','Zaedana','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70206','0','0','0','0','0','16824','0','16824','0','Quithas','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70207','0','0','0','0','0','16739','0','16739','0','Harene','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70208','0','0','0','0','0','16778','0','16778','0','Tana','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','10','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70209','0','0','0','0','0','16816','0','16816','0','Oninath','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','10','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70210','0','0','0','0','0','16829','0','16829','0','Bachi','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70211','0','0','0','0','0','16767','0','16767','0','Zelanis','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70212','0','0','0','0','0','16798','0','16798','0','Elara','Rogue Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70213','0','0','0','0','0','16858','0','16858','0','Shalannius','Druid Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70214','0','0','0','0','0','17434','0','17434','0','Deremiis','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','11','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70215','0','0','0','0','0','17247','0','17247','0','Caedmos','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70216','0','0','0','0','0','17225','0','17225','0','Baatun','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70217','0','0','0','0','0','17212','0','17212','0','Ahonan','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70218','0','0','0','0','0','17598','0','17598','0','Firmanvaar','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70219','0','0','0','0','0','16860','0','16860','0','Actron','Hunter Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','11','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70220','0','0','0','0','0','17213','0','17213','0','Behomat','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70221','0','0','0','0','0','17600','0','17600','0','Nobundo','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70222','0','0','0','0','0','17599','0','17599','0','Tuluun','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70223','0','0','0','0','0','16914','0','16914','0','Sulaa','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70224','0','0','0','0','0','17215','0','17215','0','Ruada','Warrior Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70225','0','0','0','0','0','17233','0','17233','0','Semid','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70226','0','0','0','0','0','17232','0','17232','0','Guvan','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70227','0','0','0','0','0','17234','0','17234','0','Tullas','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70228','0','0','0','0','0','17488','0','17488','0','Killac','Hunter bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','11','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70229','0','0','0','0','0','17226','0','17226','0','Jol','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70230','0','0','0','0','0','17248','0','17248','0','Fallat','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70231','0','0','0','0','0','17243','0','17243','0','Harnan','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70232','0','0','0','0','0','17241','0','17241','0','Bati','Mage Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70233','0','0','0','0','0','17792','0','17792','0','Hobahken','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70234','0','0','0','0','0','6820','0','6820','0','Gurrag','Shaman Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70235','0','0','0','0','0','19596','0','19596','0','Auberose','Paladin Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70236','0','0','0','0','0','10335','10335','10335','10335','Afina','Priest Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70237','0','0','0','0','0','26939','26939','26939','26939','Imhadria','Death Knight Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70238','0','0','0','0','0','28039','28039','28039','28039','Mynx','Death Knight Bot','','0','80','80','2','14','14','1','1.2','1.3','0.8','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70239','0','0','0','0','0','26688','26688','26688','26688','Lankral','Death Knight Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70240','0','0','0','0','0','26195','26195','26195','26195','Silver','Death Knight Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70241','0','0','0','0','0','27402','27402','27402','27402','Vereth','Death Knight Bot','','0','80','80','2','14','14','1','1.2','1.3','0.8','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70242','0','0','0','0','0','27189','27189','27189','27189','Arly','Death Knight Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70243','0','0','0','0','0','26217','26217','26217','26217','Setaal','Death Knight Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70244','0','0','0','0','0','28842','28842','28842','28842','Illyrie','Death Knight Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70245','0','0','0','0','0','28840','28840','28840','28840','Zor\'be','Death Knight Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70246','0','0','0','0','0','25512','25512','25512','25512','Datura','Death Knight Bot','','0','80','80','2','14','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+-- 70247-70300 reserved for standard classes
+('70301','0','0','0','0','0','17659','17659','17659','17659','Gorkramato','Blademaster bot','','0','81','81','2','14','14','1','1.2','1.3','1.05','4','2','24','0','0','1','2200','2000','1','0','16384','0','0','0','0','12','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157560','blademaster_bot','-1'),
+('70302','0','0','0','0','0','17659','17659','17659','17659','Mirror Image (Blademaster)','Blademaster bot','','0','81','81','2','14','14','1','1.2','1.3','1.05','4','2','24','0','0','1','2200','2000','1','0','16384','0','0','0','0','12','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157560','blademaster_bot','-1'),
+-- 70303-70349 reserved for special units
+('70350','0','0','0','0','0','1132','0','1132','0','Voidwalker','Warlock\'s Pet Bot',NULL,'0','80','80','2','14','14','0','1.2','1.3','1','0','2','3','0','0','1','2000','2000','2','0','0','0','16','0','0','0','0','0','0','0','3','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','voidwalker_bot','-1'),
+('70351','0','0','0','0','0','1105','0','0','0','Hunter\'s Pet',NULL,NULL,'0','80','80','0','14','14','0','1.1','1.14286','1','0','87','117','0','214','1','2000','0','1','0','0','0','7','0','0','0','0','61','90','21','1','1','0','0','0','0','0','0','0','0','0','5708','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','149','1','0','0','','-1'),
+-- 70352-70399 reserved for pet types
+
+('71000','0','0','0','0','0','16853','16853','16853','16853','Airen','Priestess of Suffering',NULL,'0','95','95','1','14','14','1','1.2','1.3','1.173','4','850','1150','0','100','5','1500','0','1','898','49152','2','0','0','0','0','0','0','0','0','3','67110912','0','0','0','450','450','450','450','450','450','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1000','1','5','1','0','0','0','0','0','0','0','0','617299839','1048946','npc_Airen_qI','-213');
+
+
+-- EQUIPS --
+
+delete from `creature_equip_template` where entry between @BOT_START and @BOT_END;
+
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values
+('70001','1','2132','0','0'),
+('70002','1','2132','0','0'),
+('70003','1','2132','0','0'),
+('70004','1','1388','0','0'),
+('70005','1','1388','0','0'),
+('70006','1','1388','0','0'),
+('70007','1','3661','0','0'),
+('70008','1','3661','0','0'),
+('70009','1','3661','0','0'),
+('70010','1','12282','0','2506'),
+('70011','1','1388','0','0'),
+('70012','1','12282','0','2506'),
+('70013','1','2483','0','0'),
+('70014','1','2479','0','0'),
+('70015','1','2361','0','0'),
+('70016','1','2092','3296','25873'),
+('70017','1','2092','3296','25873'),
+('70018','1','2131','2484','25873'),
+('70019','1','2092','3296','25873'),
+('70020','1','2488','7188','0'),
+('70021','1','2497','0','0'),
+('70022','1','2488','7188','0'),
+('70023','1','2497','0','0'),
+('70024','1','2132','0','0'),
+('70025','1','15903','15907','0'),
+('70026','1','3661','0','0'),
+('70027','1','1388','0','0'),
+('70028','1','2132','0','0'),
+('70029','1','28367','0','0'),
+('70030','1','2488','7188','0'),
+('70031','1','2092','3296','25873'),
+('70032','1','2479','0','0'),
+('70033','1','2483','0','0'),
+('70034','1','1388','0','0'),
+('70035','1','2132','0','0'),
+('70036','1','3661','0','0'),
+('70037','1','3661','0','0'),
+('70038','1','2132','0','0'),
+('70039','1','1388','0','0'),
+('70041','1','2132','0','0'),
+('70042','1','2132','0','0'),
+('70043','1','15903','15907','0'),
+('70044','1','15903','15907','0'),
+('70045','1','15903','15907','0'),
+('70046','1','15903','15907','0'),
+('70047','1','3327','0','0'),
+('70048','1','3327','0','0'),
+('70049','1','3327','0','0'),
+('70050','1','12282','0','2506'),
+('70051','1','12282','0','2506'),
+('70052','1','12282','0','2506'),
+('70053','1','2483','0','0'),
+('70054','1','2479','0','0'),
+('70055','1','28367','0','0'),
+('70056','1','1388','0','0'),
+('70057','1','1388','0','0'),
+('70058','1','1388','0','0'),
+('70059','1','2132','0','0'),
+('70060','1','2132','0','0'),
+('70061','1','2132','0','0'),
+('70062','1','28367','0','0'),
+('70063','1','3327','0','0'),
+('70064','1','12282','0','2506'),
+('70065','1','15903','15907','0'),
+('70066','1','2483','0','0'),
+('70067','1','3327','0','0'),
+('70068','1','12282','0','2506'),
+('70069','1','15903','15907','0'),
+('70070','1','2479','0','0'),
+('70071','1','12282','0','2506'),
+('70072','1','3661','0','0'),
+('70073','1','15903','15907','0'),
+('70074','1','2483','0','0'),
+('70075','1','12282','0','2506'),
+('70076','1','3661','0','0'),
+('70077','1','15903','15907','0'),
+('70078','1','3661','0','0'),
+('70079','1','3661','0','0'),
+('70080','1','3661','0','0'),
+('70081','1','15903','15907','0'),
+('70082','1','12282','0','2506'),
+('70083','1','2361','0','0'),
+('70084','1','2483','0','0'),
+('70085','1','15903','15907','0'),
+('70086','1','12282','0','2506'),
+('70087','1','12282','0','2506'),
+('70088','1','2479','0','0'),
+('70089','1','12282','0','2506'),
+('70090','1','28367','0','0'),
+('70091','1','2131','2484','25873'),
+('70092','1','1388','0','0'),
+('70093','1','3327','0','0'),
+('70094','1','2483','0','0'),
+('70095','1','2092','3296','25873'),
+('70096','1','1388','0','0'),
+('70097','1','3327','0','0'),
+('70098','1','12282','0','2506'),
+('70099','1','12282','0','2506'),
+('70100','1','12282','0','2506'),
+('70101','1','1388','0','0'),
+('70102','1','1388','0','0'),
+('70103','1','12282','0','2506'),
+('70104','1','2361','0','0'),
+('70105','1','2483','0','0'),
+('70106','1','1388','0','0'),
+('70107','1','1388','0','0'),
+('70108','1','1388','0','0'),
+('70109','1','2092','3296','25873'),
+('70110','1','2132','0','0'),
+('70111','1','2131','2484','25873'),
+('70112','1','2092','3296','25873'),
+('70113','1','3327','0','0'),
+('70114','1','3327','0','0'),
+('70115','1','12282','0','2506'),
+('70116','1','3661','0','0'),
+('70117','1','3661','0','0'),
+('70118','1','3661','0','0'),
+('70119','1','2132','0','0'),
+('70120','1','2132','0','0'),
+('70121','1','2132','0','0'),
+('70122','1','2479','0','0'),
+('70123','1','2483','0','0'),
+('70124','1','2361','0','0'),
+('70125','1','2483','0','0'),
+('70126','1','28367','0','0'),
+('70127','1','12282','0','2506'),
+('70128','1','12282','0','2506'),
+('70129','1','12282','0','2506'),
+('70130','1','1388','0','0'),
+('70131','1','1388','0','0'),
+('70132','1','1388','0','0'),
+('70134','1','2132','0','0'),
+('70135','1','2132','0','0'),
+('70136','1','2132','0','0'),
+('70137','1','2497','0','0'),
+('70138','1','2488','7188','0'),
+('70139','1','2497','0','0'),
+('70140','1','2131','2484','25873'),
+('70141','1','2092','3296','25873'),
+('70142','1','2131','2484','25873'),
+('70143','1','3661','0','0'),
+('70144','1','3661','0','0'),
+('70145','1','3661','0','0'),
+('70146','1','2479','0','0'),
+('70147','1','2483','0','0'),
+('70148','1','1388','0','0'),
+('70149','1','2488','7188','0'),
+('70150','1','2497','0','0'),
+('70151','1','3661','0','0'),
+('70152','1','3661','0','0'),
+('70153','1','2132','0','0'),
+('70154','1','2132','0','0'),
+('70155','1','12282','0','2506'),
+('70156','1','3327','0','0'),
+('70157','1','3327','0','0'),
+('70158','1','12282','0','2506'),
+('70159','1','12282','0','2506'),
+('70160','1','12282','0','2506'),
+('70161','1','2132','0','0'),
+('70162','1','2132','0','0'),
+('70163','1','2132','0','0'),
+('70164','1','2132','0','0'),
+('70165','1','2132','0','0'),
+('70166','1','2132','0','0'),
+('70167','1','2132','0','0'),
+('70168','1','1388','0','0'),
+('70169','1','1388','0','0'),
+('70170','1','1388','0','0'),
+('70171','1','2132','0','0'),
+('70172','1','2132','0','0'),
+('70173','1','28367','0','0'),
+('70174','1','2488','7188','0'),
+('70175','1','2361','0','0'),
+('70176','1','3327','0','0'),
+('70177','1','12282','0','2506'),
+('70178','1','3327','0','0'),
+('70179','1','12282','0','2506'),
+('70180','1','12282','0','2506'),
+('70181','1','12282','0','2506'),
+('70182','1','12282','0','2506'),
+('70183','1','1388','0','0'),
+('70184','1','1388','0','0'),
+('70185','1','1388','0','0'),
+('70186','1','3327','0','0'),
+('70187','1','2092','3296','25873'),
+('70188','1','15903','15907','0'),
+('70189','1','2132','0','0'),
+('70190','1','2488','18826','0'),
+('70191','1','3661','0','0'),
+('70192','1','1388','0','0'),
+('70193','1','2092','3296','25873'),
+('70194','1','12282','0','2506'),
+('70195','1','2488','18826','0'),
+('70196','1','1388','0','0'),
+('70197','1','12282','0','2506'),
+('70198','1','2132','0','0'),
+('70199','1','2497','0','0'),
+('70200','1','1388','0','0'),
+('70201','1','2479','0','0'),
+('70202','1','3661','0','0'),
+('70203','1','3661','0','0'),
+('70204','1','3661','0','0'),
+('70205','1','2132','0','0'),
+('70206','1','2132','0','0'),
+('70207','1','3327','0','0'),
+('70208','1','12282','0','2506'),
+('70209','1','12282','0','2506'),
+('70210','1','2488','18826','0'),
+('70211','1','2131','2484','25873'),
+('70212','1','2092','3296','25873'),
+('70213','1','3327','0','0'),
+('70214','1','12282','0','2506'),
+('70215','1','1388','0','0'),
+('70216','1','2497','0','0'),
+('70217','1','28367','0','0'),
+('70218','1','15903','15907','0'),
+('70219','1','12282','0','2506'),
+('70220','1','2483','0','0'),
+('70221','1','15903','15907','0'),
+('70222','1','15903','15907','0'),
+('70223','1','15903','15907','0'),
+('70224','1','2479','0','0'),
+('70225','1','2132','0','0'),
+('70226','1','1388','0','0'),
+('70227','1','2488','7188','0'),
+('70228','1','12282','0','2506'),
+('70229','1','2497','0','0'),
+('70230','1','1388','0','0'),
+('70231','1','2132','0','0'),
+('70232','1','2132','0','0'),
+('70233','1','15903','15907','0'),
+('70234','1','15903','15907','0'),
+('70235','1','781','7188','0'),
+('70236','1','1388','0','0'),
+('70237','1','13505','0','0'),
+('70238','1','12775','0','0'),
+('70239','1','19874','0','0'),
+('70240','1','38633','0','0'),
+('70241','1','23499','0','0'),
+('70242','1','38632','0','0'),
+('70243','1','41815','0','0'),
+('70244','1','38632','0','0'),
+('70245','1','29377','0','0'),
+('70246','1','12592','0','0'),
+('70301','1','24044','0','0'),
+('70302','1','24044','0','0'),
+
+('71000','1','0','30902','0');
+
+
+-- GOSSIPS --
+delete from `npc_text` where ID between @BOT_START and @BOT_END;
+insert into `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`,
+`text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `WDBVerified`)
+values
+('70001','I live only to serve the master.','','0','1','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','-213'),
+('70002','You need something?','','0','1','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','-213'),
+('70003','Mortals... usually I kill wretches like you at sight',NULL,'0','1','396','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0','-213');
+
+
+-- OUTFITS --
+-- Npc Dress mod by Rochet2
+CREATE TABLE IF NOT EXISTS `creature_template_outfits` (
+    `entry` INT(10) UNSIGNED NOT NULL,
+    `race` tinyint(3) UNSIGNED NOT NULL DEFAULT '1',
+    `gender` tinyint(3) UNSIGNED NOT NULL DEFAULT '0' COMMENT '0 for male, 1 for female',
+    `skin` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `face` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `hair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `haircolor` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `facialhair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `head` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `shoulders` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `body` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `chest` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `waist` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `legs` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `feet` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `wrists` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `hands` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `back` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `tabard` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    PRIMARY KEY  (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+-- End Npc Dress mod
+
+replace into `creature_template_outfits` (`entry`, `race`, `gender`, `skin`, `face`, `hair`, `haircolor`, `facialhair`, `head`, `shoulders`, `body`, `chest`, `waist`, `legs`, `feet`, `wrists`, `hands`, `back`, `tabard`)
+values
+('70301','2','0','0','14','9','7','5','0','0','0','0','59194','64674','0','36248','0','0','0'), -- Blademaster
+('70302','2','0','0','14','9','7','5','0','0','0','0','59194','64674','0','36248','0','0','0'), -- Mirror Image (Blademaster)
+('71000','11','1','0','5','0','6','0','0','53903','21842','35049','35058','35051','35067','35044','0','0','0'); -- Airen
+
+
+-- Customize section
+-- You can create your own values to be in line with your own server if these are not acceptable.
+
+SET @CLASS_WARRIOR = 1;
+SET @CLASS_PALADIN = 2;
+SET @CLASS_HUNTER  = 3;
+SET @CLASS_ROGUE   = 4;
+SET @CLASS_PRIEST  = 5;
+SET @CLASS_DK      = 6;
+SET @CLASS_SHAMAN  = 7;
+SET @CLASS_MAGE    = 8;
+SET @CLASS_WARLOCK = 9;
+SET @CLASS_DRUID   = 11;
+SET @CLASS_BM      = 12;
+
+-- Add flags_extra
+-- -- -- Update 6.04.14 - extra flags for recognizing bots core-side - CREATURE_FLAG_EXTRA_NPCBOT
+
+SET @EX_NO_PARRY_HASTEN = 8; -- 0x00000008 - CREATURE_FLAG_EXTRA_NO_PARRY_HASTEN
+SET @EX_NO_BLOCK = 16; -- 0x00000010 - CREATURE_FLAG_EXTRA_NO_BLOCK
+SET @EX_NO_CRUSH = 32; -- 0x00000020 - CREATURE_FLAG_EXTRA_NO_CRUSH
+SET @EX_NO_XP = 64; -- 0x00000040 - CREATURE_FLAG_EXTRA_NO_XP_AT_KILL
+SET @EX_DIMINISH = 1048576; -- 0x00100000 - CREATURE_FLAG_EXTRA_ALL_DIMINISH
+SET @EX_NPCBOT = 67108864; -- 0x04000000 - CREATURE_FLAG_EXTRA_NPCBOT - custom flag
+SET @FLAGS_EX = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT;
+SET @FLAGS_EXN = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT | @EX_NO_PARRY_HASTEN;
+SET @FLAGS_EX_PET = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT;
+
+-- Add extra 'unit_flags2' flags
+SET @U2_INSTANT_APPEAR_MODEL = 32; -- 0x00000020 - UNIT_FLAG2_INSTANTLY_APPEAR_MODEL - 29.05.19
+SET @U2_ENEMY_INTERRACT = 16384; -- 0x00004000 - UNIT_FLAG2_ALLOW_ENEMY_INTERACT
+SET @FLAGS_U2 = @U2_INSTANT_APPEAR_MODEL | @U2_ENEMY_INTERRACT;
+SET @FLAGS_U2_PET = @U2_INSTANT_APPEAR_MODEL;
+
+-- minions
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=4, maxdmg:=6,  minlevel:=80, maxlevel:=80, baseattacktime:=3300, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX,  unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_DK;
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=3, maxdmg:=5,  minlevel:=80, maxlevel:=80, baseattacktime:=2200, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX,  unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_DRUID;
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=3, maxdmg:=5,  minlevel:=80, maxlevel:=80, baseattacktime:=2800, rangeattacktime:=2000, minrangedmg:=4, maxrangedmg:=8, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX,  unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_HUNTER;
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=3,  minlevel:=80, maxlevel:=80, baseattacktime:=3800, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX,  unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_MAGE;
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=4, maxdmg:=6,  minlevel:=80, maxlevel:=80, baseattacktime:=2300, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX,  unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_PALADIN;
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=3,  minlevel:=80, maxlevel:=80, baseattacktime:=3600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX,  unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_PRIEST;
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=4,  minlevel:=80, maxlevel:=80, baseattacktime:=1600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX,  unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_ROGUE;
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=3, maxdmg:=5,  minlevel:=80, maxlevel:=80, baseattacktime:=2600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX,  unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_SHAMAN;
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=3,  minlevel:=80, maxlevel:=80, baseattacktime:=3500, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX,  unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_WARLOCK;
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=5, maxdmg:=7,  minlevel:=80, maxlevel:=80, baseattacktime:=3400, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX,  unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_WARRIOR;
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=4, maxdmg:=16, minlevel:=81, maxlevel:=81, baseattacktime:=2200, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EXN, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_BM;
+
+-- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK
+-- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid
+-- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter
+-- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage
+-- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin
+-- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest
+-- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue
+-- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman
+-- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock
+-- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior
+-- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster
+
+-- pets
+UPDATE `creature_template` SET exp:=2, faction_A:=35, faction_H:=35, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=3,  minlevel:=80, maxlevel:=80, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX_PET, unit_flags2:=`unit_flags2`|@FLAGS_U2_PET, AIName:='', WDBVerified:=-1 where entry between @BOT_START and @BOT_END-1 and name='Voidwalker';
diff --git a/src/server/game/AI/NpcBots/bot_Events.h b/src/server/game/AI/NpcBots/bot_Events.h
new file mode 100644
index 0000000..0fed560
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_Events.h
@@ -0,0 +1,55 @@
+#ifndef _BOT_EVENTS_H
+#define _BOT_EVENTS_H
+
+#include "EventProcessor.h"
+//#include "Creature.h"
+
+/*
+Name: bot_Events
+%Complete: ???
+Comment: Custom event types for NPCBot system by Trickerer (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/events
+
+Notes:
+All events must be executed through botAI
+*/
+
+//Teleport home: near or far, only used for free bots
+class TeleportHomeEvent : public BasicEvent
+{
+    friend class bot_minion_ai;
+    friend class bot_ai;
+    protected:
+        TeleportHomeEvent(bot_minion_ai* ai) : _ai(ai) {}
+        ~TeleportHomeEvent() {}
+
+        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+        {
+            _ai->TeleportHome();
+            return true;
+        }
+
+    private:
+        bot_minion_ai* _ai;
+};
+//Delayed teleport finish: adds bot back to world on new location
+class TeleportFinishEvent : public BasicEvent
+{
+    friend class bot_minion_ai;
+    friend class BotMgr;
+    protected:
+        TeleportFinishEvent(bot_minion_ai* ai) : _ai(ai) {}
+        ~TeleportFinishEvent() {}
+
+        //Execute is always called while creature is out of world so ai is never deleted
+        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+        {
+            _ai->FinishTeleport();
+            return true;
+        }
+
+    private:
+        bot_minion_ai* _ai;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_GridNotifiers.h b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
new file mode 100644
index 0000000..ee31d2d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
@@ -0,0 +1,1055 @@
+#ifndef _BOT_GRIDNOTIFIERS_H
+#define _BOT_GRIDNOTIFIERS_H
+
+#include "Group.h"
+#include "Player.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+#include "bot_ai.h"
+/*
+Name: bot_GridNotifiers
+%Complete: 99+
+Comment: Custom grid notifiers for Bot system by Trickerer (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/grids
+*/
+
+extern bool _botPvP;
+
+class ImmunityShieldDispelTargetCheck
+{
+    public:
+        explicit ImmunityShieldDispelTargetCheck(Unit const* unit, float dist, bot_ai const* m_ai) :
+        me(unit), range(dist), ai(m_ai) { free = ai->IAmFree(); }
+        bool operator()(Unit const* u)
+        {
+            if (!_botPvP && !free && u->IsControlledByPlayer())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, range))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (!u->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD))
+                return false;
+
+            if (!u->IsWithinLOSInMap(me))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float range;
+        bot_ai const* ai;
+        bool free;
+        ImmunityShieldDispelTargetCheck(ImmunityShieldDispelTargetCheck const&);
+};
+
+class NearestHostileUnitCheck
+{
+    public:
+        explicit NearestHostileUnitCheck(Unit const* unit, float dist, bool magic, bot_ai const* m_ai, bool targetCCed = false) :
+        me(unit), m_range(dist), byspell(magic), ai(m_ai), AttackCCed(targetCCed)
+        { free = ai->IAmFree(); }
+        bool operator()(Unit const* u)
+        {
+            if (u == me)
+                return false;
+            if (!_botPvP && !free && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+                return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!ai->CanBotAttack(u, byspell))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!AttackCCed && (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE)))
+                return false;//do not allow CCed units if checked
+            //if (u->HasUnitState(UNIT_STATE_CASTING) && (u->GetTypeId() == TYPEID_PLAYER || u->IsPet()))
+            //    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+            //        if (Spell* spell = u->GetCurrentSpell(i))
+            //            if (ai->IsInBotParty(spell->m_targets.GetUnitTarget()))
+            //                return true;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer() && !u->IsInCombat())
+                    return false;
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack())
+                    return false;
+            }
+            else
+            {
+                if (!u->IsWithinLOSInMap(me))
+                    return false;
+            }
+
+            m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
+            return true;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool byspell;
+        bot_ai const* ai;
+        bool AttackCCed;
+        bool free;
+        NearestHostileUnitCheck(NearestHostileUnitCheck const&);
+};
+
+class HostileDispelTargetCheck
+{
+    public:
+        explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false, bot_ai const* m_ai = NULL) :
+        me(unit), m_range(dist), checksteal(stealable), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u->IsInCombat() &&
+                u->InSamePhase(me) &&
+                u->IsWithinDistInMap(me, m_range) &&
+                u->isTargetableForAttack() &&
+                //!ai->InDuel(u) &&
+                ai->IsInBotParty(u->GetVictim()))
+            {
+                if (checksteal)
+                {
+                    if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449)))
+                        return false; //immune to steal
+                }
+                else if (ai->GetBotClass() == BOT_CLASS_SHAMAN)
+                {
+                    if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(370)))
+                        return false; //immune to purge
+                }
+                //else if (ai->GetBotClass() == BOT_CLASS_PRIEST)
+                //{
+                //    if (me->getLevel() < 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(527)))
+                //        return false; //immune to dispel magic
+                //}
+
+                Unit::AuraApplicationMap const &AurApps = u->GetAppliedAuras();
+                SpellInfo const* Info;
+                uint32 id;
+                for (Unit::AuraApplicationMap::const_iterator itr = AurApps.begin(); itr != AurApps.end(); ++itr)
+                {
+                    Info = itr->second->GetBase()->GetSpellInfo();
+                    if (itr->second->IsPositive() && Info->Dispel == DISPEL_MAGIC &&
+                        !(Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) &&
+                        !(checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)))
+                    {
+                        id = Info->Id;
+                        if (id != 20050 && id != 20052 && id != 20053 && //Vengeance
+                            id != 50447 && id != 50448 && id != 50449) //Bloody Vengeance
+                            return true;
+                    }
+                }
+
+                //Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                //SpellInfo const* Info;
+                //uint32 id;
+                //for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                //{
+                //    Aura* aura = itr->second;
+                //    Info = aura->GetSpellInfo();
+                //    if (Info->Dispel != DISPEL_MAGIC) continue;
+                //    id = Info->Id;
+                //    if (id == 20050 || id == 20052 || id == 20053 || //Vengeance
+                //        id == 50447 || id == 50448 || id == 50449) //Bloody Vengeance
+                //        continue;
+                //    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                //    //if (Info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                //    if (checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
+                //    AuraApplication const* aurApp = aura->GetApplicationOfTarget(u->GetGUID());
+                //    if (aurApp && aurApp->IsPositive())
+                //        return true;
+                //}
+            }
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool checksteal;
+        bot_ai const* ai;
+        HostileDispelTargetCheck(HostileDispelTargetCheck const&);
+};
+
+class AffectedTargetCheck
+{
+    public:
+        explicit AffectedTargetCheck(uint64 casterguid, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) :
+        caster(casterguid), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!u->IsAlive())
+                return false;
+            if (caster && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+                return false;
+            if (!checker->IsWithinDistInMap(u, m_range))
+                return false;
+            if (needhostile == 0 && !u->IsHostileTo(checker)) return false;
+            //else if (needhostile == 1 && !(gr && gr->IsMember(u->GetGUID()) && u->GetTypeId() == TYPEID_PLAYER)) return false;
+            //else if (needhostile == 2 && !(gr && gr->IsMember(u->GetGUID()))) return false;
+            else if (needhostile == 3 && !u->IsFriendlyTo(checker)) return false;
+            else if (needhostile == 4 && !(u->GetTypeId() == TYPEID_PLAYER && u->IsFriendlyTo(checker))) return false;
+
+            Unit::AuraMap const &Auras = u->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+            {
+                Aura* aura = itr->second;
+                if (aura->GetId() == spell)
+                    if (caster == 0 || aura->GetCasterGUID() == caster)
+                        return true;
+            }
+            return false;
+        }
+    private:
+        uint64 const caster;
+        float m_range;
+        uint32 const spell;
+        Player const* checker;
+        uint8 needhostile;
+        AffectedTargetCheck(AffectedTargetCheck const&);
+};
+
+class PolyUnitCheck
+{
+    public:
+        explicit PolyUnitCheck(Unit const* unit, float dist) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->GetVictim() || u == me->GetVictim())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat() || !u->IsAlive() || !u->GetVictim())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_HUMANOID &&
+                u->GetCreatureType() != CREATURE_TYPE_BEAST)
+                return false;
+            if (me->GetDistance(u) < 6 || me->GetVictim()->GetDistance(u) < 5 ||
+                (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE && u->GetHealthPct() < 70))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE ? !u->getAttackers().empty() : u->getAttackers().size() > 1)
+                return false;
+            if (!u->IsHostileTo(me))
+                return false;
+            if (u->IsPolymorphed() ||
+                u->isFrozen() ||
+                u->isInRoots() ||
+                u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) ||
+                u->HasAuraType(SPELL_AURA_MOD_PACIFY_SILENCE) ||
+                u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STUN, SPELLFAMILY_PALADIN, 0x4))
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(118)))//Polymorph
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_SHAMAN && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(51514)))//Hex
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        PolyUnitCheck(PolyUnitCheck const&);
+};
+
+class FearUnitCheck
+{
+    public:
+        explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->isFeared())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_BEAST &&
+                me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER)
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (u->getAttackers().size() > 1 && u->GetVictim() != me)
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARLOCK &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782)))//fear rank1
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1513)))//scare beast rank1
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        FearUnitCheck(FearUnitCheck const&);
+};
+
+class StunUnitCheck
+{
+    public:
+        explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER && me->GetTarget() == u->GetGUID())//auto shot
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_DRUID &&
+                !(u->GetCreatureType() == CREATURE_TYPE_BEAST ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER && u->isFeared())
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN && me->GetDistance(u) < 10)//prevent break due to AOE damage
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAuraType(SPELL_AURA_MOD_PACIFY_SILENCE) ||
+                u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STUN, SPELLFAMILY_PALADIN, 0x4) ||
+                //u->HasAura(51514)/*hex*/ ||
+                //u->HasAura(20066)/*repentance*/ ||
+                u->HasAuraWithMechanic((1<<MECHANIC_SHACKLE)|(1<<MECHANIC_SLEEP)|(1<<MECHANIC_DISORIENTED)))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066)))//repentance
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(60210)))//freezing arrow effect
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19386)))//wyvern sting rank 1
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1991)))//scatter shot
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(2094)))//blind
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        StunUnitCheck(StunUnitCheck const&);
+};
+
+class UndeadCCUnitCheck
+{
+    public:
+        explicit UndeadCCUnitCheck(Unit const* unit, float dist, bot_ai const* ai, uint32 spell, bool unattacked) :
+        me(unit), m_range(dist), m_ai(ai), m_spellId(spell), _unattacked(unattacked) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (_unattacked && !u->getAttackers().empty())
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PRIEST &&
+                !(u->GetCreatureType() == CREATURE_TYPE_UNDEAD && !u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                u->GetCreatureType() != CREATURE_TYPE_DEMON)
+                return false;
+            if (u->GetVictim() && !m_ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bot_ai const* m_ai;
+        uint32 m_spellId;
+        bool _unattacked;
+        UndeadCCUnitCheck(UndeadCCUnitCheck const&);
+};
+
+class RootUnitCheck
+{
+    public:
+        explicit RootUnitCheck(Unit const* unit, float dist, bot_ai const* ai, uint32 spell = 0) :
+        me(unit), m_range(dist), m_ai(ai), m_spellId(spell) { if (!spell) return; }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (u == me->GetVictim())
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (me->GetDistance(u) < 8)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (u->isFrozen() || u->isInRoots())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->GetVictim() && !m_ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAuraType(SPELL_AURA_MOD_PACIFY_SILENCE)/*hex*/ ||
+                u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STUN, SPELLFAMILY_PALADIN, 0x4)/*repentance*/ ||
+                u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STUN, SPELLFAMILY_PRIEST, 0x40000000)/*shackle undead*/)
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bot_ai const* m_ai;
+        uint32 m_spellId;
+        RootUnitCheck(RootUnitCheck const&);
+};
+
+class CastingUnitCheck
+{
+    public:
+        explicit CastingUnitCheck(Unit const* unit, float mindist = 0.f, float maxdist = 30, uint32 spell = 0, uint8 minHpPct = 0) :
+        me(unit), min_range(mindist), max_range(maxdist), m_spell(spell), m_minHpPct(minHpPct) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!u->IsAlive())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (u->HealthBelowPct(m_minHpPct))
+                return false;
+            if (min_range > 0.1f && me->GetDistance(u) < min_range)
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            //if (!m_friend && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))//prevent double silence
+            //    return false;
+            if (!u->IsNonMeleeSpellCasted(false,false,true))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (u->GetReactionTo(me) >= REP_FRIENDLY)
+                return false;
+            if (m_spell)
+            {
+                if ((m_spell == 5782 || //fear (warlock)
+                    m_spell == 64044) && //fear (priest)
+                    u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                    return false;
+                if (m_spell == 10326 && //turn evil
+                    !(u->GetCreatureType() == CREATURE_TYPE_UNDEAD ||
+                    u->GetCreatureType() == CREATURE_TYPE_DEMON))
+                    return false;
+                if (m_spell == 20066 && //repentance
+                    !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                    u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                    u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                    u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                    u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                    return false;
+                if (m_spell == 2637 && //hibernate
+                    !(u->GetCreatureType() == CREATURE_TYPE_BEAST ||
+                    u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN))
+                    return false;
+
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(m_spell);
+                if (u->IsImmunedToSpell(spellInfo))
+                    return false;
+
+                if (!CastInterruptionCheck(u, spellInfo))
+                    return false;
+            }
+
+            return true;
+        }
+
+        static bool CastInterruptionCheck(Unit const* u, SpellInfo const* spellInfo)
+        {
+            if (spellInfo->HasEffect(SPELL_EFFECT_INTERRUPT_CAST) && spellInfo->GetFirstRankSpell()->Id != 853) //hammer of justice
+            {
+                if (u->GetTypeId() == TYPEID_UNIT &&
+                    (u->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1 << (MECHANIC_INTERRUPT - 1))))
+                    return false;
+
+                Spell* curSpell;
+                for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                {
+                    curSpell = u->GetCurrentSpell(i);
+                    if (!curSpell)
+                        continue;
+
+                    //copied conditions from Spell::EffectInterruptCast
+                    if (!((curSpell->getState() == SPELL_STATE_CASTING ||
+                        (curSpell->getState() == SPELL_STATE_PREPARING && curSpell->GetCastTime() > 0.0f)) &&
+                        curSpell->GetSpellInfo()->PreventionType == SPELL_PREVENTION_TYPE_SILENCE &&
+                        ((i == CURRENT_GENERIC_SPELL && curSpell->GetSpellInfo()->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT) ||
+                        (i == CURRENT_CHANNELED_SPELL && curSpell->GetSpellInfo()->ChannelInterruptFlags & CHANNEL_INTERRUPT_FLAG_INTERRUPT))))
+                        return false;
+                }
+            }
+            bool silenceSpell = false;
+            for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+            {
+                if (spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AURA &&
+                    spellInfo->Effects[i].ApplyAuraName == SPELL_AURA_MOD_SILENCE)
+                {
+                    silenceSpell = true;
+                    break;
+                }
+            }
+            if (silenceSpell)
+            {
+                if (u->GetTypeId() == TYPEID_UNIT &&
+                    (u->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1 << (MECHANIC_SILENCE - 1))))
+                    return false;
+
+                Spell* curSpell;
+                for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                {
+                    curSpell = u->GetCurrentSpell(i);
+                    if (curSpell && curSpell->GetSpellInfo()->PreventionType != SPELL_PREVENTION_TYPE_SILENCE)
+                        return false;
+                }
+            }
+
+            return true; //do not check players and non-interrupt non-silence spells
+        }
+
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        uint32 m_spell;
+        uint8 m_minHpPct;
+        CastingUnitCheck(CastingUnitCheck const&);
+};
+
+class SecondEnemyCheck
+{
+    public:
+        explicit SecondEnemyCheck(Unit const* unit, float dist, float splashdist, Unit const* currtarget, bot_ai const* m_ai) :
+        me(unit), m_range(dist), m_splashrange(splashdist), mytar(currtarget), ai(m_ai) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u == mytar)
+                return false;//We need to find SECONDARY target
+            if (u->isMoving() != mytar->isMoving())//only when both targets idle or both moving
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range + 1.f))//distance check
+                return false;
+            if (mytar->GetDistance(u) > m_splashrange)//not close enough to each other
+                return false;
+
+            if (ai->CanBotAttack(u))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range, m_splashrange;
+        Unit const* mytar;
+        bot_ai const* ai;
+        SecondEnemyCheck(SecondEnemyCheck const&);
+};
+
+class TranquilTargetCheck
+{
+    public:
+        explicit TranquilTargetCheck(Unit const* unit, float mindist, float maxdist, bot_ai const* m_ai) :
+        me(unit), min_range(mindist), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u != me->GetVictim() &&//check hunter_bot::hunter_botAI::CheckTranquil(uint32)
+                u->IsWithinDistInMap(me, max_range) &&
+                u->GetDistance(me) > min_range &&
+                u->IsAlive() &&
+                u->InSamePhase(me) &&
+                u->IsInCombat() &&
+                u->isTargetableForAttack() &&
+                u->IsVisible() &&
+                ai->IsInBotParty(u->GetVictim()) &&
+                u->GetReactionTo(me) <= REP_NEUTRAL)
+            {
+                if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19801))) return false;//immune to tranquilizing shot
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    SpellInfo const* Info = itr->second->GetSpellInfo();
+                    if (Info->Dispel != DISPEL_MAGIC && Info->Dispel != DISPEL_ENRAGE) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    //if (Info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(u->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        bot_ai const* ai;
+        TranquilTargetCheck(TranquilTargetCheck const&);
+};
+
+class NearbyHostileUnitCheck
+{
+    public:
+        explicit NearbyHostileUnitCheck(Unit const* unit, float maxdist, bot_ai const* m_ai, bool forCC, WorldObject const* source) :
+        me(unit), max_range(maxdist), ai(m_ai), m_forCC(forCC), _source(source)
+        {
+            free = ai->IAmFree();
+        }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me || u == _source)
+                return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(_source))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if (m_forCC && u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (!free && !ai->CanBotAttack(u))
+                return false;
+            if (!_source->IsWithinDistInMap(u, max_range))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+
+            if (!free && !ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer())
+                    return false;
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack())
+                    return false;
+            }
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        bool m_forCC;
+        bool free;
+        WorldObject const* _source;
+        NearbyHostileUnitCheck(NearbyHostileUnitCheck const&);
+};
+
+class NearbyHostileUnitInConeCheck
+{
+    public:
+        explicit NearbyHostileUnitInConeCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) :
+        me(unit), max_range(maxdist), ai(m_ai), cone(M_PI/2)
+        {
+            free = ai->IAmFree();
+        }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            //if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+            //    return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if (!free && !ai->CanBotAttack(u))
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (!me->HasInArc(cone, u))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+
+            if (!free && !ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer())
+                    return false;
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack())
+                    return false;
+            }
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        float cone;
+        bot_ai const* ai;
+        bool free;
+        NearbyHostileUnitInConeCheck(NearbyHostileUnitInConeCheck const&);
+};
+
+class NearbyFriendlyUnitCheck
+{
+    public:
+        explicit NearbyFriendlyUnitCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) : me(unit), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            //if (!u->IsInCombat())
+            //    return false;
+            if (!u->IsAlive())
+                return false;
+            if (u->IsTotem() || u->IsSummon())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!ai->IsInBotParty(u))
+                return false;
+            if (!me->CanSeeOrDetect(u))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        NearbyFriendlyUnitCheck(NearbyFriendlyUnitCheck const&);
+};
+
+class FarTauntUnitCheck
+{
+    public:
+        explicit FarTauntUnitCheck(Unit const* unit, float maxdist, bool ally, bot_ai const* m_ai) :
+        me(unit), max_range(maxdist), targetAlly(ally), ai(m_ai)
+        {
+            free = ai->IAmFree();
+        }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if (u->GetTypeId() != TYPEID_UNIT)
+                return false;
+            if (u->IsControlledByPlayer())
+                return false;
+            if (!u->GetVictim() || u->GetVictim() == me)
+                return false;
+            if (!u->CanHaveThreatList())
+                return false;
+            if (u->HasAuraType(SPELL_AURA_MOD_TAUNT))
+                return false;
+            if (ai->IsTank(u->GetVictim()))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!free && !ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARRIOR && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(355)))
+                return false; //taunt
+            else if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(62124)))
+                return false; //HoR
+            else if (me->ToCreature()->GetBotClass() == BOT_CLASS_DRUID && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(6795)))
+                return false; //Growl
+
+            if (free && (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack()))
+                return false;
+
+            if (me->GetDistance(targetAlly ? u->GetVictim() : u) > max_range)
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        bool free;
+        bool targetAlly;
+        FarTauntUnitCheck(FarTauntUnitCheck const&);
+};
+
+class NearbyRezTargetCheck
+{
+    public:
+        explicit NearbyRezTargetCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) : me(unit), max_range(maxdist), ai(m_ai) { }
+        bool operator()(WorldObject const* u) const
+        {
+            if (u == me)
+                return false;
+            if (u->GetTypeId() != TYPEID_PLAYER && u->GetTypeId() != TYPEID_CORPSE)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (Player const* p = u->ToPlayer())
+            {
+                if (p->IsAlive())
+                    return false;
+                if (p->isRessurectRequested())
+                    return false;
+                if (!ai->IsInBotParty(p))
+                    return false;
+            }
+            if (!me->CanSeeOrDetect(u))
+                return false;
+            if (urand(0,100) > 20)
+                return false;
+            if (u->GetTypeId() == TYPEID_CORPSE && !sObjectAccessor->FindPlayer(u->ToCorpse()->GetOwnerGUID()))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        NearbyRezTargetCheck(NearbyRezTargetCheck const&);
+};
+
+class NearestLockedGameObjectInRangeCheck
+{
+public:
+    NearestLockedGameObjectInRangeCheck(WorldObject const* unit, float range) : _unit(unit), _range(range) { }
+    bool operator()(GameObject* go)
+    {
+        if (go->GetGOInfo()->GetLockId() && go->getLootState() == GO_READY && _unit->IsWithinDistInMap(go, _range))
+        {
+            _range = _unit->GetExactDist(go);
+            return true;
+        }
+        return false;
+    }
+private:
+    WorldObject const* _unit;
+    float _range;
+
+    NearestLockedGameObjectInRangeCheck(NearestLockedGameObjectInRangeCheck const&);
+};
+
+//Professions
+class NearbyObjectBySkillCheck
+{
+public:
+    NearbyObjectBySkillCheck(WorldObject const* checker, float const range, uint16 skillMask) :
+      _checker(checker), _range(range), _skillMask(skillMask) { ASSERT(_checker->GetTypeId() == TYPEID_PLAYER); }
+
+    bool operator()(WorldObject const* ob)
+    {
+        if (!_checker->IsWithinDistInMap(ob, _range))
+            return false;
+
+        if (GameObject const* go = ob->ToGameObject())
+        {
+            if (/*go->getLootState() == GO_READY && */go->isSpawned() && go->GetGOInfo()->GetLockId() &&
+                go->IsLootAllowedFor(_checker->ToPlayer()) && _checker->CanSeeOrDetect(go) && _checker->ToPlayer()->HaveAtClient(ob))
+            {
+                if (LockEntry const* lockInfo = sLockStore.LookupEntry(go->GetGOInfo()->GetLockId()))
+                {
+                    for (uint8 i = 0; i != MAX_LOCK_CASE; ++i)
+                    {
+                        if (lockInfo->Type[i] == LOCK_KEY_SKILL &&
+                            CheckSkill(SkillByLockType(LockType(lockInfo->Index[i]))) &&
+                            lockInfo->Skill[i] <= MaxSkillForLevel(_checker->ToUnit()->getLevel()))
+                            return true;
+                    }
+                }
+            }
+        }
+        else if (Creature const* cre = ob->ToCreature())
+        {
+            if (cre->IsVisible() && cre->getDeathState() == CORPSE && cre->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && cre->loot.isLooted() &&
+                CheckSkill(cre->GetCreatureTemplate()->GetRequiredLootSkill()))
+            {
+                if (int32(cre->getLevel() < 20 ? (cre->getLevel() - 10) * 10 : cre->getLevel() * 5) <= int32(MaxSkillForLevel(_checker->ToUnit()->getLevel())))
+                    return true;
+            }
+        }
+        return false;
+    }
+private:
+    WorldObject const* _checker;
+    float const _range;
+    uint16 const _skillMask;
+
+    inline bool CheckSkill(SkillType const skill) const
+    {
+        switch (skill)
+        {
+            case SKILL_MINING:
+                return (_skillMask & BOT_ROLE_GATHERING_MINING);
+            case SKILL_HERBALISM:
+                return (_skillMask & BOT_ROLE_GATHERING_HERBALISM);
+            case SKILL_SKINNING:
+                return (_skillMask & BOT_ROLE_GATHERING_SKINNING);
+            case SKILL_ENGINEERING:
+                return (_skillMask & BOT_ROLE_GATHERING_ENGINEERING);
+            default:
+                return false;
+        }
+    }
+
+    inline uint32 MaxSkillForLevel(uint8 const level) const
+    {
+        return
+            level <= 20 ? 150 :
+            level <= 40 ? 225 :
+            level <= 60 ? 300 :
+            level <= 70 ? 375 : 450;
+
+        //return level <= 60 ? level * 5 : 300 + (((level - 60) * 15) / 2);
+    }
+
+    NearbyObjectBySkillCheck(NearbyObjectBySkillCheck const&);
+};
+
+namespace BOTAI_PRED
+{
+    class HealTargetExclude
+    {
+        public:
+            bool operator()(Unit const* target)
+            {
+                return target->GetHealthPct() > 95 && target->GetMaxHealth() - target->GetHealth() < 500;
+            }
+    };
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_ai.cpp b/src/server/game/AI/NpcBots/bot_ai.cpp
new file mode 100644
index 0000000..5b98723
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.cpp
@@ -0,0 +1,10915 @@
+#include "bot_ai.h"
+#include "bot_Events.h"
+#include "bot_GridNotifiers.h"
+#include "botmgr.h"
+#include "botdatamgr.h"
+#include "CellImpl.h"
+#include "Chat.h"
+#include "GameEventMgr.h"
+#include "GridNotifiersImpl.h"
+#include "LFG.h"
+#include "LFGMgr.h"
+#include "ScriptedGossip.h"
+#include "SpellAuraEffects.h"
+/*
+NpcBot System by Trickerer (https://bitbucket.org/trickerer/trinity-bots; onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+TODO:
+Aura Remove hook
+Specs
+Encounter Scenarios
+I NEED MORE
+*/
+#define MAX_AMMO_LEVEL 13
+uint8 const AmmoDPSForLevel[MAX_AMMO_LEVEL][2] =
+{
+    {  1,  1 },
+    {  5,  2 },
+    { 10,  3 },
+    { 15,  4 },
+    { 25,  7 },
+    { 30,  8 },
+    { 37, 12 },
+    { 44, 15 },
+    { 52, 17 },
+    { 57, 26 },
+    { 62, 43 },
+    { 72, 67 },
+    { 80, 91 }
+};
+#define MAX_POTION_SPELLS 8
+#define MAX_FEAST_SPELLS 11
+uint32 const ManaPotionSpells[MAX_POTION_SPELLS][2] =
+{
+    {  5,   437 },
+    { 14,   438 },
+    { 22,  2023 },
+    { 31, 11903 },
+    { 41, 17530 },
+    { 49, 17531 },
+    { 55, 28499 },
+    { 70, 43186 }
+};
+uint32 const HealingPotionSpells[MAX_POTION_SPELLS][2] =
+{
+    {  1,   439 },
+    {  3,   440 },
+    { 12,   441 },
+    { 21,  2024 },
+    { 35,  4042 },
+    { 45, 17534 },
+    { 55, 28495 },
+    { 70, 43185 }
+};
+uint32 const DrinkSpells[MAX_FEAST_SPELLS][2] =
+{
+    {  1,   430 },
+    {  5,   431 },
+    { 15,   432 },
+    { 25,  1133 },
+    { 35,  1135 },
+    { 45,  1137 },
+    { 60, 34291 },
+    { 65, 27089 },
+    { 70, 43182 },
+    { 75, 43183 },
+    { 80, 57073 }
+};
+uint32 const EatSpells[MAX_FEAST_SPELLS][2] =
+{
+    {  1,   433 },
+    {  5,   434 },
+    { 15,   435 },
+    { 25,  1127 },
+    { 35,  1129 },
+    { 45,  1131 },
+    { 55, 27094 },
+    { 65, 35270 },
+    { 70, 43180 }, //req 65 but
+    { 75, 45548 },
+    { 80, 45548 }
+};
+uint8 const GroupIconsFlags[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+static uint16 __rand; //calculated for each bot separately once every updateAI tick
+
+static std::set<uint32> BotCustomSpells;
+static bool SPELLS_DEFINED = false;
+
+extern bool _botPvP;
+extern uint8 _maxClassNpcBots;
+extern uint8 _healTargetIconFlags;
+extern float _mult_dmg_melee;
+extern float _mult_dmg_spell;
+extern float _mult_healing;
+
+extern bool allBotsLoaded;
+
+bot_minion_ai::bot_minion_ai(Creature* creature) : bot_ai(creature)
+{
+    _potionTimer = 0;
+    _classinfo = new PlayerClassLevelInfo();
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        for (uint8 j = 0; j != MAX_BOT_ITEM_MOD; ++j)
+            _stats[i][j] = 0;
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        _equips[i] = NULL;
+
+    _reviveTimer = 0;
+    _powersTimer = 0;
+    _chaseTimer = 0;
+
+    _jumpCount = 0;
+    _evadeCount = 0;
+
+    _lastTargetGuid = 0;
+}
+bot_minion_ai::~bot_minion_ai()
+{
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        if (_equips[i])
+            delete _equips[i];
+    delete _classinfo;
+}
+
+bot_pet_ai::bot_pet_ai(Creature* creature) : bot_ai(creature)
+{
+    m_creatureOwner = me->GetCreatureOwner();
+    basearmor = 0;
+}
+bot_pet_ai::~bot_pet_ai() { }
+
+bot_ai::bot_ai(Creature* creature) : ScriptedAI(creature)
+{
+    bot_ai::InitBotCustomSpells();
+
+    ResetBotAI(BOTAI_RESET_INIT);
+    m_botCommandState = COMMAND_FOLLOW;
+    checkMasterTimer = urand(5000, 15000);
+    feast_health = false;
+    feast_mana = false;
+    spawned = false;
+    firstspawn = true;
+    _evadeMode = false;
+    _atHome = true;
+    _roleMask = 0;
+    haste = 0;
+    hit = 0.f;
+    parry = 0.f;
+    dodge = 0.f;
+    block = 0.f;
+    crit = 0.f;
+    dmg_taken = 1.f;
+    armor_pen = 0.f;
+    expertise = 0;
+    spellpower = 0;
+    spellpen = 0;
+    defense = 0;
+    blockvalue = 1;
+    regenTimer = 0;
+    m_botSpellInfo = NULL;
+    waitTimer = 0;
+    GC_Timer = 0;
+    lastdiff = 0;
+    _bootTimer = -1;
+    _updateTimerMedium = 0;
+    _updateTimerEx1 = urand(12000, 15000);
+    checkAurasTimer = 0;
+    roleTimer = 0;
+    doHealth = false;
+    doMana = false;
+    //shouldUpdateStats = true;
+    pos.m_positionX = 0.f;
+    pos.m_positionY = 0.f;
+    pos.m_positionZ = 0.f;
+    aftercastTargetGuid = 0;
+
+    _deathsCount = 0;
+    _killsCount = 0;
+    _pvpKillsCount = 0;
+    _playerKillsCount = 0;
+
+    for (uint8 i = 0; i != 6; ++i)
+        resistbonus[i] = 0;
+
+    //visUpEvent = NULL;
+    teleHomeEvent = NULL;
+    //evadeEvent = NULL;
+    teleFinishEvent = NULL;
+}
+bot_ai::~bot_ai()
+{
+    while (!_spells.empty())
+    {
+        BotSpellMap::iterator itr = _spells.begin();
+        delete itr->second;
+        _spells.erase(itr);
+    }
+}
+
+uint16 bot_ai::Rand() const
+{
+    return __rand;
+}
+
+void bot_ai::GenerateRand() const
+{
+    __rand = urand(0, IAmFree() ? 100 : 100 + (master->GetNpcBotsCount() - 1) * 5);
+}
+
+void bot_ai::BotSay(char const* text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->MonsterSay(text, LANG_UNIVERSAL, target->GetGUID());
+}
+void bot_ai::BotWhisper(char const* text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->MonsterWhisper(text, target->GetGUID());
+}
+void bot_ai::BotYell(char const* text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->MonsterYell(text, LANG_UNIVERSAL, target->GetGUID());
+}
+
+bool bot_ai::SetBotOwner(Player* newowner)
+{
+    ASSERT(newowner && "Trying to set NULL owner!!!");
+    ASSERT(IS_PLAYER_GUID(newowner->GetGUID()) && "Trying to set a non-player as owner!!!");
+    //ASSERT(master->GetGUID() == me->GetGUID());
+    //ASSERT(!IsMinionAI() || IAmFree());
+
+    //have master already
+    if (master->GetGUID() != me->GetGUID())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): bot %s (id: %u) has master %s while trying to set to %s...",
+            me->GetName().c_str(), me->GetEntry(), master->GetName().c_str(), newowner->GetName().c_str());
+        return false;
+    }
+    if (IsMinionAI() && !IAmFree())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): minion bot %s (id: %u) IS NOT FREE (has master %s) while trying to set to %s",
+            me->GetName().c_str(), me->GetEntry(), master->GetName().c_str(), newowner->GetName().c_str());
+        return false;
+    }
+
+    if (IsMinionAI())
+    {
+        BotMgr* mgr = newowner->GetBotMgr();
+        if (!mgr)
+            mgr = new BotMgr(newowner);
+
+        bool takeMoney = (_ownerGuid != newowner->GetGUIDLow());
+        if (mgr->AddBot(me, takeMoney) & BOT_ADD_FATAL)
+        {
+            //TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): player %s (%u) can't add bot %s (FATAL), removing...",
+            //    master->GetName().c_str(), master->GetGUIDLow(), me->GetName().c_str());
+            //failed to add bot
+            //if (_ownerGuid)
+            //{
+            //    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+            //    //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+            //    stmt->setUInt32(0, uint32(0));
+            //    stmt->setUInt32(1, me->GetEntry());
+            //    CharacterDatabase.Execute(stmt);
+            //}
+
+            if (_ownerGuid)
+            {
+                TC_LOG_ERROR("entities.player", "bot_ai::FindMaster(): %s's master %s (guid: %u) is found but bot failed to set owner (fatal)! Unbinding bot temporarily (until server restart)...",
+                    me->GetName().c_str(), newowner->GetName().c_str(), newowner->GetGUIDLow());
+                _ownerGuid = 0;
+            }
+
+            checkMasterTimer = 30000;
+            ResetBotAI(BOTAI_RESET_LOST);
+            return false;
+        }
+
+        (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 &= ~(UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+        me->SetUInt32Value(UNIT_FIELD_FLAGS_2, me->GetCreatureTemplate()->unit_flags2);
+    }
+
+    //recursive
+    if (master->GetGUID() == newowner->GetGUID())
+        return true;
+
+    master = newowner;
+    _ownerGuid = newowner->GetGUIDLow();
+    spawned = false;
+
+    ASSERT(me->IsInWorld());
+    AbortTeleport();
+    return true;
+}
+
+void bot_ai::ResetBotAI(uint8 resetType)
+{
+    //ASSERT(me->IsInWorld());
+
+    master = reinterpret_cast<Player*>(me);
+    if (resetType & BOTAI_RESET_MASK_ABANDON_MASTER)
+        _ownerGuid = 0;
+
+    (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 |= (UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+    me->SetUInt32Value(UNIT_FIELD_FLAGS_2, me->GetCreatureTemplate()->unit_flags2);
+
+    me->IsAIEnabled = true;
+    me->SetCanUpdate(true);
+
+    if (spawned)
+        ReturnHome();
+
+    if (!me->IsInWorld())
+    {
+        ASSERT(IsMinionAI());
+        AbortTeleport();
+
+        //if no master - will teleport to spawn position
+        //otherwise - will teleport to master
+        teleHomeEvent = new TeleportHomeEvent(ToMinionAI());
+        Events.AddEvent(teleHomeEvent, Events.CalculateTime(0)); //make sure event will be deleted
+        teleHomeEvent->to_Abort = true; //make sure event will not be executed twice
+        teleHomeEvent->Execute(0,0);
+    }
+    else
+    {
+        _atHome = false;
+        spawned = false;
+    }
+}
+
+bool bot_ai::_checkImmunities(Unit const* target, SpellInfo const* spellInfo) const
+{
+    return target && spellInfo && !target->IsImmunedToDamage(spellInfo);
+}
+
+SpellCastResult bot_ai::CheckBotCast(Unit const* victim, uint32 spellId, uint8 botclass) const
+{
+    if (spellId == 0)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (victim->GetTypeId() == TYPEID_PLAYER && victim->ToPlayer()->IsGameMaster())
+        return SPELL_FAILED_BAD_TARGETS;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (me->IsMounted() && !(spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_MOUNTED))
+        return SPELL_FAILED_NOT_MOUNTED;
+
+    if (int32(me->GetPower(Powers(spellInfo->PowerType))) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+        return SPELL_FAILED_NO_POWER;
+
+    if (!IsSpellReady(spellInfo->GetFirstRankSpell()->Id, lastdiff, false))
+        return SPELL_FAILED_NOT_READY;
+
+    //if (victim->isType(TYPEMASK_UNIT) && InDuel(victim))
+    //    return SPELL_FAILED_BAD_TARGETS;
+
+    if (!spellInfo->IsPassive() && spellInfo->IsRanked() && victim->isType(TYPEMASK_UNIT))
+    {
+        bool needRankSelection = false;
+        for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        {
+            if (spellInfo->IsPositiveEffect(i) &&
+                (spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AURA ||
+                spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_PARTY ||
+                spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_RAID))
+            {
+                needRankSelection = true;
+                break;
+            }
+        }
+        if (needRankSelection && victim->getLevel() < spellInfo->GetFirstRankSpell()->BaseLevel)
+        {
+            //TC_LOG_ERROR("entities.player", "bot_ai::CheckBotCast(): spell %u returns SPELL_FAILED_LOWLEVEL", spellInfo->GetFirstRankSpell()->Id);
+            return SPELL_FAILED_LOWLEVEL;
+        }
+    }
+
+    //disarmed
+    if (spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON)
+    {
+        if (spellInfo->EquippedItemInventoryTypeMask != 0)
+        {
+            if ((spellInfo->EquippedItemInventoryTypeMask & (1<<INVTYPE_WEAPONMAINHAND)) &&
+                !me->CanUseAttackType(BASE_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND;
+            if ((spellInfo->EquippedItemInventoryTypeMask & (1<<INVTYPE_WEAPONOFFHAND)) &&
+                !me->CanUseAttackType(OFF_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS_OFFHAND;
+            if ((spellInfo->EquippedItemInventoryTypeMask & ((1<<INVTYPE_RANGED)|(1<<INVTYPE_RANGEDRIGHT)|(1<<INVTYPE_THROWN))) &&
+                !me->CanUseAttackType(RANGED_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+        }
+        else if (!me->CanUseAttackType(BASE_ATTACK))
+            return SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND;
+    }
+
+    //immunities
+    if (victim->isType(TYPEMASK_UNIT))
+    {
+        if (spellInfo->HasEffect(SPELL_EFFECT_HEAL) || spellInfo->HasAura(SPELL_AURA_PERIODIC_HEAL))
+        {
+            //banish or something
+            Unit::AuraEffectList const& healPctEffects = victim->GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_PCT);
+            if (!healPctEffects.empty())
+            {
+                int32 castTime = spellInfo->CastTimeEntry ? spellInfo->CastTimeEntry->CastTime : 0;
+                if (castTime)
+                    ApplyClassSpellCastTimeMods(spellInfo, castTime);
+                for (Unit::AuraEffectList::const_iterator itr = healPctEffects.begin(); itr != healPctEffects.end(); ++itr)
+                    if ((*itr)->GetAmount() <= -100 && (!castTime || (*itr)->GetBase()->GetDuration() >= castTime))
+                        return SPELL_FAILED_BAD_TARGETS;
+            }
+        }
+        else if (//spells that ignore immunities
+            spellId != 64382 && //shattering throw
+            spellId != 32375 && //mass dispel
+            !_checkImmunities(victim, spellInfo))
+            return SPELL_FAILED_BAD_TARGETS;
+    }
+
+    switch (botclass)
+    {
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_DRUID:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+            if (Feasting() && !master->IsInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_WARRIOR:
+            //BladeStorm
+            if (me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_BM:
+            //BladeStorm PLACEHOLDER
+            if (me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY)/*me->HasAura(46924 67541)*/)
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_ROGUE:
+            //Killing Spree
+            if (me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_DEATH_KNIGHT:
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "CheckBotCast(): Unknown bot class %u", botclass);
+            break;
+    }
+
+    return SPELL_CAST_OK;
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, bool triggered)
+{
+    return doCast(victim, spellId, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, TriggerCastFlags flags)
+{
+    if (spellId == 0) return false;
+    if (!victim || !victim->IsInWorld() || me->GetMap() != victim->FindMap()) return false;
+    if (IsCasting()) return false;
+
+    m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!m_botSpellInfo)
+        return false;
+
+    //select aura level
+    if (victim->isType(TYPEMASK_UNIT))
+        if (SpellInfo const* actualSpellInfo = m_botSpellInfo->GetAuraRankForLevel(victim->getLevel()))
+            m_botSpellInfo = actualSpellInfo;
+
+    if (victim->isType(TYPEMASK_UNIT) && (flags & TRIGGERED_FULL_MASK) != TRIGGERED_FULL_MASK &&
+        !(m_botSpellInfo->AttributesEx2 & SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS) &&
+        !IsInBotParty(victim) && !me->IsWithinLOSInMap(victim))
+        return false;
+
+    //check wrong spell interruption attempts
+    if (/*victim->isType(TYPEMASK_UNIT) && */!CastingUnitCheck::CastInterruptionCheck(victim, m_botSpellInfo))
+        return false;
+
+    //for debug only
+    if (victim->isType(TYPEMASK_UNIT) && !victim->IsAlive() &&
+        !(m_botSpellInfo->AttributesEx2 & SPELL_ATTR2_CAN_TARGET_DEAD) &&
+        !m_botSpellInfo->HasEffect(SPELL_EFFECT_RESURRECT) &&
+        !m_botSpellInfo->HasEffect(SPELL_EFFECT_RESURRECT_NEW) &&
+        !m_botSpellInfo->HasEffect(SPELL_EFFECT_SELF_RESURRECT))
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::doCast(): %s (bot class %u) tried to cast spell %u on a dead target %s",
+            me->GetName().c_str(), _botclass, spellId, victim->GetName().c_str());
+        //return false;
+    }
+
+    if (me->isMoving() &&
+        ((m_botSpellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_MOVEMENT)
+        //channeled spells missing SPELL_INTERRUPT_FLAG_MOVEMENT
+        //Mind Flay (Rank 8)
+        || spellId == 48155) &&
+        !(m_botSpellInfo->Attributes & SPELL_ATTR0_ON_NEXT_SWING) && !m_botSpellInfo->IsAutoRepeatRangedSpell() &&
+        !(flags & TRIGGERED_FULL_MASK) && (m_botSpellInfo->IsChanneled() || m_botSpellInfo->CalcCastTime()))
+    {
+        if (JumpingOrFalling())
+            return false;
+        if (urand(1,100) <= 80)
+            return false;
+
+        //if (m_botSpellInfo->IsChanneled())
+        //    TC_LOG_ERROR("entities.player", "bot_ai::doCast(): spell %u interrupts movement", spellId);
+        me->BotStopMovement();
+    }
+
+    if ((!victim->isType(TYPEMASK_UNIT) || IsInBotParty(victim)) && !victim->IsWithinLOSInMap(me))
+    {
+        if (!IAmFree())
+        {
+            if (me->GetDistance(victim) > 20.f)
+            {
+                Position pos;
+                victim->GetPosition(&pos);
+                me->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            }
+            else
+                me->Relocate(victim);
+        }
+        else
+            return false;
+    }
+
+    //remove shapeshifts manually to restore powers/stats
+    if (me->GetShapeshiftForm() != FORM_NONE)
+    {
+        if (m_botSpellInfo->CheckShapeshift(me->GetShapeshiftForm()) != SPELL_CAST_OK)
+            if (!removeShapeshiftForm())
+                return false;
+    }
+
+    //CHECKS PASSED, NOW DO IT
+
+    if (me->getStandState() == UNIT_STAND_STATE_SIT && !(m_botSpellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_SITTING))
+    {
+        if (!doMana && (me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+            UpdateMana();
+
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+
+    //debug
+    //TC_LOG_ERROR("entities.player", "CheckBotCast(): %s (%u) by %s", m_botSpellInfo->SpellName[0], spellId, me->GetName().c_str());
+
+    bool triggered = flags == TRIGGERED_FULL_MASK;
+    SpellCastTargets targets;
+    targets.SetUnitTarget(victim);
+    Spell* spell = new Spell(me, m_botSpellInfo, flags);
+    spell->prepare(&targets); //sets current spell if succeed
+
+    bool casted = triggered; //triggered casts are casted immediately
+    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+    {
+        if (me->GetCurrentSpell(i) == spell)
+        {
+            casted = true;
+            break;
+        }
+    }
+
+    if (!casted)
+    {
+        //failed to cast
+        return false;
+    }
+
+    if (triggered)
+        return true;
+    if (m_botSpellInfo->IsPassive() || m_botSpellInfo->IsCooldownStartedOnEvent())
+        return true;
+    if (!m_botSpellInfo->StartRecoveryCategory)
+        return true;
+
+    float gcd = float(m_botSpellInfo->StartRecoveryTime);
+
+    if (gcd != 0x0)
+    {
+        ApplyBotSpellGlobalCooldownMods(m_botSpellInfo, gcd);
+        //Apply haste to cooldown
+        if (haste && m_botSpellInfo->StartRecoveryCategory == 133 && m_botSpellInfo->StartRecoveryTime == 1500 &&
+            m_botSpellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE && m_botSpellInfo->DmgClass != SPELL_DAMAGE_CLASS_RANGED &&
+            !(m_botSpellInfo->Attributes & (SPELL_ATTR0_REQ_AMMO|SPELL_ATTR0_ABILITY)))
+            ApplyPercentModFloatVar(gcd, float(haste), false);
+
+        //if cast time is lower than 1.5 sec it also reduces gcd but only if not instant
+        if (m_botSpellInfo->CastTimeEntry)
+        {
+            if (int32 castTime = m_botSpellInfo->CastTimeEntry->CastTime)
+            {
+                if (castTime > 0)
+                {
+                    ApplyClassSpellCastTimeMods(m_botSpellInfo, castTime);
+                    if (castTime < gcd)
+                        gcd = castTime;
+                }
+            }
+        }
+
+        GC_Timer = uint32(gcd);
+        //global cd cannot be less than 1000 ms
+        GC_Timer = std::max<uint32>(GC_Timer, 1000);
+        //global cd cannot be greater than 1500 ms
+        GC_Timer = std::min<uint32>(GC_Timer, 1500);
+    }
+
+    return true;
+}
+//Follow point calculation
+void bot_minion_ai::_calculatePos(Position& pos)
+{
+    ASSERT(!IAmFree());
+
+    uint8 followdist = master->GetBotFollowDist();
+    float mydist, angle;
+
+    if (HasRole(BOT_ROLE_TANK) && !IsTank(master))
+    {
+        uint8 tanks = master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_TANK);
+        uint8 slot = master->GetBotMgr()->GetNpcBotSlotByRole(BOT_ROLE_TANK, me);
+        angle = M_PI / 6.0f; //max bias (left of right) //total arc is angle * 2
+        angle = (angle / tanks) * (slot - (slot % 2)); //bias
+        if (slot % 2) angle *= -1.f; //bias interchange
+        mydist = 3.5f;
+    }
+    else if (HasRole(BOT_ROLE_RANGED))
+    {
+        uint8 rangeds = master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_RANGED);
+        uint8 slot = master->GetBotMgr()->GetNpcBotSlotByRole(BOT_ROLE_RANGED, me);
+        angle = M_PI / 3.5f; //max bias (left of right) //total arc is angle * 2
+        angle = (angle / rangeds) * (slot - (slot % 2)); //bias
+        if (slot % 2) angle *= -1.f; //bias interchange
+        angle += M_PI; //behind
+        mydist = 1.0f;
+    }
+    else if (HasRole(BOT_ROLE_DPS))
+    {
+        uint8 dpss = master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_DPS);
+        uint8 slot = master->GetBotMgr()->GetNpcBotSlotByRole(BOT_ROLE_DPS, me);
+        angle = M_PI / 7.5f; //max bias (left of right) //total arc is angle * 2
+        angle = (angle / dpss) * (slot); //bias
+        if (slot % 2) angle *= -1.f; //bias interchange
+        angle += ((slot % 4) < 2) ? (M_PI/2.f) : -(M_PI/2.f); //sides
+        mydist = 2.0f;
+    }
+    else
+    {
+        angle = (me->GetEntry() % 2) ? (M_PI/2.f) : -(M_PI/2.f);
+        mydist = 2.5f;
+    }
+
+    mydist += std::max<float>(int8(followdist) - 30, 5) / 7.f; //1.f-10.f
+    mydist = std::max<float>(mydist - 2.f, 0.0f); //get bots closer
+    angle += master->GetOrientation();
+
+    float x(0),y(0),z(master->GetPositionZ());
+    float size = me->GetObjectSize()/3.f;
+    bool over = false;
+    for (uint8 i = 0; i != 5 + over; ++i)
+    {
+        if (over)
+        {
+            mydist *= 0.2f;
+            break;
+        }
+        //master->GetNearPoint(me, x, y, z, size, mydist, angle);
+        master->GetNearPoint2D(x, y, mydist+size, angle);
+        if (!master->IsWithinLOS(x,y,z)) //try to get much closer to master
+        {
+            mydist *= 0.4f - float(i*0.07f);
+            size *= 0.1f;
+            if (size < 0.1)
+                size = 0.f;
+        }
+        else
+            over = true;
+    }
+
+    //plan ahead
+    //float dist = 5-8
+    //dest x = x + dist*cos(ori)
+    //dest y = y + dist*sin(ori)
+    uint32 movFlags = master->m_movementInfo.GetMovementFlags();
+    if ((movFlags & MOVEMENTFLAG_FORWARD) && !(movFlags & (MOVEMENTFLAG_FALLING_FAR)))
+    {
+        float const aheadDist = std::max<float>(followdist * 0.08, 6.f);
+        x += aheadDist * std::cos(master->GetOrientation());
+        y += aheadDist * std::sin(master->GetOrientation());
+    }
+    master->UpdateAllowedPositionZ(x, y, z);
+    if (size == 0x0 && me->GetPositionZ() < master->GetPositionZ())
+        z += 1.0f; //prevent going underground
+
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+
+    //           TTT
+    //
+    //     mmmm       mmmm
+    //    mmmm    M    mmmm
+    //     mmmm       mmmm
+    //      rrrrrrrrrrrrr
+    //         rrrrrrr
+    //
+    //M - master
+    //T - bot tank (ROLE_TANK)
+    //r - ranged (ROLE_RANGED)
+    //m - melee (ROLE_DPS)
+}
+// Movement set
+// Uses MovePoint() for following instead of MoveFollow()
+// This helps bots overcome a bug with fanthom walls on grid borders blocking creatures' movement
+// This bug is related to mmaps generating precision parameter (less precision - more such glitches)
+void bot_minion_ai::SetBotCommandState(CommandStates st, bool force, Position* newpos)
+{
+    if (!me->IsAlive())
+        return;
+
+    if (JumpingOrFalling())
+        return;
+
+    if (st == COMMAND_FOLLOW && !IsChanneling() &&
+        ((!me->isMoving() && !IsCasting() && master->IsAlive() && !Feasting()) || force))
+    {
+        if (!me->IsInMap(master)) return;
+        if (CCed(me, true)/* || master->HasUnitState(UNIT_STATE_FLEEING)*/) return;
+        if (me->isMoving() && Rand() > 10) return;
+        if (!newpos)
+            _calculatePos(pos);
+        else
+        {
+            pos.m_positionX = newpos->m_positionX;
+            pos.m_positionY = newpos->m_positionY;
+            pos.m_positionZ = newpos->m_positionZ;
+        }
+        if (me->getStandState() == UNIT_STAND_STATE_SIT && !Feasting())
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+        me->GetMotionMaster()->MovePoint(master->GetMapId(), pos);
+        //me->GetMotionMaster()->MoveFollow(master, mydist, angle);
+    }
+    else if (st == COMMAND_STAY)
+    {
+        me->BotStopMovement();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+    if (Creature* m_botsPet = me->GetBotsPet())
+        m_botsPet->SetBotCommandState(st, force);
+}
+
+void bot_pet_ai::SetBotCommandState(CommandStates st, bool force, Position* /*newpos*/)
+{
+    if (!me->IsAlive() || IAmDead())
+        return;
+
+    if (JumpingOrFalling())
+        return;
+
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (!me->IsInMap(master)) return;
+        if (CCed(me, true)) return;
+        if (me->isMoving() && Rand() > 20) return;
+        Unit* followtarget = m_creatureOwner;
+        if (CCed(m_creatureOwner))
+            followtarget = master;
+        if (followtarget == m_creatureOwner)
+        {
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(master)*0.75f < me->GetDistance(m_creatureOwner))
+                me->GetMotionMaster()->MoveFollow(m_creatureOwner, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+        }
+        else
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(m_creatureOwner)*0.75f < me->GetDistance(master))
+                me->GetMotionMaster()->MoveFollow(master, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+    }
+    else if (st == COMMAND_STAY)//NUY
+    {
+        me->BotStopMovement();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+}
+// Buffs And Heal (really)
+// Priority as follows: 1) heal players 2) buff players 3) heal bots 4) buff bots
+// Priority adjustments to be considered
+void bot_minion_ai::BuffAndHealGroup(uint32 diff)
+{
+    if (GC_Timer > diff) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+
+    if (IAmFree())
+    {
+        //heals
+        if (HealTarget(me, diff))
+            return;
+        if (Creature* pet = me->GetBotsPet())
+        {
+            if (pet->IsAlive())
+            {
+                if (HealTarget(pet, diff))
+                    return;
+            }
+        }
+
+        bool omniHostile = (me->getFaction() == 14 || me->HasAura(BERSERK));
+
+        if (!omniHostile && HasRole(BOT_ROLE_HEAL))
+        {
+            std::list<Unit*> targets1;
+            GetNearbyFriendlyTargetsList(targets1, 38);
+            targets1.remove_if(BOTAI_PRED::HealTargetExclude());
+            if (!targets1.empty() && HealTarget(Trinity::Containers::SelectRandomContainerElement(targets1), diff))
+                return;
+        }
+
+        //buffs
+        if (BuffTarget(me, diff))
+            return;
+        if (Creature* pet = me->GetBotsPet())
+        {
+            if (pet->IsAlive())
+            {
+                if (BuffTarget(pet, diff))
+                    return;
+            }
+        }
+
+        if (!omniHostile)
+        {
+            std::list<Unit*> targets2;
+            GetNearbyFriendlyTargetsList(targets2, 38);
+            for (std::list<Unit*>::const_iterator itr = targets2.begin(); itr != targets2.end(); ++itr)
+                if (urand(1,100) < 30 && BuffTarget(*itr, diff))
+                    return;
+        }
+
+        return;
+    }
+
+    BotMap const* map;
+    Group const* pGroup = master->GetGroup();
+    if (!pGroup)
+    {
+        //heals
+        map = master->GetBotMgr()->GetBotMap();
+        if (HasRole(BOT_ROLE_HEAL))
+        {
+            std::list<Unit*> targets3;
+            if (master->IsAlive() && GetHealthPCT(master) < 95 && me->GetDistance(master) < 40)
+                targets3.push_back(master);
+            //if (Unit* veh = master->GetVehicleBase())
+            //    if (veh->GetTypeId() == TYPEID_UNIT)
+            //        if (veh->ToCreature()->GetCreatureTemplate()->type != CREATURE_TYPE_MECHANICAL)
+            //            targets3.push_back(veh);
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                Unit* u = itr->second;
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                    u->ToCreature()->IsTempBot() || me->GetDistance(u) > 40 ||
+                    (GetHealthPCT(u) > 95 && !IsTank(u)))
+                    continue;
+
+                targets3.push_back(u);
+            }
+            for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                    u->IsTotem() || u->GetEntry() == SHAMAN_EARTH_ELEMENTAL || me->GetDistance(u) > 40 ||
+                    (GetHealthPCT(u) > 95 && !IsTank(u)))
+                    continue;
+
+                targets3.push_back(u);
+            }
+
+            if (!targets3.empty() && HealTarget(Trinity::Containers::SelectRandomContainerElement(targets3), diff))
+                return;
+        }
+        //buffs
+        std::list<Unit*> targets4;
+        if (master->IsAlive() && me->GetDistance(master) < 30)
+            targets4.push_back(master);
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Unit* u = itr->second;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                u->IsTotem() || me->GetDistance(u) > 30)
+                continue;
+
+            targets4.push_back(u);
+        }
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                u->IsTotem() || me->GetDistance(u) > 30) continue;
+
+            targets4.push_back(u);
+        }
+
+        if (!targets4.empty() && BuffTarget(Trinity::Containers::SelectRandomContainerElement(targets4), diff))
+            return;
+
+        return;
+    }
+    bool Bots = false;
+    //heals
+    if (HasRole(BOT_ROLE_HEAL))
+    {
+        std::list<Unit*> targets5;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (!Bots)
+                Bots = true;
+            if (!tPlayer->IsAlive()) continue;
+            if (me->GetDistance(tPlayer) > 40) continue;
+            if (GetHealthPCT(tPlayer) < 95 || IsTank(tPlayer))
+                targets5.push_back(tPlayer);
+        }
+        if (Bots)
+        {
+            for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player const* tPlayer = itr->GetSource();
+                if (tPlayer == NULL) continue;
+                if (me->GetMap() != tPlayer->FindMap()) continue;
+
+                if (tPlayer->HaveBot())
+                {
+                    map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        Unit* u = itr->second;
+                        if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                            u->ToCreature()->IsTempBot() || me->GetDistance(u) > 40 ||
+                            (GetHealthPCT(u) > 95 && !IsTank(u)))
+                            continue;
+
+                        targets5.push_back(u);
+                    }
+                }
+                for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+                {
+                    Unit* u = *itr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        u->IsTotem() || u->GetEntry() == SHAMAN_EARTH_ELEMENTAL || me->GetDistance(u) > 40 ||
+                        (GetHealthPCT(u) > 95 && !IsTank(u)))
+                        continue;
+
+                    targets5.push_back(u);
+                }
+            }
+        }
+
+        //check if we have pointed heal target
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+        {
+            if (_healTargetIconFlags & GroupIconsFlags[i])
+            {
+                if (uint64 guid = pGroup->GetTargetIcons()[i])//check this one
+                {
+                    if (Unit* unit = sObjectAccessor->FindUnit(guid))
+                    {
+                        if (unit->IsAlive() && me->GetMap() == unit->FindMap() && me->GetDistance(unit) < 40 &&
+                            GetHealthPCT(unit) < 95 && master->GetVictim() != unit && !IsInBotParty(unit->GetVictim()) &&
+                            unit->GetEntry() != SHAMAN_EARTH_ELEMENTAL ||
+                            !(unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->GetCreatureTemplate()->type == CREATURE_TYPE_MECHANICAL) &&
+                            unit->GetReactionTo(master) >= REP_NEUTRAL)
+                        {
+                            targets5.push_back(unit);
+                        }
+                    }
+                }
+            }
+        }
+        if (!targets5.empty() && HealTarget(Trinity::Containers::SelectRandomContainerElement(targets5), diff))
+            return;
+    }
+    //buffs
+    std::list<Unit*> targets6;
+    for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        if (!Bots)
+            Bots = true;
+        if (!tPlayer->IsAlive()) continue;
+        if (me->GetDistance(tPlayer) > 30) continue;
+        targets6.push_back(tPlayer);
+    }
+    if (Bots)
+    {
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player const* tPlayer = itr->GetSource();
+            if (tPlayer == NULL) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+
+            if (tPlayer->HaveBot())
+            {
+                map = tPlayer->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    Unit* u = itr->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        u->IsTotem() || me->GetDistance(u) > 30)
+                        continue;
+
+                    targets6.push_back(u);
+                }
+            }
+            for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                    u->IsTotem() || me->GetDistance(u) > 30) continue;
+
+                targets6.push_back(u);
+            }
+        }
+    }
+
+    if (!targets6.empty() && BuffTarget(Trinity::Containers::SelectRandomContainerElement(targets6), diff))
+        return;
+}
+// Attempt to resurrect dead players and bots
+// Target is either bot, player or player corpse
+// no need to check global cooldown
+void bot_minion_ai::RezGroup(uint32 REZZ)
+{
+    if (!REZZ || Rand() > 10)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "RezGroup by %s", me->GetName().c_str());
+
+    if (IAmFree())
+    {
+        if (me->getFaction() == 14 || me->HasAura(BERSERK))
+            return;
+
+        WorldObject* playerOrCorpse = GetNearbyRezTarget(30);
+        if (!playerOrCorpse)
+            return;
+
+        if (!playerOrCorpse->IsWithinLOSInMap(me))
+            me->Relocate(*playerOrCorpse);
+
+        Unit* target = playerOrCorpse->GetTypeId() == TYPEID_PLAYER ? playerOrCorpse->ToUnit() : (Unit*)playerOrCorpse->ToCorpse();
+        if (doCast(target, REZZ)) //rezzing it
+        {
+            if (Player const* player = playerOrCorpse->GetTypeId() == TYPEID_PLAYER ? playerOrCorpse->ToPlayer() : sObjectAccessor->FindPlayer(playerOrCorpse->ToCorpse()->GetOwnerGUID()))
+                BotWhisper("Rezzing You", player);
+        }
+
+        return;
+    }
+
+    Group const* group = master->GetGroup();
+    if (!group)
+    {
+        if (master->IsAlive() || master->isRessurectRequested())
+            return;
+
+        Unit* target = master;
+        if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)master->GetCorpse();
+        if (!target || !target->IsInWorld()) return;
+        if (me->GetMap() != target->FindMap()) return;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            return;
+        }
+        else if (me->GetDistance(target) < 15 && !target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+            BotWhisper("Rezzing You");
+
+        return;
+    }
+
+    bool Bots = false;
+    Player* player;
+    Unit* target;
+    for (GroupReference const* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        player = itr->GetSource();
+        target = player;
+        if (!player || player->FindMap() != me->GetMap()) continue;
+        if (!Bots && player->HaveBot())
+            Bots = true;
+        if (player->IsAlive() || player->isRessurectRequested()) continue;
+        if (player->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)player->GetCorpse();
+        if (!target || !target->IsInWorld()) continue;
+        if (target->GetTypeId() != player->GetTypeId() && me->GetMap() != target->FindMap()) continue;
+        if (me->GetDistance(target) > 30)
+        {
+            if (player == master)
+            {
+                me->GetMotionMaster()->MovePoint(me->GetMapId(), *target);
+                return;
+            }
+            continue;
+        }
+        else if (me->GetDistance(target) < 15 && !target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            BotWhisper("Rezzing You", player);
+            if (player != master)
+            {
+                std::string rezstr = "Rezzing ";
+                rezstr += player->GetName();
+                BotWhisper(rezstr.c_str());
+            }
+            return;
+        }
+    }
+
+    if (!Bots)
+        return;
+
+    std::list<Unit*> targets;
+    BotMap const* map;
+    for (GroupReference const* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        player = itr->GetSource();
+        if (!player || player->FindMap() != me->GetMap() || !player->HaveBot()) continue;
+
+        map = player->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            target = itr->second;
+            if (!target || !target->IsInWorld() || target->IsAlive()) continue;
+            if (itr->second->GetBotAI()->GetMinionAI()->GetReviveTimer() < 15000) continue;
+            if (me->GetDistance(target) < 30 && target->IsWithinLOSInMap(me))
+                targets.push_back(target);
+        }
+    }
+
+    if (targets.empty())
+        return;
+
+    target = targets.size() < 2 ? targets.front() : Trinity::Containers::SelectRandomContainerElement(targets);
+
+    if (doCast(target, REZZ))
+    {
+        Player const* targetOwner = target->ToCreature()->GetBotOwner();
+        if (targetOwner != master)
+        {
+            std::string rezstr1 = "Rezzing ";
+            rezstr1 += target->GetName();
+            rezstr1 += " (your bot)";
+
+            std::string rezstr2 = "Rezzing ";
+            rezstr2 += target->GetName();
+            rezstr2 += " (";
+            rezstr2 += targetOwner->GetName();
+            rezstr2 += "'s bot)";
+
+            BotWhisper(rezstr1.c_str(), targetOwner);
+            BotWhisper(rezstr2.c_str());
+        }
+        else
+        {
+            std::string rezstr3 = "Rezzing ";
+            rezstr3 += target->GetName();
+            BotWhisper(rezstr3.c_str());
+        }
+        return;
+    }
+}
+// CURES
+//cycle through the group sending members for cure
+void bot_minion_ai::CureGroup(uint32 cureSpell, uint32 diff)
+{
+    if (!cureSpell || GC_Timer > diff) return;
+    if (me->IsMounted()) return;
+    if (IsCasting()) return;
+
+    if (IAmFree())
+    {
+        if (_canCureTarget(me, cureSpell) && doCast(me, cureSpell))
+            return;
+        if (Creature* pet = me->GetBotsPet())
+            if (_canCureTarget(pet, cureSpell) && doCast(pet, cureSpell))
+                return;
+
+        if (me->getFaction() == 14 || me->HasAura(BERSERK))
+            return;
+
+        std::list<Unit*> targets1;
+        std::list<Unit*> cureTargets;
+        GetNearbyFriendlyTargetsList(targets1, 38);
+        for (std::list<Unit*>::const_iterator itr = targets1.begin(); itr != targets1.end(); ++itr)
+            if (_canCureTarget(*itr, cureSpell))
+                cureTargets.push_back(*itr);
+
+        if (!cureTargets.empty() && doCast(Trinity::Containers::SelectRandomContainerElement(cureTargets), cureSpell))
+            return;
+
+        return;
+    }
+
+    if (!master->GetMap()->IsRaid() && Rand() > 35)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "%s: CureGroup() on %s", me->GetName().c_str(), pTarget->GetName().c_str());
+    std::list<Unit*> targets;
+    Group const* pGroup = master->GetGroup();
+    BotMap const* map;
+    Unit* u;
+    if (!pGroup)
+    {
+        if (_canCureTarget(master, cureSpell))
+            targets.push_back(master);
+
+        map = master->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            u = itr->second;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+            if (_canCureTarget(u, cureSpell))
+                targets.push_back(u);
+        }
+
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsPet() || !u->IsAlive() || me->GetDistance(u) > 30) continue;
+
+            if (_canCureTarget(u, cureSpell))
+                targets.push_back(u);
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (!tPlayer || (!tPlayer->IsAlive() && !tPlayer->HaveBot())) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (_canCureTarget(tPlayer, cureSpell))
+                targets.push_back(tPlayer);
+        }
+        if (!Bots) return;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+
+            if (tPlayer->HaveBot())
+            {
+                map = tPlayer->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+                    if (_canCureTarget(u, cureSpell))
+                        targets.push_back(u);
+                }
+            }
+
+            for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsPet() || !u->IsAlive() || me->GetDistance(u) > 30) continue;
+
+                if (_canCureTarget(u, cureSpell))
+                    targets.push_back(u);
+            }
+        }
+    }
+
+    if (!targets.empty() && doCast(Trinity::Containers::SelectRandomContainerElement(targets), cureSpell))
+        return;
+}
+
+// determines if unit has something to cure
+bool bot_minion_ai::_canCureTarget(Unit const* target, uint32 cureSpell) const
+{
+    if (me->getLevel() < 10 || target->getLevel() < 10) return false;
+    if (me->IsMounted() || IsCasting() || Feasting()) return false;
+    if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsTempBot()) return false;
+
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info)
+        return false;
+
+    if (me->GetDistance(target) > info->GetMaxRange(true))
+        return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->Effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->Effects[i].MiscValue));
+
+    if (dispelMask == 0)
+        return false;
+
+    std::list<Aura const*> dispel_list;
+    _getBotDispellableAuraList(target, me, dispelMask, dispel_list);
+
+    return !(dispel_list.empty());
+}
+
+void bot_minion_ai::_getBotDispellableAuraList(Unit const* target, Unit const* caster, uint32 dispelMask, std::list<Aura const*> &dispelList) const
+{
+    //Unholy Blight prevents diseases from being dispelled
+    if (dispelMask & (1<<DISPEL_DISEASE) &&
+        target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 1494, 0))
+        dispelMask &= ~(1<<DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura const* aura = itr->second;
+
+        if (aura->IsPassive())
+            continue;
+
+        AuraApplication const* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            //do not dispel positive auras from enemies and negative ones from friends
+            if (aurApp->IsPositive() == target->IsFriendlyTo(caster))
+                continue;
+
+            //skip Vampiric Touch to prevent being CCed just heal it out
+            if (aura->GetSpellInfo()->IsRankOf(sSpellMgr->GetSpellInfo(34914)))
+                continue;
+
+            if (((aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount()) > 0)
+                dispelList.push_back(aura);
+        }
+    }
+}
+//protected
+// Quick check if current target has school immunities to prevent cast attempts spam
+// CheckBotCast()->_checkImmunities()
+// Only called after opponent is validated in CheckAttackTarget()->_getTarget()
+bool bot_ai::CanAffectVictim(uint32 schoolMask) const
+{
+    if (schoolMask == SPELL_SCHOOL_MASK_NONE)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::CanDamageVictim(): schoolMask is not present (class = %u)", _botclass);
+        return false;
+    }
+
+    Unit::AuraEffectList const& schoolImmunityAurasList = opponent->GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY);
+    if (!schoolImmunityAurasList.empty())
+    {
+        uint32 finalMask = 0;
+        for (Unit::AuraEffectList::const_iterator itr = schoolImmunityAurasList.begin(); itr != schoolImmunityAurasList.end(); ++itr)
+        {
+            finalMask |= ((*itr)->GetMiscValue() & schoolMask);
+            if (finalMask == schoolMask)
+                return false;
+        }
+    }
+
+    return true;
+}
+// Check if can cast some spell out of main rotation to use up target's spell reflection charges
+// Supposed to check instant non-damaging spells but these checks are not performed (Shaman, Priest)
+bool bot_ai::CanRemoveReflectSpells(Unit const* target, uint32 spellId) const
+{
+    if (!target || !spellId)
+        return false;
+
+    if (!target->HasAuraType(SPELL_AURA_REFLECT_SPELLS) && !target->HasAuraType(SPELL_AURA_REFLECT_SPELLS_SCHOOL))
+        return false;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return false;
+
+    if (!spellInfo->IsPositive() && spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC &&
+        !(spellInfo->Attributes & SPELL_ATTR0_ABILITY) && !(spellInfo->AttributesEx & SPELL_ATTR1_CANT_BE_REFLECTED) &&
+        !(spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY))
+    {
+        //bool directDamage = false;
+        //for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        //{
+        //    if (spellInfo->Effects[i].TargetA.GetTarget() == TARGET_UNIT_TARGET_ENEMY)
+        //    {
+        //        if (spellInfo->Effects[i].IsEffect(SPELL_EFFECT_SCHOOL_DAMAGE) ||
+        //            spellInfo->Effects[i].IsAura(SPELL_AURA_PERIODIC_DAMAGE) ||
+        //            spellInfo->Effects[i].IsAura(SPELL_AURA_PERIODIC_LEECH) ||
+        //            spellInfo->Effects[i].IsAura(SPELL_AURA_MOD_SPEED_SLOW_ALL) ||//Icy Touch
+        //            spellInfo->Effects[i].IsAura(SPELL_AURA_HASTE_SPELLS))//Slow
+        //        {
+        //            directDamage = true;
+        //            break;
+        //        }
+        //    }
+        //}
+        //if (directDamage)
+        //{
+            Unit::AuraEffectList const& reflectAuras1 = target->GetAuraEffectsByType(SPELL_AURA_REFLECT_SPELLS);
+            for (Unit::AuraEffectList::const_iterator itr = reflectAuras1.begin(); itr != reflectAuras1.end(); ++itr)
+            {
+                //All existing SPELL_AURA_REFLECT_SPELLS spells have at least amount 50
+                if ((*itr)->GetBase()->IsUsingCharges() &&
+                    (*itr)->GetBase()->GetCharges() <= target->getAttackers().size() * ((*itr)->GetBase()->GetDuration() / 1000) / 4)
+                    return true;
+            }
+
+            Unit::AuraEffectList const& reflectAuras2 = target->GetAuraEffectsByType(SPELL_AURA_REFLECT_SPELLS_SCHOOL);
+            for (Unit::AuraEffectList::const_iterator itr = reflectAuras2.begin(); itr != reflectAuras2.end(); ++itr)
+            {
+                if ((*itr)->GetBase()->IsUsingCharges() &&
+                    (*itr)->GetAmount() >= 50 && ((*itr)->GetMiscValue() & spellInfo->GetSchoolMask()) &&
+                    (*itr)->GetBase()->GetCharges() <= ((*itr)->GetBase()->GetDuration() / 1000) / 4)
+                    return true;
+            }
+        //}
+    }
+
+    return false;
+}
+//LIST AURAS
+// Debug: Returns bot's info to called player
+void bot_ai::_listAuras(Player const* player, Unit const* unit) const
+{
+    //if (player->GetSession()->GetSecurity() == SEC_PLAYER) return;
+    if (!player->IsGameMaster() && (IAmFree() || !IsInBotParty(player))) return;
+    if (!IsInBotParty(unit)) return;
+    ChatHandler ch(player->GetSession());
+    std::ostringstream botstring;
+    if (unit->GetTypeId() == TYPEID_PLAYER)
+        botstring << "player";
+    else if (unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->IsNPCBot())
+    {
+        bot_ai const* ai = unit->ToCreature()->GetBotAI();
+        if (ai->IsMinionAI())
+        {
+            botstring << "minion bot, master: ";
+            Player const* owner = ai->GetBotOwner();
+            botstring << (owner != unit ? owner->GetName() : "none");
+        }
+        else if (ai->IsPetAI())
+        {
+            Player const* owner = ai->GetBotOwner();
+            Creature const* creowner = ai->GetPetAI()->GetCreatureOwner();
+            std::string const& ownername = owner != unit ? owner->GetName() : "none";
+            std::string const& creownername = creowner ? creowner->GetName() : "none";
+            botstring << "pet bot, master: ";
+            botstring << ownername;
+            botstring << ", creature owner: ";
+            botstring << creownername;
+            if (creowner)
+                botstring << " (" << creowner->GetGUIDLow() << ')';
+        }
+    }
+    uint32 const bot_pet_player_class = unit->GetTypeId() == TYPEID_PLAYER ? unit->getClass() : unit->ToCreature()->GetBotAI()->GetBotClass();
+    ch.PSendSysMessage("ListAuras for %s (class: %u), %s", unit->GetName().c_str(), bot_pet_player_class, botstring.str().c_str());
+    uint8 locale = player->GetSession()->GetSessionDbcLocale();
+    Unit::AuraMap const &vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+        if (!spellInfo)
+            continue;
+        uint32 id = spellInfo->Id;
+        SpellInfo const* learnSpellInfo = sSpellMgr->GetSpellInfo(spellInfo->Effects[0].TriggerSpell);
+        const std::string name = spellInfo->SpellName[locale];
+        std::ostringstream spellmsg;
+        spellmsg << id << " - |cffffffff|Hspell:" << id << "|h[" << name;
+        spellmsg << ' ' << localeNames[locale] << "]|h|r";
+        uint32 talentcost = GetTalentSpellCost(id);
+        uint32 rank = 0;
+        if (talentcost > 0 && (spellInfo->GetNextRankSpell() || spellInfo->GetPrevRankSpell()))
+            rank = talentcost;
+        else if (learnSpellInfo && (spellInfo->GetNextRankSpell() || spellInfo->GetPrevRankSpell()))
+            rank = spellInfo->GetRank();
+        else if (spellInfo->GetNextRankSpell() || spellInfo->GetPrevRankSpell())
+            rank = spellInfo->GetRank();
+        if (rank > 0)
+            spellmsg << " Rank " << rank;
+        if (talentcost > 0)
+            spellmsg << " [talent]";
+        if (spellInfo->IsPassive())
+            spellmsg << " [passive]";
+        if ((spellInfo->Attributes & SPELL_ATTR0_HIDDEN_CLIENTSIDE) ||
+            (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR))
+            spellmsg << " [hidden]";
+        if (unit->GetTypeId() == TYPEID_PLAYER && unit->ToPlayer()->HasSpell(id))
+            spellmsg << " [known]";
+        else if (unit == me && GetSpell(spellInfo->GetFirstRankSpell()->Id))
+            spellmsg << " [ability]";
+
+        ch.SendSysMessage(spellmsg.str().c_str());
+    }
+    for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+    {
+        std::string mystat;
+        switch (i)
+        {
+            case STAT_STRENGTH: mystat = "str"; break;
+            case STAT_AGILITY: mystat = "agi"; break;
+            case STAT_STAMINA: mystat = "sta"; break;
+            case STAT_INTELLECT: mystat = "int"; break;
+            case STAT_SPIRIT: mystat = "spi"; break;
+            default: mystat = "unk stat"; break;
+        }
+        //ch.PSendSysMessage("base %s: %.1f", mystat.c_str(), unit->GetCreateStat(Stats(i));
+        float totalstat = unit->GetTotalStatValue(Stats(i));
+        //ch.PSendSysMessage("base total %s: %.1f", mystat.c_str(), totalstat);
+        if (unit == me && IsMinionAI())
+        {
+            int8 t = -1;
+            switch (i)
+            {
+                case STAT_STRENGTH:     t = BOT_STAT_MOD_STRENGTH;  break;
+                case STAT_AGILITY:      t = BOT_STAT_MOD_AGILITY;   break;
+                case STAT_STAMINA:      t = BOT_STAT_MOD_STAMINA;   break;
+                case STAT_INTELLECT:    t = BOT_STAT_MOD_INTELLECT; break;
+                case STAT_SPIRIT:       t = BOT_STAT_MOD_SPIRIT;    break;
+                default:                                            break;
+            }
+
+            if (t >= BOT_STAT_MOD_MANA)
+                totalstat = GetMinionAI()->GetTotalBotStat(t);
+        }
+        ch.PSendSysMessage("total %s: %.1f", mystat.c_str(), totalstat);
+    }
+    ch.PSendSysMessage("Melee AP: %.1f", unit->GetTotalAttackPowerValue(BASE_ATTACK));
+    ch.PSendSysMessage("Ranged AP: %.1f", unit->GetTotalAttackPowerValue(RANGED_ATTACK));
+    ch.PSendSysMessage("armor: %u", unit->GetArmor());
+    ch.PSendSysMessage("crit: %.2f pct", crit);
+    ch.PSendSysMessage("defense: %u", unit->GetDefenseSkillValue());
+    ch.PSendSysMessage("miss : %.2f pct", unit->GetUnitMissChance(BASE_ATTACK));
+    ch.PSendSysMessage("dodge: %.2f pct", unit->GetUnitDodgeChance());
+    ch.PSendSysMessage("parry: %.2f pct", unit->GetUnitParryChance());
+    ch.PSendSysMessage("block: %.2f pct", unit->GetUnitBlockChance());
+    ch.PSendSysMessage("block value: %u", unit->GetShieldBlockValue());
+    ch.PSendSysMessage("Damage taken melee: %.2f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL));
+    ch.PSendSysMessage("Damage taken spell: %.2f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC));
+
+    WeaponAttackType type = BASE_ATTACK;
+    float attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+    ch.PSendSysMessage("Damage range mainhand: min: %.0f, max: %.0f", unit->GetFloatValue(UNIT_FIELD_MINDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    ch.PSendSysMessage("Damage mult mainhand: %.2f", unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    ch.PSendSysMessage("Attack time mainhand: %.2f (%.1f DPS)", attSpeed,
+        ((unit->GetFloatValue(UNIT_FIELD_MINDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE)) / 2) * unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) * unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT) / attSpeed);
+    if (unit->haveOffhandWeapon())
+    {
+        type = OFF_ATTACK;
+        attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+        ch.PSendSysMessage("Damage range offhand: min: %.0f, max: %.0f", unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+        ch.PSendSysMessage("Damage mult offhand: %.2f", unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+        ch.PSendSysMessage("Attack time offhand: %.2f (%.1f DPS)", attSpeed,
+            ((unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE)) / 2) * unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT) * unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT) / attSpeed);
+    }
+    if (unit != me ||
+        (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2) &&
+        _botclass != BOT_CLASS_PALADIN &&
+        _botclass != BOT_CLASS_DEATH_KNIGHT &&
+        _botclass != BOT_CLASS_DRUID &&
+        _botclass != BOT_CLASS_SHAMAN))
+    {
+        type = RANGED_ATTACK;
+        attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+        ch.PSendSysMessage("Damage range ranged: min: %.1f, max: %.1f", unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+        ch.PSendSysMessage("Damage mult ranged: %.2f", unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+        ch.PSendSysMessage("Attack time ranged: %.2f (%.1f (%.1f from ammo) DPS)", attSpeed,
+            ((unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE)) / 2) * unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) * unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT) / attSpeed,
+            unit->GetTypeId() == TYPEID_PLAYER ? unit->ToPlayer()->GetAmmoDPS() : unit->ToCreature()->GetCreatureAmmoDPS());
+    }
+    ch.PSendSysMessage("base hp: %u", unit->GetCreateHealth());
+    ch.PSendSysMessage("total hp: %u", unit->GetMaxHealth());
+    ch.PSendSysMessage("base mana: %u", unit->GetCreateMana());
+    ch.PSendSysMessage("total mana: %u", unit->GetMaxPower(POWER_MANA));
+    if (unit->GetMaxPower(POWER_MANA) > 1 && unit->getPowerType() != POWER_MANA)
+        ch.PSendSysMessage("cur mana: %u", unit->GetPower(POWER_MANA));
+
+    if (unit == me)
+    {
+        ch.PSendSysMessage("melee damage mult: %.3f", _mult_dmg_melee);
+        ch.PSendSysMessage("spell damage mult: %.3f", _mult_dmg_spell);
+        ch.PSendSysMessage("healing done mult: %.3f", _mult_healing);
+        ch.PSendSysMessage("spell power: %i", me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC));
+        ch.PSendSysMessage("mana regen_5 casting: %.2f", me->GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER) * sWorld->getRate(RATE_POWER_MANA) * 5.0f);
+        ch.PSendSysMessage("mana regen_5 no cast: %.2f", me->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER) * sWorld->getRate(RATE_POWER_MANA) * 5.0f);
+        ch.PSendSysMessage("haste: %s%.2f pct", (haste >= 0 ? "+" : "-"), float(haste));
+        ch.PSendSysMessage("hit: +%.2f pct", hit);
+        ch.PSendSysMessage("expertise: %i (-%.2f pct)", expertise, float(expertise) * 0.25f);
+        ch.PSendSysMessage("armor penetration: %.2f pct", me->GetCreatureArmorPenetrationCoef());
+        ch.PSendSysMessage("spell penetration: %u", spellpen);
+
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            uint32 curresist = me->GetResistance(SpellSchools(i)) + resistbonus[i-1];
+
+            const char* resist = NULL;
+            switch (i)
+            {
+                case 1: resist = "holy";   break;
+                case 2: resist = "fire";   break;
+                case 3: resist = "nature"; break;
+                case 4: resist = "frost";  break;
+                case 5: resist = "shadow"; break;
+                case 6: resist = "arcane"; break;
+            }
+            ch.PSendSysMessage("Resistance %s: %u", resist, curresist);
+        }
+        ch.PSendSysMessage("BotCommandState: %s", m_botCommandState == COMMAND_FOLLOW ? "Follow" : m_botCommandState == COMMAND_ATTACK ? "Attack" : m_botCommandState == COMMAND_STAY ? "Stay" : m_botCommandState == COMMAND_ABANDON ? "Reset" : "none");
+        if (!IAmFree())
+            ch.PSendSysMessage("Follow distance: %u", master->GetBotFollowDist());
+
+        //ch.PSendSysMessage("Boot timer: %i", _bootTimer);
+        ch.PSendSysMessage("Bot roles mask main: %u", _roleMask & BOT_ROLE_MASK_MAIN);
+        ch.PSendSysMessage("Bot roles mask gathering: %u", _roleMask & BOT_ROLE_MASK_GATHERING);
+
+        ch.PSendSysMessage("PvP kills: %u, players: %u, total: %u", _pvpKillsCount, _playerKillsCount, _killsCount);
+        ch.PSendSysMessage("Died %u times", _deathsCount);
+
+        //debug
+        //for (uint32 i = 0; i != 148; ++i)
+        //{
+        //    float val = me->GetFloatValue(i);
+        //    ch.PSendSysMessage("Float value at %u: %.9f", i, val);
+        //}
+
+        //ch.PSendSysMessage("healTargetIconFlags: %u", healTargetIconFlags);
+
+        //ch.PSendSysMessage("Roles:");
+        //for (uint16 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+        //{
+        //    if (_roleMask & i)
+        //    {
+        //        switch (i)
+        //        {
+        //            case BOT_ROLE_TANK:
+        //                ch.PSendSysMessage("BOT_ROLE_TANK");
+        //                break;
+        //            case BOT_ROLE_DPS:
+        //                ch.PSendSysMessage("BOT_ROLE_DPS");
+        //                break;
+        //            case BOT_ROLE_HEAL:
+        //                ch.PSendSysMessage("BOT_ROLE_HEAL");
+        //                break;
+        //            //case BOT_ROLE_MELEE:
+        //            //    ch.PSendSysMessage("BOT_ROLE_MELEE");
+        //            //    break;
+        //            case BOT_ROLE_RANGED:
+        //                ch.PSendSysMessage("BOT_ROLE_RANGED");
+        //                break;
+        //        }
+        //    }
+        //}
+
+        //ch.PSendSysMessage("Stat bonuses:");
+        //for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        //{
+        //    int32 val = 0;
+        //    uint32 const a = i;
+        //    for (uint8 j = 0; j != BOT_INVENTORY_SIZE; ++j)
+        //        val += static_cast<BotStat>(_stats[j])[a];
+
+        //    if (val != 0)
+        //        ch.PSendSysMessage("Item mod %u: bonus = %i", i, val);
+        //}
+    }
+}
+//SetStats
+// Health, Armor, Powers, Combat Ratings, and global update setup
+void bot_minion_ai::SetStats(bool force)
+{
+    if (IsTempBot() && !force)
+        return;
+
+    uint8 myclass = _botclass;
+    uint8 mylevel = std::min<uint8>(master->getLevel(), 80);
+
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+    else if (myclass != BOT_CLASS_WARRIOR && !shouldUpdateStats && !force)
+        return;
+
+    shouldUpdateStats = false;
+    /*TC_LOG_ERROR("entities.player", "*etStats(): Updating bot %s, class: %u, race: %u, level %u, master: %s",
+        me->GetName().c_str(), myclass, myrace, mylevel, master->GetName().c_str());*/
+
+    switch (me->GetCreatureTemplate()->rank) //TODO: conditions
+    {
+        case CREATURE_ELITE_RARE:       mylevel += 1;   break;
+        case CREATURE_ELITE_ELITE:      mylevel += 2;   break;
+        case CREATURE_ELITE_RAREELITE:  mylevel += 3;   break;
+        default:                                        break;
+    }
+    mylevel = std::min<uint8>(mylevel, 83);
+
+    //Do not remove this code
+    if (_botclass == BOT_CLASS_DEATH_KNIGHT)
+        mylevel = std::max<uint8>(mylevel, 55);
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //reinit spells/passives/other
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells(); //this must stay before class passives
+        ApplyClassPassives();
+    }
+
+    //INIT STATS
+    //get base class stats, we'll need all this later
+    uint8 tempclass = myclass == uint8(DRUID_BEAR_FORM) || myclass == uint8(DRUID_CAT_FORM) ? uint8(BOT_CLASS_DRUID) : myclass;
+    if (myclass >= BOT_CLASS_EX_START)
+        sObjectMgr->GetPlayerClassLevelInfo(GetPlayerClass(), std::min<uint8>(mylevel, 80), _classinfo);
+    else
+        sObjectMgr->GetPlayerClassLevelInfo(tempclass, std::min<uint8>(mylevel, 80), _classinfo);
+
+    if (force)
+    {
+        PlayerLevelInfo info;
+        sObjectMgr->GetPlayerLevelInfo(me->getRace(), GetPlayerClass(), std::min<uint8>(mylevel, 80), &info);
+        for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+            me->SetCreateStat(Stats(i), info.stats[i]);
+    }
+
+    switch (myclass)
+    {
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_SHAMAN:
+        case BOT_CLASS_DRUID:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_WARLOCK:
+        case DRUID_BEAR_FORM:
+        case DRUID_CAT_FORM:
+        case DRUID_MOONKIN_FORM:
+        case DRUID_TREE_FORM:
+        case DRUID_TRAVEL_FORM:
+        case DRUID_AQUATIC_FORM:
+        //case DRUID_FLIGHT_FORM:
+        case BOT_CLASS_BM:
+            break;
+
+        default:
+            TC_LOG_ERROR("entities.player", "minion_ai: *etStats():Init - unknown bot class %u, real class: %u, _botclass: %u", myclass, GetPlayerClass(), _botclass);
+            break;
+    }
+
+    float value;
+    float tempval;
+    float ap_mod = 1.0f, armor_mod = 1.0f;
+
+    //DAMAGE PHYSICAL
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+    {
+        float weap_damage_base_min = _getBotStat(i, BOT_STAT_MOD_DAMAGE_MIN);
+        float weap_damage_base_max = _getBotStat(i, BOT_STAT_MOD_DAMAGE_MAX);
+        me->SetBaseWeaponDamage(WeaponAttackType(BASE_ATTACK + i), MINDAMAGE, std::max<float>(weap_damage_base_min, 1.f));
+        me->SetBaseWeaponDamage(WeaponAttackType(BASE_ATTACK + i), MAXDAMAGE, std::max<float>(weap_damage_base_max, 1.f));
+    }
+
+    //Update Attack Time on main hand for shapeshifters
+    //do not add me->GetShapeshiftForm() check here, need to change attack time after shapeshift removal too
+    if (_botclass == BOT_CLASS_DRUID && RespectEquipsAttackTime())
+    {
+        uint32 delay;
+        SpellShapeshiftEntry const* ssEntry = sSpellShapeshiftStore.LookupEntry(me->GetShapeshiftForm());
+        if (!ssEntry || !ssEntry->attackSpeed)
+            delay = _equips[BOT_SLOT_MAINHAND] ? _equips[BOT_SLOT_MAINHAND]->GetTemplate()->Delay : me->GetCreatureTemplate()->baseattacktime;
+        else
+            delay = ssEntry->attackSpeed;
+
+        me->SetAttackTime(BASE_ATTACK, delay);
+    }
+
+    float atpower = float(me->getLevel() * (IAmFree() ? 100 : 3)); //+8000/+240(legit) base ap at 80
+    atpower += _getTotalBotStat(BOT_STAT_MOD_ATTACK_POWER);
+
+    float strmult, agimult;
+    switch (myclass)
+    {
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_DRUID:
+            strmult = 2.f; agimult = 0.f; break;
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_SHAMAN:
+            strmult = 1.f; agimult = 1.f; break;
+        case BOT_CLASS_HUNTER:
+            strmult = 0.5f; agimult = 1.f; break; //until attack power is separated
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+            strmult = 1.f; agimult = 0.f; break;
+        case DRUID_CAT_FORM:
+            strmult = 2.f; agimult = 1.f; break;
+        case DRUID_BEAR_FORM:
+        case DRUID_MOONKIN_FORM:
+        case DRUID_TREE_FORM:
+        case DRUID_TRAVEL_FORM:
+        case DRUID_AQUATIC_FORM:
+        //case DRUID_FLIGHT_FORM:
+            strmult = 2.f; agimult = 0.f; break;
+        case BOT_CLASS_BM:
+            strmult = 0.f; agimult = 4.f; break;
+        default:
+            TC_LOG_ERROR("entities.player", "_MeleeDamageUpdate(): NIY myclass %u!", uint32(myclass));
+            strmult = 0.f; agimult = 0.f; break;
+    }
+
+    atpower += strmult * _getTotalBotStat(BOT_STAT_MOD_STRENGTH);
+    atpower += agimult * _getTotalBotStat(BOT_STAT_MOD_AGILITY);
+
+    //hunter Expose Weakness checked
+    Unit::AuraEffectList const& mAPbyStat = me->GetAuraEffectsByType(SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT);
+    for (Unit::AuraEffectList::const_iterator i = mAPbyStat.begin(); i != mAPbyStat.end(); ++i)
+        atpower += CalculatePct(me->GetStat(Stats((*i)->GetMiscValue())), (*i)->GetAmount());
+
+    Unit::AuraEffectList const& mAPbyArmor = me->GetAuraEffectsByType(SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR);
+    for (Unit::AuraEffectList::const_iterator iter = mAPbyArmor.begin(); iter != mAPbyArmor.end(); ++iter)
+        atpower += int32(me->GetArmor() / (*iter)->GetAmount());
+
+    //Handle mods
+    //pct mods
+    if (_botclass == BOT_CLASS_BM)
+    {
+        //Blademaster's power
+        ap_mod *= 2.5f;
+    }
+    if (_botclass == BOT_CLASS_DRUID)
+    {
+        //Heart of the Wild part 3
+        if (mylevel >= 35 && myclass == DRUID_CAT_FORM)
+            ap_mod *= 1.1f;
+        //Protector of the Pack part 2
+        if (mylevel >= 45 && myclass == DRUID_BEAR_FORM)
+            ap_mod *= 1.06f;
+    }
+    if (_botclass == BOT_CLASS_ROGUE)
+    {
+        //Deadliness
+        if (mylevel >= 35)
+            ap_mod *= 1.1f;
+        //Savage Combat
+        if (mylevel >= 50)
+            ap_mod *= 1.04f;
+    }
+    //from stats mods
+    if (myclass == DRUID_BEAR_FORM || myclass == DRUID_CAT_FORM)
+    {
+        atpower += _getTotalBotStat(BOT_STAT_MOD_FERAL_ATTACK_POWER);
+        //Predatory Strikes
+        if (me->getLevel() >= 25)
+        {
+            uint8 slot = BOT_SLOT_MAINHAND;
+            atpower += 1.5f * me->getLevel();
+            atpower += 0.2f * (
+                _getBotStat(slot, BOT_STAT_MOD_FERAL_ATTACK_POWER)
+                + _getBotStat(slot, BOT_STAT_MOD_ATTACK_POWER)
+                //+ _getBotStat(slot, BOT_STAT_MOD_RANGED_ATTACK_POWER)
+                );
+        }
+    }
+    if (_botclass == BOT_CLASS_HUNTER)
+    {
+        //Careful Aim
+        if (me->getLevel() >= 15)
+            atpower += _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        //Hunter vs. Wild
+        if (me->getLevel() >= 30)
+            atpower += 0.3f * _getTotalBotStat(BOT_STAT_MOD_STAMINA);
+    }
+    if (_botclass == BOT_CLASS_SHAMAN)
+    {
+        //Mental Dexterity
+        if (me->getLevel() >= 30)
+            atpower += _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+    }
+
+    atpower *= ap_mod;
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+
+    me->UpdateAttackPowerAndDamage();
+    if (/*_botclass == BOT_CLASS_WARRIOR || */_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE)
+    {
+        atpower += _getTotalBotStat(BOT_STAT_MOD_RANGED_ATTACK_POWER) * ap_mod;
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage(true);
+    }
+
+    //ARMOR
+    //value = IAmFree() ? 0 : me->getLevel() * 10; //0/800 at 80
+    value = 2.f * _getTotalBotStat(BOT_STAT_MOD_AGILITY);
+    value += _getTotalBotStat(BOT_STAT_MOD_ARMOR);
+
+    if (mylevel >= 10)
+    {
+        //Toughness
+        if (mylevel >= 20 && (_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_PALADIN))
+            armor_mod += 0.1f;
+        //Frost Presence
+        if (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE)
+            armor_mod += 0.6f;
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            //Thick Hide
+            if (mylevel >= 15)
+                armor_mod += 0.1f;
+            //Survival of the Fittest
+            if (myclass == DRUID_BEAR_FORM)
+                armor_mod += 0.33f + (me->GetShapeshiftForm() == FORM_BEAR ? 1.8 : 3.7f);
+            //Moonkin Form innate
+            else if (myclass == DRUID_MOONKIN_FORM)
+                armor_mod += 3.7f;
+            //Improved Tree Form
+            else if (myclass == DRUID_TREE_FORM)
+                armor_mod += 2.0f;
+            //Improved Barkskin
+            //else if (myclass == DRUID_TRAVEL_FORM || GetBotStance() == BOT_STANCE_NONE)
+            //    armor_mod += 1.6f;
+        }
+        if (_botclass == BOT_CLASS_HUNTER)
+        {
+            //Thick Hide
+            if (mylevel >= 15)
+                armor_mod += 0.1f;
+        }
+    }
+
+    value *= armor_mod;
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor(); //buffs will be processed here
+
+    //RESISTANCES
+    //Do not store resistance bonuses directly lest we want calcs screwed up
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = IAmFree() ? 0 : mylevel;
+        value += _getTotalBotStat(BOT_STAT_MOD_RESIST_HOLY + (i - 1));
+        resistbonus[i-1] = int32(value);
+        //me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    value = 1.0f;
+
+    //class-specified
+    //Protector of the Pack part 1
+    if (mylevel >= 45 && myclass == DRUID_BEAR_FORM)
+        value -= 0.12f;
+    //Deadened Nerves
+    if (mylevel >= 45 && _botclass == BOT_CLASS_ROGUE)
+        value -= 0.06f;
+    //Survival Instincts
+    if (mylevel >= 15 && _botclass == BOT_CLASS_HUNTER)
+        value -= 0.04f;
+
+    dmg_taken = value;
+
+    //HEALTH
+    _OnHealthUpdate();
+
+    //HASTE
+    if (haste)
+    {
+        //unapply old haste
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), false);
+        me->ApplyCastTimePercentMod(float(haste), false);
+    }
+
+    value =  IAmFree() ? std::max<int32>(int32(mylevel) - 60, 0) : 0; // +20%/+0% haste at 80
+
+    //25.5 HR = 1% haste at 80
+    tempval = _getTotalBotStat(BOT_STAT_MOD_HASTE_MELEE_RATING) + _getTotalBotStat(BOT_STAT_MOD_HASTE_RANGED_RATING) + _getTotalBotStat(BOT_STAT_MOD_HASTE_SPELL_RATING) + _getTotalBotStat(BOT_STAT_MOD_HASTE_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_HASTE_MELEE) | (1 << CR_HASTE_RANGED) | (1 << CR_HASTE_SPELL));
+    value += tempval * (_botclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_HASTE_RANGED) : std::max<float>(_getRatingMultiplier(CR_HASTE_MELEE), _getRatingMultiplier(CR_HASTE_SPELL)));
+
+    //class-specific
+    if (_botclass == BOT_CLASS_HUNTER)
+    {
+        value += 15.f; //innate ranged haste bonus 15% for hunters (still applies to all haste types)
+        //Serpent's Swiftness
+        if (mylevel >= 45)
+            value += 20.f;
+    }
+    if (_botclass == BOT_CLASS_ROGUE)
+    {
+        //Lightning Reflexes part 2
+        if (mylevel >= 25)
+            value += 10.f;
+    }
+    if (_botclass == BOT_CLASS_BM)
+    {
+        //Blademaster haste
+        value += 150.f;
+    }
+
+    haste = int32(value);
+
+    if (haste)
+    {
+        //apply new haste (using truncated value - gonna need it for unapply on next SetStats)
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), true);
+        me->ApplyCastTimePercentMod(float(haste), true);
+    }
+
+    //HIT
+    if (CanMiss())
+    {
+        value = IAmFree() ? mylevel / 8 : 0; // +10%/+0% at 80
+        //32.5 HR = 1% hit at 80
+        tempval = _getTotalBotStat(BOT_STAT_MOD_HIT_MELEE_RATING) + _getTotalBotStat(BOT_STAT_MOD_HIT_RANGED_RATING) + _getTotalBotStat(BOT_STAT_MOD_HIT_SPELL_RATING) + _getTotalBotStat(BOT_STAT_MOD_HIT_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_HIT_MELEE) | (1 << CR_HIT_RANGED) | (1 << CR_HIT_SPELL));
+        value += tempval * (_botclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_HIT_RANGED) : std::max<float>(_getRatingMultiplier(CR_HIT_MELEE), _getRatingMultiplier(CR_HIT_SPELL)));
+
+        //class-specific
+        //Precision
+        if (_botclass == BOT_CLASS_ROGUE && mylevel >= 15)
+            value += 5.f;
+        //Enlightened Judgements part 2,3
+        if (_botclass == BOT_CLASS_PALADIN && mylevel >= 55)
+            value += 4.f;
+        //Nerves of Cold Steel part 1
+        if (_botclass == BOT_CLASS_DEATH_KNIGHT && mylevel >= 15)
+            value += 3.f;
+        //Dual Wield Specialization
+        if (_botclass == BOT_CLASS_SHAMAN && mylevel >= 40 && me->haveOffhandWeapon())
+            value += 6.f;
+        //Precision
+        if (_botclass == BOT_CLASS_WARRIOR && mylevel >= 30)
+            value += 3.f;
+        //Focused Aim
+        if (_botclass == BOT_CLASS_HUNTER && mylevel >= 10)
+            value += 3.f;
+
+        hit = value;
+    }
+    else
+        hit = 100.0f;
+
+    //ARMOR PENETRATION
+    value = IAmFree() ? 5 + mylevel / 4 : 0; // 25%/0% at 80
+    //? APR = 1% armor ignored at 80
+    tempval = _getTotalBotStat(BOT_STAT_MOD_ARMOR_PENETRATION_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_ARMOR_PENETRATION));
+    value += tempval * _getRatingMultiplier(CR_ARMOR_PENETRATION);
+    armor_pen = value;
+
+    //EXPERTISE
+    value = IAmFree() ? mylevel / 2 : 0; // -10%/-0% at 80
+    //~8.0 ER = 1 expertise at 80
+    tempval = _getTotalBotStat(BOT_STAT_MOD_EXPERTISE_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_EXPERTISE));
+    value += tempval * _getRatingMultiplier(CR_EXPERTISE);
+
+    //class-specific
+    //Weapon Expertise
+    if (mylevel >= 35 && _botclass == BOT_CLASS_ROGUE)
+        value += 10.f;
+    //Combat Expertise
+    if (mylevel >= 45 && _botclass == BOT_CLASS_PALADIN)
+        value += 6.f;
+    if (_botclass == BOT_CLASS_WARRIOR)
+    {
+        //Vitality: 6, Strength of Arms: 4
+        if (mylevel >= 45)
+            value += 10.f;
+        else if (mylevel >= 40)
+            value += 4.f;
+    }
+
+    expertise = value;
+
+    //CRIT
+    if (CanCrit())
+    {
+        value = IAmFree() ? mylevel / 4 : 0; // +20%/+0% at 80
+        tempval = value;
+
+        GtChanceToMeleeCritBaseEntry const* critBaseMelee  = sGtChanceToMeleeCritBaseStore.LookupEntry(GetPlayerClass()-1);
+        GtChanceToMeleeCritEntry const* critRatioMelee = sGtChanceToMeleeCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1);
+        if (critBaseMelee && critRatioMelee)
+            value += (critBaseMelee->base + _getTotalBotStat(BOT_STAT_MOD_AGILITY)) * critRatioMelee->ratio * 100.0f;
+
+        //crit from intellect
+        GtChanceToSpellCritBaseEntry const* critBaseSpell  = sGtChanceToSpellCritBaseStore.LookupEntry(GetPlayerClass()-1);
+        GtChanceToSpellCritEntry const* critRatioSpell = sGtChanceToSpellCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1);
+        if (critBaseSpell && critRatioSpell)
+            tempval += (critBaseSpell->base + _getTotalBotStat(BOT_STAT_MOD_INTELLECT)) * critRatioSpell->ratio * 100.f;
+
+        value = std::max<float>(value, tempval);
+
+        //45 CR = 1% crit at 80
+        tempval = _getTotalBotStat(BOT_STAT_MOD_CRIT_MELEE_RATING) + _getTotalBotStat(BOT_STAT_MOD_CRIT_RANGED_RATING) + _getTotalBotStat(BOT_STAT_MOD_CRIT_SPELL_RATING) + _getTotalBotStat(BOT_STAT_MOD_CRIT_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_CRIT_MELEE) | (1 << CR_CRIT_RANGED) | (1 << CR_CRIT_SPELL));
+
+        //Molten Armor: 35% spirit to crit rating (+40% double-glyphed)
+        if (_botclass == BOT_CLASS_MAGE && me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RATING_FROM_STAT, SPELLFAMILY_MAGE, 0x40000))
+            tempval += _getTotalBotStat(BOT_STAT_MOD_SPIRIT) * (mylevel >= 70 ? 0.75f : 0.55f);
+
+        value += tempval * (_botclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_CRIT_RANGED) : std::max<float>(_getRatingMultiplier(CR_CRIT_MELEE), _getRatingMultiplier(CR_CRIT_SPELL)));
+
+        //common crit talents
+        if (mylevel >= 10 &&
+            (_botclass != BOT_CLASS_MAGE && _botclass != BOT_CLASS_PRIEST &&
+            _botclass != BOT_CLASS_DRUID && _botclass != BOT_CLASS_WARLOCK))
+            value += 5.f;
+
+        //class-specific
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            //Sharpened Claws
+            if (mylevel >= 20 && (myclass == DRUID_CAT_FORM || myclass == DRUID_BEAR_FORM))
+                value += 6.f;
+        }
+        if (_botclass == BOT_CLASS_ROGUE)
+        {
+            //Close Quarters Combat
+            if (mylevel >= 20)
+            {
+                if (Item const* mainhand = _equips[BOT_SLOT_MAINHAND])
+                {
+                    if (mainhand->GetTemplate()->Class == ITEM_CLASS_WEAPON &&
+                        (mainhand->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+                        mainhand->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_FIST))
+                        value += 5.f;
+                }
+            }
+        }
+        if (_botclass == BOT_CLASS_PALADIN)
+        {
+            //Sanctity of Battle part 1
+            if (mylevel >= 25)
+                value += 3.f;
+            //Combat Expertise
+            if (mylevel >= 45)
+                value += 6.f;
+        }
+        if (_botclass == BOT_CLASS_HUNTER)
+        {
+            //Killer Instinct
+            if (mylevel >= 30)
+                value += 3.f;
+            //Master Marksman
+            if (mylevel >= 45)
+                value += 5.f;
+        }
+
+        crit = value;
+    }
+    else
+        crit = 0.0f;
+
+    //DEFENSE
+    value = 0.f;
+    tempval = _getTotalBotStat(BOT_STAT_MOD_DEFENSE_SKILL_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DEFENSE_SKILL));
+    value += tempval * _getRatingMultiplier(CR_DEFENSE_SKILL);
+    value += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SKILL, SKILL_DEFENSE);
+    defense = mylevel * 5 + uint32(value); //truncate
+
+    float defbonus = defense - mylevel * 5; //difference
+
+    //PARRY
+    if (CanParry())
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 8 : 0); // +10%/+0% at 80
+
+        if (mylevel >= 10)
+        {
+            //67 PR = 1% parry at 80
+            float tempval = _getTotalBotStat(BOT_STAT_MOD_PARRY_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_PARRY));
+
+            //Forceful Deflection: 25% of strength goes to parry rating
+            if (_botclass == BOT_CLASS_DEATH_KNIGHT/* && mylevel >= 55*/)
+                tempval += _getTotalBotStat(BOT_STAT_MOD_STRENGTH) * 0.25f;
+
+            value += tempval * _getRatingMultiplier(CR_PARRY);
+            //125 DR = 1% block/parry/dodge at 80
+            value += defbonus * 0.04f;
+        }
+
+        //Deflection (general)
+        if ((_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_ROGUE || _botclass == BOT_CLASS_PALADIN) && mylevel >= 10)
+            parry += 5.0f;
+        if (_botclass == BOT_CLASS_HUNTER && mylevel >= 20)
+            parry += 3.f;
+
+        parry = value;
+    }
+    else
+        parry = 0.0f;
+
+    //DODGE
+    if (CanDodge())
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 8 : 0); // +10%/+0% at 80
+
+        if (GtChanceToMeleeCritEntry  const* dodgeRatio = sGtChanceToMeleeCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1))
+            value += _getTotalBotStat(BOT_STAT_MOD_AGILITY) * dodgeRatio->ratio * 100.0f;
+
+        if (mylevel >= 10)
+        {
+            //53 DR = 1% dodge at 80
+            float tempval = _getTotalBotStat(BOT_STAT_MOD_DODGE_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DODGE));
+            value += tempval * _getRatingMultiplier(CR_DODGE);
+            //125 DR = 1% block/parry/dodge at 80
+            value += defbonus * 0.04f;
+        }
+
+        //evasion (general)
+        if ((_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_ROGUE || _botclass == BOT_CLASS_PALADIN ||
+            _botclass == BOT_CLASS_DEATH_KNIGHT || _botclass == BOT_CLASS_SHAMAN) &&
+            mylevel >= 15)
+            value += 5.0f;
+
+        //class-specific
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            //Feral Swiftness
+            if (mylevel >= 20 && (myclass == DRUID_CAT_FORM || myclass == DRUID_BEAR_FORM))
+                value += 4.f;
+        }
+
+        dodge = value;
+    }
+    else
+        dodge = 0.0f;
+
+    //BLOCK
+    if (IsBlockingClass(_botclass))
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 4 : 0); // +20%/+0% at 80
+
+        //16.5 BR = 1% block at 80
+        float tempval = _getTotalBotStat(BOT_STAT_MOD_BLOCK_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_BLOCK));
+        value += tempval * _getRatingMultiplier(CR_BLOCK);
+        //125 DR = 1% block/parry/dodge at 80
+        value += defbonus * 0.04f;
+
+        //Shield Specialization (general)
+        if ((_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_PALADIN) && mylevel >= 10)
+            value += 5.0f;
+
+        //base block chance is capped at 75%
+        block = std::min<float>(value, 75.0f);
+
+        //BLOCK VALUE
+        value = float(mylevel + (mylevel >> 2)); //100 at 80
+        //2 str = 1 block value
+        value += 0.5f * _getTotalBotStat(BOT_STAT_MOD_STRENGTH);
+        value += _getTotalBotStat(BOT_STAT_MOD_BLOCK_VALUE);
+        value -= 10.f;
+
+        //Shield Mastery
+        if (mylevel >= 20 && _botclass == BOT_CLASS_WARRIOR)
+            value *= 1.3f;
+        //Redoubt handled in passives
+        //if (mylevel >= 45 && _botclass == BOT_CLASS_PALADIN)
+        //    value *= 1.3f;
+
+        blockvalue = std::max<float>(int32(value), 0);
+    }
+    //else
+    //{
+    //    block = 0.0f;
+    //    blockvalue = 0;
+    //}
+
+    //MANA
+    _OnManaUpdate();
+
+    //SPELL POWER
+    if (IsCastingClass(_botclass))
+    {
+        //SPELL PENETRATION
+        value = IAmFree() ? mylevel : 0; // 80/0 at 80
+        //~1 SPPR = 1 spell penetration
+        value += _getTotalBotStat(BOT_STAT_MOD_SPELL_PENETRATION);
+        spellpen = uint32(value);
+
+        value = IAmFree() ? std::max<int32>((int8(mylevel) - 30) * 80, 0) : 0; // +4000/+0 spp at 80
+        value += _getTotalBotStat(BOT_STAT_MOD_SPELL_POWER);
+
+        //class-specified mods
+        if (_botclass == BOT_CLASS_PALADIN && mylevel >= 50)
+        {
+            //Touched by the Light / Sheath of Light - 60% of strength (30% attack power) to spell power
+            if (HasRole(BOT_ROLE_TANK | BOT_ROLE_DPS))
+                value += 0.3f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+            //Holy Guidance - 20% Intellect to spell power
+            if (HasRole(BOT_ROLE_HEAL) && HasRole(BOT_ROLE_RANGED))
+                value += 0.2f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_PRIEST && mylevel >= 55)
+        {
+            //Spiritual Guidance - 25% Spirit to spell power
+            if (HasRole(BOT_ROLE_HEAL))
+                value += 0.25f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+            //Twisted Faith - 20% Spirit to spell power
+            else if (HasRole(BOT_ROLE_DPS))
+                value += 0.2f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+        }
+        if (_botclass == BOT_CLASS_SHAMAN && mylevel >= 50)
+        {
+            //Mental Quickness - 30% attack power to spell power (only enhancement)
+            if (HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_RANGED))
+                value += 0.3f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+        }
+        if (_botclass == BOT_CLASS_DRUID && mylevel >= 30)
+        {
+            //Nurturing Instinct - 70% Agility to spell power
+            value += 0.7f * _getTotalBotStat(BOT_STAT_MOD_AGILITY);
+            //Lunar Guidance - 12% Intellect to spell power
+            value += 0.12f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+            //Improved Moonkin Form - 30% Spirit to spell power
+            if (mylevel >= 40 && myclass == DRUID_MOONKIN_FORM)
+                value += 0.3f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+            //Improved Tree (of Life) Form - 15% Spirit to spell power
+            if (mylevel >= 50 && myclass == DRUID_TREE_FORM)
+                value += 0.15f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+        }
+        if (_botclass == BOT_CLASS_MAGE && mylevel >= 45)
+        {
+            //Mind Mastery - 15% Intellect to spell power
+            //if (HasRole(BOT_ROLE_DPS))
+                value += 0.15f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_WARLOCK &&
+            me->GetAuraEffect(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT, SPELLFAMILY_WARLOCK, 0x0, 0x20000000, 0x0)
+            /*HasAuraName(me, 28176, me->GetGUID())*/)
+        {
+            //Fel Armor + Demonic Aegis - 39% Spirit to spell power
+            value += 0.39f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+        }
+
+        spellpower = uint32(value);
+    }
+    //else
+    //{
+    //    spellpower = 0;
+    //}
+
+    //if init or levelup
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    //SetStats for pet
+    if (Creature const* pet = me->GetBotsPet())
+        if (bot_pet_ai* petai = pet->GetBotPetAI())
+            petai->SetStats(force);
+}
+
+void bot_pet_ai::SetStats(bool force)
+{
+    uint8 mylevel = m_creatureOwner->getLevel();
+    uint8 petType = GetPetType(me);
+    if (petType == PET_TYPE_NONE || petType >= MAX_PET_TYPES) return;
+    if (!shouldUpdateStats && !force) return;
+
+    shouldUpdateStats = false;
+    //TC_LOG_ERROR("entities.player", "*etStats(): Updating pet bot %s, type: %u, level %u, owner: %s, master: %s", me->GetName().c_str(), petType, mylevel, m_creatureOwner->GetName().c_str(), master->GetName().c_str());
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells();
+        ApplyClassPassives();
+    }
+
+    //PHASE
+    //if (m_creatureOwner->GetPhaseMask() != me->GetPhaseMask())
+    //    me->SetPhaseMask(master->GetPhaseMask(), true);
+
+    //INIT STATS
+    //if (force)
+    //    for (uint8 i = STAT_STRENGTH; i != MAX_STATS; i++)
+    //        me->SetCreateStat(Stats(i), 0.5f * m_creatureOwner->GetCreateStat(Stats(i)));
+
+    //INIT CLASS MODIFIERS
+    //STAT -- 'mod' -- used stat values to apply
+    //WARLOCK
+    //Stamina x0.3  -- health
+    //Armor   x0.35 -- armor
+    //Int     x0.3  -- crit/mana
+    //Spd     x0.15 -- spd (if has mana)
+    //AP      x0.57 -- attack power (if melee pet)
+    //Resist  x0.4  -- resistances
+    //MAGE
+    //
+    //SHAMAN
+    //
+    //HUNTER
+    //
+
+    switch (petType)
+    {
+        case PET_TYPE_VOIDWALKER:       //ap_mod = 0.57f; spp_mod = 0.15f; 
+            break;
+        //case PET_TYPE_FELHUNTER:        ap_mod = 0.57f; spp_mod = 0.15f; break;//NYI
+        //case PET_TYPE_FELGUARD:         ap_mod = 0.57f; spp_mod = 0.15f; break;//NYI
+        //case PET_TYPE_SUCCUBUS:         ap_mod = 0.57f; spp_mod = 0.15f; break;//NYI
+        //case PET_TYPE_IMP:              ap_mod = 0.f;   spp_mod = 0.15f; break;//NYI
+
+        //case PET_TYPE_WATER_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_VULTURE:          ap_mod = 0.9f;  spp_mod = 1.0f; break;//NYI
+        default:
+            TC_LOG_ERROR("entities.player", "pet_ai: *etStats():Init - unknown pet type %u", petType);
+            //ap_mod = 0.0f;  spp_mod = 0.0f;
+            break;
+    }
+
+    float value;
+    float ap_mod = 0.57f, spp_mod = 0.15f;
+
+    //DAMAGE
+    //if (ap_mod > 0.f)//do not bother casters
+    //{
+    //    switch (m_creatureOwner->GetBotClass())
+    //    {
+    //        case BOT_CLASS_WARLOCK:
+    //            value = float(m_creatureOwner->GetCreatureSpellPower());
+    //            break;
+    //        case BOT_CLASS_DEATH_KNIGHT:
+    //            value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+    //            break;
+    //        case BOT_CLASS_HUNTER:
+    //            value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+    //            break;
+    //        default: //some weird class or NYI
+    //            TC_LOG_ERROR("entities.player", "*etStats():Damage - unknown bot owner class %u", uint8(m_creatureOwner->GetBotClass()));
+    //            value = 0.0f;
+    //            break;
+    //    }
+
+    //    me->SetModifierValue(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, me->GetCreateStat(STAT_STRENGTH) - 9.f);
+    //    float atpower = (me->GetTotalAuraModValue(UNIT_MOD_STAT_STRENGTH) * 2.f + value) * ap_mod;
+    //    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+    //    me->UpdateAttackPowerAndDamage();
+    //}
+
+    //ARMOR
+    //value = float(basearmor);
+    ////get minion's armor and give 35% to pet (just as for real pets)
+    //value += m_creatureOwner->GetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE) * 0.35f;
+    //me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    //me->UpdateArmor();
+
+    //RESISTANCES
+    //based on minion's resistances gain x0.4
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = 0/*float(mylevel + mylevel)*/;
+        value += 0.4f * float(m_creatureOwner->GetCreatureResistanceBonus(SpellSchoolMask(i)));
+        resistbonus[i-1] = int32(value);
+        //me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    //dmg_taken = m_creatureOwner->GetBotAI()->GetBotDamageTakenMod();
+
+    //HEALTH
+    _OnHealthUpdate();
+
+    //HASTE
+    //if (haste)
+    //{
+    //    for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+    //        me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), false);
+    //    me->ApplyCastTimePercentMod(float(haste), false);
+    //}
+
+    //haste = m_creatureOwner->GetBotAI()->GetHaste();
+
+    //if (haste)
+    //{
+    //    for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+    //        me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), true);
+    //    me->ApplyCastTimePercentMod(float(haste), true);
+    //}
+
+    //HIT
+    //hit = m_creatureOwner->GetBotAI()->GetHitRating();
+
+    //CRIT
+    if (CanCrit())
+    {
+        value = m_creatureOwner->GetCreatureCritChance();
+        crit = value;
+    }
+
+    //PARRY
+    if (CanParry())
+    {
+        value = m_creatureOwner->GetCreatureParryChance();
+        parry = value;
+    }
+
+    //DODGE
+    if (CanDodge())
+    {
+        value = m_creatureOwner->GetCreatureDodgeChance();
+        dodge = value;
+    }
+
+    //MANA
+    _OnManaUpdate();
+
+    //SPELL PENETRATION
+    spellpen = m_creatureOwner->GetCreatureSpellPenetration();
+
+    //SPELL POWER
+    if (IsCastingClass(_botclass))
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                value = m_creatureOwner->GetCreatureSpellPower();
+                break;
+            case BOT_CLASS_DEATH_KNIGHT:
+                value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+                break;
+            case BOT_CLASS_HUNTER:
+                value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+                break;
+            default: //some weird class or NYI
+                TC_LOG_ERROR("entities.player", "*etStats():Spellpower - unknown bot owner class %u", uint8(m_creatureOwner->GetBotClass()));
+                value = 0.f;
+                break;
+        }
+
+        spellpower = uint32(value * spp_mod);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+}
+//Emotion-based action
+void bot_ai::ReceiveEmote(Player* player, uint32 emote)
+{
+    switch (emote)
+    {
+        case TEXT_EMOTE_BONK:
+            _listAuras(player, me);
+            break;
+        case TEXT_EMOTE_SALUTE:
+            _listAuras(player, player);
+            break;
+        case TEXT_EMOTE_STAND:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_STAY);
+            BotWhisper("Standing Still.", player);
+            break;
+        case TEXT_EMOTE_WAVE:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            if (me->IsNonMeleeSpellCasted(true))
+                me->InterruptNonMeleeSpells(true);
+            SetBotCommandState(COMMAND_FOLLOW, true);
+            BotWhisper("Following!", player);
+            break;
+        case TEXT_EMOTE_TICKLE:
+        {
+            if ((me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED) || me->HasUnitState(UNIT_STATE_STUNNED)) &&
+                !me->HasAuraType(SPELL_AURA_MOD_STUN))
+            {
+                me->ClearUnitState(UNIT_STATE_STUNNED);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+            }
+            if ((me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED) || me->HasUnitState(UNIT_STATE_CONFUSED)) &&
+                !me->HasAuraType(SPELL_AURA_MOD_CONFUSE))
+            {
+                me->ClearUnitState(UNIT_STATE_CONFUSED);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED);
+            }
+            if ((me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING) || me->HasUnitState(UNIT_STATE_FLEEING)) &&
+                !me->HasAuraType(SPELL_AURA_MOD_FEAR))
+            {
+                me->ClearUnitState(UNIT_STATE_FLEEING);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING);
+            }
+            std::ostringstream msg;
+            msg << "%s (bot) pulls "
+                << (me->getGender() == GENDER_MALE ? "himself" : me->getGender() == GENDER_FEMALE ? "herself" : "itself")
+                << " together.";
+            me->MonsterTextEmote(msg.str().c_str(), 0);
+            break;
+        }
+        default:
+            break;
+    }
+}
+
+//ISINBOTPARTY
+//Returns group members (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_ai::IsInBotParty(Unit const* unit) const
+{
+    if (!unit) return false;
+    if (unit == master || unit == me || unit == me->GetBotsPet()) return true;
+
+    if (IAmFree())
+    {
+        if (me->getFaction() == 14 || unit->getFaction() == 14)
+            return false;
+
+        return
+            (unit->GetTypeId() == TYPEID_PLAYER || unit->ToCreature()->IsPet() || unit->ToCreature()->IsNPCBot()) &&
+            (unit->getFaction() == me->getFaction() ||
+            (me->GetReactionTo(unit) >= REP_FRIENDLY && unit->GetReactionTo(me) >= REP_FRIENDLY));
+    }
+
+    //cheap check
+    if (Group const* gr = master->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if (_healTargetIconFlags & GroupIconsFlags[i])
+                if (uint64 guid = gr->GetTargetIcons()[i])//check this one
+                    if (guid == unit->GetGUID())
+                        if (unit->GetReactionTo(master) >= REP_NEUTRAL &&
+                            master->GetVictim() != unit &&
+                            unit->GetVictim() != master)
+                            return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature const* cre = unit->ToCreature())
+    {
+        uint64 ownerGuid = unit->GetOwnerGUID();
+        //controlled by master
+        if (ownerGuid == master->GetGUID())
+            return true;
+        //npcbot/npcbot's pet case
+        if (cre->GetBotOwner() == master)
+            return true;
+        //controlled by group member
+        //pets, minions, guardians etc.
+        if (ownerGuid)
+            if (Group const* gr = master->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+    }
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/removes/reapplies aura stacks
+bool bot_ai::RefreshAura(uint32 spellId, int8 count) const
+{
+    if (count < 0 || count > 10)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): count is out of bounds (%i) for bot %s (botclass: %u, entry: %u)",
+            int32(count), me->GetName().c_str(), uint32(_botclass), me->GetEntry());
+        return false;
+    }
+    if (!spellId)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): spellId is 0 for bot %s (botclass: %u, entry: %u)",
+            me->GetName().c_str(), uint32(_botclass), me->GetEntry());
+        return false;
+    }
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): Invalid spellInfo for spell %u! Bot - %s (botclass: %u, entry: %u)",
+            spellId, me->GetName().c_str(), uint32(_botclass), me->GetEntry());
+        return false;
+    }
+
+    me->RemoveAurasDueToSpell(spellId);
+
+    for (int8 i = 0; i < count; ++i)
+        me->AddAura(spellInfo, MAX_EFFECT_MASK, me);
+
+    return true;
+}
+//CHECKAURAS
+//Updates bot's condition every tick
+void bot_minion_ai::CheckAuras(bool force)
+{
+    opponent = me->GetVictim(); //safe
+
+    if (!force && !IsTempBot())
+    {
+        Regenerate();
+        _updateRations(); //safe
+    }
+
+    if (_bootTimer >= 0 && _bootTimer <= int32(lastdiff))
+    {
+        //timer will be cancelled at bot removal so we are always free here
+        //_bootTimer = -1; //Set in AbortTeleport()
+        //master->m_Controlled.erase(me);
+        BotMgr::TeleportBot(me, master->GetMap(), master);
+        return;
+    }
+
+    if (checkAurasTimer <= lastdiff)
+    {
+        checkAurasTimer += uint32(__rand + __rand + (IAmFree() ? 1000 : 40 * (1 + master->GetNpcBotsCount())));
+
+        //group demand
+        if (!IAmFree() && HasRole(BOT_ROLE_PARTY) && (!master->GetGroup() || !master->GetGroup()->IsMember(me->GetGUID())))
+        {
+            //TC_LOG_ERROR("entities.player", "CheckAuras(): adding %s to group", me->GetName().c_str());
+            master->GetBotMgr()->AddBotToGroup(me);
+        }
+
+        if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY && opponent && !CCed(me, true) &&
+            !me->isMoving() && !IsCasting())
+        {
+            if (!HasRole(BOT_ROLE_RANGED))
+            {
+                if (me->GetDistance(opponent) > 1.5f)
+                    GetInPosition(true, opponent);
+            }
+            else
+            {
+                CalculateAttackPos(opponent, attackpos);
+                if (me->GetExactDist2d(&attackpos) > 10.f || !me->IsWithinDistInMap(opponent, 30) || !me->IsWithinLOSInMap(opponent))
+                    GetInPosition(true, opponent, &attackpos);
+            }
+        }
+        if (shouldUpdateStats && me->GetPhaseMask() == master->GetPhaseMask())
+            SetStats(false);
+        else if (_powersTimer <= lastdiff && !IsTempBot())
+        {
+            _powersTimer += REGEN_CD; //do not mistake for regen, this is only for updating max health/mana
+            UpdateHealth();
+            UpdateMana();
+        }
+        if (_atHome && Rand() < 10)
+            _atHome = false;
+        return;
+    }
+    else if (force)
+    {
+        if (!opponent && !IAmFree())
+        {
+            if (!master->IsAlive())
+            {
+                //If ghost move to corpse, else move to dead player
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                {
+                    Corpse const* corpse = master->GetCorpse();
+                    if (corpse && me->GetMap() == corpse->FindMap() && !me->IsInCombat() && !me->HasUnitState(UNIT_STATE_MOVING) && !IsCasting() && !CCed(me) && me->GetDistance(corpse) > 5)
+                        me->GetMotionMaster()->MovePoint(corpse->GetMapId(), *corpse);
+                }
+                else
+                {
+                    if (m_botCommandState != COMMAND_FOLLOW || me->GetDistance(master) > 30 - 20 * (!me->IsWithinLOSInMap(master)))
+                        Follow(true);
+                }
+            }
+            else if (m_botCommandState != COMMAND_STAY && !IsCasting())
+            {
+                _calculatePos(pos);
+                uint8 followdist = master->GetBotFollowDist();
+                //100 / 12.5 = 8
+                if (me->GetExactDist(&pos) > std::max<float>(followdist * (master->isMoving() ? 0.02f : 0.1f), 4.f))
+                    Follow(true, &pos); //check if doing nothing
+            }
+        }
+        if (!IsCasting())
+        {
+            if (me->IsInCombat() || !CanSheath())
+            {
+                if (!me->IsSitState())
+                {
+                    if (_botclass == BOT_CLASS_HUNTER)
+                    {
+                        if (me->GetSheath() != SHEATH_STATE_RANGED)
+                            me->SetSheath(SHEATH_STATE_RANGED);
+                    }
+                    else if (me->GetSheath() != SHEATH_STATE_MELEE)
+                        me->SetSheath(SHEATH_STATE_MELEE);
+                }
+            }
+            else if (me->IsStandState() && me->GetSheath() != SHEATH_STATE_UNARMED && Rand() < 50)
+            {
+                if (me->GetSheath() == SHEATH_STATE_RANGED)
+                    me->SetSheath(SHEATH_STATE_MELEE);
+                else
+                    me->SetSheath(SHEATH_STATE_UNARMED);
+            }
+        }
+
+        _updateMountedState();
+        _updateStandState();
+
+        //update flags
+        if (!me->IsInCombat() && !_evadeMode && _atHome)
+        {
+            if (!me->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP))
+                me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT))
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
+        }
+    }
+}
+void bot_pet_ai::CheckAuras(bool /*force*/)
+{
+    Regenerate();
+
+    if (checkAurasTimer > lastdiff)
+        return;
+
+    checkAurasTimer += uint32(__rand + __rand + (IAmFree() ? 1000 : 40 * (1 + master->GetNpcBotsCount())));
+
+    if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY)
+    {
+        opponent = me->GetVictim();
+        if (opponent)
+        {
+            switch (GetPetType(me))
+            {
+                case PET_TYPE_IMP:
+                    CalculateAttackPos(opponent, attackpos);
+                    if (me->GetExactDist2d(&attackpos) > 10.f)
+                        GetInPosition(true, opponent, &attackpos);
+                    break;
+                default:
+                    if (me->GetDistance(opponent) > 1.5f)
+                        GetInPosition(true, opponent);
+                    break;
+            }
+        }
+    }
+
+    return;
+}
+
+bool bot_ai::CanBotAttack(Unit const* target, int8 byspell) const
+{
+    if (!target)
+        return false;
+    if (!_botPvP && !IAmFree() && target->IsControlledByPlayer())
+        return false;
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    return
+       (target->IsAlive() &&
+       target->IsVisible() &&
+       //me->IsValidAttackTarget(target) &&
+       ((me->CanSeeOrDetect(target) && target->InSamePhase(me)) || CanSeeEveryone()) &&
+       //!target->HasStealthAura() && !target->HasInvisibilityAura() &&
+       (!master->IsAlive() || target->GetTypeId() == TYPEID_PLAYER || target->IsPet() ||
+       (target->GetDistance(master) < foldist && me->GetDistance(master) < followdist)) &&//if master is killed pursue to the end
+        target->isTargetableForAttack() &&
+        !IsInBotParty(target) &&
+        (target->IsHostileTo(master) ||
+        (target->GetReactionTo(master) < REP_FRIENDLY/* && master->GetVictim() == target*/ && (master->IsInCombat() || target->IsInCombat())) ||//master has pointed this target
+        target->IsHostileTo(me)) &&//if master is controlled
+        //target->IsWithinLOSInMap(me) &&
+        (byspell == -1 || !target->IsImmunedToDamage(byspell ? SPELL_SCHOOL_MASK_MAGIC : SPELL_SCHOOL_MASK_NORMAL)));
+}
+//GETTARGET
+//Returns attack target or 'no target'
+//All code above 'x = _getTarget() call must not dereference opponent since it can be invalid
+Unit* bot_ai::_getTarget(bool byspell, bool ranged, bool &reset) const
+{
+    //if (_evadeMode) //IAmFree() case only
+    //    return NULL;
+
+    Unit* mytar = me->GetVictim();
+
+    //check if no need to change target
+    if (!mytar && IsMinionAI())
+        if (Creature const* pet = me->GetBotsPet())
+            mytar = pet->GetVictim();
+    if (!mytar && IsPetAI())
+        mytar = ToPetAI()->GetCreatureOwner()->GetVictim();
+
+    //TC_LOG_ERROR("entities.player", "bot_ai::getTarget(): bot: %s", me->GetName().c_str());
+
+    if (mytar && me->HasAuraType(SPELL_AURA_MOD_TAUNT))
+        return mytar;
+
+    Unit* u = master->GetVictim();
+    if (!u && master->IsInCombat())
+    {
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_MAX_SPELL; ++i)
+        {
+            if (Spell const* spell = master->GetCurrentSpell(CurrentSpellTypes(i)))
+            {
+                if (!spell->GetSpellInfo()->IsPositive())
+                {
+                    Unit* victim = spell->m_targets.GetUnitTarget();
+                    if (victim && victim->IsInCombat()/* && !IsInBotParty(victim) && master->IsValidAttackTarget(victim)*/)
+                    {
+                        u = victim;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    if (u && u == mytar && !IAmFree() && u->GetTypeId() == TYPEID_PLAYER && CanBotAttack(u, byspell))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack common target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;//forced
+    }
+    //Follow if...
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    if ((!u || IAmFree()) && master->IsAlive() && (me->GetDistance(master) > foldist ||
+        (IAmFree() && mytar && me->GetDistance(mytar) > followdist) ||
+        (mytar && master->GetDistance(mytar) > followdist / 2 && !mytar->IsWithinLOSInMap(me)) ||
+        (mytar && master->GetDistance(mytar) > foldist && me->GetDistance(master) > foldist)))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s cannot attack target %s, too far away or not in LoS", me->GetName().c_str(), mytar ? mytar->GetName().c_str() : "");
+        return NULL;
+    }
+
+    if (u && !IAmFree() && (master->IsInCombat() || u->IsInCombat())/* && !InDuel(u)*/ && !IsInBotParty(u) && (_botPvP || !u->IsControlledByPlayer()))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s starts attack master's target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;
+    }
+
+    if (mytar && (!IAmFree() || me->GetDistance(mytar) < BOT_MAX_CHASE_RANGE) && CanBotAttack(mytar, byspell) &&/* !InDuel(mytar) &&*/
+        !(mytar->GetVictim() != NULL && IsTank() && IsTank(mytar->GetVictim())))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack its target %s", me->GetName().c_str(), mytar->GetName().c_str());
+        if (me->GetDistance(mytar) > (ranged ? 20.f : 5.f) && m_botCommandState != COMMAND_STAY && m_botCommandState != COMMAND_FOLLOW)
+            reset = true;
+        return mytar;
+    }
+
+    if (followdist == 0 && master->IsAlive())
+        return NULL; //do not bother
+
+    //check group
+    if (!IAmFree())
+    {
+        Group const* gr = master->GetGroup();
+        if (!gr)
+        {
+            Creature const* bot;
+            BotMap const* map = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                bot = itr->second;
+                if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                if (IsTank() && IsTank(bot)) continue;
+                u = bot->GetVictim();
+                if (u && (bot->IsInCombat() || u->IsInCombat()) &&
+                    (!master->IsAlive() || master->GetDistance(u) < foldist) &&
+                    CanBotAttack(u, byspell))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+            }
+        }
+        else
+        {
+            Player const* pl;
+            Creature const* bot;
+            for (GroupReference const* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+            {
+                pl = ref->GetSource();
+                if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                if (IsTank() && IsTank(pl)) continue;
+                u = pl->GetVictim();
+                if (u && pl != master &&
+                    (pl->IsInCombat() || u->IsInCombat()) &&
+                    (!master->IsAlive() || master->GetDistance(u) < foldist) &&
+                    CanBotAttack(u, byspell))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pl->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+                if (!pl->HaveBot()) continue;
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    bot = it->second;
+                    if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                    if (!bot->IsInWorld()) continue;
+                    if (me->GetMap() != bot->FindMap()) continue;
+                    if (IsTank() && IsTank(bot)) continue;
+                    u = bot->GetVictim();
+                    if (u && (bot->IsInCombat() || u->IsInCombat()) &&
+                        (!master->IsAlive() || master->GetDistance(u) < foldist) &&
+                        CanBotAttack(u, byspell))
+                    {
+                        //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                        return u;
+                    }
+                }
+            }
+        }
+    }
+
+    //check targets around
+    Unit* t = NULL;
+    float maxdist = InitAttackRange(float(followdist), ranged);
+    //first cycle we search non-cced target, then, if not found, check all
+    for (uint8 i = 0; i != 2; ++i)
+    {
+        if (!t)
+        {
+            bool attackCC = i;
+            NearestHostileUnitCheck check(me, maxdist, byspell, this, attackCC);
+            Trinity::UnitLastSearcher <NearestHostileUnitCheck> searcher(master, t, check);
+            me->VisitNearbyObject(maxdist, searcher);
+        }
+    }
+
+    if (t && opponent && t != opponent)
+        reset = true;
+
+    //Allow free bots to ignore temp invulnerabilities if no other target is present
+    if (IAmFree() && t == NULL)
+        t = mytar;
+
+    //if (t)
+    //    TC_LOG_ERROR("entities.player", "bot %s has found new target %s", me->GetName().c_str(), t->GetName().c_str());
+
+    return t;
+}
+//'CanAttack' function
+//Only called in class ai UpdateAI function
+bool bot_ai::CheckAttackTarget(uint8 botClassOrPetType)
+{
+    if (IsDuringTeleport()/* || _evadeMode*/)
+    {
+        //me->AttackStop(); //already in CombatStop()
+        me->CombatStop(true);
+        return false;
+    }
+
+    if (IAmFree() && Feasting())
+        return false;
+
+    bool ranged = HasRole(BOT_ROLE_RANGED);
+    bool byspell = false;
+    bool reset = false;
+
+    if (IsMinionAI())
+    {
+        switch (botClassOrPetType)
+        {
+            case BOT_CLASS_DRUID:
+                switch (GetBotStance())
+                {
+                    case DRUID_CAT_FORM:
+                    case DRUID_BEAR_FORM:
+                        break;
+                    case DRUID_TREE_FORM:
+                    case DRUID_TRAVEL_FORM:
+                    case DRUID_AQUATIC_FORM:
+                    //case DRUID_FLIGHT_FORM:
+                        ranged = true;
+                        break;
+                    case DRUID_MOONKIN_FORM:
+                        byspell = true;
+                        break;
+                    case BOT_STANCE_NONE:
+                        byspell = ranged && HasRole(BOT_ROLE_DPS);
+                        break;
+                    default:
+                        TC_LOG_ERROR("entities.player", "bot_ai::CheckAttackTarget(): druid has NYI bot stance %u", uint32(GetBotStance()));
+                        break;
+                }
+                break;
+            case BOT_CLASS_PRIEST:
+            case BOT_CLASS_MAGE:
+            case BOT_CLASS_WARLOCK:
+            case BOT_CLASS_SHAMAN:
+                byspell = ranged && HasRole(BOT_ROLE_DPS);
+                break;
+            case BOT_CLASS_HUNTER:
+                break;
+            case BOT_CLASS_DEATH_KNIGHT:
+            case BOT_CLASS_PALADIN:
+            case BOT_CLASS_WARRIOR:
+            case BOT_CLASS_ROGUE:
+            case BOT_CLASS_BM:
+                break;
+            default:
+                TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - unknown bot class %u", botClassOrPetType);
+                return false;
+        }
+    }
+    else
+    {
+        switch (botClassOrPetType)
+        {
+            case PET_TYPE_IMP:
+                byspell = true;
+                ranged = true;
+                break;
+            default:
+                TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - unknown pet type %u", botClassOrPetType);
+                return false;
+        }
+    }
+
+    opponent = _getTarget(byspell, ranged, reset);
+
+    if (!opponent)
+    {
+        //TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - bot %s lost target", me->GetName().c_str());
+        if (me->GetVictim() || me->IsInCombat()/* || !me->getThreatManager().isThreatListEmpty()*/)
+        {
+            //TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - bot %s Evades", me->GetName().c_str());
+            if (me->GetVictim())
+                me->AttackStop();
+            else if (me->IsInCombat())
+                Evade(true);
+        }
+
+        return false;
+    }
+
+    //boss engage phase // CanHaveThreatList checks for typeid == UNIT
+    if (!IsTank() && opponent != me->GetVictim() && opponent->CanHaveThreatList() &&
+        opponent->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_WORLDBOSS && me->GetMap()->IsRaid())
+    {
+        Unit* supposedTank = opponent->GetVictim();
+        if (supposedTank && uint32(opponent->ToCreature()->getThreatManager().getThreat(supposedTank)) < supposedTank->GetMaxHealth())
+            return false;
+    }
+
+    if (reset)
+        m_botCommandState = COMMAND_ABANDON;//reset AttackStart()
+
+    if (opponent != me->GetVictim())
+    {
+        //me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL); // hunters need that for autoshot reset
+        me->Attack(opponent, !ranged);
+    }
+
+    return true;
+}
+//POSITION
+void bot_ai::CalculateAttackPos(Unit const* target, Position& pos) const
+{
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    float x(0),y(0),z(0),
+        dist = followdist >= 40 ? followdist :
+        _botclass == BOT_CLASS_HUNTER ?
+        8 + urand(followdist/2, followdist/2 + 5) :/*23-33 at 40, 18-28 at 30*/
+        5 + urand(followdist/3, followdist/3 + 5)/*18-23 at 40, 15-20 at 30*/,
+        angle = target->GetAngle(me);
+    bool boss = target->GetTypeId() == TYPEID_UNIT &&
+        (target->ToCreature()->isWorldBoss() || target->ToCreature()->IsDungeonBoss() || target->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_WORLDBOSS);
+    //most ranged classes have some sort of 20yd spell
+    dist = std::min(dist, _botclass == BOT_CLASS_HUNTER ? (me->getLevel() >= 10 ? 40.f : 34.f) : boss ? 30.f : 20.f);
+    if (IsPetAI())
+        dist *= 0.5f;
+    float clockwise = RAND(1.f,1.f,-1.f,-1.f);
+    float angleDelta1 = IsTank(master) ? frand(M_PI*0.40f, M_PI*0.60f) : frand(0.0f, M_PI*0.15f) * clockwise;
+    float angleDelta2 = frand(0.0f, M_PI*0.15f) * clockwise;
+    for (uint8 i = 0; i != 5; ++i)
+    {
+        target->GetNearPoint(me, x, y, z, 0.f, dist, angle);
+        bool toofaraway = master->GetDistance(x,y,z) > (followdist > 38.f ? 38.f : followdist < 20 ? 20.f : float(followdist));
+        bool outoflos = !target->IsWithinLOS(x,y,z);
+        if (!toofaraway && !outoflos)
+            break;
+
+        if (toofaraway)
+        {
+            angle = target->GetAngle(master) + angleDelta1;
+            //dist -= 5.f;
+        }
+        if (outoflos)
+        {
+            if (i >= 2)
+                dist *= 0.65f;
+            angle += angleDelta2;
+        }
+    }
+
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_ai::GetInPosition(bool force, Unit* newtarget, Position* mypos)
+{
+    if (CCed(me, true) || JumpingOrFalling())
+        return;
+    if (!newtarget)
+        newtarget = me->GetVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->IsInCombat() || m_botCommandState == COMMAND_STAY || me->isMoving()) && !force)
+        return;
+    if (IsCasting())
+        return;
+    if (UpdateImpossibleChase(newtarget))
+        return;
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    if (HasRole(BOT_ROLE_RANGED))
+    {
+        //do not allow constant runaway from player
+        if (!force && newtarget->GetTypeId() == TYPEID_PLAYER &&
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3))
+            return;
+
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        if (me->GetExactDist2d(&attackpos) > 10.f || !me->IsWithinDistInMap(newtarget, 30) || !me->IsWithinLOSInMap(newtarget))
+        {
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+            if (!me->HasUnitState(UNIT_STATE_MELEE_ATTACKING))
+                me->SetInFront(newtarget);
+        }
+    }
+    else if (!JumpingOrFalling() && ((!me->HasUnitState(UNIT_STATE_CHASE) && !me->isMoving()) || (!me->HasUnitState(UNIT_STATE_CHASE_MOVE) && me->GetDistance(newtarget) > 1.5f)))
+        me->GetMotionMaster()->MoveChase(newtarget);
+
+    if (newtarget != me->GetVictim())
+    {
+        //me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL); // hunters need that for autoshot reset
+        if (!me->Attack(newtarget, !HasRole(BOT_ROLE_RANGED)))
+            me->SetInFront(newtarget);
+    }
+}
+
+void bot_ai::CheckAttackState()
+{
+    if (me->GetVictim())
+    {
+        if (HasRole(BOT_ROLE_DPS) && !me->HasAuraType(SPELL_AURA_MOD_STEALTH))
+            DoMeleeAttackIfReady();
+    }
+    else
+        Evade();
+}
+
+void bot_ai::MoveBehind(Unit const* target) const
+{
+    if (HasRole(BOT_ROLE_RANGED) || IsTank() || CCed(me, true)) return;
+    if (JumpingOrFalling()) return;
+    if (((_botclass == BOT_CLASS_ROGUE || GetBotStance() == DRUID_CAT_FORM) ?
+        target->GetVictim() != me || CCed(target) || target->GetTypeId() == TYPEID_PLAYER :
+        target->GetVictim() != me && !CCed(target))      &&
+        target->IsWithinCombatRange(me, ATTACK_DISTANCE) &&
+        target->HasInArc(M_PI, me))
+    {
+        float x(0),y(0),z(0);
+        target->GetNearPoint(me, x, y, z, me->GetCombatReach(), 0.1f, me->GetAngle(target));
+        me->GetMotionMaster()->MovePoint(me->GetMapId(), x, y, z);
+        static_cast<uint32>(waitTimer) = 500;
+    }
+}
+//MOUNT SUPPORT
+void bot_minion_ai::_updateMountedState()
+{
+    if (IAmFree())
+        return;
+    if (GetBotCommandState() != COMMAND_FOLLOW)
+        return;
+
+    bool aura = me->HasAuraType(SPELL_AURA_MOUNTED);
+    bool mounted = me->IsMounted();
+
+    //allow dismount
+    if (!CanMount() && !aura && !mounted)
+        return;
+
+    if ((!master->IsMounted() || aura != mounted || (me->IsInCombat() && opponent)) && (aura || mounted))
+    {
+        const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType &= ~INHABIT_AIR;
+        me->SetCanFly(false);
+        me->SetDisableGravity(false);
+        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+        me->Dismount();
+        me->RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING|MOVEMENTFLAG_FALLING_FAR|MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_SPLINE_ELEVATION|MOVEMENTFLAG_FALLING_SLOW);
+        me->BotStopMovement();
+        return;
+    }
+    if (me->IsInCombat() || IsCasting()/* || me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING)*/)
+        return;
+
+    if (master->IsMounted() && !me->IsMounted() && !master->IsInCombat() && !me->IsInCombat() && !me->GetVictim())
+    {
+        uint32 mount = 0;
+        Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        if (!mounts.empty())
+        {
+            //Winter Veil addition
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                mount = master->CanFly() ? REINDEER_FLY : REINDEER;
+            else
+                mount = mounts.front()->GetId();
+        }
+        if (mount)
+        {
+            if (me->HasAuraType(SPELL_AURA_MOUNTED))
+                me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+            //me->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_MOUNTED);
+
+            //if (!GetSpell(mount))
+            //    InitSpellMap(mount, true); //learn
+
+            me->BotStopMovement();
+            if (doCast(me, mount))
+            { }
+
+            //RemoveSpell(mount);
+        }
+    }
+}
+//STANDSTATE
+void bot_minion_ai::_updateStandState() const
+{
+    if (IAmFree())
+    {
+        if (_atHome && !_evadeMode && CanSit() && !me->IsInCombat() && !me->isMoving() &&
+            me->IsStandState() && Rand() < 15)
+        {
+            uint16 mapid;
+            Position pos;
+            GetHomePosition(mapid, &pos);
+            if (me->GetExactDist(&pos) < 5 && me->GetOrientation() == pos.GetOrientation())
+            {
+                if (_botclass == BOT_CLASS_DRUID && me->GetShapeshiftForm() != FORM_NONE)
+                    ToMinionAI()->removeShapeshiftForm();
+
+                me->SetStandState(UNIT_STAND_STATE_SIT);
+            }
+        }
+
+        return;
+    }
+
+    if (master->getStandState() == UNIT_STAND_STATE_STAND &&
+        me->getStandState() == UNIT_STAND_STATE_SIT &&
+        !(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    if (CanSit() && !me->IsInCombat() && !me->isMoving() &&
+        (master->getStandState() == UNIT_STAND_STATE_SIT || (me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED)) &&
+        me->getStandState() == UNIT_STAND_STATE_STAND)
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+}
+//RATIONS
+void bot_minion_ai::_updateRations()
+{
+    bool noFeast = me->IsInCombat() || CCed(me);
+
+    //check
+    if (IAmFree() || !master->IsSitState())
+    {
+        if (feast_mana)
+        {
+            if (noFeast || me->IsStandState() || me->GetMaxPower(POWER_MANA) <= 1 || me->GetPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA))
+            {
+                std::list<uint32> spellIds;
+                Unit::AuraApplicationMap const& aurApps = me->GetAppliedAuras();
+                for (Unit::AuraApplicationMap::const_iterator ci = aurApps.begin(); ci != aurApps.end(); ++ci)
+                    if (ci->second->GetBase()->GetSpellInfo()->GetSpellSpecific() == SPELL_SPECIFIC_DRINK &&
+                        !ci->second->GetBase()->GetSpellInfo()->HasAura(SPELL_AURA_PERIODIC_TRIGGER_SPELL)) //skip buffing food
+                        spellIds.push_back(ci->first);
+                for (std::list<uint32>::const_iterator cit = spellIds.begin(); cit != spellIds.end(); ++cit)
+                    me->RemoveAurasDueToSpell(*cit);
+                feast_mana = false;
+                UpdateMana();
+            }
+        }
+        if (feast_health)
+        {
+            if (noFeast || me->IsStandState() || me->GetHealth() >= me->GetMaxHealth())
+            {
+                std::list<uint32> spellIds;
+                Unit::AuraApplicationMap const& aurApps = me->GetAppliedAuras();
+                for (Unit::AuraApplicationMap::const_iterator ci = aurApps.begin(); ci != aurApps.end(); ++ci)
+                    if (ci->second->GetBase()->GetSpellInfo()->GetSpellSpecific() == SPELL_SPECIFIC_FOOD &&
+                        !ci->second->GetBase()->GetSpellInfo()->HasAura(SPELL_AURA_PERIODIC_TRIGGER_SPELL)) //skip buffing food
+                        spellIds.push_back(ci->first);
+                for (std::list<uint32>::const_iterator cit = spellIds.begin(); cit != spellIds.end(); ++cit)
+                    me->RemoveAurasDueToSpell(*cit);
+                feast_health = false;
+            }
+        }
+    }
+
+    if (noFeast)
+        return;
+
+    //drink
+    if (!feast_mana && me->GetMaxPower(POWER_MANA) > 1 && !me->IsMounted() && !me->isMoving() && CanDrink() &&
+        !me->IsInCombat() && !IsCasting() && GetManaPCT(me) < 75 && urand(0, 100) < 20)
+    {
+        //me->SetStandState(UNIT_STAND_STATE_SIT);
+        me->CastSpell(me, GetRation(true), true);
+    }
+
+    //eat
+    if (!feast_health && !me->IsMounted() && !me->isMoving() && CanEat() &&
+        !me->IsInCombat() && !IsCasting() && GetHealthPCT(me) < 80 && urand(0, 100) < 20)
+    {
+        //me->SetStandState(UNIT_STAND_STATE_SIT);
+        me->CastSpell(me, GetRation(false), true);
+    }
+}
+//Powers regeneration
+//Due to regen tick timer differences only mana and energy are handled here
+//Rage regen is handled inside class AI UpdateAI()
+void bot_minion_ai::Regenerate()
+{
+    regenTimer += lastdiff;
+
+    if (me->getPowerType() == POWER_ENERGY)
+        RegenerateEnergy();
+
+    if (regenTimer >= REGEN_CD)
+    {
+        regenTimer -= REGEN_CD;
+        // Regen Health
+        if ((!me->IsInCombat() || me->IsPolymorphed()) && me->GetHealth() < me->GetMaxHealth())
+        {
+            int32 add = IAmFree() ? me->GetMaxHealth() / 8 : me->GetCreateHealth() / 50 + me->getLevel() / 2;
+
+            if (me->IsPolymorphed())
+                add += me->GetMaxHealth() / 3;
+            else if (!me->IsInCombat() || me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+            {
+                if (!me->IsInCombat())
+                {
+                    Unit::AuraEffectList const& mModHealthRegenPct = me->GetAuraEffectsByType(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
+                    for (Unit::AuraEffectList::const_iterator i = mModHealthRegenPct.begin(); i != mModHealthRegenPct.end(); ++i)
+                        AddPct(add, (*i)->GetAmount());
+
+                    add += me->GetTotalAuraModifier(SPELL_AURA_MOD_REGEN) * REGEN_CD / 5000;
+                }
+                else if (me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+                    ApplyPct(add, me->GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT));
+            }
+
+            add += me->GetTotalAuraModifier(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT);
+
+            if (add < 0)
+                add = 0;
+
+            me->ModifyHealth(add);
+        }
+        // Regen Mana
+        if (me->GetMaxPower(POWER_MANA) > 1 && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA))
+        {
+            //update mana regen before set
+            _OnManaRegenUpdate();
+
+            float addvalue;
+            if (me->IsUnderLastManaUseEffect())
+                addvalue = me->GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER);
+            else
+                addvalue = me->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER);
+
+            addvalue *= sWorld->getRate(RATE_POWER_MANA) * REGEN_CD * 0.001f; //regenTimer threshold / 1000
+            if (addvalue < 0.0f)
+                addvalue = 0.0f;
+
+            me->ModifyPower(POWER_MANA, int32(addvalue));
+        }
+    }
+}
+
+void bot_pet_ai::Regenerate() //TODO
+{
+}
+
+bool bot_minion_ai::Feasting() const
+{
+    if (!(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+        return false;
+
+    return
+        (me->HasAuraType(SPELL_AURA_MOD_REGEN)       || me->HasAuraType(SPELL_AURA_OBS_MOD_HEALTH) ||
+         me->HasAuraType(SPELL_AURA_MOD_POWER_REGEN) || me->HasAuraType(SPELL_AURA_OBS_MOD_POWER));
+}
+uint32 bot_minion_ai::GetRation(bool drink) const
+{
+    for (uint8 i = MAX_FEAST_SPELLS - 1; i >= 0; --i)
+        if (me->getLevel() >= (drink ? DrinkSpells[i][0] : EatSpells[i][0]))
+            return (drink ? DrinkSpells[i][1] : EatSpells[i][1]);
+
+    return (drink ? DrinkSpells[0][1] : EatSpells[0][1]);
+}
+
+void bot_minion_ai::DrinkPotion(bool mana)
+{
+    me->CastSpell(me, GetPotion(mana), false);
+}
+bool bot_minion_ai::IsPotionReady() const
+{
+    return _potionTimer <= lastdiff;
+}
+uint32 bot_minion_ai::GetPotion(bool mana) const
+{
+    for (uint8 i = MAX_POTION_SPELLS - 1; i >= 0; --i)
+        if (me->getLevel() >= (mana ? ManaPotionSpells[i][0] : HealingPotionSpells[i][0]))
+            return (mana ? ManaPotionSpells[i][1] : HealingPotionSpells[i][1]);
+
+    return (mana ? ManaPotionSpells[0][1] : HealingPotionSpells[0][1]);
+}
+bool bot_minion_ai::IsPotionSpell(uint32 spellId) const
+{
+    return spellId == GetPotion(true) || spellId == GetPotion(false);
+}
+//check if our party players are in duel. if so - ignore them, their opponents and any bots they have
+//Deprecated after 4c26c85
+//bool bot_ai::InDuel(Unit const* target) const
+//{
+//    if (!target) return false;
+//    bool isbot = target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBot();
+//    Player const* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : isbot ? target->ToCreature()->GetBotOwner()->ToPlayer() : NULL;
+//    if (!player)
+//    {
+//        if (!target->IsControlledByPlayer())
+//            return false;
+//        player = target->GetCharmerOrOwnerPlayerOrPlayerItself();
+//    }
+//
+//    return (player && player->duel && (IsInBotParty(player) || IsInBotParty(player->duel->opponent)));
+//}
+////////////////
+//GRID SEARCHERS
+////////////////
+//Finds player or it's corpse for resurrection returned as WorldObject*
+WorldObject* bot_minion_ai::GetNearbyRezTarget(float dist) const
+{
+    std::list<WorldObject*> list;
+
+    NearbyRezTargetCheck check(me, dist, this);
+    Trinity::WorldObjectListSearcher <NearbyRezTargetCheck> searcher(me, list, check);
+
+    TypeContainerVisitor<Trinity::WorldObjectListSearcher <NearbyRezTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+
+    if (list.empty())
+        return NULL;
+    if (list.size() == 1)
+        return *list.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(list);
+}
+//Finds target for warrior's Shattering Throw
+Unit* bot_minion_ai::FindImmunityShieldDispelTarget(float dist) const
+{
+    if (me->GetVictim() && me->GetVictim()->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD))
+        return me->GetVictim();
+
+    Unit* unit = NULL;
+
+    ImmunityShieldDispelTargetCheck check(me, dist, this);
+    Trinity::UnitSearcher <ImmunityShieldDispelTargetCheck> searcher(me, unit, check);
+    me->VisitNearbyObject(dist, searcher);
+
+    return unit;
+}
+//Used to find target for priest's dispels, mage's spellsteal and shaman's purge
+//Returns dispellable/stealable 'Any Hostile Unit Attacking BotParty'
+Unit* bot_minion_ai::FindHostileDispelTarget(float dist, bool stealable) const
+{
+    std::list<Unit*> unitList;
+
+    HostileDispelTargetCheck check(me, dist, stealable, this);
+    Trinity::UnitListSearcher <HostileDispelTargetCheck> searcher(me, unitList, check);
+    me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return NULL;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds single target affected by given spell (and given caster if is)
+//Can check:
+//    hostile targets  (hostile = 0) <default>
+// DEPRECATED our party players (hostile = 1)
+// DEPRECATED our party members  (hostile = 2)
+//    any friendly target (hostile = 3)
+//    any friendly player (hostile = 4)
+//    any target in range  (hostile = any other value)
+Unit* bot_minion_ai::FindAffectedTarget(uint32 spellId, uint64 caster, float dist, uint8 hostile) const
+{
+    if (!spellId)
+        return NULL;
+    if ((hostile == 2 || hostile == 1)/* && IAmFree()*/)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::FindAffectedTarget(): hostile = %u Setting to ALL...", hostile);
+        hostile = 255;
+    }
+    if (master->GetMap()->Instanceable())
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+
+    Unit* unit = NULL;
+
+    AffectedTargetCheck check(caster, dist, spellId, master, hostile);
+    Trinity::UnitSearcher <AffectedTargetCheck> searcher(master, unit, check);
+    me->VisitNearbyObject(dist, searcher);
+
+    return unit;
+}
+//Finds target for mage's polymorph or shaman's hex
+Unit* bot_minion_ai::FindPolyTarget(float dist) const
+{
+    std::list<Unit*> unitList;
+
+    PolyUnitCheck check(me, dist);
+    Trinity::UnitListSearcher <PolyUnitCheck> searcher(me, unitList, check);
+    me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return NULL;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for direct fear (warlock, hunter)
+Unit* bot_minion_ai::FindFearTarget(float dist) const
+{
+    std::list<Unit*> unitList;
+
+    FearUnitCheck check(me, dist);
+    Trinity::UnitListSearcher <FearUnitCheck> searcher(me, unitList, check);
+    me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return NULL;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for paladin's repentance
+Unit* bot_minion_ai::FindStunTarget(float dist) const
+{
+    std::list<Unit*> unitList;
+
+    StunUnitCheck check(me, dist);
+    Trinity::UnitListSearcher <StunUnitCheck> searcher(me, unitList, check);
+    me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return NULL;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for priest's shackles
+Unit* bot_minion_ai::FindUndeadCCTarget(float dist, uint32 spellId, bool unattacked) const
+{
+    if (!spellId)
+        return NULL;
+
+    std::list<Unit*> unitList;
+
+    UndeadCCUnitCheck check(me, dist, this, spellId, unattacked);
+    Trinity::UnitListSearcher <UndeadCCUnitCheck> searcher(me, unitList, check);
+    me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return NULL;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for druid's Entangling Roots
+Unit* bot_minion_ai::FindRootTarget(float dist, uint32 spellId) const
+{
+    if (!spellId)
+        return NULL;
+
+    std::list<Unit*> unitList;
+
+    RootUnitCheck check(me, dist, this, spellId);
+    Trinity::UnitListSearcher <RootUnitCheck> searcher(me, unitList, check);
+    me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return NULL;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds casting target (neutral or enemy)
+//Can be used to get silence/interruption/reflect/grounding check
+Unit* bot_minion_ai::FindCastingTarget(float maxdist, float mindist, uint32 spellId, uint8 minHpPct) const
+{
+    std::list<Unit*> unitList;
+
+    CastingUnitCheck check(me, mindist, maxdist, spellId, minHpPct);
+    Trinity::UnitListSearcher <CastingUnitCheck> searcher(me, unitList, check);
+    me->VisitNearbyObject(maxdist, searcher);
+
+    if (unitList.empty())
+        return NULL;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+// Returns target for dest AOE spell (blizzard, hurricane etc.) based on attackers count
+// Cycles through BotParty, first checks player and, if checked, npcbots
+// If checked, can return friendly target as target for AOE spell
+Unit* bot_minion_ai::FindAOETarget(float dist, bool checkbots, bool targetfriend) const
+{
+    if (IsCasting() || IAmFree())
+        return NULL;
+
+    Unit* unit = NULL;
+    Group const* pGroup = master->GetGroup();
+    if (!pGroup)
+    {
+        Unit::AttackerSet m_attackers = master->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for (Unit::AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || !(*iter)->IsAlive()) continue;
+                if ((*iter)->isMoving()) continue;
+                if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                    continue;
+                if (me->GetExactDist(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = master->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = master;
+                else if (u && FindSplashTarget(dist + 4, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (!checkbots)
+            return unit;
+        BotMap const* map = master->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Creature* bot = itr->second;
+            if (!bot || !bot->IsAlive() || !bot->IsInWorld() || me->GetExactDist(bot) > dist) continue;
+
+            Unit::AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || !(*iter)->IsAlive()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                        continue;
+                    if (me->GetExactDist(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 4, u))
+                        unit = u;
+                }//end if
+            }//end if
+            if (unit) return unit;
+        }//end for
+        return unit;
+    }
+    bool Bots = false;
+    for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (!tPlayer) continue;
+        if (checkbots && tPlayer->HaveBot())
+            Bots = true;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
+        if (me->GetExactDist(tPlayer) > 40) continue;
+
+        Unit::AttackerSet m_attackers = tPlayer->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for (Unit::AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || !(*iter)->IsAlive()) continue;
+                if ((*iter)->isMoving()) continue;
+                if (me->GetExactDist(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = tPlayer->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = tPlayer;
+                else if (u && FindSplashTarget(dist + 4, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (unit) return unit;
+    }//end for
+    if (!Bots) return NULL;
+    for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+        {
+            Creature* bot = it->second;
+            if (!bot || !bot->IsAlive() || me->GetMap() != bot->FindMap()) continue;
+            if (!bot->IsInWorld()) continue;
+            if (me->GetExactDist(bot) > 30) continue;
+
+            Unit::AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || !(*iter)->IsAlive()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if (me->GetExactDist(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 4, u))
+                        unit = u;
+                }//end if
+            }//end if
+        }//end for
+        if (unit) return unit;
+    }//end for
+    return unit;
+}
+// Finds secondary target for spells like Cleave, Swipe, etc.
+Unit* bot_minion_ai::FindSplashTarget(float dist, Unit* To, float splashdist) const
+{
+    if (!To)
+        To = me->GetVictim();
+    if (!To)
+        return NULL;
+
+    if (me->GetDistance(To) > dist)
+        return NULL;
+
+    Unit* unit = NULL;
+
+    SecondEnemyCheck check(me, dist, splashdist, To, this);
+    Trinity::UnitSearcher <SecondEnemyCheck> searcher(me, unit, check);
+    me->VisitNearbyObject(dist, searcher);
+
+    return unit;
+}
+// Finds secondary target for AoE spells like Mind Sear (not damaging primary target)
+Unit* bot_minion_ai::FindSplashTarget(float dist, Unit* To, float splashdist, uint8 minTargets) const
+{
+    if (!To || minTargets < 1)
+        return NULL;
+
+    if (me->GetDistance(To) > dist)
+        return NULL;
+
+    std::list<Unit*> unitList;
+
+    SecondEnemyCheck check(me, dist, splashdist, To, this);
+    Trinity::UnitListSearcher <SecondEnemyCheck> searcher(me, unitList, check);
+    me->VisitNearbyObject(dist, searcher);
+
+    if (uint8(unitList.size()) < minTargets)
+        return NULL;
+
+    return *unitList.begin();
+}
+//Finds target for hunter's Tranquilizing Shot (has dispellable magic or enrage effect)
+Unit* bot_minion_ai::FindTranquilTarget(float mindist, float maxdist) const
+{
+    Unit* unit = NULL;
+
+    TranquilTargetCheck check(me, mindist, maxdist, this);
+    Trinity::UnitSearcher <TranquilTargetCheck> searcher(me, unit, check);
+    me->VisitNearbyObject(maxdist, searcher);
+
+    return unit;
+}
+//Find target to cast taunt on
+//In case of paladin's Righetoous Defense returns IsInBotParty() unit
+Unit* bot_minion_ai::FindDistantTauntTarget(float maxdist, bool ally) const
+{
+    std::list<Unit*> unitList;
+
+    FarTauntUnitCheck check(me, maxdist, ally, this);
+    Trinity::UnitListSearcher <FarTauntUnitCheck> searcher(me, unitList, check);
+    me->VisitNearbyObject(maxdist, searcher);
+
+    if (unitList.empty())
+        return NULL;
+
+    Unit* unit = unitList.size() == 1 ? *unitList.begin() : Trinity::Containers::SelectRandomContainerElement(unitList);
+    return ally ? unit->GetVictim() : unit;
+}
+//Finds all targets within given range with option for not having CC breaking auras
+//used for finding targets for spells which need reasonable amount of targets (ex. Death Knight AOE spells)
+void bot_minion_ai::GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, bool forCC, WorldObject const* source) const
+{
+    if (!source)
+        source = me;
+
+    NearbyHostileUnitCheck check(me, maxdist, this, forCC, source);
+    Trinity::UnitListSearcher <NearbyHostileUnitCheck> searcher(me, targets, check);
+    me->VisitNearbyObject(maxdist, searcher);
+}
+//Find all targets within given range in cone in front of caster; angle is PI/2 (TC confirmed)
+//used by mage Dragon's Breath and Cone of Cold spells
+//also Swipe (Bear) and Swipe (Cat)
+void bot_minion_ai::GetNearbyTargetsInConeList(std::list<Unit*> &targets, float maxdist) const
+{
+    NearbyHostileUnitInConeCheck check(me, maxdist, this);
+    Trinity::UnitListSearcher <NearbyHostileUnitInConeCheck> searcher(me, targets, check);
+    me->VisitNearbyObject(maxdist, searcher);
+}
+//Finds all friendly targets within given range
+//used for finding targets to heal/buff for uncontrolled bots
+void bot_minion_ai::GetNearbyFriendlyTargetsList(std::list<Unit*> &targets, float maxdist) const
+{
+    NearbyFriendlyUnitCheck check(me, maxdist, this);
+    Trinity::UnitListSearcher <NearbyFriendlyUnitCheck> searcher(me, targets, check);
+    me->VisitNearbyObject(maxdist, searcher);
+}
+//////////
+//SPELLMAP
+//////////
+//Using first-rank spell as source, returns spellId of max rank allowed for given caster
+//If you want bot to use this spell through doCast() go InitSpellMap(uint32) instead
+uint32 bot_ai::InitSpell(Unit const* caster, uint32 spell)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "InitSpell(): No SpellInfo found for spell %u", spell);
+        return 0; //weird spell with no info, disable it
+    }
+
+    uint8 lvl = caster->getLevel();
+    if (lvl < info->BaseLevel) //only 1st rank spells check
+        return 0; //cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell; //cannot use next rank, use this one
+        else
+            return InitSpell(caster, spInfo->Id); //can use next rank, forward check
+    }
+
+    return spell; //max rank, use this
+}
+//Using first-rank spell as source, puts spell of max rank allowed for given caster in spellmap
+void bot_ai::InitSpellMap(uint32 basespell, bool forceadd, bool forwardRank)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(basespell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::InitSpellMap(): No SpellInfo found for base spell %u", basespell);
+        return; //invalid spell id
+    }
+
+    uint8 lvl = me->getLevel();
+    uint32 spellId = forceadd ? basespell : 0;
+
+    while (info != NULL && forwardRank && (forceadd || lvl >= info->BaseLevel))
+    {
+        spellId = info->Id; //can use this spell
+        info = info->GetNextRankSpell(); //check next rank
+    }
+
+    BotSpell* newSpell = _spells[basespell];
+    if (!newSpell)
+    {
+        newSpell = new BotSpell();
+        _spells[basespell] = newSpell;
+    }
+
+    newSpell->spellId = spellId;
+}
+//Using first-rank spell as source, return current spell id
+uint32 bot_ai::GetSpell(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr != _spells.end() && (itr->second->enabled == true || IAmFree()) ? itr->second->spellId : 0;
+}
+//Using first-rank spell as source, returns cooldown on current spell
+uint32 bot_ai::GetSpellCooldown(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr != _spells.end() ? itr->second->cooldown : 0;
+}
+bool bot_ai::IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD) const
+{
+    if (checkGCD && GC_Timer > diff)
+        return false;
+
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr == _spells.end() ? true :
+        ((itr->second->enabled == true || IAmFree()) && itr->second->spellId != 0 && itr->second->cooldown <= diff);
+}
+//Using first-rank spell as source, sets cooldown for current spell
+void bot_ai::SetSpellCooldown(uint32 basespell, uint32 msCooldown)
+{
+    //if (!msCooldown)
+    //    return;
+
+    BotSpellMap::iterator itr = _spells.find(basespell);
+    if (itr != _spells.end())
+    {
+        itr->second->cooldown = msCooldown;
+        return;
+    }
+    else if (!msCooldown)
+        return;
+
+    InitSpellMap(basespell, true, false);
+    SetSpellCooldown(basespell, msCooldown);
+}
+//Using first-rank spell as source, sets cooldown for spells of that category
+void bot_ai::SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown)
+{
+    if (!msCooldown)
+        return;
+
+    uint32 category = spellInfo->GetCategory();
+    if (!category)
+        return;
+
+    SpellInfo const* info;
+    for (BotSpellMap::iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        //skip spell which has triggered this category cooldown
+        if (itr->first == spellInfo->Id && itr->second->cooldown >= msCooldown)
+            continue;
+
+        info = sSpellMgr->GetSpellInfo(itr->second->spellId);
+        if (info && info->GetCategory() == category && itr->second->cooldown < msCooldown)
+            itr->second->cooldown = msCooldown;
+    }
+}
+//Handles spell cooldowns for spell with IsCooldownStartedOnEvent() == true
+void bot_ai::ReleaseSpellCooldown(uint32 basespell)
+{
+    SpellInfo const* baseInfo = sSpellMgr->GetSpellInfo(basespell);
+
+    if (!baseInfo->IsCooldownStartedOnEvent())
+    {
+        TC_LOG_ERROR("spells", "bot_ai::ReleaseSpellCooldown is called for wrong spell %u!", basespell);
+        return;
+    }
+
+    uint32 rec = baseInfo->RecoveryTime;
+    uint32 catrec = baseInfo->CategoryRecoveryTime;
+
+    ApplyBotSpellCooldownMods(baseInfo, rec);
+    ApplyBotSpellCategoryCooldownMods(baseInfo, catrec);
+
+    SetSpellCooldown(baseInfo->Id, rec > 0 ? rec : 0);
+    SetSpellCategoryCooldown(baseInfo, catrec > 0 && !(baseInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS) ? catrec : 0);
+}
+//Using first-rank spell as source, disables certain spell for this bot
+void bot_ai::RemoveSpell(uint32 basespell)
+{
+    BotSpellMap::iterator itr = _spells.find(basespell);
+    if (itr != _spells.end())
+    {
+        itr->second->spellId = 0;
+        itr->second->cooldown = 0;
+    }
+}
+//See CommonTimers(uint32)
+void bot_ai::SpellTimers(uint32 diff)
+{
+    // spell must be initialized!!!
+    for (BotSpellMap::iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        if (itr->second->cooldown > diff)
+            itr->second->cooldown -= diff;
+        else if (itr->second->cooldown > 0)
+            itr->second->cooldown = 0;
+    }
+}
+uint32 bot_ai::RaceSpellForClass(uint8 myrace, uint8 myclass)
+{
+    switch (myrace)
+    {
+        case RACE_ORC:
+            switch (myclass)
+            {
+                case BOT_CLASS_WARLOCK:
+                    return RACIAL_BLOOD_FURY_WARLOCK;
+                case BOT_CLASS_SHAMAN:
+                    return RACIAL_BLOOD_FURY_SHAMAN;
+                default:
+                    return RACIAL_BLOOD_FURY_OTHERS;
+            }
+            break;
+        case RACE_BLOODELF:
+            switch (myclass)
+            {
+                case BOT_CLASS_DEATH_KNIGHT:
+                    return RACIAL_ARCANE_TORRENT_DEATHKNIGHT;
+                case BOT_CLASS_ROGUE:
+                    return RACIAL_ARCANE_TORRENT_ROGUE;
+                default:
+                    return RACIAL_ARCANE_TORRENT_OTHERS;
+            }
+            break;
+        case RACE_DRAENEI:
+            switch (myclass)
+            {
+                case BOT_CLASS_WARRIOR:
+                    return RACIAL_GIFT_OF_NAARU_WARRIOR;
+                case BOT_CLASS_PALADIN:
+                    return RACIAL_GIFT_OF_NAARU_PALADIN;
+                case BOT_CLASS_HUNTER:
+                    return RACIAL_GIFT_OF_NAARU_HUNTER;
+                case BOT_CLASS_PRIEST:
+                    return RACIAL_GIFT_OF_NAARU_PRIEST;
+                case BOT_CLASS_DEATH_KNIGHT:
+                    return RACIAL_GIFT_OF_NAARU_DEATHKNIGHT;
+                case BOT_CLASS_SHAMAN:
+                    return RACIAL_GIFT_OF_NAARU_SHAMAN;
+                case BOT_CLASS_MAGE:
+                    return RACIAL_GIFT_OF_NAARU_MAGE;
+                default:
+                    TC_LOG_ERROR("entities.player", "RaceSpellForClass(): unknows race:class combo %u, %u", uint32(myrace), uint32(myclass));
+                    return 0;
+            }
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "RaceSpellForClass(): unknows race:class combo %u, %u", uint32(myrace), uint32(myclass));
+            return 0;
+    }
+}
+//Health magement for minions
+//Including health calcs, set
+void bot_minion_ai::_OnHealthUpdate() const
+{
+    uint8 myclass = _botclass;
+    uint8 mylevel = master->getLevel();
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+    //TC_LOG_ERROR("entities.player", "_OnHealthUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = me->GetHealth() == me->GetMaxHealth() ? 100.f : me->GetHealthPct(); // needs for regeneration
+    uint32 m_basehp = _classinfo->basehealth;
+    //TC_LOG_ERROR("entities.player", "class base health: %u", m_basehp);
+    me->SetCreateHealth(m_basehp);
+
+    float stamValue = _getTotalBotStat(BOT_STAT_MOD_STAMINA);
+
+    stamValue -= std::min<float>(me->GetCreateStat(STAT_STAMINA), 20.f); //not a mistake
+    stamValue = std::max<float>(stamValue, 0.f);
+
+    //TC_LOG_ERROR("entities.player", "bot's stats to health add: Stamina (%f), value: %f", stamValue, stamValue * 10.f);
+    float hp_add = stamValue * 10.f + 20; //20 is not a mistake;
+    hp_add += IAmFree() ? mylevel * 250.f : 0; //+20000/+0 hp at 80
+    hp_add += _getTotalBotStat(BOT_STAT_MOD_HEALTH);
+    //TC_LOG_ERROR("entities.player", "health to add after stam mod: %i", hp_add);
+    uint32 m_totalhp = m_basehp + int32(hp_add); //m_totalhp = uint32(float(m_basehp + hp_add) * stammod);
+    //TC_LOG_ERROR("entities.player", "total base health: %u", m_totalhp);
+
+    //hp bonuses
+    uint8 bonuspct = 0;
+    if (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE)
+        bonuspct += 8;
+    if (_botclass == BOT_CLASS_HUNTER && mylevel >= 10)
+        bonuspct += 5;
+    if (bonuspct)
+        m_totalhp = (m_totalhp * (100 + bonuspct)) / 100;
+
+    m_totalhp = float(uint32(m_totalhp) - (uint32(m_totalhp) % 10));
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp)); //replaces base hp at max lvl
+    me->UpdateMaxHealth(); //will use our values we just set (update base health and buffs)
+    //TC_LOG_ERROR("entities.player", "overall hp: %u", me->GetMaxHealth());
+    me->SetHealth(pct == 100.f ? me->GetMaxHealth() : uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+}
+//Mana management for minions
+//Including calcs and set
+void bot_minion_ai::_OnManaUpdate() const
+{
+    if (me->GetMaxPower(POWER_MANA) <= 1)
+        return;
+
+    uint8 myclass = _botclass;
+    uint8 mylevel = master->getLevel();
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+
+    //TC_LOG_ERROR("entities.player", "_OnManaUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = me->GetPower(POWER_MANA) == me->GetMaxPower(POWER_MANA) ? 100.f :
+        (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = _classinfo->basemana;
+    if (_botclass == BOT_CLASS_BM)
+        m_basemana = 240.f;
+    //TC_LOG_ERROR("entities.player", "classinfo base mana = %f", m_basemana);
+
+    me->SetCreateMana(uint32(m_basemana));
+
+    float intValue = _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+
+    intValue -= std::min<float>(me->GetCreateStat(STAT_INTELLECT), 20.f); //not a mistake
+    intValue = std::max<float>(intValue, 0.f);
+
+    m_basemana += intValue * 15.0f + 20.f; //20.f is not a mistake
+    m_basemana += IAmFree() ? mylevel * 50.f : 0; //+4000/+0 mana at 80
+    m_basemana += _getTotalBotStat(BOT_STAT_MOD_MANA);
+    //mana bonuses
+    m_basemana = float(uint32(m_basemana) - (uint32(m_basemana) % 5));
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, pct == 100.f ? me->GetMaxPower(POWER_MANA) :
+        uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f)); //restore pct
+
+    _OnManaRegenUpdate();
+}
+//Mana regen for minions
+void bot_minion_ai::_OnManaRegenUpdate() const
+{
+    //regen_normal
+    uint8 mylevel = me->getLevel();
+    float value = IAmFree() ? mylevel/4 : 0; //100/0 mp5 at 80
+
+    // Mana regen from spirit and intellect
+    float spiregen = 0.001f;
+    uint8 tempclass = _botclass < BOT_CLASS_EX_START ? _botclass : BOT_CLASS_MAGE;
+    if (GtRegenMPPerSptEntry const* moreRatio = sGtRegenMPPerSptStore.LookupEntry((tempclass-1)*GT_MAX_LEVEL + mylevel-1))
+        spiregen = moreRatio->ratio * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+
+    // PCT bonus from SPELL_AURA_MOD_POWER_REGEN_PERCENT aura on spirit base regen
+    value += sqrt(_getTotalBotStat(BOT_STAT_MOD_INTELLECT)) * spiregen * me->GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_POWER_REGEN_PERCENT, POWER_MANA);
+    // regen from SPELL_AURA_MOD_POWER_REGEN aura (per second)
+    float power_regen_mp5 = 0.2f * (me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + _getTotalBotStat(BOT_STAT_MOD_MANA_REGENERATION));
+    if (IAmFree())
+        power_regen_mp5 += float(mylevel);
+    // bonus from SPELL_AURA_MOD_MANA_REGEN_FROM_STAT aura
+    Unit::AuraEffectList const& regenAura = me->GetAuraEffectsByType(SPELL_AURA_MOD_MANA_REGEN_FROM_STAT);
+    for (Unit::AuraEffectList::const_iterator i = regenAura.begin(); i != regenAura.end(); ++i)
+        power_regen_mp5 += me->GetStat(Stats((*i)->GetMiscValue())) * (*i)->GetAmount() * 0.002f; //per second
+    // Set regen rate in cast state apply only on spirit based regen
+    int32 modManaRegenInterrupt = std::min<int32>(100, me->GetTotalAuraModifier(SPELL_AURA_MOD_MANA_REGEN_INTERRUPT));
+
+    if (_botclass >= BOT_CLASS_EX_START)
+    {
+        if (_botclass == BOT_CLASS_BM)
+        {
+            modManaRegenInterrupt = 100;
+            power_regen_mp5 = 0.0f;
+            value = 2.0f + 0.05f * (me->getLevel() > 3 ? me->getLevel() - 3 : 0);
+        }
+    }
+    //Unrelenting Storm, Dreamstate: 12% of intellect as mana regen always
+    if (_botclass == BOT_CLASS_SHAMAN || _botclass == BOT_CLASS_DRUID)
+        power_regen_mp5 += 0.2f * 0.12f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+
+    me->SetStatFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER, power_regen_mp5 + CalculatePct(value, modManaRegenInterrupt));
+    me->SetStatFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER, power_regen_mp5 + value);
+}
+//Health for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnHealthUpdate() const
+{
+    uint8 mylevel = master->getLevel();
+    float hp_mult;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_IMP:          hp_mult = 8.4f; break;
+        case PET_TYPE_VOIDWALKER:   hp_mult = 11.f; break;
+        case PET_TYPE_SUCCUBUS:     hp_mult = 9.1f; break;
+        case PET_TYPE_FELHUNTER:    hp_mult = 9.5f; break;
+        case PET_TYPE_FELGUARD:     hp_mult = 11.f; break;
+        default:                    hp_mult = 10.f; break;
+    }
+    float pct = me->GetHealthPct();
+    uint32 m_basehp = me->GetCreateHealth();
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA) - 20.f; //remove base stamina (not calculated into health)
+    uint32 hp_add = uint32(stamValue * hp_mult);
+    hp_add += (m_creatureOwner->GetMaxHealth() - m_creatureOwner->GetCreateHealth()) / 3;
+    uint8 miscVal = GetPetType(me) * mylevel;
+    hp_add += miscVal;
+    uint32 m_totalhp = m_basehp + hp_add;
+    if (IsTank())
+        m_totalhp = (m_totalhp * 135) / 100; //35% hp bonus for tanks
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp));
+    me->UpdateMaxHealth(); //will use values set (update base health and buffs)
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+}
+//Mana for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnManaUpdate() const
+{
+    if (me->GetMaxPower(POWER_MANA) <= 1)
+        return;
+
+    uint8 mylevel = m_creatureOwner->getLevel();
+    float mana_mult;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_IMP:          mana_mult = 4.95f; break;
+        case PET_TYPE_SUCCUBUS:
+        case PET_TYPE_FELHUNTER:
+        case PET_TYPE_FELGUARD:
+        case PET_TYPE_VOIDWALKER:   mana_mult = 11.5f;  break;
+        default:                    mana_mult = 15.f;   break;
+    }
+    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = float(me->GetCreateMana());
+    m_basemana += me->GetTotalStatValue(STAT_INTELLECT) * mana_mult;
+    m_basemana += (m_creatureOwner->GetMaxPower(POWER_MANA) - m_creatureOwner->GetCreateMana()) / 3;
+    m_basemana += (GetPetType(me) * mylevel);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f));//restore pct
+}
+//Sends all master's bots a message to not try to evade for a certain period of time
+//void bot_ai::SendPartyEvadeAbort() const
+//{
+//    ASSERT(!IAmFree());
+//
+//    BotMap const* map = master->GetBotMgr()->GetBotMap();
+//    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+//        if (Creature* bot = itr->second)
+//            if (bot_minion_ai* ai = bot->GetBotMinionAI())
+//                ai->SetEvadeTimer(50);
+//}
+//Bots cannot dodge/parry from behind so try to condense enemies at front
+//opponent is always valid
+void bot_minion_ai::AdjustTankingPosition() const
+{
+    if (/*!IsTank() || */!me->IsInCombat() || me->isMoving()/* || HasRole(BOT_ROLE_RANGED)*/ ||
+        JumpingOrFalling() || CCed(me, true) || Rand() > 20 + 30*me->GetMap()->IsDungeon())
+        return;
+
+    Unit::AttackerSet const& myattackers = me->getAttackers();
+    if (myattackers.size() < 2)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "AdjustTankingPosition() by %s", me->GetName().c_str());
+
+    uint32 bCount = 0;
+    for (Unit::AttackerSet::const_iterator itr = myattackers.begin(); itr != myattackers.end(); ++itr)
+    {
+        if (/*!CCed(*itr) && */(*itr)->IsWithinMeleeRange(me) && !me->HasInArc(M_PI * 0.8f, *itr))
+            ++bCount;
+            //if (++bCount)
+            //    break;
+    }
+
+    if (bCount == 0)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "AdjustTankingPosition(): atts %u, behind %u", uint32(myattackers.size()), bCount);
+
+    //calculate new position
+    float x = me->GetPositionX();
+    float y = me->GetPositionY();
+    float z = me->GetPositionZ();
+    float ori = me->GetOrientation();
+    float const moveDist = (opponent->GetVictim() == me ? 1.f : -1.f) * std::max<float>(opponent->GetObjectSize() * 0.5f, 8.f);
+    float moveX;
+    float moveY;
+    bool move = false;
+    for (uint8 i = 0; i != 3; ++i)
+    {
+        if (i)
+        {
+            ori = Position::NormalizeOrientation(ori + (i+1)*(M_PI*0.5f));
+        }
+
+        //move back
+        moveX = moveDist * std::cos(ori);
+        moveY = moveDist * std::sin(ori);
+
+        if (me->IsWithinLOS(x+moveX, y+moveY, z))
+            break;
+
+        if (i == 2)
+        {
+            moveX *= 0.2f;
+            moveY *= 0.2f;
+        }
+    }
+
+    x+= moveX;
+    y+= moveY;
+
+    me->UpdateAllowedPositionZ(x, y, z);
+    if (me->GetPositionZ() < z)
+        z += 0.75f; //prevent going underground
+
+    //if (CCed(opponent, true))
+    //    me->AttackStop();
+    //me->SetOrientation(ori);
+    me->GetMotionMaster()->MovePoint(me->GetMapId(), x, y, z);
+}
+void bot_minion_ai::Evade(bool force)
+{
+    EnterEvadeMode(force);
+}
+//SpellHit()... OnSpellHit()
+void bot_ai::OnSpellHit(Unit* caster, SpellInfo const* spell)
+{
+    //uint32 const spellId = spell->Id;
+
+    if (spell->HasAura(SPELL_AURA_MOD_TAUNT) || spell->HasEffect(SPELL_EFFECT_ATTACK_ME))
+        if (caster && me->Attack(caster, !HasRole(BOT_ROLE_RANGED)))
+        {}//me->GetMotionMaster()->MoveChase(caster);
+
+    if (spell->GetSpellSpecific() == SPELL_SPECIFIC_DRINK)
+    {
+        feast_mana = true;
+        UpdateMana();
+        regenTimer = 0;
+    }
+    else if (spell->GetSpellSpecific() == SPELL_SPECIFIC_FOOD)
+    {
+        feast_health = true;
+        regenTimer = 0;
+    }
+
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        uint32 const auraname = spell->Effects[i].ApplyAuraName;
+        //remove pet on mount
+        if (auraname == SPELL_AURA_MOUNTED)
+        {
+            me->SetBotsPetDied();
+            UnsummonAll();
+            if (master->HasAuraType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED) ||
+                master->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+            {
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType |= INHABIT_AIR;
+                me->SetCanFly(true);
+                me->SetDisableGravity(true);
+                me->SetSpeed(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+                me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+            }
+            else
+                me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_RUN) * 1.1f);
+        }
+
+        //update stats
+        if (auraname == SPELL_AURA_MOD_STAT || auraname == SPELL_AURA_MOD_PERCENT_STAT ||
+            auraname == SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE || auraname == SPELL_AURA_MOD_SKILL ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER || auraname == SPELL_AURA_MOD_ATTACK_POWER_PCT ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT || auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR ||
+            auraname == SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT ||
+            auraname == SPELL_AURA_MOD_RATING || auraname == SPELL_AURA_MOD_RATING_FROM_STAT)
+            shouldUpdateStats = true;
+        else if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH ||
+            auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 ||
+            auraname == SPELL_AURA_230 ||//SPELL_AURA_MOD_INCREASE_HEALTH_2
+            auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
+            UpdateHealth();
+        else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY || auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
+            UpdateMana(); //Divine Hymn - max mana increase
+
+        uint32 const effect = spell->Effects[i].Effect;
+        if (effect == SPELL_EFFECT_RESURRECT || effect == SPELL_EFFECT_RESURRECT_NEW || effect == SPELL_EFFECT_SELF_RESURRECT)
+        {
+            //resurrect effects are not handled for creatures
+            if (!me->IsAlive())
+            {
+                uint32 health = 0;
+                uint32 mana = 0;
+                int32 damage = spell->Effects[i].BasePoints;
+
+                if (effect == SPELL_EFFECT_RESURRECT_NEW)
+                {
+                    //Glyph of Rebirth: resurrect with 100% health
+                    if (spell->IsRankOf(sSpellMgr->GetSpellInfo(20484)))
+                        health = me->GetMaxHealth();
+                    else
+                        health = damage;
+                    mana = spell->Effects[i].MiscValue;
+                }
+                else if (damage < 0)
+                {
+                    health = uint32(-damage);
+                    mana = spell->Effects[i].MiscValue;
+                }
+                else
+                {
+                    health = me->CountPctFromMaxHealth(damage);
+                    if (me->GetMaxPower(POWER_MANA) > 1)
+                        mana = CalculatePct(me->GetMaxPower(POWER_MANA), damage);
+                }
+                me->Relocate(caster);
+                me->SetUInt32Value(UNIT_NPC_FLAGS, me->GetCreatureTemplate()->npcflag);
+                me->ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
+                me->RemoveFlag(UNIT_FIELD_FLAGS, uint32(-1));
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+                me->setDeathState(ALIVE);
+
+                me->SetHealth(health);
+                if (me->GetMaxPower(POWER_MANA) > 1)
+                    me->SetPower(POWER_MANA, mana);
+
+                shouldUpdateStats = true;
+            }
+        }
+    }
+
+    //TODO:
+    if (/*!(spell->AttributesEx & SPELL_ATTR1_NO_THREAT) &&
+        !(spell->AttributesEx3 & SPELL_ATTR3_NO_INITIAL_AGGRO) &&*/
+        IsMinionAI() && /*!CCed(me) && */(me->IsHostileTo(caster) || caster->IsHostileTo(me)))
+    {
+        //_atHome = false;
+        if (!me->CanSeeOrDetect(caster))
+        {
+            if (_evadeMode)
+                me->BotStopMovement();
+        }
+        else if (caster->IsInCombat() || me->IsInCombat())
+            this->OwnerAttackedBy(caster);
+        //if (_evadeMode == true && me->isMoving() && IAmFree())
+    }
+}
+//Update delay
+//Delays UpdateAI cycles for randomization of bots' reaction and performance adjustments
+bool bot_ai::Wait()
+{
+    if (waitTimer > lastdiff || !master->IsInWorld())
+        return true;
+
+    CheckAuras(true);
+    FindMaster();
+    //SavePosition();
+
+    if (IAmFree())
+        waitTimer = me->IsInCombat() ? 500 : urand(750, 1250);
+    else if (!master->GetMap()->IsRaid())
+        waitTimer = std::min<uint32>(uint32(100 * (master->GetNpcBotsCount() - 1) + __rand), 500);
+    //else if (master->GetMap()->IsRaid())
+    //    waitTimer = 0;
+
+    return false;
+}
+//Spell Mod Hooks
+//Bug with config reload (creatures do not update their damage on reload) is not bot-related but still annoying
+void bot_ai::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    //WHITE ATTACKS damage bonus
+    ApplyClassDamageMultiplierMelee(damage, damageinfo);
+    damage = uint32(damage * _mult_dmg_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    //MELEE ABILITIES damage bonus
+    ApplyClassDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(damage * _mult_dmg_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    //DAMAGE SPELLS damage bonus
+    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(damage * _mult_dmg_spell);
+}
+void bot_ai::ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+{
+    //HEALING SPELLS amount bonus
+    ApplyClassDamageMultiplierHeal(victim, heal, spellInfo, damagetype, stack);
+    heal = (heal * _mult_healing);
+}
+void bot_ai::ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
+{
+    //ALL SPELLS crit bonus + base
+    ApplyClassSpellCritMultiplierAll(victim, crit_chance, spellInfo, schoolMask, attackType);
+    crit_chance += crit;
+}
+void bot_ai::ApplyBotSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+{
+    //ALL SPELLS power cost bonus
+    ApplyClassSpellCostMods(spellInfo, cost);
+}
+void bot_ai::ApplyBotSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+{
+    //ALL SPELLS cast time bonus
+    ApplyClassSpellCastTimeMods(spellInfo, casttime);
+}
+void bot_ai::ApplyBotSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+{
+    //ALL SPELLS cooldown bonus
+    ApplyClassSpellCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+{
+    //ALL SPELLS category cooldown bonus
+    ApplyClassSpellCategoryCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+{
+    //ALL SPELLS global cooldown bonus
+    ApplyClassSpellGlobalCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+{
+    //ALL SPELLS radius bonus (not range)
+    ApplyClassSpellRadiusMods(spellInfo, radius);
+}
+void bot_ai::ApplyBotSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const
+{
+    //ALL SPELLS range bonus
+    ApplyClassSpellRangeMods(spellInfo, maxrange);
+}
+void bot_ai::ApplyBotSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const
+{
+    //ALL SPELLS max targets bonus
+    ApplyClassSpellMaxTargetsMods(spellInfo, targets);
+}
+void bot_ai::ApplyBotSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const
+{
+    //ALL CLASS PROC_TRIGGER_SPELL SPELLS chance of success bonus
+    ApplyClassSpellChanceOfSuccessMods(spellInfo, chance);
+}
+//Spell Mod Utilities
+float bot_ai::CalcSpellMaxRange(uint32 spellId, bool enemy) const
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    //ASSERT(spellInfo);
+
+    float maxRange = spellInfo->GetMaxRange(!enemy);
+    if (maxRange == 0x0)
+        return maxRange;
+
+    ApplyClassSpellRangeMods(spellInfo, maxRange);
+    return maxRange;
+}
+//////////
+//GOSSIP//
+//////////
+//GossipHello (static)
+bool bot_minion_ai::OnGossipHello(Player* player, Creature* creature, uint32 /*option*/)
+{
+    ASSERT(player);
+    ASSERT(creature);
+
+    if (!BotMgr::IsNpcBotModEnabled() || creature->IsInCombat() || bot_ai::CCed(creature) ||
+        creature->HasUnitState(UNIT_STATE_CASTING) || creature->GetBotAI()->IsDuringTeleport())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    if (creature->GetBotAI()->IsTempBot()) //Blademaster illusion etc.
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    if (creature->isMoving())
+        creature->BotStopMovement();
+
+    uint32 gossipTextId = creature->IsFreeBot() ? GOSSIP_NEED_SMTH : GOSSIP_SERVE_MASTER;
+
+    bool menus = false;
+
+    if (player->IsGameMaster())
+    {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Debug>", GOSSIP_SENDER_DEBUG, GOSSIP_ACTION_INFO_DEF + 1);
+        menus = true;
+    }
+
+    if (player->GetGUIDLow() != creature->GetBotAI()->GetBotOwnerGuid())
+    {
+        if (creature->IsFreeBot())
+        {
+            uint32 cost = BotMgr::GetNpcBotCost(player->getLevel(), creature);
+
+            int8 reason = 0;
+            if (creature->HasAura(BERSERK))
+                reason = -1;
+            if (!reason && creature->GetBotAI()->GetBotOwnerGuid())
+                reason = 1;
+            if (!reason && player->GetNpcBotsCount() >= BotMgr::GetMaxNpcBots())
+                reason = 2;
+            if (!reason && !player->HasEnoughMoney(cost))
+                reason = 3;
+
+            if (!reason && _maxClassNpcBots && player->HaveBot())
+            {
+                uint8 count = 0;
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    if (itr->second->GetBotClass() == creature->GetBotClass())
+                        ++count;
+
+                if (!reason && count >= _maxClassNpcBots)
+                    reason = 4;
+            }
+
+            if (!reason)
+            {
+                std::ostringstream message;
+                message << "Do you wish to hire " << creature->GetName() << '?';
+                player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TAXI, "<Hire bot>",
+                    GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF + 0, message.str().c_str(), cost, false);
+            }
+            else
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TAXI, "<Hire bot>", GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF + reason);
+
+            //if (creature->GetBotClass() >= BOT_CLASS_EX_START)
+            //    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "<Take a better look on this one>", GOSSIP_SENDER_SCAN, GOSSIP_ACTION_INFO_DEF + 1);
+
+            menus = true;
+        }
+    }
+
+    if (creature->GetBotAI()->GetBotOwnerGuid())
+    {
+        Group const* gr = player->GetGroup();
+
+        if (player == creature->GetBotOwner())
+        {
+            menus = true;
+
+            //general: equips, roles, distance, abilities, comsumables, group
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage equipment...", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage roles...", GOSSIP_SENDER_ROLES_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage formation...", GOSSIP_SENDER_FORMATION, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage abilities...", GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Give consumable...", GOSSIP_SENDER_USEITEM, GOSSIP_ACTION_INFO_DEF + 1);
+            //player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Abilities status...", GOSSIP_SENDER_SCAN_OWNER, GOSSIP_ACTION_INFO_DEF + 1);
+
+            if (!gr)
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Create group>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+                if (player->GetNpcBotsCount() > 1)
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Create group (all bots)>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 2);
+            }
+            else if (!gr->IsMember(creature->GetGUID()))
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Add to group>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Add all bots to group>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 2);
+            }
+            else
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Remove from group>", GOSSIP_SENDER_LEAVE_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+        }
+        if (player == creature->GetBotOwner() || (gr && gr->IsMember(creature->GetBotOwner()->GetGUID())))
+        {
+            //class-specific for party: mage rations, rogue lockpicking etc.
+            //TODO: priest lightwell (manual only) maybe move into abilities
+            switch (creature->GetBotClass())
+            {
+                case BOT_CLASS_MAGE:
+                {
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need food", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need water", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                    menus = true;
+                    break;
+                }
+                case BOT_CLASS_ROGUE:
+                {
+                    //Learned at 16
+                    //Allow rogues to gain skill with bot's help
+                    if (creature->getLevel() >= 16/* && !player->HasSkill(SKILL_LOCKPICKING)*/)
+                    {
+                        std::ostringstream msg;
+                        msg << "I need your lockpicks (" << uint32(creature->getLevel() * 5) << ")";
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, msg.str().c_str(), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                        menus = true;
+                    }
+                    break;
+                }
+                case BOT_CLASS_WARLOCK:
+                {
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need your your healthstone", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    menus = true;
+                    break;
+                }
+                default:
+                    break;
+            }
+        }
+        if (player == creature->GetBotOwner())
+        {
+            //class-specific for owner: poisons, enchants, etc.
+            switch (creature->GetBotClass())
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    if (creature->getLevel() >= 20)
+                    {
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need you to refresh poisons", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "<Choose poison (Main Hand)>", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 3);
+                        Item const* oweap = creature->GetBotEquips(BOT_SLOT_OFFHAND);
+                        if (oweap && oweap->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "<Choose poison (Offhand)>", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 4);
+                    }
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    if (creature->getLevel() >= 10)
+                    {
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need you to refresh enchants", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "<Choose enchant (Main Hand)>", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 3);
+                        Item const* oweap = creature->GetBotEquips(BOT_SLOT_OFFHAND);
+                        if (oweap && oweap->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "<Choose enchant (Offhand)>", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 4);
+                    }
+                    break;
+                }
+                case BOT_CLASS_DRUID:
+                {
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need you to remove shapeshift", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    break;
+                }
+                default:
+                    break;
+            }
+
+            std::ostringstream astr;
+            astr << "Are you going to abandon " << creature->GetName() << "? You may regret it...";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TAXI, "You are dismissed",
+                GOSSIP_SENDER_DISMISS, GOSSIP_ACTION_INFO_DEF + 1, astr.str().c_str(), 0, false);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Pull yourself together, damnit", GOSSIP_SENDER_TROUBLESHOOTING, GOSSIP_ACTION_INFO_DEF + 1);
+        }
+    }
+
+    if (menus)
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Nevermind", 0, GOSSIP_ACTION_INFO_DEF + 1);
+
+    player->PlayerTalkClass->SendGossipMenu(gossipTextId, creature->GetGUID());
+    return true;
+}
+
+//GossipSelect
+bool bot_minion_ai::OnGossipSelect(Player* player, Creature* creature/* == me*/, uint32 sender, uint32 action)
+{
+    //if (!IsInBotParty(player))
+    //{
+    //    player->CLOSE_GOSSIP_MENU();
+    //    return true;
+    //}
+
+    if (!BotMgr::IsNpcBotModEnabled() || me->HasUnitState(UNIT_STATE_CASTING) || CCed(me) || IsDuringTeleport())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    uint32 gossipTextId = IAmFree() ? GOSSIP_NEED_SMTH : GOSSIP_SERVE_MASTER;
+
+    player->PlayerTalkClass->ClearMenus();
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case 0: //any kind of fail
+        {
+            BotSay("...", player);
+            break;
+        }
+        case 1: //BACK: return to main menu
+        {
+            return bot_minion_ai::OnGossipHello(player, creature, 0);
+        }
+        case GOSSIP_SENDER_CLASS:
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_MAGE:
+                {
+                    if (IsCasting())
+                    {
+                        player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, NULL);
+                        break;
+                    }
+
+                    //Prevent high-leveled consumables for low-level characters
+                    Unit* checker;
+                    if (player->getLevel() < me->getLevel())
+                        checker = player;
+                    else
+                        checker = me;
+
+                    // Conjure Refreshment rank 1
+                    uint32 food = InitSpell(checker, 42955);
+                    bool iswater = (action == GOSSIP_ACTION_INFO_DEF + 2);
+                    if (!food)
+                    {
+                        if (!iswater)// Conjure Food rank 1
+                            food = InitSpell(checker, 587);
+                        else// Conjure Water rank 1
+                            food = InitSpell(checker, 5504);
+                    }
+                    if (!food)
+                    {
+                        std::string errorstr = "I can't conjure ";
+                        errorstr += iswater ? "water" : "food";
+                        errorstr += " yet";
+                        BotWhisper(errorstr.c_str(), player);
+                        //player->PlayerTalkClass->ClearMenus();
+                        //return OnGossipHello(player, me);
+                        break;
+                    }
+                    SpellInfo const* Info = sSpellMgr->GetSpellInfo(food);
+                    Spell* foodspell = new Spell(me, Info, TRIGGERED_NONE, player->GetGUID());
+                    SpellCastTargets targets;
+                    targets.SetUnitTarget(player);
+                    //TODO implement checkcast for bots
+                    SpellCastResult result = me->IsMounted() || CCed(me) ? SPELL_FAILED_CUSTOM_ERROR : foodspell->CheckPetCast(player);
+                    if (result != SPELL_CAST_OK)
+                    {
+                        foodspell->finish(false);
+                        delete foodspell;
+                        BotWhisper("I can't do it right now", player);
+                    }
+                    else
+                    {
+                        aftercastTargetGuid = player->GetGUID();
+                        foodspell->prepare(&targets);
+                        BotWhisper("Here you go...", player);
+                    }
+                    break;
+                }
+                case BOT_CLASS_ROGUE:
+                {
+                    action -= GOSSIP_ACTION_INFO_DEF;
+
+                    if (action == 1)
+                    {
+                        // Pick Lock
+                        subMenu = true;
+
+                        uint32 count = 0;
+                        uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 1; //BACK
+
+                        //1 Nearest gameobject
+                        GameObject* obj = NULL;
+                        NearestLockedGameObjectInRangeCheck check(player, 4.f);
+                        Trinity::GameObjectLastSearcher<NearestLockedGameObjectInRangeCheck> searcher(player, obj, check);
+                        player->VisitNearbyGridObject(4.f, searcher);
+                        if (obj)
+                        {
+                            std::ostringstream msg;
+                            msg << obj->GetGOInfo()->name << " (dist = " << player->GetExactDist(obj) << ")";
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, msg.str().c_str(), GOSSIP_SENDER_CLASS_ACTION, GOSSIP_ACTION_INFO_DEF + ++count);
+                        }
+
+                        //2 Inventory
+                        Item* item = NULL;
+                        LockEntry const* lockInfo;
+
+                        //backpack
+                        for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                        {
+                            item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                            if (item && item->IsLocked() && item->GetTemplate()->LockID)
+                            {
+                                lockInfo = sLockStore.LookupEntry(item->GetTemplate()->LockID);
+                                if (!lockInfo)
+                                    continue;
+
+                                for (uint8 j = 0; j != MAX_LOCK_CASE; ++j)
+                                {
+                                    if (lockInfo->Type[j] == LOCK_KEY_SKILL && lockInfo->Index[j] == LOCKTYPE_PICKLOCK &&
+                                        lockInfo->Skill[j] <= uint32(15 + creature->getLevel() * 5))
+                                    {
+                                        std::ostringstream name;
+                                        _AddItemLink(player, item, name, false);
+                                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_CLASS_ACTION, GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                        //bags
+                        for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                        {
+                            if (Bag const* bag = player->GetBagByPos(i))
+                            {
+                                for (uint32 j = 0; j != bag->GetBagSize() && count <= maxcounter; j++)
+                                {
+                                    item = player->GetItemByPos(i, j);
+                                    if (item && item->IsLocked() && item->GetTemplate()->LockID)
+                                    {
+                                        lockInfo = sLockStore.LookupEntry(item->GetTemplate()->LockID);
+                                        if (!lockInfo)
+                                            continue;
+
+                                        for (uint8 j = 0; j != MAX_LOCK_CASE; ++j)
+                                        {
+                                            if (lockInfo->Type[j] == LOCK_KEY_SKILL && lockInfo->Index[j] == LOCKTYPE_PICKLOCK &&
+                                                lockInfo->Skill[j] <= uint32(15 + creature->getLevel() * 5))
+                                            {
+                                                std::ostringstream name;
+                                                _AddItemLink(player, item, name, false);
+                                                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_CLASS_ACTION, GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                                                ++count;
+                                                break;
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + ++count);
+                    }
+                    else if (action == 2)
+                    {
+                        //Clear poisons (autorefresh is in class ai DoNonCombatActions
+                        RemoveItemClassEnchants();
+                    }
+                    else if (action == 3)
+                    {
+                        subMenu = true;
+                        //Send list of available poisons on MH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_6; ++i)
+                        {
+                            uint32 possiblePoison = GetAIMiscValue(i);
+                            if (uint32 possiblePoisonMaxRank = GetSpell(possiblePoison))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possiblePoisonMaxRank);
+                                uint32 curMHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH);
+                                bool same = possiblePoison == curMHId;
+                                player->ADD_GOSSIP_ITEM(same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, availableInfo->SpellName[0], GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + possiblePoison);
+                            }
+                        }
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Auto>", GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + 0);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else if (action == 4)
+                    {
+                        subMenu = true;
+                        //Send list of available poisons on OH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_6; ++i)
+                        {
+                            uint32 possiblePoison = GetAIMiscValue(i);
+                            if (uint32 possiblePoisonMaxRank = GetSpell(possiblePoison))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possiblePoisonMaxRank);
+                                uint32 curOHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH);
+                                bool same = possiblePoison == curOHId;
+                                player->ADD_GOSSIP_ITEM(same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, availableInfo->SpellName[0], GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + possiblePoison);
+                            }
+                        }
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Auto>", GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + 0);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    action -= GOSSIP_ACTION_INFO_DEF;
+
+                    if (action == 2)
+                    {
+                        //Clear enchants (autorefresh is in class ai DoNonCombatActions
+                        RemoveItemClassEnchants();
+                    }
+                    else if (action == 3)
+                    {
+                        subMenu = true;
+                        //Send list of available enchants on MH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_5; ++i)
+                        {
+                            uint32 possibleEnchant = GetAIMiscValue(i);
+                            if (uint32 possibleEcnhantMaxRank = GetSpell(possibleEnchant))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possibleEcnhantMaxRank);
+                                uint32 curMHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH);
+                                bool same = possibleEnchant == curMHId;
+                                player->ADD_GOSSIP_ITEM(same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, availableInfo->SpellName[0], GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + possibleEnchant);
+                            }
+                        }
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Auto>", GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + 0);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else if (action == 4)
+                    {
+                        subMenu = true;
+                        //Send list of available enchants on OH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_5; ++i)
+                        {
+                            uint32 possibleEnchant = GetAIMiscValue(i);
+                            if (uint32 possibleEcnhantMaxRank = GetSpell(possibleEnchant))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possibleEcnhantMaxRank);
+                                uint32 curOHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH);
+                                bool same = possibleEnchant == curOHId;
+                                player->ADD_GOSSIP_ITEM(same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, availableInfo->SpellName[0], GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + possibleEnchant);
+                            }
+                        }
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Auto>", GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + 0);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+
+                    break;
+                }
+                case BOT_CLASS_WARLOCK:
+                {
+                    if (IsCasting())
+                    {
+                        player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, NULL);
+                        break;
+                    }
+
+                    if (GetAIMiscValue(6201) == 0)
+                    {
+                        BotWhisper("I don't have a healthstone", player);
+                        break;
+                    }
+
+                    //Prevent high-leveled healthstone for low-level characters
+                    Unit* checker;
+                    if (player->getLevel() < me->getLevel())
+                        checker = player;
+                    else
+                        checker = me;
+
+                    static uint32 HealthStones[8] = { 19005,19007,19009,19011,19013,22105,36891,36894 };
+                    uint32 spellId = InitSpell(me, 6201); //Create Healthstone Rank 1
+                    SpellInfo const* spellInfo = spellId ? sSpellMgr->GetSpellInfo(spellId) : NULL;
+                    if (!spellInfo)
+                    {
+                        BotWhisper("I can't create healthstones yet!", player);
+                        break;
+                    }
+
+                    uint8 i = spellInfo->GetRank() - 1;
+                    for (; i != 0; --i)
+                        if (ItemTemplate const* stone = sObjectMgr->GetItemTemplate(HealthStones[i]))
+                            if (stone->RequiredLevel <= checker->getLevel())
+                                break;
+
+                    //at least rank 1 (even if player is level 1)
+                    ItemPosCountVec dest;
+                    InventoryResult msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, HealthStones[i], 1);
+                    if (msg != EQUIP_ERR_OK)
+                    {
+                        player->SendEquipError(msg, NULL, NULL, HealthStones[i]);
+                        break;
+                    }
+                    Item* item = player->StoreNewItem(dest, HealthStones[i], true, 0);
+                    if (!item)
+                    {
+                        player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+                        break;
+                    }
+
+                    //remove healthstone
+                    SetAIMiscValue(6201, 0);
+
+                    //unsafe possible
+                    player->SetUInt32Value(ITEM_FIELD_CREATOR, me->GetGUIDLow());
+
+                    player->SendNewItem(item, 1, true, false, true);
+                    break;
+                }
+                case BOT_CLASS_DRUID:
+                {
+                    if (IsCasting())
+                    {
+                        player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, NULL);
+                        break;
+                    }
+                    if (me->GetShapeshiftForm() == FORM_NONE)
+                    {
+                        BotWhisper("I am not shapeshifted", player);
+                        break;
+                    }
+
+                    removeShapeshiftForm();
+                    break;
+                }
+
+                default:
+                    break;
+            }
+            break;
+        }
+        case GOSSIP_SENDER_CLASS_ACTION:
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    if (!IsCasting())
+                    {
+                        // Pick Lock
+                        uint32 picklock = InitSpell(me, 1804);
+                        if (!picklock)
+                        {
+                            BotWhisper("WTF I don't have lockpicking!", player);
+                            break;
+                        }
+
+                        SpellInfo const* Info = sSpellMgr->GetSpellInfo(picklock);
+                        Spell* lockpickspell = new Spell(player, Info, TRIGGERED_NONE, me->GetGUID());
+                        SpellCastTargets targets;
+
+                        if (action == GOSSIP_ACTION_INFO_DEF + 1)
+                        {
+                            //1 Nearest gameobject
+                            GameObject* obj = NULL;
+                            NearestLockedGameObjectInRangeCheck check(player, 4.f);
+                            Trinity::GameObjectLastSearcher<NearestLockedGameObjectInRangeCheck> searcher(player, obj, check);
+                            player->VisitNearbyGridObject(4.f, searcher);
+                            if (obj)
+                            {
+                                targets.SetGOTarget(obj);
+                                lockpickspell->m_targets.SetGOTarget(obj); //for checkCast only
+                            }
+                        }
+                        else
+                        {
+                            //2 Inventory
+                            Item* item = NULL;
+                            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+                            bool found = false;
+                            //backpack
+                            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                            {
+                                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                                if (item && item->GetGUIDLow() == guidLow)
+                                {
+                                    targets.SetItemTarget(item);
+                                    lockpickspell->m_targets.SetItemTarget(item); //for checkCast only
+                                    found = true;
+                                    break;
+                                }
+                            }
+                            //bags
+                            if (!found)
+                            {
+                                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                                {
+                                    if (Bag const* bag = player->GetBagByPos(i))
+                                    {
+                                        for (uint32 j = 0; j != bag->GetBagSize(); j++)
+                                        {
+                                            item = player->GetItemByPos(i, j);
+                                            if (item && item->GetGUIDLow() == guidLow)
+                                            {
+                                                targets.SetItemTarget(item);
+                                                lockpickspell->m_targets.SetItemTarget(item); //for checkCast only
+                                                found = true;
+                                                break;
+                                            }
+                                        }
+                                    }
+
+                                    if (found)
+                                        break;
+                                }
+                            }
+                        }
+
+                        SpellCastResult result = me->IsMounted() || CCed(me) ? SPELL_FAILED_CUSTOM_ERROR : lockpickspell->CheckCast(false);
+                        if (result != SPELL_CAST_OK)
+                        {
+                            lockpickspell->finish(false);
+                            delete lockpickspell;
+                            if (result == SPELL_FAILED_LOW_CASTLEVEL)
+                                BotWhisper("My skill level in not high enough", player);
+                            else
+                                BotWhisper("Failed", player);
+                        }
+                        else
+                        {
+                            lockpickspell->prepare(&targets);
+                            //BotWhisper("Here...", player);
+                        }
+                    }
+                    return OnGossipSelect(player, creature, GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    //break;
+                }
+                default:
+                    break;
+            }
+            break;
+        }
+        case GOSSIP_SENDER_CLASS_ACTION2: //set cur MH enchant
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH, baseId);
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH, baseId);
+                    break;
+                }
+            }
+
+            return OnGossipHello(player, creature, 0);
+        }
+        case GOSSIP_SENDER_CLASS_ACTION3: //set cur OH enchant
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH, baseId);
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH, baseId);
+                    break;
+                }
+            }
+
+            return OnGossipHello(player, creature, 0);
+        }
+        case GOSSIP_SENDER_EQUIPMENT: //equips change s1: send what slots we can use
+        {
+            subMenu = true;
+
+            //general
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Show me your inventory", GOSSIP_SENDER_EQUIPMENT_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //auto-equip
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Auto-equip...", GOSSIP_SENDER_EQUIP_AUTOEQUIP, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //weapons
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Main hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_MAINHAND);
+            if (_canUseOffHand())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Off-hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_OFFHAND);
+            if (_canUseRanged())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Ranged...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_RANGED);
+            else
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Relic...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_RANGED);
+
+            //armor
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Head...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HEAD);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Shoulders...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_SHOULDERS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Chest...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_CHEST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Waist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WAIST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Legs...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_LEGS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Feet...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FEET);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Wrist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WRIST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Hands...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HANDS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BACK);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Shirt...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BODY);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Finger1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Finger2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Trinket1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Trinket2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Neck...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_NECK);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Unequip all", GOSSIP_SENDER_UNEQUIP_ALL, GOSSIP_ACTION_INFO_DEF + 1);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_LIST: //list inventory
+        {
+            //if (action - GOSSIP_ACTION_INFO_DEF != BOT_SLOT_NONE)
+            //    break;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment list for bot with no equip info!");
+
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                Item const* item = _equips[i];
+                if (!item) continue;
+                std::ostringstream msg;
+                _AddItemLink(player, item, msg/*, false*/);
+                //uncomment if needed
+                //msg << " in slot " << uint32(i) << " (" << _getNameForSlot(i + 1) << ')';
+                if (i <= BOT_SLOT_RANGED && einfo->ItemEntry[i] == item->GetEntry())
+                    msg << " |cffe6cc80|h[!standard item!]|h|r";
+                BotWhisper(msg.str().c_str(), player);
+            }
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_INFO: //request equip item info
+        {
+            //GOSSIP ITEMS RESTRICTED
+            //subMenu = true; //needed for return
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment info for bot with no equip info!");
+
+            uint8 slot = action - GOSSIP_ACTION_INFO_DEF;
+            Item const* item = _equips[slot];
+            ASSERT(item);
+
+            std::ostringstream msg;
+            _AddItemLink(player, item, msg, false);
+
+            if (slot <= BOT_SLOT_RANGED && einfo->ItemEntry[slot] == item->GetEntry())
+                msg << " |cffe6cc80|h[!standard item!]|h|r";
+
+            BotWhisper(msg.str().c_str(), player);
+
+            //break; //no break here - return to menu
+        }
+        case GOSSIP_SENDER_EQUIPMENT_SHOW: //equips change s2: send list of equippable items
+        {
+            subMenu = true;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment show for bot with no equip info!");
+
+            std::set<uint32> itemList, idsList;
+
+            //s2.1: build list
+            //s2.1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                if (Item const* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    bool standard = false;
+                    for (uint8 j = 0; j != MAX_EQUIPMENT_ITEMS; ++j)
+                    {
+                        if (einfo->ItemEntry[j] == pItem->GetEntry())
+                        {
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+                    if (_canEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF, true) &&
+                        /*itemList.find(pItem->GetGUIDLow()) == itemList.end() &&*/
+                        (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                    {
+                        itemList.insert(pItem->GetGUIDLow());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //s2.1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+            {
+                if (Bag const* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                    {
+                        if (Item const* pItem = player->GetItemByPos(i, j))
+                        {
+                            bool standard = false;
+                            for (uint8 k = 0; k != MAX_EQUIPMENT_ITEMS; ++k)
+                            {
+                                if (einfo->ItemEntry[k] == pItem->GetEntry())
+                                {
+                                    standard = true;
+                                    break;
+                                }
+                            }
+                            if (standard)
+                                continue;
+                            if (_canEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF, true) &&
+                                /*itemList.find(pItem->GetGUIDLow()) == itemList.end() &&*/
+                                (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                            {
+                                itemList.insert(pItem->GetGUIDLow());
+                                idsList.insert(pItem->GetEntry());
+                            }
+                        }
+                    }
+                }
+            }
+
+            //s2.2: add gossips
+
+            //s2.2.0 add current item (with return)
+            uint8 slot = action - GOSSIP_ACTION_INFO_DEF;
+            std::ostringstream str;
+            str << "Equipped: ";
+            if (Item const* item = _equips[slot])
+            {
+                _AddItemLink(player, item, str);
+                if (slot <= BOT_SLOT_RANGED && einfo->ItemEntry[slot] == item->GetEntry())
+                    str << " |cffe6cc80|h[!standard item!]|h|r";
+
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_INFO, action);
+            }
+            else
+            {
+                str << "nothing";
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_SHOW, action);
+            }
+
+            if (_equips[slot])
+            {
+                //s2.2.1 add unequip option if have weapon (GMs only)
+                if (slot <= BOT_SLOT_RANGED)
+                {
+                    if (einfo->ItemEntry[slot] != 0)
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Use your old equipment", GOSSIP_SENDER_EQUIP_RESET, action);
+                    else
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Unequip it", GOSSIP_SENDER_UNEQUIP, action);
+                }
+
+                //s2.2.2 add unequip option for non-weapons
+                if (slot > BOT_SLOT_RANGED)
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Unequip it", GOSSIP_SENDER_UNEQUIP, action);
+            }
+
+            //s2.2.3a: add an empty submenu with info if no items are found
+            if (itemList.empty())
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Hm... I have nothing to give you", 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                uint32 counter = 0;
+                uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 4; //unequip, reset, current, back
+                uint32 slot = action - GOSSIP_ACTION_INFO_DEF;
+                Item const* item;
+                //s2.2.3b: add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    bool found = false;
+                    for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUIDLow() == (*itr))
+                        {
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + slot, GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                    {
+                        if (Bag const* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUIDLow() == (*itr))
+                                {
+                                    std::ostringstream name;
+                                    _AddItemLink(player, item, name);
+                                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + slot, GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                                    ++counter;
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+
+                    if (found)
+                        continue;
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+
+            //TC_LOG_ERROR("entities.player", "OnGossipSelect(bot): added %u item(s) to list of %s (requester: %s)",
+            //    counter, me->GetName().c_str(), player->GetName().c_str());
+
+            break;
+        }
+        case GOSSIP_SENDER_UNEQUIP: //equips change s3: Unequip DEPRECATED
+        {
+            if (!_unequip(action - GOSSIP_ACTION_INFO_DEF))
+                BotWhisper("Impossible...", player);
+            break;
+        }
+        case GOSSIP_SENDER_UNEQUIP_ALL:
+        {
+            bool suc = true;
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (!(i <= BOT_SLOT_RANGED ? _resetEquipment(i) : _unequip(i)))
+                {
+                    suc = false;
+                    std::ostringstream estr;
+                    estr << "Cannot reset equipment in slot " << uint32(i) << " (" << _getNameForSlot(i) << ")!";
+                    BotWhisper(estr.str().c_str(), player);
+                }
+            }
+
+            if (suc)
+                me->HandleEmoteCommand(EMOTE_ONESHOT_CRY);
+
+            break;
+        }
+        //autoequips change s5b: AtoEquip item
+        //base is GOSSIP_SENDER_EQUIP_AUTOEQUIP + 0...1...2... etc.
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_MHAND:     //0 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_OHAND:     //1 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_RANGED:    //2 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_HEAD:      //3 - 1 head
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_SHOULDERS: //4 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_CHEST:     //5 - 1 chest
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_WAIST:     //6 - 1 waist
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_LEGS:      //7 - 1 legs
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FEET:      //8 - 1 feet
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_WRIST:     //9 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_HANDS:     //10 - 1 hands
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_BACK:      //11 - 1 back
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_BODY:      //12 - 1 body
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER1:   //13 - 1 finger
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER2:   //14 - 2 finger
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET1:  //15 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET2:  //16 - 2 trinket
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_NECK:      //17 - 1 neck
+        {
+            Item* item = NULL;
+            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+            bool found = false;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (item && item->GetGUIDLow() == guidLow)
+                {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found)
+            {
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                {
+                    if (Bag const* pBag = player->GetBagByPos(i))
+                    {
+                        for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                        {
+                            item = player->GetItemByPos(i, j);
+                            if (item && item->GetGUIDLow() == guidLow)
+                            {
+                                found = true;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (found)
+                        break;
+                }
+            }
+
+            if (found && _equip(sender - GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP, item)){}
+
+            //break; //no break: update list
+        }
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP:
+        {
+            subMenu = true;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send auto-equip for bot with no equip info!");
+
+            std::set<uint32> itemList, idsList;
+
+            //1: build list
+            //1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                if (Item const* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    bool standard = false;
+                    for (uint8 j = 0; j != MAX_EQUIPMENT_ITEMS; ++j)
+                    {
+                        if (einfo->ItemEntry[j] == pItem->GetEntry())
+                        {
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+
+                    bool canEquip = false;
+
+                    for (uint8 k = BOT_SLOT_MAINHAND; k != BOT_INVENTORY_SIZE; ++k)
+                    {
+                        if (_canEquip(pItem->GetTemplate(), k))
+                        {
+                            canEquip = true;
+                            break;
+                        }
+                    }
+
+                    if (canEquip &&/* itemList.find(pItem->GetGUIDLow()) == itemList.end() &&*/
+                        (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                    {
+                        itemList.insert(pItem->GetGUIDLow());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+            {
+                if (Bag const* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                    {
+                        if (Item const* pItem = player->GetItemByPos(i, j))
+                        {
+                            bool standard = false;
+                            for (uint8 k = 0; k != MAX_EQUIPMENT_ITEMS; ++k)
+                            {
+                                if (einfo->ItemEntry[k] == pItem->GetEntry())
+                                {
+                                    standard = true;
+                                    break;
+                                }
+                            }
+                            if (standard)
+                                continue;
+
+                            bool canEquip = false;
+
+                            for (uint8 k = BOT_SLOT_MAINHAND; k != BOT_INVENTORY_SIZE; ++k)
+                            {
+                                if (_canEquip(pItem->GetTemplate(), k))
+                                {
+                                    canEquip = true;
+                                    break;
+                                }
+                            }
+
+                            if (canEquip &&/* itemList.find(pItem->GetGUIDLow()) == itemList.end() &&*/
+                                (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                            {
+                                itemList.insert(pItem->GetGUIDLow());
+                                idsList.insert(pItem->GetEntry());
+                            }
+                        }
+                    }
+                }
+            }
+
+            //2: add gossips
+
+            if (itemList.empty())
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Hm... I have nothing to give you", 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                uint32 counter = 0;
+                uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 1; // back
+                Item const* item;
+                //add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    bool found = false;
+                    for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUIDLow() == (*itr))
+                        {
+                            uint8 k = 0;
+                            for (; k != BOT_INVENTORY_SIZE; ++k)
+                            {
+                                if (_canEquip(item->GetTemplate(), k))
+                                {
+                                    //workaround for double slots
+                                    //if first slot is occupied and second slot is vacant use second slot
+                                    if (k == BOT_SLOT_FINGER1 || k == BOT_SLOT_TRINKET1)
+                                        if (_equips[k] != NULL && _canEquip(item->GetTemplate(), k + 1))
+                                            ++k;
+                                    break;
+                                }
+                            }
+
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP + k, GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                    {
+                        if (Bag const* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUIDLow() == (*itr))
+                                {
+                                    uint8 k = 0;
+                                    for (; k != BOT_INVENTORY_SIZE; ++k)
+                                    {
+                                        if (_canEquip(item->GetTemplate(), k))
+                                        {
+                                            //workaround for double slots
+                                            //if first slot is occupied and second slot is vacant use second slot
+                                            if (k == BOT_SLOT_FINGER1 || k == BOT_SLOT_TRINKET1)
+                                                if (_equips[k] != NULL && _canEquip(item->GetTemplate(), k + 1))
+                                                    ++k;
+                                            break;
+                                        }
+                                    }
+
+                                    std::ostringstream name;
+                                    _AddItemLink(player, item, name);
+                                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP + k, GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                                    ++counter;
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+
+                    if (found)
+                        continue;
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_EQUIP_RESET: //equips change s4a: reset equipment
+        {
+            if (_resetEquipment(action - GOSSIP_ACTION_INFO_DEF)){}
+            break;
+        }
+        //equips change s4b: Equip item
+        //base is GOSSIP_SENDER_EQUIP + 0...1...2... etc.
+        case GOSSIP_SENDER_EQUIP_MHAND:     //0 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_OHAND:     //1 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_RANGED:    //2 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_HEAD:      //3 - 1 head
+        case GOSSIP_SENDER_EQUIP_SHOULDERS: //4 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_CHEST:     //5 - 1 chest
+        case GOSSIP_SENDER_EQUIP_WAIST:     //6 - 1 waist
+        case GOSSIP_SENDER_EQUIP_LEGS:      //7 - 1 legs
+        case GOSSIP_SENDER_EQUIP_FEET:      //8 - 1 feet
+        case GOSSIP_SENDER_EQUIP_WRIST:     //9 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_HANDS:     //10 - 1 hands
+        case GOSSIP_SENDER_EQUIP_BACK:      //11 - 1 back
+        case GOSSIP_SENDER_EQUIP_BODY:      //12 - 1 body
+        case GOSSIP_SENDER_EQUIP_FINGER1:   //13 - 1 finger
+        case GOSSIP_SENDER_EQUIP_FINGER2:   //14 - 1 finger
+        case GOSSIP_SENDER_EQUIP_TRINKET1:  //15 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_TRINKET2:  //16 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_NECK:      //17 - 1 neck
+        {
+            Item* item = NULL;
+            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+            bool found = false;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (item && item->GetGUIDLow() == guidLow)
+                {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found)
+            {
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                {
+                    if (Bag const* pBag = player->GetBagByPos(i))
+                    {
+                        for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                        {
+                            item = player->GetItemByPos(i, j);
+                            if (item && item->GetGUIDLow() == guidLow)
+                            {
+                                found = true;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (found)
+                        break;
+                }
+            }
+
+            if (found && _equip(sender - GOSSIP_SENDER_EQUIP, item)){}
+            break;
+        }
+        case GOSSIP_SENDER_ROLES_MAIN_TOGGLE: //ROLES 2: set/unset
+        {
+            ToggleRole(action - GOSSIP_ACTION_INFO_DEF, false);
+
+            //break;
+        }
+        case GOSSIP_SENDER_ROLES_MAIN: //ROLES 1: list
+        {
+            subMenu = true;
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Gathering...", GOSSIP_SENDER_ROLES_GATHERING, GOSSIP_ACTION_INFO_DEF + 1);
+
+            uint16 role = BOT_ROLE_TANK;
+            for (; role != BOT_MAX_ROLE; role <<= 1)
+            {
+                if (!(role & BOT_ROLE_MASK_MAIN)) //hidden
+                    continue;
+                if (role == BOT_ROLE_HEAL && !CanHeal())
+                    continue;
+
+                player->ADD_GOSSIP_ITEM(_onOffIcon(role), GetRoleString(role), GOSSIP_SENDER_ROLES_MAIN_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ROLES_GATHERING_TOGGLE:
+        {
+            ToggleRole(action - GOSSIP_ACTION_INFO_DEF, false);
+
+            //break;
+        }
+        case GOSSIP_SENDER_ROLES_GATHERING:
+        {
+            subMenu = true;
+
+            uint16 role = BOT_ROLE_GATHERING_MINING;
+            for (; role != BOT_MAX_ROLE; role <<= 1)
+            {
+                if (!(role & BOT_ROLE_MASK_GATHERING)) //hidden
+                    continue;
+
+                player->ADD_GOSSIP_ITEM(_onOffIcon(role), GetRoleString(role), GOSSIP_SENDER_ROLES_GATHERING_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_ROLES_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_USE:
+        {
+            if (uint32 basespell = action - GOSSIP_ACTION_INFO_DEF)
+                //if (CheckBotCast(me, basespell, me->GetBotClass()) == SPELL_CAST_OK)
+                    if (IsSpellReady(basespell, lastdiff, true))
+                        doCast(player, GetSpell(basespell));
+
+            //break;
+            action = GOSSIP_ACTION_INFO_DEF;
+        }
+        case GOSSIP_SENDER_ABILITIES:
+        {
+            subMenu = true;
+
+            if (HasAbilitiesSpecifics())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Abilities status...", GOSSIP_SENDER_ABILITIES_SPECIFICS_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+            if (HasAblitiesAllowedList())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage allowed abilities...", GOSSIP_SENDER_ABILITIES_USAGE_LIST, GOSSIP_ACTION_INFO_DEF + 2);
+
+            uint32 basespell;
+            SpellInfo const* spellInfo;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                basespell = itr->first; //always valid
+                if (!CanUseManually(basespell)) continue;
+                if (!IsSpellReady(basespell, lastdiff, false)) continue;
+                spellInfo = sSpellMgr->GetSpellInfo(basespell); //always valid
+
+                std::ostringstream name;
+                name << "Use ";
+                _AddSpellLink(player, spellInfo, name);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, name.str().c_str(), GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF + basespell);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update", sender, action);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 2);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_SPECIFICS_LIST:
+        {
+            subMenu = true;
+
+            std::list<std::string> specList;
+            FillAbilitiesSpecifics(specList);
+            for (std::list<std::string>::const_iterator itr = specList.begin(); itr != specList.end(); ++itr)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, *itr, GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE:
+        {
+            uint32 basespell = action - GOSSIP_ACTION_INFO_DEF;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                if (itr->first == basespell)
+                {
+                    itr->second->enabled = !itr->second->enabled;
+                    break;
+                }
+            }
+        }
+        case GOSSIP_SENDER_ABILITIES_USAGE_LIST:
+        {
+            subMenu = true;
+
+            uint32 counter = 0;
+            uint32 basespell;
+            SpellInfo const* spellInfo;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                basespell = itr->first; //always valid
+                spellInfo = sSpellMgr->GetSpellInfo(basespell); //always valid
+
+                bool skip = false;
+                if (itr->second->spellId == 0) //not init'ed
+                    skip = true;
+                else if (spellInfo->SpellFamilyName == SPELLFAMILY_GENERIC) //not a class spell
+                    skip = true;
+                //spells innate for a class and cannot be disabled
+                else if (basespell == 2457 || basespell == 71 || basespell == 2458)//warrior stances
+                    skip = true;
+
+                if (skip)
+                    continue;
+
+                std::ostringstream name;
+                _AddSpellLink(player, spellInfo, name);
+                //DEBUG
+                //name << " (" << basespell << ") " << itr->second->spellId;
+                uint8 icon = itr->second->enabled ? BOT_ICON_ON : BOT_ICON_OFF;
+                player->ADD_GOSSIP_ITEM(icon, name.str().c_str(), GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE, GOSSIP_ACTION_INFO_DEF + basespell);
+                if (++counter >= BOT_GOSSIP_MAX_ITEMS - 1) //back
+                    break;
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_USEITEM_USE:
+        {
+            if (uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF)
+            {
+                Item const* item = NULL;
+                bool found = false;
+                for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                {
+                    item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                    if (item && item->GetGUIDLow() == guidLow)
+                    {
+                        found = true;
+                        break;
+                    }
+                }
+
+                if (!found)
+                {
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                    {
+                        if (Bag const* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUIDLow() == guidLow)
+                                {
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+                }
+
+                if (found)
+                {
+                    ItemTemplate const* proto = item->GetTemplate();
+                    if (proto->Spells[0].SpellId == 483 || proto->Spells[0].SpellId == 55884)
+                        break;
+
+                    // cast item spell
+                    SpellCastTargets targets;
+                    targets.SetUnitTarget(me);
+                    _castBotItemUseSpell(item, targets, 0, 0);
+                }
+            }
+
+            //break;
+            action = GOSSIP_ACTION_INFO_DEF;
+        }
+        case GOSSIP_SENDER_USEITEM:
+        {
+            subMenu = true;
+
+            uint32 counter = 0;
+            uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 2; //update, back
+            Item const* item;
+            ItemTemplate const* proto;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                //if (item && item->IsSoulBound()) continue;
+                proto = item ? item->GetTemplate() : NULL;
+                if (proto && proto->Class == ITEM_CLASS_CONSUMABLE &&
+                    (proto->SubClass == ITEM_SUBCLASS_POTION || proto->SubClass == ITEM_SUBCLASS_ELIXIR ||
+                    proto->SubClass == ITEM_SUBCLASS_FLASK || proto->SubClass == ITEM_SUBCLASS_FOOD ||
+                    proto->SubClass == ITEM_SUBCLASS_POTION || proto->SubClass == ITEM_SUBCLASS_CONSUMABLE ||
+                    proto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) &&
+                    (proto->AllowableClass == 0 || (proto->AllowableClass & (1<<GetPlayerClass()))) &&
+                    proto->RequiredSkill == 0 &&
+                    proto->RequiredSpell == 0 &&
+                    me->getLevel() >= proto->RequiredLevel)
+                {
+                    std::ostringstream name;
+                    _AddItemLink(player, item, name);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_USEITEM_USE, GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                    ++counter; //no need to check max counter here
+                }
+            }
+
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+            {
+                if (Bag const* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize() && counter < maxcounter; j++)
+                    {
+                        item = player->GetItemByPos(i, j);
+                        //if (item && item->IsSoulBound()) continue;
+                        proto = item ? item->GetTemplate() : NULL;
+                        if (proto && proto->Class == ITEM_CLASS_CONSUMABLE &&
+                            //proto->Spells[0].SpellCategory != SPELL_CATEGORY_FOOD && proto->Spells[0].SpellCategory != SPELL_CATEGORY_DRINK
+                            (proto->SubClass == ITEM_SUBCLASS_POTION || proto->SubClass == ITEM_SUBCLASS_ELIXIR ||
+                            proto->SubClass == ITEM_SUBCLASS_FLASK || proto->SubClass == ITEM_SUBCLASS_FOOD ||
+                            proto->SubClass == ITEM_SUBCLASS_POTION || proto->SubClass == ITEM_SUBCLASS_CONSUMABLE ||
+                            proto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) &&
+                            (proto->AllowableClass == 0 || (proto->AllowableClass & (1<<GetPlayerClass()))) &&
+                            proto->RequiredSkill == 0 &&
+                            proto->RequiredSpell == 0 &&
+                            me->getLevel() >= proto->RequiredLevel)
+                        {
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_USEITEM_USE, GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                            ++counter;
+                        }
+                    }
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update", sender, action);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_HIRE:
+        {
+            int32 reason = action - GOSSIP_ACTION_INFO_DEF;
+            if (!reason)
+            {
+                if (_ownerGuid)
+                {
+                    std::ostringstream ostr;
+                    std::string name;
+                    ostr << "Go away. I serve my master ";
+                    if (sObjectMgr->GetPlayerNameByGUID(MAKE_NEW_GUID(_ownerGuid, 0, HIGHGUID_PLAYER), name))
+                        ostr << name;
+                    else
+                        ostr << "unknown (" << _ownerGuid << ')';
+                    BotWhisper(ostr.str().c_str(), player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s will not join you until owner dismisses %s", me->GetName().c_str(), (me->getGender() == GENDER_MALE ? "him" : "her"));
+                    break;
+                }
+
+                if (_botclass == BOT_CLASS_DEATH_KNIGHT && player->getLevel() < 55)
+                {
+                    BotWhisper("Go away, weakling", player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s will not join you until you are level 55", me->GetName().c_str());
+                    break;
+                }
+
+                if (SetBotOwner(player))
+                    BotWhisper("I am ready", player);
+                else
+                    BotSay("...", player);
+            }
+            else if (reason == -1)
+            {
+                me->setFaction(14);
+                if (Creature* pet = me->GetBotsPet())
+                    pet->setFaction(14);
+                BotYell("Die!", player);
+                me->Attack(player, true);
+                break;
+            }
+            else
+            {
+                ChatHandler ch(player->GetSession());
+                switch (reason)
+                {
+                    case 1: //has owner
+                    {
+                        std::ostringstream ostr;
+                        std::string name;
+                        ostr << "Go away. I serve my master ";
+                        if (sObjectMgr->GetPlayerNameByGUID(MAKE_NEW_GUID(_ownerGuid, 0, HIGHGUID_PLAYER), name))
+                            ostr << name;
+                        else
+                            ostr << "unknown (" << _ownerGuid << ')';
+                        BotWhisper(ostr.str().c_str(), player);
+                        ch.PSendSysMessage("%s will not join you until owner dismisses %s", me->GetName().c_str(), (me->getGender() == GENDER_MALE ? "him" : "her"));
+                        break;
+                    }
+                    case 2: //max npcbots exceed
+                        ch.PSendSysMessage("You exceed max npcbots (%u)", BotMgr::GetMaxNpcBots());
+                        BotSay("...", player);
+                        break;
+                    case 3: //not enough money
+                    {
+                        std::string str = "You don't have enough money (";
+                        str += BotMgr::GetNpcBotCostStr(player->getLevel(), me);
+                        str += ")!";
+                        ch.SendSysMessage(str.c_str());
+                        player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+                        BotSay("...", player);
+                        break;
+                    }
+                    case 4: //class bots exceed
+                    {
+                        uint8 count = 0;
+                        BotMap const* map = player->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                            if (itr->second->GetBotClass() == GetBotClass())
+                                ++count;
+
+                        ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, _maxClassNpcBots);
+                        BotSay("...", player);
+                        break;
+                    }
+                    default:
+                        break;
+                }
+            }
+            break;
+        }
+        case GOSSIP_SENDER_DISMISS:
+        {
+            BotMgr* mgr = player->GetBotMgr();
+            ASSERT(mgr);
+
+            //send items to owner -- Unequip all
+            bool abort = false;
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (!(i <= BOT_SLOT_RANGED ? _resetEquipment(i) : _unequip(i)))
+                {
+                    std::ostringstream estr;
+                    estr << "Cannot reset equipment in slot " << uint32(i) << " (" << _getNameForSlot(i) << ")! Cannot dismiss bot!";
+                    ChatHandler ch(player->GetSession());
+                    ch.SendSysMessage(estr.str().c_str());
+                    abort = true;
+                    break;
+                }
+            }
+
+            if (abort)
+                break;
+
+            mgr->RemoveBot(me->GetGUID(), BOT_REMOVE_DISMISS);
+            if (Aura* bers = me->AddAura(BERSERK, me))
+            {
+                uint32 dur = 5 * MINUTE * IN_MILLISECONDS;
+                bers->SetDuration(dur);
+                bers->SetMaxDuration(dur);
+            }
+            //if (urand(1,100) <= 25)
+            //{
+            //    me->setFaction(14);
+            //    if (Creature* pet = me->GetBotsPet())
+            //        pet->setFaction(14);
+            //    BotSay("Fool...", player);
+            //    me->Attack(player, true);
+            //}
+            //else
+                BotSay("...", player);
+
+            break;
+        }
+        case GOSSIP_SENDER_JOIN_GROUP:
+        {
+            uint32 option = action - GOSSIP_ACTION_INFO_DEF;
+            switch (option)
+            {
+                case 1: //single bot
+                    player->GetBotMgr()->AddBotToGroup(me);
+                    break;
+                case 2: //all bots
+                {
+                    BotMap const* bmap = player->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator citr = bmap->begin(); citr != bmap->end(); ++citr)
+                    {
+                        if (!citr->second)
+                            continue;
+                        player->GetBotMgr()->AddBotToGroup(citr->second);
+                    }
+                    break;
+                }
+            }
+            break;
+        }
+        case GOSSIP_SENDER_LEAVE_GROUP:
+        {
+            player->GetBotMgr()->RemoveBotFromGroup(me, false);
+            break;
+        }
+        case GOSSIP_SENDER_FORMATION:
+        {
+            subMenu = true;
+            std::ostringstream diststr;
+            diststr << "Set distance (current: " << uint32(player->GetBotFollowDist()) << ')';
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, diststr.str(),
+                GOSSIP_SENDER_FORMATION_DISTANCE, GOSSIP_ACTION_INFO_DEF + 1, "", 0, true);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_TROUBLESHOOTING_AURA:
+        {
+            uint32 spellId = action - GOSSIP_ACTION_INFO_DEF;
+            Unit::AuraMap const& auras = me->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+            {
+                if (itr->first != spellId)
+                    continue;
+
+                SpellInfo const* info = itr->second->GetSpellInfo();
+                if (info->IsChanneled())
+                    if (Spell const* curSpell = me->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+                        if (curSpell->m_spellInfo->Id == spellId)
+                            me->InterruptSpell(CURRENT_CHANNELED_SPELL);
+
+                //Debug
+                //std::ostringstream msg;
+                //msg << "Removing ";
+                //_AddSpellLink(player, info, msg);
+                //msg << " by ";
+                //uint64 casterGuid = itr->second->GetCasterGUID();
+                //Unit* caster = casterGuid ? sObjectAccessor->FindUnit(casterGuid) : NULL;
+                //if (caster)
+                //{
+                //    if (casterGuid == me->GetGUID())
+                //        msg << "me";
+                //    else
+                //        msg << caster->GetName();
+                //}
+                //else
+                //    msg << "Unknown unit";
+                //BotWhisper(msg.str().c_str());
+
+                me->RemoveOwnedAura(spellId, 0, 0, AURA_REMOVE_BY_CANCEL);
+                break;
+            }
+
+            //break;
+            action = GOSSIP_ACTION_INFO_DEF + 2; //return to the list and update
+        }
+        case GOSSIP_SENDER_TROUBLESHOOTING_FIX:
+        {
+            uint32 option = action - GOSSIP_ACTION_INFO_DEF;
+            switch (option)
+            {
+                //MOVED TO RECEIVEEMOTE
+                //case 1: //Bot is not mounting, not following while player is mounted
+                //{
+                //    //Reason: creature can sometimes retain UNIT_FLAG_X and UNIT_STATE_X
+                //    //rare occasion, even for bots, you can still talk to them so yeah, stange
+                //    if (me->HasUnitState(UNIT_STATE_STUNNED) && !me->HasAuraType(SPELL_AURA_MOD_STUN))
+                //    {
+                //        me->ClearUnitState(UNIT_STATE_STUNNED);
+                //        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+                //    }
+                //    if (me->HasUnitState(UNIT_STATE_CONFUSED) && !me->HasAuraType(SPELL_AURA_MOD_CONFUSE))
+                //    {
+                //        me->ClearUnitState(UNIT_STATE_CONFUSED);
+                //        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED);
+                //    }
+                //    break;
+                //}
+                case 2: //Remove a visible buff
+                {
+                    subMenu = true;
+                    uint32 count = 0;
+                    Unit::AuraMap const& auras = me->GetOwnedAuras();
+                    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                    {
+                        SpellInfo const* info = itr->second->GetSpellInfo();
+                        //spells we cannot remove
+                        //1 passive, negative spells, hidden, locked, shapeshift spells (no hook for that)
+                        if (info->IsPassive() || !info->IsPositive())
+                            continue;
+                        if ((info->Attributes & (SPELL_ATTR0_CANT_CANCEL | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) ||
+                            (info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR))
+                            continue;
+                        if (info->HasAura(SPELL_AURA_MOD_SHAPESHIFT))
+                            continue;
+                        //2 custom list
+                        //2.1 Leader of the Pack AOE (supposed to be passive)
+                        if (info->Id == 24932)
+                            continue;
+                        //2.2 Tree of Life AOE (supposed to be passive)
+                        if (info->Id == 34123)
+                            continue;
+                        //2.3 Moonkin Aura AOE (supposed to be passive)
+                        if (info->Id == 24907)
+                            continue;
+
+                        std::ostringstream msg;
+                        _AddSpellLink(player, info, msg);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, msg.str().c_str(), GOSSIP_SENDER_TROUBLESHOOTING_AURA, GOSSIP_ACTION_INFO_DEF + itr->first);
+
+                        if (++count >= BOT_GOSSIP_MAX_ITEMS - 2) //update, back
+                            break;
+                    }
+
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update", sender, action);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    break;
+                }
+                default:
+                    BotWhisper("Unknown action in GOSSIP_SENDER_TROUBLESHOOTING_FIX", player);
+                    break;
+            }
+            break;
+        }
+        case GOSSIP_SENDER_TROUBLESHOOTING:
+        {
+            subMenu = true;
+            //player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Fix not mounting/following", GOSSIP_SENDER_TROUBLESHOOTING_FIX, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Remove buff...", GOSSIP_SENDER_TROUBLESHOOTING_FIX, GOSSIP_ACTION_INFO_DEF + 2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 3);
+            break;
+        }
+        case GOSSIP_SENDER_DEBUG_ACTION:
+        {
+            //!!! player != owner !!!
+            bool close = true;
+            switch (action - GOSSIP_ACTION_INFO_DEF)
+            {
+                case 1: //reset owner
+                    if (!IAmFree())
+                        master->GetBotMgr()->RemoveBot(me->GetGUID(), BOT_REMOVE_DISMISS);
+                    else
+                    {
+                        uint32 newOwner = 0;
+                        BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_OWNER, &newOwner);
+                        ResetBotAI(BOTAI_RESET_DISMISS);
+                    }
+                    break;
+                case 2: //reset stats
+                    spawned = false;
+                    DefaultInit();
+                    break;
+                case 3: //list stats
+                    close = false;
+                    ReceiveEmote(player, TEXT_EMOTE_BONK);
+                    break;
+                case 4: //list roles
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s's Roles:", me->GetName().c_str());
+                    for (uint16 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+                    {
+                        if (_roleMask & i)
+                        {
+                            switch (i)
+                            {
+                                case BOT_ROLE_TANK:
+                                    ch.SendSysMessage("BOT_ROLE_TANK");
+                                    break;
+                                case BOT_ROLE_DPS:
+                                    ch.SendSysMessage("BOT_ROLE_DPS");
+                                    break;
+                                case BOT_ROLE_HEAL:
+                                    ch.SendSysMessage("BOT_ROLE_HEAL");
+                                    break;
+                                //case BOT_ROLE_MELEE:
+                                //    ch.SendSysMessage("BOT_ROLE_MELEE");
+                                //    break;
+                                case BOT_ROLE_RANGED:
+                                    ch.SendSysMessage("BOT_ROLE_RANGED");
+                                    break;
+                                case BOT_ROLE_PARTY:
+                                    ch.SendSysMessage("BOT_ROLE_PARTY");
+                                    break;
+                                default:
+                                    ch.PSendSysMessage("BOT_ROLE_%u",i);
+                                    break;
+                            }
+                        }
+                    }
+                    break;
+                }
+                case 5: //list spells
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s's Spells:", me->GetName().c_str());
+                    uint32 counter = 0;
+                    SpellInfo const* spellInfo;
+                    BotSpellMap const& myspells = GetSpellMap();
+                    for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+                    {
+                        //if (itr->second->spellId == 0)
+                        //    continue;
+
+                        ++counter;
+                        std::ostringstream sstr;
+                        spellInfo = sSpellMgr->GetSpellInfo(itr->first); //always valid
+                        _AddSpellLink(player, spellInfo, sstr);
+                        sstr << " id: " <<  itr->second->spellId << ", base: " << itr->first
+                            << ", cd: " << itr->second->cooldown << ", base: " << std::max<uint32>(spellInfo->RecoveryTime, spellInfo->CategoryRecoveryTime);
+                        if (itr->second->enabled == false)
+                            sstr << " (disabled)";
+                        ch.PSendSysMessage("%u) %s", counter, sstr.str().c_str());
+                    }
+                    break;
+                }
+                case 6: //reload config
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+
+                    TC_LOG_INFO("misc", "Re-Loading config settings...");
+                    sWorld->LoadConfigSettings(true);
+                    sMapMgr->InitializeVisibilityDistanceInfo();
+                    ch.SendGlobalGMSysMessage("World config settings reloaded.");
+                    BotMgr::ReloadConfig();
+                    ch.SendGlobalGMSysMessage("NpcBot config settings reloaded.");
+
+                    break;
+                }
+                default:
+                    close = false;
+                    break;
+            }
+
+            if (close)
+                break;
+        }
+        case GOSSIP_SENDER_DEBUG:
+        {
+            //!!! player != owner !!!
+            subMenu = true;
+
+            std::ostringstream ostr;
+            std::string name;
+            ostr << "Bot: " << me->GetName()
+                << " (Id: " << me->GetEntry()
+                << ", guidlow: " << me->GetGUIDLow()
+                << ", faction: " << me->getFaction()
+                << "). owner: ";
+            if (_ownerGuid && sObjectMgr->GetPlayerNameByGUID(MAKE_NEW_GUID(_ownerGuid, 0, HIGHGUID_PLAYER), name))
+                ostr << name << " (" << _ownerGuid << ')';
+            else
+                ostr << "none";
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ostr.str().c_str(), GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 0);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Reset Owner>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Reset Stats>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<List Stats>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 3);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<List Roles>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 4);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<List Spells>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 5);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Reload Config>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 6);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+            break;
+        }
+        case GOSSIP_SENDER_SCAN:
+        {
+            //!!! player != owner !!!
+            subMenu = true;
+
+            //ListAbilities(true);
+            switch (_botclass)
+            {
+                case BOT_CLASS_BM:
+                    gossipTextId = GOSSIP_CLASS_BM;
+                    break;
+                default:
+                    break;
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_SCAN_OWNER_ABILITY:
+        {
+            uint32 Id = action - GOSSIP_ACTION_INFO_DEF;
+            SpellInfo const* info = sSpellMgr->GetSpellInfo(Id);
+            ASSERT(info);
+
+            ChatHandler ch(player->GetSession());
+            std::ostringstream smsg1, smsg2;
+            switch (Id)
+            {
+                //Blademaster
+                case SPELL_NETHERWALK:
+                    _AddSpellLink(player, info, smsg1, false);
+                    smsg2 << "    Invisibilty: |cff00ff00" << uint32(100 + (me->getLevel() * 5) / 2) << "|r, speed: +|cff00ff00" << uint32(10 + me->getLevel() / 2) << "|r%, |cff00ff00150|r% normal damage";
+                    ch.SendSysMessage(smsg1.str().c_str());
+                    ch.SendSysMessage("Allows Blademaster to become invisible, and move faster for a set amount of time. When the Blademaster attacks a unit to break invisibility, he will deal bonus damage.");
+                    ch.SendSysMessage(smsg2.str().c_str());
+                    break;
+                case SPELL_MIRROR_IMAGE_BM:
+                    _AddSpellLink(player, info, smsg1, false);
+                    smsg2 << "    |cff00ff00" << GetAIMiscValue(Id) << "|r " << (GetAIMiscValue(Id) == 1 ? "illusion" : "illusions");
+                    ch.SendSysMessage(smsg1.str().c_str());
+                    ch.SendSysMessage("Confuses the enemy by creating illusions of the Blademaster and dispelling all magic from the Blademaster.");
+                    ch.SendSysMessage(smsg2.str().c_str());
+                    break;
+                case SPELL_CRITICAL_STRIKE:
+                    _AddSpellLink(player, info, smsg1, false);
+                    smsg1 << " |cffffff00(Passive)|r";
+                    smsg2 << "    |cff00ff0015|r% chance to deal |cff00ff00" << GetAIMiscValue(Id) << "|r times normal damage";
+                    ch.SendSysMessage(smsg1.str().c_str());
+                    ch.SendSysMessage("Gives a 15% chance that the Blademaster will do more damage on his attacks.");
+                    ch.SendSysMessage(smsg2.str().c_str());
+                    break;
+                //case SPELL_BLADESTORM_BM: TODO:
+                default:
+                    break;
+            }
+
+            //break;
+        }
+        case GOSSIP_SENDER_SCAN_OWNER:
+        {
+            subMenu = true;
+
+            std::ostringstream abmsg1, abmsg2, abmsg3/*, abmsg4*/;
+            switch (_botclass)
+            {
+                case BOT_CLASS_BM:
+                    if (me->getLevel() >= 10)
+                    {
+                        _AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_NETHERWALK), abmsg1);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg1.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_NETHERWALK);
+                    }
+                    if (me->getLevel() >= 20)
+                    {
+                        _AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_MIRROR_IMAGE_BM), abmsg2);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg2.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_MIRROR_IMAGE_BM);
+                    }
+                    if (me->getLevel() >= 10)
+                    {
+                        _AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_CRITICAL_STRIKE), abmsg3);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg3.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_CRITICAL_STRIKE);
+                    }
+                    //TODO:
+                    //_AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_CRITICAL_STRIKE), abmsg4);
+                    //player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg4.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_BLADESTORM_BM);
+                    break;
+                default:
+                    break;
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        default:
+            break;
+    }
+
+    //if we add submenus send them else we should return
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    else
+        player->CLOSE_GOSSIP_MENU();
+
+    return true;
+}
+
+//GossipSelectCode
+bool bot_minion_ai::OnGossipSelectCode(Player* player, Creature* creature/* == me*/, uint32 sender, uint32 action, char const* code)
+{
+    if (!*code)
+        return true;
+
+    if (!BotMgr::IsNpcBotModEnabled() || me->HasUnitState(UNIT_STATE_CASTING) || CCed(me) || IsDuringTeleport())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    uint32 gossipTextId = (player->GetGUIDLow() == _ownerGuid || !IAmFree()) ? GOSSIP_SERVE_MASTER : GOSSIP_NEED_SMTH;
+
+    player->PlayerTalkClass->ClearMenus();
+
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case GOSSIP_SENDER_FORMATION_DISTANCE:
+        {
+            char* dist = strtok((char*)code, "");
+            uint8 distance = std::min<uint8>(uint8(std::max<int32>(atoi(dist), 0)), 100);
+
+            player->GetBotMgr()->SetBotFollowDist(distance);
+
+            player->CLOSE_GOSSIP_MENU();
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_FORMATION, action);
+        }
+        default:
+            break;
+    }
+
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    else
+        player->CLOSE_GOSSIP_MENU();
+    return true;
+}
+//Summons pet for bot
+void bot_minion_ai::SummonBotsPet(uint32 entry)
+{
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet)
+        me->SetBotsPetDied();
+
+    uint8 mylevel = std::min<uint8>(master->getLevel(), 80);
+    uint32 originalentry = bot_pet_ai::GetPetOriginalEntry(entry);
+    if (!originalentry)
+    {
+        //annoy master
+        if (!IAmFree())
+            BotWhisper("Why am I trying to summon unknown pet!?");
+        return;
+    }
+    float x(0),y(0),z(0);
+    me->GetClosePoint(x, y, z, me->GetObjectSize());
+    m_botsPet = me->SummonCreature(entry, x, y, z, 0, TEMPSUMMON_DEAD_DESPAWN);
+
+    if (!m_botsPet)
+    {
+        if (!IAmFree())
+            BotWhisper("Failed to summon pet!");
+        return;
+    }
+
+    //std::string name = sObjectMgr->GeneratePetName(originalentry);//voidwalker
+    //if (!name.empty())
+    //    m_botsPet->SetName(name);
+
+    //TODO: Preloading at server start (like bots themselves
+    //PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS);
+    //stmt->setUInt32(0, originalentry);
+    //stmt->setUInt8(1, mylevel);
+    //PreparedQueryResult result = WorldDatabase.Query(stmt);
+    ////QueryResult result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi, sta, inte, spi FROM `pet_levelstats` WHERE `creature_entry` = '%u' AND `level` = '%u'", originalentry, mylevel);
+
+    //if (result)
+    //{
+    //    Field* fields = result->Fetch();
+    //    uint32 hp = fields[0].GetUInt16();
+    //    uint32 mana = fields[1].GetUInt16();
+    //    //armor = fields[2].GetUInt32();
+    //    uint32 str = fields[3].GetUInt16();
+    //    uint32 agi = fields[4].GetUInt16();
+    //    uint32 sta = fields[5].GetUInt16();
+    //    uint32 inte = fields[6].GetUInt16();
+    //    uint32 spi = fields[7].GetUInt16();
+
+    //    m_botsPet->SetCreateHealth(hp);
+    //    m_botsPet->SetMaxHealth(hp);
+    //    m_botsPet->SetCreateMana(mana);
+    //    m_botsPet->SetMaxPower(POWER_MANA, mana);
+
+    //    m_botsPet->SetCreateStat(STAT_STRENGTH, str);
+    //    m_botsPet->SetCreateStat(STAT_AGILITY, agi);
+    //    m_botsPet->SetCreateStat(STAT_STAMINA, sta);
+    //    m_botsPet->SetCreateStat(STAT_INTELLECT, inte);
+    //    m_botsPet->SetCreateStat(STAT_SPIRIT, spi);
+    //}
+
+    m_botsPet->SetBotOwner(master);
+    m_botsPet->SetCreatureOwner(me);
+    //m_botsPet->SetBotClass(bot_pet_ai::GetPetClass(m_botsPet));
+    //master->SetMinion((Minion*)m_botsPet, true);
+    m_botsPet->SetCreatorGUID(me->GetGUID());
+    //m_botsPet->DeleteThreatList();
+    //m_botsPet->AddUnitTypeMask(UNIT_MASK_MINION);
+    //m_botsPet->SetLevel(master->getLevel());
+    //m_botsPet->AIM_Initialize();
+    //m_botsPet->InitBotAI(true);
+    m_botsPet->setFaction(master->getFaction());
+    //bot_pet_ai* petai = m_botsPet->GetBotPetAI();
+    //petai->SetCreatureOwner(me);
+    //petai->SetBaseArmor(armor);
+    m_botsPet->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    me->SetBotsPet(m_botsPet);
+
+    m_botsPet->SendUpdateToPlayer(master);
+}
+
+//Returns pet type (maybe unneeded)
+uint8 bot_pet_ai::GetPetType(Creature const* pet)
+{
+    switch (pet->GetEntry())
+    {
+        case PET_VOIDWALKER:
+            return PET_TYPE_VOIDWALKER;
+    }
+    return PET_TYPE_NONE;
+}
+//Returns pet's class
+uint8 bot_pet_ai::GetPetClass(Creature const* pet)
+{
+    switch (GetPetType(pet))
+    {
+        case PET_TYPE_IMP:
+            return BOT_CLASS_MAGE;
+        default:
+            return BOT_CLASS_PALADIN;
+    }
+}
+//Return entry used to summon real pets
+uint32 bot_pet_ai::GetPetOriginalEntry(uint32 entry)
+{
+    switch (entry)
+    {
+        case PET_VOIDWALKER:
+            return ORIGINAL_ENTRY_VOIDWALKER;
+        default:
+            return 0;
+    }
+}
+//PvP trinket for minions
+void bot_minion_ai::BreakCC(uint32 diff)
+{
+    if (me->getLevel() >= 60 && IsSpellReady(PVPTRINKET, diff, false) && CCed(me, true) &&
+        (me->GetVictim() || !me->getAttackers().empty()) && Rand() < 20)
+    {
+        if (doCast(me, PVPTRINKET))
+            return;
+    }
+
+    uint8 myrace = me->getRace();
+
+    //Racial 6) Every Man for Himself
+    if (myrace == RACE_HUMAN && IsSpellReady(RACIAL_EVERY_MAN_FOR_HIMSELF, diff, false) && CCed(me, true) &&
+        !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+        (me->IsInCombat() || !me->getAttackers().empty()) && Rand() < 40 && !IsCasting() &&
+        (me->getLevel() < 60 || !IsSpellReady(PVPTRINKET, diff, false)))
+    {
+        if (doCast(me, RACIAL_EVERY_MAN_FOR_HIMSELF))
+            return;
+    }
+    //Racial 5) Forsaken (Will of the Forsaken)
+    if (myrace == RACE_UNDEAD_PLAYER && IsSpellReady(RACIAL_WILL_OF_THE_FORSAKEN, diff, false) &&
+        (me->IsInCombat() || !me->getAttackers().empty()) && CCed(me) &&
+        Rand() < 10 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting() &&
+        (me->getLevel() < 60 || !IsSpellReady(PVPTRINKET, diff, false)) &&
+        me->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+    {
+        if (doCast(me, RACIAL_WILL_OF_THE_FORSAKEN))
+            return;
+    }
+    //Racial 7) Escape Artist
+    if (me->getRace() == RACE_GNOME && IsSpellReady(RACIAL_ESCAPE_ARTIST, diff, false) && CCed(me, true) &&
+        !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+        (me->IsInCombat() || !me->getAttackers().empty()) && Rand() < 40 && !IsCasting() &&
+        (me->getLevel() < 60 || !IsSpellReady(PVPTRINKET, diff, false)) &&
+        me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+    {
+        if (doCast(me, RACIAL_ESCAPE_ARTIST))
+            return;
+    }
+
+}
+//Racial abilities
+void bot_minion_ai::CheckRacials(uint32 diff)
+{
+    //At this point checked CCed and pots
+    uint8 myrace = me->getRace();
+    //Racial 1) Tauren (War Stomp)
+    if (myrace == RACE_TAUREN && IsSpellReady(RACIAL_WARSTOMP, diff, false) &&
+        (!IsTank() || me->GetShapeshiftForm() == FORM_NONE) &&
+        Rand() < 20 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        Unit const* u = me->SelectNearestTarget(7);
+        if (u && u->IsInCombat() && !CCed(u) && u->isTargetableForAttack() && IsInBotParty(u->GetVictim()) && me->IsWithinLOSInMap(u))
+        {
+            if (doCast(me, RACIAL_WARSTOMP))
+                return;
+        }
+    }
+    //Racial 2) Orc (Blood Fury)
+    if (myrace == RACE_ORC)
+    {
+        uint32 bloodFury = RaceSpellForClass(myrace, _botclass);
+        if (IsSpellReady(bloodFury, diff, false) && me->GetVictim() && GetHealthPCT(me) > 35 && !CCed(me, true) &&
+            (me->GetVictim()->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1) &&
+            Rand() < 20 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+        {
+            if (doCast(me, bloodFury))
+                return;
+        }
+    }
+    //Racial 3) Dwarf (Stoneform)
+    if (myrace == RACE_DWARF && IsSpellReady(RACIAL_STONEFORM, diff, false) && GetHealthPCT(me) < 80 &&
+        Rand() < 10 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        //Unholy Blight prevents diseases from being dispelled
+        uint32 const dispelMask = me->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 1494, 0) ?
+            (1<<DISPEL_POISON) : (1<<DISPEL_DISEASE)|(1<<DISPEL_POISON);
+        uint8 count = 0;
+        Unit::AuraMap const& auras = me->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        {
+            Aura const* aura = itr->second;
+
+            if (aura->IsPassive())
+                continue;
+
+            AuraApplication const* aurApp = aura->GetApplicationOfTarget(me->GetGUID());
+            if (!aurApp)
+                continue;
+            if (aurApp->IsPositive())
+                continue;
+
+            if ((aura->GetSpellInfo()->GetDispelMask() & dispelMask) ||
+                aura->GetSpellInfo()->Mechanic == MECHANIC_BLEED)
+                if (++count > 1)
+                    break;
+        }
+
+        if (count > 1 - 1*(me->IsInCombat()) && doCast(me, RACIAL_STONEFORM))
+            return;
+    }
+    //Racial 4) Night Elf (Shadowmeld)
+    if (myrace == RACE_NIGHTELF && IsSpellReady(RACIAL_SHADOWMELD, diff, false) && !me->IsInCombat() && me->GetVictim() &&
+        me->GetVictim()->GetTypeId() == TYPEID_PLAYER && Rand() < 50 &&
+        !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        if (Spell const* spell = me->GetVictim()->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+        {
+            if (spell->m_targets.GetUnitTarget() == me && spell->GetTimer() < 500 &&
+                spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE))
+                if (doCast(me, RACIAL_SHADOWMELD))
+                    return;
+        }
+    }
+    //Racial 8) Troll (Berserking)
+    if (myrace == RACE_TROLL && IsSpellReady(RACIAL_BERSERKING, diff, false) && me->GetVictim() &&
+        GetHealthPCT(me) > 35 && !CCed(me, true) &&
+        (me->GetVictim()->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1) &&
+        Rand() < 20 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        if (doCast(me, RACIAL_BERSERKING))
+            return;
+    }
+    //Racial 9) Blood Elf (Arcane Torrent)
+    if (myrace == RACE_BLOODELF)
+    {
+        uint32 arcaneTorrent = RaceSpellForClass(myrace, _botclass);
+        if (IsSpellReady(arcaneTorrent, diff, false) && !IsCasting())
+        {
+            Unit const* victim = me->GetVictim();
+            if (victim && victim->IsNonMeleeSpellCasted(false, false, true) &&
+                (me->GetVictim()->GetHealth() > me->GetHealth() / 4 || me->getAttackers().size() > 1) &&
+                me->GetDistance(victim) < 7 && Rand() < 30 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH))
+            {
+                if (Spell const* spell = victim->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (IsInBotParty(spell->m_targets.GetUnitTarget()) && spell->GetTimer() < 1000)
+                        if (doCast(me, arcaneTorrent))
+                            return;
+                }
+            }
+            else if (GetManaPCT(me) < 25)
+                if (doCast(me, arcaneTorrent))
+                    return;
+        }
+    }
+    //Racial 10) Draenei (Gift of The Naaru) - self only
+    if (myrace == RACE_DRAENEI)
+    {
+        uint32 giftOfNaaru = RaceSpellForClass(myrace, _botclass);
+        if (IsSpellReady(giftOfNaaru, diff, false) && (me->IsInCombat() || !me->getAttackers().empty()) &&
+            GetHealthPCT(me) < 60 - 10*me->HasAuraType(SPELL_AURA_PERIODIC_HEAL) &&
+            Rand() < 50 && !IsCasting())
+        {
+            if (doCast(me, giftOfNaaru))
+                return;
+        }
+    }
+}
+//Returns attack range based on given range
+//If mounted: 20%
+//If ranged: 125%
+//If master is dead: max range
+float bot_ai::InitAttackRange(float origRange, bool ranged) const
+{
+    if (me->IsMounted())
+        origRange *= 0.2f;
+    else
+    {
+        if (ranged)
+            origRange *= 1.25f;
+        if (!master->IsAlive())
+            origRange += sWorld->GetMaxVisibleDistanceOnContinents();
+        else if (IAmFree())
+        {
+            origRange =
+                //me->GetMap()->IsBattlegroundOrArena() ? sWorld->GetMaxVisibleDistanceInBGArenas() :
+                //me->GetMap()->Instanceable() ? sWorld->GetMaxVisibleDistanceInInstances() :
+                sWorld->GetMaxVisibleDistanceOnContinents();
+        }
+    }
+    return origRange;
+}
+//Force bots to start attack anyone who tries to DAMAGE me or master
+//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
+void bot_minion_ai::OnOwnerDamagedBy(Unit* attacker)
+{
+    if (me->GetVictim() && (!IAmFree() || me->GetDistance(me->GetVictim()) < me->GetDistance(attacker)))
+        return;
+    //if (InDuel(attacker))
+    //    return;
+
+    bool byspell = false;
+    switch (_botclass)
+    {
+        case BOT_CLASS_DRUID:
+            byspell = GetBotStance() == BOT_STANCE_NONE || GetBotStance() == DRUID_MOONKIN_FORM;
+            break;
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+            byspell = true;
+            break;
+        default:
+            //TC_LOG_ERROR("entities.player", "minion_ai: OnOwnerDamagedBy() - unknown bot class %u", uint8(_botclass));
+            break;
+    }
+    float maxdist = InitAttackRange(float(IAmFree() ? 100 : master->GetBotFollowDist()), HasRole(BOT_ROLE_RANGED)); //use increased range
+    if (!attacker->IsWithinDist(me, maxdist))
+        return;
+    if (!CanBotAttack(attacker, byspell))
+        return;
+
+    m_botCommandState = COMMAND_ABANDON; //reset AttackStart()
+    me->Attack(attacker, !HasRole(BOT_ROLE_RANGED));
+}
+//////////
+//EQUIPS//
+//////////
+bool bot_minion_ai::_canUseOffHand() const
+{
+    //bm can on only equip in main hand
+    if (_botclass == BOT_CLASS_BM)
+        return false;
+
+    //warrior can wield any offhand with titan's grip
+    if (_botclass == BOT_CLASS_WARRIOR && me->getLevel() >= 60)
+        return true;
+
+    ItemTemplate const* protoMH = _equips[BOT_SLOT_MAINHAND] ? _equips[BOT_SLOT_MAINHAND]->GetTemplate() : NULL;
+
+    //no mainhand weapon OR
+    //mainhand is an one-hand weapon
+    if (!protoMH)
+        return true;
+
+    if (protoMH->Class == ITEM_CLASS_WEAPON &&
+        (protoMH->InventoryType == INVTYPE_WEAPON || protoMH->InventoryType == INVTYPE_WEAPONMAINHAND) &&
+        (protoMH->SubClass == ITEM_SUBCLASS_WEAPON_AXE || protoMH->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+        protoMH->SubClass == ITEM_SUBCLASS_WEAPON_FIST || protoMH->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+        protoMH->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
+        return true;
+
+    //NO
+    return false;
+}
+
+bool bot_minion_ai::_canUseRanged() const
+{
+    return (_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+        _botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_PRIEST ||
+        _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK);
+}
+//slot = BotEquipSlot
+bool bot_minion_ai::_canEquip(ItemTemplate const* item, uint8 slot, bool ignoreItemLevel) const
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    if (Item const* oldItem = _equips[slot])
+    {
+        ItemTemplate const* oldProto = oldItem->GetTemplate();
+        //prevent reequipping same items
+        if (item->ItemId == oldProto->ItemId && !oldItem->GetItemRandomPropertyId())
+            return false;
+        //prevent equipping worse items (only standard or not)
+        if (!ignoreItemLevel)
+            if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != oldProto->ItemId)
+                if (IAmFree() || !master->IsGameMaster())
+                    if (oldProto->GetItemLevelIncludingQuality() > item->GetItemLevelIncludingQuality())
+                        return false;
+    }
+
+    if (slot == BOT_SLOT_OFFHAND && !_canUseOffHand())
+        return false;
+
+    //level requirements
+    if (me->getLevel() < item->RequiredLevel)
+        return false;
+
+    //class requirements
+    if (!(item->AllowableClass & (1<<(GetPlayerClass()-1))))
+        return false;
+
+    //skip race requirements
+
+    if (item->Class == ITEM_CLASS_WEAPON)
+    {
+        switch (slot)
+        {
+            case BOT_SLOT_MAINHAND:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_BM:
+                        if (item->SubClass != ITEM_SUBCLASS_WEAPON_POLEARM &&
+                            item->SubClass != ITEM_SUBCLASS_WEAPON_AXE2 &&
+                            item->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2)
+                            return false;
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            case BOT_SLOT_OFFHAND:
+                if (item->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || item->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_DEATH_KNIGHT:
+                    case BOT_CLASS_ROGUE:
+                        break;
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_HUNTER:
+                        if (me->getLevel() < 20)
+                            return false;
+                        break;
+                    case BOT_CLASS_SHAMAN:
+                        if (me->getLevel() < 40)
+                            return false;
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_SLOT_RANGED:
+                if (!_canUseRanged())
+                    return false;
+                break;
+            default:
+                return false;
+        }
+
+        switch (item->InventoryType)
+        {
+            case INVTYPE_WEAPONMAINHAND:
+                if (slot != BOT_SLOT_MAINHAND)
+                    return false;
+                break;
+            case INVTYPE_WEAPONOFFHAND:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                break;
+            case INVTYPE_2HWEAPON:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_WARRIOR:
+                        switch (slot)
+                        {
+                            case BOT_SLOT_OFFHAND:
+                                if (me->getLevel() < 60)
+                                    return false;
+                                break;
+                            case BOT_SLOT_RANGED:
+                                return false;
+                            default:
+                                break;
+                        }
+                        break;
+                    default:
+                        if (slot != BOT_SLOT_MAINHAND)
+                            return false;
+                        break;
+                }
+                break;
+            case INVTYPE_WEAPON:
+                if (slot != BOT_SLOT_MAINHAND && slot != BOT_SLOT_OFFHAND)
+                    return false;
+                break;
+            case INVTYPE_THROWN:
+            case INVTYPE_RANGED:
+            case INVTYPE_RANGEDRIGHT:
+                if (slot != BOT_SLOT_RANGED)
+                    return false;
+                break;
+            default:
+                return false;
+        }
+
+        switch (_botclass)
+        {
+            case BOT_CLASS_WARRIOR:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                    case ITEM_SUBCLASS_WEAPON_GUN:
+                    case ITEM_SUBCLASS_WEAPON_THROWN:
+                    //case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_PALADIN:
+            case BOT_CLASS_DEATH_KNIGHT:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_HUNTER:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    //case ITEM_SUBCLASS_WEAPON_MACE:
+                    //case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                    case ITEM_SUBCLASS_WEAPON_GUN:
+                    //case ITEM_SUBCLASS_WEAPON_THROWN: //hunters can use thrown but bots can't, also pointless
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_ROGUE:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                    case ITEM_SUBCLASS_WEAPON_GUN:
+                    case ITEM_SUBCLASS_WEAPON_THROWN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_PRIEST:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_MAGE:
+            case BOT_CLASS_WARLOCK:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_DRUID:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_SHAMAN:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_BM:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            default:
+                return false;
+        }
+
+        return true;
+    }
+    else if (item->Class == ITEM_CLASS_ARMOR)
+    {
+        switch (item->InventoryType)
+        {
+            case INVTYPE_HEAD:
+                if (slot != BOT_SLOT_HEAD)
+                    return false;
+                break;
+            case INVTYPE_SHOULDERS:
+                if (slot != BOT_SLOT_SHOULDERS)
+                    return false;
+                break;
+            case INVTYPE_BODY:
+                if (slot != BOT_SLOT_BODY)
+                    return false;
+                break;
+            case INVTYPE_CHEST:
+            case INVTYPE_ROBE:
+                if (slot != BOT_SLOT_CHEST)
+                    return false;
+                break;
+            case INVTYPE_WAIST:
+                if (slot != BOT_SLOT_WAIST)
+                    return false;
+                break;
+            case INVTYPE_LEGS:
+                if (slot != BOT_SLOT_LEGS)
+                    return false;
+                break;
+            case INVTYPE_FEET:
+                if (slot != BOT_SLOT_FEET)
+                    return false;
+                break;
+            case INVTYPE_WRISTS:
+                if (slot != BOT_SLOT_WRIST)
+                    return false;
+                break;
+            case INVTYPE_HANDS:
+                if (slot != BOT_SLOT_HANDS)
+                    return false;
+                break;
+            case INVTYPE_FINGER:
+                if (slot != BOT_SLOT_FINGER1 && slot != BOT_SLOT_FINGER2)
+                    return false;
+                break;
+            case INVTYPE_TRINKET:
+                if (slot != BOT_SLOT_TRINKET1 && slot != BOT_SLOT_TRINKET2)
+                    return false;
+                break;
+            case INVTYPE_NECK:
+                if (slot != BOT_SLOT_NECK)
+                    return false;
+                break;
+            case INVTYPE_CLOAK:
+                if (slot != BOT_SLOT_BACK)
+                    return false;
+                break;
+            case INVTYPE_HOLDABLE:
+            case INVTYPE_SHIELD:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                break;
+            case INVTYPE_RELIC:
+                if (slot != BOT_SLOT_RANGED)
+                    return false;
+                break;
+            default:
+                return false;
+        }
+
+        switch (item->SubClass)
+        {
+            case ITEM_SUBCLASS_ARMOR_SHIELD:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_SHAMAN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_PLATE:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_DEATH_KNIGHT:
+                    case BOT_CLASS_BM:
+                        if (me->getLevel() >= 40)
+                            break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_MAIL:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_DEATH_KNIGHT:
+                    case BOT_CLASS_BM:
+                        break;
+                    case BOT_CLASS_SHAMAN:
+                    case BOT_CLASS_HUNTER:
+                        if (me->getLevel() >= 40)
+                            break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_LEATHER:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_DEATH_KNIGHT:
+                    case BOT_CLASS_BM:
+                    case BOT_CLASS_SHAMAN:
+                    case BOT_CLASS_HUNTER:
+                    case BOT_CLASS_ROGUE:
+                    case BOT_CLASS_DRUID:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_CLOTH:
+                break;
+            case ITEM_SUBCLASS_ARMOR_MISC:
+                break;
+            case ITEM_SUBCLASS_ARMOR_LIBRAM:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_PALADIN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_IDOL:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_DRUID:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_TOTEM:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SHAMAN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_SIGIL:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_DEATH_KNIGHT:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            default:
+                return false;
+        }
+
+        return true;
+    }
+
+    return false;
+}
+
+bool bot_minion_ai::_unequip(uint8 slot)
+{
+    ASSERT(!IAmFree());
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to unequip item for bot with no equip info!");
+
+    Item* item = _equips[slot];
+    if (!item)
+        return true; //already unequipped
+
+    uint32 itemId = item->GetEntry();
+
+    //hand old weapon to master
+    if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != itemId)
+    {
+        ItemPosCountVec dest;
+        uint32 no_space = 0;
+        InventoryResult msg = master->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1, &no_space);
+        if (msg != EQUIP_ERR_OK)
+        {
+            std::ostringstream istr, iistr;
+            istr << "Cannot unequip ";
+            _AddItemLink(master, item, iistr, false);
+            istr << iistr.str() << " for some stupid reason! Sending through mail";
+            ChatHandler ch(master->GetSession());
+            ch.SendSysMessage(istr.str().c_str());
+
+            //MailHnadler::HandleSendMail()
+            item->SetOwnerGUID(master->GetGUID());
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            item->SaveToDB(trans);
+            MailDraft(iistr.str(), "").AddItem(item).SendMailTo(trans, MailReceiver(master), MailSender(me));
+            CharacterDatabase.CommitTransaction(trans);
+
+            //master->SendEquipError(msg, NULL, NULL, itemId);
+            //return false;
+        }
+        else
+        {
+            Item* pItem = master->StoreItem(dest, item, true);
+            master->SendNewItem(pItem, 1, true, false, false);
+        }
+    }
+    else
+    {
+        //slot < BOT_SLOT_RANGED && einfo->ItemEntry[slot] == itemId
+        //we have our standard weapon which we should get rid of
+        //item->SetState(ITEM_REMOVED, master); //delete Item object
+        delete item; //!Invalidated!
+        //item = NULL; //already in "_updateEquips(slot, NULL);"
+    }
+
+    //only for non-standard items
+    if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != itemId)
+        RemoveItemBonuses(slot);
+
+    if (slot <= BOT_SLOT_RANGED && CanChangeEquip(slot)) //weapons
+    {
+        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, 0);
+        me->SetAttackTime(WeaponAttackType(slot), 2000); //without weapon
+    }
+
+    _updateEquips(slot, NULL);
+
+    //offhand check
+    if (slot == BOT_SLOT_OFFHAND)
+    {
+        if (me->CanDualWield())
+            me->SetCanDualWield(false);
+        if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+            const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra |= CREATURE_FLAG_EXTRA_NO_BLOCK;
+    }
+
+    return true;
+}
+
+bool bot_minion_ai::_equip(uint8 slot, Item* newItem)
+{
+    ASSERT(!IAmFree());
+
+    if (!newItem)
+        return true; //nothing to equip
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to equip item for bot with no equip info!");
+
+    ItemTemplate const* proto = newItem->GetTemplate();
+
+    if (newItem->GetState() == ITEM_REMOVED)
+    {
+        TC_LOG_ERROR("entities.player",
+            "minion_ai::_equip(): player %s (guidLow: %u) is trying to make bot %s (id: %u) equip item: %s (id: %u, guidLow: %u) which has state ITEM_REMOVED!",
+            master->GetName().c_str(), master->GetGUIDLow(), me->GetName().c_str(), me->GetEntry(), proto->Name1.c_str(), proto->ItemId, newItem->GetGUIDLow());
+        return false;
+    }
+
+    uint32 newItemId = newItem->GetEntry();
+
+    if (Item const* oldItem = _equips[slot])
+    {
+        //same id
+        if (oldItem->GetEntry() == newItemId && !newItem->GetItemRandomPropertyId())
+            return false;
+    }
+
+    if (!_unequip(slot))
+    {
+        BotWhisper("You have no space for my current item", master);
+        return false;
+    }
+
+    if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != newItemId)
+    {
+        //cheating
+        if (newItem->GetOwnerGUID() != master->GetGUID() || !master->HasItemCount(newItemId, 1))
+        {
+            std::ostringstream msg;
+            msg << "Cannot find ";
+            _AddItemLink(master, newItem, msg, false);
+            msg << " (id: " << uint32(newItemId) << ")!";
+            BotWhisper(msg.str().c_str());
+
+            TC_LOG_ERROR("entities.player",
+                "minion_ai::_equip(): player %s (guidLow: %u) is trying to make bot %s (id: %u) equip item: %s (id: %u, guidLow: %u) but either does not have this item or does not own it",
+                master->GetName().c_str(), master->GetGUIDLow(), me->GetName().c_str(), me->GetEntry(), proto->Name1.c_str(), proto->ItemId, newItem->GetGUIDLow());
+            return false;
+        }
+
+        master->MoveItemFromInventory(newItem->GetBagSlot(), newItem->GetSlot(), true);
+        //Item is removed from inventory table in _updateEquips(slot, newItem);
+        newItem->SetOwnerGUID(0); //needed to prevent some logs to be sent to master, restored at unequip
+    }
+
+    if (slot <= BOT_SLOT_RANGED)
+    {
+        if (CanChangeEquip(slot))
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, newItemId);
+        uint32 delay =
+            /*einfo->ItemEntry[slot] != newItemId || */RespectEquipsAttackTime() || slot == BOT_SLOT_OFFHAND ? proto->Delay :
+            slot == BOT_SLOT_RANGED ? me->GetCreatureTemplate()->rangeattacktime : me->GetCreatureTemplate()->baseattacktime;
+        //attack time will be updated in SetStats() -> OnMeleeDamageUpdate()
+        if (!me->IsInFeralForm())
+            me->SetAttackTime(WeaponAttackType(slot), delay); //set attack speed
+    }
+
+    _updateEquips(slot, newItem);
+
+    //only for non-standard items
+    if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != newItemId)
+        ApplyItemBonuses(slot);
+
+    if (slot == BOT_SLOT_OFFHAND)
+    {
+        if (proto->Class == ITEM_CLASS_WEAPON)
+        {
+            if (!me->CanDualWield())
+                me->SetCanDualWield(true);
+        }
+        else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        {
+            if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+        }
+    }
+    else if (slot == BOT_SLOT_MAINHAND && proto->InventoryType == INVTYPE_2HWEAPON && !(_botclass == BOT_CLASS_WARRIOR && me->getLevel() >= 60))
+    {
+        //if have incompatible offhand unequip it
+        if (_equips[BOT_SLOT_OFFHAND] != NULL)
+            _unequip(BOT_SLOT_OFFHAND);
+    }
+
+    //rogue rotation update
+    if (proto->Class == ITEM_CLASS_WEAPON)
+    {
+        if (slot == BOT_SLOT_MAINHAND)
+        {
+            SetAIMiscValue(BOTAI_MISC_DAGGER_MAINHAND, proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER);
+            SetAIMiscValue(BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH, newItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
+        }
+        if (slot == BOT_SLOT_OFFHAND)
+        {
+            SetAIMiscValue(BOTAI_MISC_DAGGER_OFFHAND, proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER);
+            SetAIMiscValue(BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH, newItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
+        }
+    }
+
+    return true;
+}
+
+void bot_minion_ai::_updateEquips(uint8 slot, Item* item)
+{
+    _equips[slot] = item;
+    BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_EQUIPS, _equips);
+}
+//Called from gossip menu only (applies only to weapons)
+bool bot_minion_ai::_resetEquipment(uint8 slot)
+{
+    ASSERT(!IAmFree());
+    ASSERT(slot <= BOT_SLOT_RANGED);
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to reset equipment for bot with no equip info!");
+
+    uint32 itemId = einfo->ItemEntry[slot];
+    if (!itemId)
+        return _unequip(slot);
+    else if (Item const* oldItem = _equips[slot])
+        if (oldItem->GetEntry() == itemId)
+            return true;
+
+    if (slot == BOT_SLOT_MAINHAND && !(_botclass == BOT_CLASS_WARRIOR && me->getLevel() >= 60))
+    {
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+        {
+            if (proto->Class == ITEM_CLASS_WEAPON &&
+                (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2 ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF || proto->SubClass == ITEM_SUBCLASS_WEAPON_SPEAR))
+            {
+                if (!_unequip(BOT_SLOT_OFFHAND))
+                    return false;
+            }
+        }
+    }
+
+    //we have our standard weapon itemId which we should use to create new item
+    Item* stItem = Item::CreateItem(itemId, 1, NULL);
+    ASSERT(stItem && "Failed to create standard Item for bot!");
+
+    if (!_equip(slot, stItem))
+    {
+        TC_LOG_ERROR("entities.player", "minion_ai::_resetEquipment(): player %s (guidLow: %u) failed to reset equipment for bot %s (id: %u) in slot %u",
+                master->GetName().c_str(), master->GetGUIDLow(), me->GetName().c_str(), me->GetEntry(), slot);
+        return false;
+    }
+    return true;
+}
+
+void bot_minion_ai::ApplyItemBonuses(uint8 slot)
+{
+    //ensurance to set zeros
+    RemoveItemBonuses(slot);
+
+    Item* item = _equips[slot];
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->GetEntry());
+    if (!proto)
+        return;
+
+    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : NULL;
+
+    uint32 ssd_level = me->getLevel();
+    if (ssd && ssd_level > ssd->MaxLevel)
+        ssd_level = ssd->MaxLevel;
+
+    ScalingStatValuesEntry const* ssv = proto->ScalingStatValue ? sScalingStatValuesStore.LookupEntry(ssd_level) : NULL;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_STATS; ++i)
+    {
+        uint32 statType = 0;
+        int32  val = 0;
+        if (ssd && ssv)
+        {
+            if (ssd->StatMod[i] < 0)
+                continue;
+            statType = ssd->StatMod[i];
+            val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Modifier[i]) / 10000;
+        }
+        else
+        {
+            if (i >= proto->StatsCount)
+                continue;
+            statType = proto->ItemStat[i].ItemStatType;
+            val = proto->ItemStat[i].ItemStatValue;
+        }
+
+        if (val == 0)
+            continue;
+
+        _stats[slot][statType] += val;
+    }
+
+    _stats[slot][BOT_STAT_MOD_RESIST_HOLY] += proto->HolyRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_FIRE] += proto->FireRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_NATURE] += proto->NatureRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_FROST] += proto->FrostRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_SHADOW] += proto->ShadowRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_ARCANE] += proto->ArcaneRes;
+
+    _stats[slot][BOT_STAT_MOD_ARMOR] += proto->Armor;
+    _stats[slot][BOT_STAT_MOD_BLOCK_VALUE] += proto->Block;
+
+
+    if (ssv)
+    {
+        float average = ssv->getDPSMod(proto->ScalingStatValue) * proto->Delay / 1000.0f;
+        _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += 0.7f * average;
+        _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += 1.3f * average;
+    }
+    else
+    {
+        _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += proto->Damage[0].DamageMin;
+        _stats[slot][BOT_STAT_MOD_DAMAGE_MAX] += proto->Damage[0].DamageMax;
+    }
+
+    if (_botclass == BOT_CLASS_DRUID)
+    {
+        int32 dpsMod = 0;
+        int32 feral_bonus = 0;
+
+        if (ssv)
+        {
+            dpsMod = ssv->getDPSMod(proto->ScalingStatValue);
+            feral_bonus += ssv->getFeralBonus(proto->ScalingStatValue);
+        }
+
+        feral_bonus += proto->getFeralBonus(dpsMod);
+        if (feral_bonus)
+            _stats[slot][BOT_STAT_MOD_FERAL_ATTACK_POWER] += feral_bonus;
+            //ApplyFeralAPBonus(feral_bonus, apply);
+    }
+
+    ApplyItemEnchantments(item, slot);
+    ApplyItemEquipSpell(item, true);
+
+    shouldUpdateStats = true;
+}
+
+void bot_minion_ai::RemoveItemBonuses(uint8 slot)
+{
+    Item* item = _equips[slot];
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->GetEntry());
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        _stats[slot][i] = 0;
+
+    RemoveItemEnchantments(item); //remove spells
+    ApplyItemEquipSpell(item, false);
+
+    shouldUpdateStats = true;
+}
+
+void bot_minion_ai::ApplyItemEnchantments(Item* item, uint8 slot)
+{
+    for (uint8 i = 0; i != MAX_ENCHANTMENT_SLOT; ++i)
+        ApplyItemEnchantment(item, EnchantmentSlot(i), slot);
+}
+
+void bot_minion_ai::ApplyItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot)
+{
+    uint32 enchant_id = item->GetEnchantmentId(eslot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    if (pEnchant->requiredLevel > me->getLevel())
+        return;
+
+    uint32 enchant_display_type;
+    uint32 enchant_amount;
+    uint32 enchant_spell_id;
+
+    for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+    {
+        enchant_display_type = pEnchant->type[s];
+        enchant_amount = pEnchant->amount[s];
+        enchant_spell_id = pEnchant->spellid[s];
+
+        switch (enchant_display_type)
+        {
+            case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += enchant_amount;
+                _stats[slot][BOT_STAT_MOD_DAMAGE_MAX] += enchant_amount;
+                break;
+            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                if (enchant_spell_id)
+                {
+                    int32 basepoints = 0;
+                    // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
+                    if (item->GetItemRandomPropertyId())
+                    {
+                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand)
+                        {
+                            // Search enchant_amount
+                            for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                            {
+                                if (item_rand->enchant_id[k] == enchant_id)
+                                {
+                                    basepoints = int32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    // Cast custom spell vs all equal basepoints got from enchant_amount
+                    if (basepoints)
+                        me->CastCustomSpell(me, enchant_spell_id, &basepoints, &basepoints, &basepoints, true, item);
+                    else
+                        me->CastSpell(me, enchant_spell_id, true, item);
+                }
+                break;
+            case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand)
+                    {
+                        for (uint8 k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand->enchant_id[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+                _stats[slot][BOT_STAT_MOD_RESISTANCE_START + enchant_spell_id] += enchant_amount;
+                break;
+            case ITEM_ENCHANTMENT_TYPE_STAT:
+            {
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand_suffix)
+                    {
+                        for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand_suffix->enchant_id[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand_suffix->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                switch (enchant_spell_id)
+                {
+                    case ITEM_MOD_MANA:
+                    case ITEM_MOD_HEALTH:
+                    case ITEM_MOD_AGILITY:
+                    case ITEM_MOD_STRENGTH:
+                    case ITEM_MOD_INTELLECT:
+                    case ITEM_MOD_SPIRIT:
+                    case ITEM_MOD_STAMINA:
+                    case ITEM_MOD_DEFENSE_SKILL_RATING:
+                    case ITEM_MOD_DODGE_RATING:
+                    case ITEM_MOD_PARRY_RATING:
+                    case ITEM_MOD_BLOCK_RATING:
+                    case ITEM_MOD_HIT_MELEE_RATING:
+                    case ITEM_MOD_HIT_RANGED_RATING:
+                    case ITEM_MOD_HIT_SPELL_RATING:
+                    case ITEM_MOD_CRIT_MELEE_RATING:
+                    case ITEM_MOD_CRIT_RANGED_RATING:
+                    case ITEM_MOD_CRIT_SPELL_RATING:
+                    case ITEM_MOD_HASTE_MELEE_RATING:
+                    case ITEM_MOD_HASTE_RANGED_RATING:
+                    case ITEM_MOD_HASTE_SPELL_RATING:
+                    case ITEM_MOD_HIT_RATING:
+                    case ITEM_MOD_CRIT_RATING:
+                    case ITEM_MOD_HASTE_RATING:
+                    case ITEM_MOD_RESILIENCE_RATING:
+                    case ITEM_MOD_EXPERTISE_RATING:
+                    case ITEM_MOD_ATTACK_POWER:
+                    case ITEM_MOD_RANGED_ATTACK_POWER:
+                    case ITEM_MOD_MANA_REGENERATION:
+                    case ITEM_MOD_ARMOR_PENETRATION_RATING:
+                    case ITEM_MOD_SPELL_POWER:
+                    case ITEM_MOD_SPELL_PENETRATION:
+                    case ITEM_MOD_BLOCK_VALUE:
+                    case ITEM_MOD_SPELL_HEALING_DONE:   // deprecated
+                    case ITEM_MOD_SPELL_DAMAGE_DONE:    // deprecated
+                        _stats[slot][enchant_spell_id] += enchant_amount;
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            }
+            case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+            case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+            case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void bot_minion_ai::RemoveItemEnchantments(Item const* item)
+{
+    for (uint8 i = 0; i != MAX_ENCHANTMENT_SLOT; ++i)
+        RemoveItemEnchantment(item, EnchantmentSlot(i));
+}
+
+void bot_minion_ai::RemoveItemEnchantment(Item const* item, EnchantmentSlot eslot)
+{
+    uint32 enchant_id = item->GetEnchantmentId(eslot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    ////skip level reqs
+    //if (pEnchant->requiredLevel > me->getLevel())
+    //    return;
+
+    uint32 enchant_display_type;
+    //uint32 enchant_amount;
+    uint32 enchant_spell_id;
+
+    for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+    {
+        enchant_display_type = pEnchant->type[s];
+        //enchant_amount = pEnchant->amount[s];
+        enchant_spell_id = pEnchant->spellid[s];
+
+        switch (enchant_display_type)
+        {
+            case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                if (enchant_spell_id)
+                    me->RemoveAurasDueToItemSpell(enchant_spell_id, item->GetGUID());
+                break;
+            case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_STAT:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+            case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+            case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void bot_minion_ai::RemoveItemClassEnchants()
+{
+    uint8 eslot = TEMP_ENCHANTMENT_SLOT;
+    for (uint8 k = BOT_SLOT_MAINHAND; k != BOT_SLOT_RANGED; ++k)
+    {
+        if (!GetAIMiscValue(k == 0 ? BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH : BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH))
+            continue;
+
+        Item* weap = _equips[k];
+        if (!weap || !weap->GetEnchantmentId(EnchantmentSlot(eslot)))
+            continue;
+
+        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+            weap->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + eslot*MAX_ENCHANTMENT_OFFSET + i, 0);
+    }
+}
+
+void bot_minion_ai::ApplyItemEquipSpell(Item* item, bool apply)
+{
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        _Spell const& spellData = proto->Spells[i];
+
+        if (!spellData.SpellId)
+            continue;
+
+        // wrong triggering type
+        if (apply && spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_EQUIP)
+            continue;
+
+        // check if it is valid spell
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+        if (!spellInfo)
+            continue;
+
+        //ApplyEquipSpell(spellproto, item, apply);
+
+        //if (apply)
+        //    me->AddAura(spellInfo->Id, me);
+        //else
+        //    me->RemoveAura(spellInfo->Id);
+
+        if (apply)
+            me->CastSpell(me, spellInfo, true, item);
+        else
+            me->RemoveAurasDueToItemSpell(spellInfo->Id, item->GetGUID());  // un-apply all spells, not only at-equipped
+    }
+}
+
+void bot_minion_ai::ApplyItemEquipEnchantmentSpells(Item* item)
+{
+    for (uint8 e_slot = 0; e_slot != MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        if (!enchant_id)
+            continue;
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+        if (pEnchant->requiredLevel > me->getLevel())
+            continue;
+
+        uint32 enchant_display_type;
+        uint32 enchant_amount;
+        uint32 enchant_spell_id;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            enchant_display_type = pEnchant->type[s];
+            enchant_amount = pEnchant->amount[s];
+            enchant_spell_id = pEnchant->spellid[s];
+
+            switch (enchant_display_type)
+            {
+                case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                {
+                    if (!enchant_spell_id)
+                        break;
+                    int32 basepoints = 0;
+                    // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
+                    if (item->GetItemRandomPropertyId())
+                    {
+                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand)
+                        {
+                            // Search enchant_amount
+                            for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                            {
+                                if (item_rand->enchant_id[k] == enchant_id)
+                                {
+                                    basepoints = int32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    // Cast custom spell vs all equal basepoints got from enchant_amount
+                    if (basepoints)
+                        me->CastCustomSpell(me, enchant_spell_id, &basepoints, &basepoints, &basepoints, true, item);
+                    else
+                        me->CastSpell(me, enchant_spell_id, true, item);
+
+                    break;
+                }
+                default:
+                    break;
+            }
+        }
+    }
+}
+
+void bot_minion_ai::ApplyItemsSpells()
+{
+    //int8 id = 1;
+    //EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    //only for non-standard items
+    for (uint8 slot = BOT_SLOT_MAINHAND; slot != BOT_INVENTORY_SIZE; ++slot)
+    {
+        if (Item* item = _equips[slot])
+        {
+            //if (slot >= BOT_SLOT_RANGED || einfo->ItemEntry[slot] != item->GetEntry())
+            {
+                ApplyItemEquipSpell(item, true); //item template spells
+                ApplyItemEquipEnchantmentSpells(item); //item enchants
+            }
+        }
+    }
+}
+
+inline float bot_minion_ai::_getBotStat(uint8 slot, uint8 stat) const
+{
+    return float(static_cast<BotStat>(_stats[slot])[stat]);
+}
+
+inline float bot_minion_ai::_getTotalBotStat(uint8 stat) const
+{
+    int32 value = 0;
+    for (uint8 slot = BOT_SLOT_MAINHAND; slot != BOT_INVENTORY_SIZE; ++slot)
+        value += static_cast<BotStat>(_stats[slot])[stat];
+
+    uint8 lvl = me->getLevel();
+    float fval = float(value);
+
+    switch (stat)
+    {
+        case BOT_STAT_MOD_STRENGTH:
+            fval += me->GetTotalStatValue(STAT_STRENGTH);
+            switch (_botclass)
+            {
+                case BOT_CLASS_WARRIOR:
+                    //Vitality, Strength of Arms
+                    if (lvl >= 45)
+                        fval *= 1.1f;
+                    else if (lvl >= 40)
+                        fval *= 1.04f;
+                    //Improved Berserker Stance
+                    if (lvl >= 45 && GetBotStance() == WARRIOR_BERSERKER_STANCE)
+                        fval *= 1.2f;
+                    break;
+                case BOT_CLASS_PALADIN:
+                    //Divine Strength
+                    if (lvl >= 10)
+                        fval *= 1.15f;
+                    break;
+                case BOT_CLASS_DEATH_KNIGHT:
+                    //Veteran of the Third War
+                    if (lvl >= 30)
+                        fval *= 1.06f;
+                    break;
+                case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_AGILITY:
+            fval += me->GetTotalStatValue(STAT_AGILITY);
+            switch (_botclass)
+            {
+               case BOT_CLASS_HUNTER:
+                    //Combat Experience, Lightning Reflexes
+                    if (lvl >= 35)
+                        fval *= 1.19f;
+                    //Hunting Party
+                    if (lvl >= 35)
+                        fval *= 1.03f;
+                    break;
+               case BOT_CLASS_ROGUE:
+                    //Sinister Calling
+                    if (lvl >= 45)
+                        fval *= 1.15f;
+                    break;
+               case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_STAMINA:
+            fval += me->GetTotalStatValue(STAT_STAMINA);
+            switch (_botclass)
+            {
+               case BOT_CLASS_WARRIOR:
+                    //Vitality, Strength of Arms
+                    if (lvl >= 45)
+                        fval *= 1.13f;
+                    else if (lvl >= 40)
+                        fval *= 1.04f;
+                    break;
+               case BOT_CLASS_PALADIN:
+                    //Combat Expertise, Sacred Duty
+                    if (lvl >= 45)
+                        fval *= 1.1f;
+                    else if (lvl >= 35)
+                        fval *= 1.04f;
+                    break;
+               case BOT_CLASS_HUNTER:
+                    //Survivalist
+                    if (lvl >= 20)
+                        fval *= 1.1f;
+                   break;
+               case BOT_CLASS_ROGUE:
+                    //Lightning Reflexes part 2
+                    if (lvl >= 20)
+                        fval *= 1.04f;
+                   break;
+               case BOT_CLASS_WARLOCK:
+                    //Demonic Embrace: 10% stam bonus
+                    if (lvl >= 10)
+                        fval *= 1.1f;
+                   break;
+               case BOT_CLASS_DRUID:
+                    if (GetBotStance() == DRUID_BEAR_FORM)
+                    {
+                        //Bear form: stamina bonus base 25%
+                        //Heart of the Wild: 10% stam bonus for bear
+                        if (lvl >= 35)
+                            fval *= 1.35f;
+                        else
+                            fval *= 1.25f;
+                    }
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_INTELLECT:
+            fval += me->GetTotalStatValue(STAT_INTELLECT);
+            switch (_botclass)
+            {
+               case BOT_CLASS_PALADIN:
+                    //Divine Intellect
+                    if (lvl >= 15)
+                        fval *= 1.1f;
+                    break;
+               case BOT_CLASS_HUNTER:
+                    //Combat Experience
+                    if (lvl >= 35)
+                        fval *= 1.04f;
+                    break;
+               case BOT_CLASS_MAGE:
+                    //Arcane Mind
+                    if (lvl >= 30)
+                        fval *= 1.15f;
+                    break;
+               case BOT_CLASS_PRIEST:
+                    //Mental Strength
+                    if (lvl >= 30)
+                        fval *= 1.15f;
+                    break;
+               case BOT_CLASS_SHAMAN:
+                    //Ancestral Knowledge
+                    if (lvl >= 10)
+                        fval *= 1.1f;
+                    break;
+               case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    //Furor (Moonkin Form)
+                    if (GetBotStance() == DRUID_MOONKIN_FORM)
+                        fval *= 1.1f;
+                    //Heart of the Wild: ferals only (tanks included)
+                    if (lvl >= 35 && (IAmFree() || IsMelee()))
+                        fval *= 1.2f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_SPIRIT:
+            fval += me->GetTotalStatValue(STAT_SPIRIT);
+            switch (_botclass)
+            {
+               case BOT_CLASS_MAGE:
+                    //Student of the Mind
+                    if (lvl >= 20)
+                        fval *= 1.1f;
+                    break;
+               case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    //Living Spirit
+                    if (lvl >= 40)
+                        fval *= 1.15f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+    }
+
+    return fval;
+}
+
+inline float bot_minion_ai::_getRatingMultiplier(CombatRating cr) const
+{
+    GtCombatRatingsEntry const* Rating =
+        sGtCombatRatingsStore.LookupEntry(cr*GT_MAX_LEVEL + (me->getLevel()-1));
+    GtOCTClassCombatRatingScalarEntry const* classRating =
+        sGtOCTClassCombatRatingScalarStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_RATING + cr + 1);
+    if (!Rating || !classRating)
+        return 1.0f;
+
+    return classRating->ratio / Rating->ratio;
+}
+
+char const* bot_minion_ai::_getNameForSlot(uint8 slot) const
+{
+    switch (slot)
+    {
+        case BOT_SLOT_MAINHAND:
+            return "Main Hand Weapon";
+        case BOT_SLOT_OFFHAND:
+            return "Offhand Weapon";
+        case BOT_SLOT_RANGED:
+            return "Ranged Weapon";
+        case BOT_SLOT_HEAD:
+            return "Head";
+        case BOT_SLOT_SHOULDERS:
+            return "Shoulders";
+        case BOT_SLOT_CHEST:
+            return "Chest";
+        case BOT_SLOT_WAIST:
+            return "Waist";
+        case BOT_SLOT_LEGS:
+            return "Legs";
+        case BOT_SLOT_FEET:
+            return "Feet";
+        case BOT_SLOT_WRIST:
+            return "Wrist";
+        case BOT_SLOT_HANDS:
+            return "Hands";
+        case BOT_SLOT_BACK:
+            return "Back";
+        case BOT_SLOT_BODY:
+            return "Body";
+        case BOT_SLOT_FINGER1:
+            return "Finger1";
+        case BOT_SLOT_FINGER2:
+            return "Finger2";
+        case BOT_SLOT_TRINKET1:
+            return "Trinket1";
+        case BOT_SLOT_TRINKET2:
+            return "Trinket2";
+        case BOT_SLOT_NECK:
+            return "Neck";
+        default:
+            return "Unknown";
+    }
+}
+
+//!Copied from Player::CastItemUseSpell
+void bot_minion_ai::_castBotItemUseSpell(Item const* item, SpellCastTargets const& targets, uint8 cast_count, uint32 glyphIndex)
+{
+    ItemTemplate const* proto = item->GetTemplate();
+
+    // use triggered flag only for items with many spell casts and for not first cast
+    uint8 count = 0;
+
+    // item spells casted at use
+    SpellInfo const* spellInfo;
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        _Spell const& spellData = proto->Spells[i];
+        if (!spellData.SpellId || spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
+            continue;
+
+        spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+        if (!spellInfo)
+            continue;
+
+        Spell* spell = new Spell(me, spellInfo, (count > 0) ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+        //spell->m_CastItem = item; // DO NOT TAKE ITEM
+        //spell->m_cast_count = cast_count;                   // set count of casts
+        //spell->m_glyphIndex = glyphIndex;                   // glyph index
+        spell->prepare(&targets);
+        ++count;
+    }
+
+    // Item enchantments spells casted at use
+    for (uint8 e_slot = 0; e_slot != MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            if (pEnchant->type[s] != ITEM_ENCHANTMENT_TYPE_USE_SPELL)
+                continue;
+
+            spellInfo = sSpellMgr->GetSpellInfo(pEnchant->spellid[s]);
+            if (!spellInfo)
+                continue;
+
+            Spell* spell = new Spell(me, spellInfo, (count > 0) ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+            //spell->m_CastItem = item; // DO NOT TAKE ITEM
+            //spell->m_cast_count = cast_count;               // set count of casts
+            //spell->m_glyphIndex = glyphIndex;               // glyph index
+            spell->prepare(&targets);
+            ++count;
+        }
+    }
+}
+
+Item* bot_minion_ai::GetEquipsByGuid(uint64 itemGuid) const
+{
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        if (Item* item = _equips[i])
+            if (item->GetGUID() == itemGuid)
+                return item;
+    }
+
+    return NULL;
+}
+
+/////////
+//ROLES//
+/////////
+uint8 bot_minion_ai::_onOffIcon(uint16 role) const
+{
+    return HasRole(role) ? BOT_ICON_ON : BOT_ICON_OFF;
+}
+
+char const* bot_ai::GetRoleString(uint16 role) const
+{
+    switch (role)
+    {
+        //case BOT_ROLE_NONE:
+        //    return "???";
+        case BOT_ROLE_TANK:
+            return "Tanking";
+        case BOT_ROLE_DPS:
+            return "DPS";
+        case BOT_ROLE_HEAL:
+            return "Heal";
+        case BOT_ROLE_RANGED:
+            return "Ranged";
+        case BOT_ROLE_GATHERING_MINING:
+            return "Miner";
+        case BOT_ROLE_GATHERING_HERBALISM:
+            return "Herbalist";
+        case BOT_ROLE_GATHERING_SKINNING:
+            return "Skinner";
+        case BOT_ROLE_GATHERING_ENGINEERING:
+            return "Engineer";
+        default:
+        {
+            std::ostringstream str;
+            str << "role " << uint32(role);
+            return str.str().c_str();
+        }
+    }
+}
+
+void bot_ai::DefaultInit()
+{
+    //only once
+    if (spawned) return;
+    spawned = true;
+
+    if (!firstspawn)
+    {
+        me->RemoveAllAuras();
+        if (IsMinionAI())
+        {
+            ToMinionAI()->RemoveItemClassEnchants(); //clear rogue poisons / shaman ecnhants
+            ToMinionAI()->ApplyItemsSpells(); //restore item equip spells
+        }
+    }
+
+    if (!IsTempBot())
+        ApplyRacials();
+
+    me->SetPvP(true);
+    InitRoles();
+    SetStats(true); // Class passives included
+    //InitPowers(); // already in *etStats();
+
+    if (firstspawn)
+    {
+        firstspawn = false;
+        ASSERT(!me->GetBotAI());
+        me->SetBotAI(this);
+
+        if (!IsTempBot())
+        {
+            InitFaction();
+            InitOwner();
+            InitEquips();
+        }
+    }
+}
+
+void bot_minion_ai::ApplyRacials()
+{
+    uint8 myrace = me->getRace();
+    switch (myrace)
+    {
+        case RACE_HUMAN:
+            RefreshAura(20598); //Human Spirit
+            RefreshAura(20864); //Mace Specialization
+            RefreshAura(20597); //Sword Specialization
+            //RefreshAura(58985); //Perception pointless
+            if (firstspawn)
+                InitSpellMap(RACIAL_EVERY_MAN_FOR_HIMSELF, true, false);
+            break;
+        case RACE_ORC:
+            //Command: has to be implemented with pets
+            RefreshAura(20573); //Hardiness
+            RefreshAura(20574); //Axe Specialization
+            //Blood Fury
+            if (firstspawn)
+                InitSpellMap(RaceSpellForClass(myrace, _botclass), true, false);
+            break;
+        case RACE_DWARF:
+            RefreshAura(20595); //Gun Specialization
+            RefreshAura(59224); //Mace Specialization
+            RefreshAura(20596); //Frost Resistance
+            if (firstspawn)
+                InitSpellMap(RACIAL_STONEFORM, true, false);
+            break;
+        case RACE_NIGHTELF:
+            RefreshAura(20583); //Nature Resistance
+            RefreshAura(20582); //Quickness
+            InitSpellMap(RACIAL_SHADOWMELD, true, false);
+            break;
+        case RACE_UNDEAD_PLAYER:
+            RefreshAura(20579); //Shadow Resistance
+            if (firstspawn)
+                InitSpellMap(RACIAL_WILL_OF_THE_FORSAKEN, true, false);
+            //cannibalize is skipped
+            break;
+        case RACE_TAUREN:
+            RefreshAura(20550); //Endurance TODO: confirm if working
+            RefreshAura(20551); //Nature Resistance
+            if (firstspawn)
+                InitSpellMap(RACIAL_WARSTOMP, true, false);
+            break;
+        case RACE_GNOME:
+            RefreshAura(20552); //Arcane Resistance
+            RefreshAura(20591); //Expansive Mind
+            if (firstspawn)
+                InitSpellMap(RACIAL_ESCAPE_ARTIST, true, false);
+            break;
+        case RACE_TROLL:
+            RefreshAura(20557); //Beast Slaying
+            RefreshAura(20558); //Thrown Specialization
+            RefreshAura(26290); //Bow Specialization
+            RefreshAura(58943); //Da Voodoo Shuffle
+            RefreshAura(20555); //Regeneration
+            if (firstspawn)
+                InitSpellMap(RACIAL_BERSERKING, true, false);
+            break;
+        case RACE_BLOODELF:
+            RefreshAura(822); //Magic Resistance
+            if (firstspawn)
+                InitSpellMap(RaceSpellForClass(myrace, _botclass), true, false);
+            break;
+        case RACE_DRAENEI:
+            RefreshAura(6562); //Heroic Presence (28878 is not present)
+            RefreshAura(20579); //Shadow Resistance (universal since creatures do not lose cast time on damage anyways)
+            if (firstspawn)
+                InitSpellMap(RaceSpellForClass(myrace, _botclass), true, false);
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "bot_ai::ApplyRacePassives(): unknown race %u for bot %s (%u)", uint32(me->getRace()), me->GetName().c_str(), me->GetEntry());
+            return;
+    }
+}
+
+void bot_minion_ai::InitFaction()
+{
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData && "bot_minion_ai::InitFaction(): data not found!");
+
+    uint32 faction = npcBotData->faction;
+
+    //if (faction == 14)
+    //    faction = 35;
+
+    me->setFaction(faction);
+    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->faction_A = faction;
+    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->faction_H = faction;
+}
+
+void bot_minion_ai::InitOwner()
+{
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData && "bot_minion_ai::InitOwner(): data not found!");
+
+    _ownerGuid = npcBotData->owner;
+}
+
+void bot_minion_ai::InitRoles()
+{
+    if (IAmFree() || IsTempBot())
+    {
+        //default roles
+        _roleMask = BOT_ROLE_DPS;
+        if (!IsMeleeClass(_botclass))
+        {
+            //make about 33% of free druid bots feral
+            if (_botclass != BOT_CLASS_DRUID || urand(1,100) <= 67)
+                _roleMask |= BOT_ROLE_RANGED;
+        }
+        if (CanHeal())
+            _roleMask |= BOT_ROLE_HEAL;
+
+        return;
+    }
+
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    if (!npcBotData)
+    {
+        //default roles
+        _roleMask = BOT_ROLE_DPS;
+        if (!IsMeleeClass(_botclass))
+            _roleMask |= BOT_ROLE_RANGED;
+        if (CanHeal())
+            _roleMask |= BOT_ROLE_HEAL;
+
+        return;
+    }
+
+    _roleMask = npcBotData->roles;
+}
+
+void bot_pet_ai::InitRoles()
+{
+    _roleMask = BOT_ROLE_DPS;
+    if (!IsMeleeClass(GetPetClass(me)))
+        _roleMask |= BOT_ROLE_RANGED;
+    if (CanHeal())
+        _roleMask |= BOT_ROLE_HEAL;
+}
+
+void bot_minion_ai::InitEquips()
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to spawn bot with no equip info!");
+
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData);
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE);
+    //                    0                   1         2            3           4         5                6                    7              8             9        10       11            12             13
+    //SELECT ii.creatorGuid, ii.giftCreatorGuid, ii.count, ii.duration, ii.charges, ii.flags, ii.enchantments, ii.randomPropertyId, ii.durability, ii.playedTime, ii.text, ii.guid, ii.itemEntry, ii.owner_guid "
+    //  "FROM item_instance ii JOIN characters_npcbot cn ON ii.guid IN "
+    //  "(cn.equipMhEx, cn.equipOhEx, cn.equipRhEx, cn.equipHead, cn.equipShoulders, cn.equipChest, cn.equipWaist, cn.equipLegs, cn.equipFeet, cn.equipWrist, cn.equipHands, cn.equipBack, cn.equipBody, cn.equipFinger1, cn.equipFinger2, cn.equipTrinket1, cn.equipTrinket2, cn.equipNeck) "
+    //  "WHERE cn.entry = ?", CONNECTION_SYNCH
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult iiresult = CharacterDatabase.Query(stmt);
+
+    Field* fields2;
+    uint32 itemId;
+    uint32 itemGuidLow;
+    Item* item;
+
+    if (!iiresult) //blank bot - fill with standard items
+    {
+        for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+        {
+            itemId = einfo->ItemEntry[i];
+            if (!itemId)
+                continue;
+
+            item = Item::CreateItem(itemId, 1, NULL);
+            ASSERT(item && "Failed to init standard Item for bot!");
+            _equips[i] = item;
+        }
+    }
+    else
+    {
+        do
+        {
+            fields2 = iiresult->Fetch();
+            itemGuidLow = fields2[11].GetUInt32();
+            itemId = fields2[12].GetUInt32();
+            item = new Item;
+            ASSERT(item->LoadFromDB(itemGuidLow, 0, fields2, itemId));
+            //gonna find where to store our new item
+            bool found = false;
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (npcBotData->equips[i] == itemGuidLow && !_equips[i])
+                {
+                    _equips[i] = item;
+                    found = true;
+                    break;
+                }
+            }
+            ASSERT(found);
+            //ItemTemplate const* proto = item->GetTemplate();
+            //TC_LOG_ERROR("entities.player", "minion_ai::InitEquips(): bot %s (id: %u): found item: for slot %u: %s (id: %u, guidLow: %u)",
+            //    me->GetName().c_str(), me->GetEntry(), i, proto->Name1.c_str(), itemId, itemGuidLow);
+
+        } while (iiresult->NextRow());
+    }
+
+    //visualize
+    for (uint8 i = BOT_SLOT_MAINHAND; i <= BOT_SLOT_RANGED; ++i)
+    {
+        if (CanChangeEquip(i) && _equips[i])
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, _equips[i]->GetEntry());
+        else if (einfo->ItemEntry[i])
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+    }
+
+    //apply weapons' parameters
+    if (Item const* MH = _equips[BOT_SLOT_MAINHAND])
+    {
+        itemId = MH->GetEntry();
+        if (einfo->ItemEntry[0] != itemId)
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+            {
+                if (RespectEquipsAttackTime())
+                    me->SetAttackTime(BASE_ATTACK, proto->Delay);
+                ApplyItemBonuses(BOT_SLOT_MAINHAND);
+            }
+        }
+    }
+    if (Item const* OH = _equips[BOT_SLOT_OFFHAND])
+    {
+        itemId = OH->GetEntry();
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+        {
+            if (einfo->ItemEntry[1] != itemId)
+                ApplyItemBonuses(BOT_SLOT_OFFHAND);
+
+            if (proto->Class == ITEM_CLASS_WEAPON)
+            {
+                if (RespectEquipsAttackTime())
+                    me->SetAttackTime(OFF_ATTACK, proto->Delay);
+                me->SetCanDualWield(true);
+            }
+            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            {
+                if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+            }
+        }
+    }
+    if (Item const* RH = _equips[BOT_SLOT_RANGED])
+    {
+        itemId = RH->GetEntry();
+        if (einfo->ItemEntry[2] != itemId)
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+            {
+                if (proto->Class == ITEM_CLASS_WEAPON)
+                    if (RespectEquipsAttackTime())
+                        me->SetAttackTime(RANGED_ATTACK, proto->Delay);
+
+                ApplyItemBonuses(BOT_SLOT_RANGED);
+            }
+        }
+    }
+
+    for (uint8 i = BOT_SLOT_RANGED + 1; i != BOT_INVENTORY_SIZE; ++i)
+        ApplyItemBonuses(i);
+
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+    {
+        if (_equips[i] == NULL && einfo->ItemEntry[i] != 0)
+        {
+            if (i == BOT_SLOT_OFFHAND && !_canUseOffHand())
+                continue;
+
+            //if bot has no equips but equip template then use those
+            item = Item::CreateItem(einfo->ItemEntry[i], 1, NULL);
+            ASSERT(item && "Failed to init standard Item for bot point 2!");
+            _equips[i] = item;
+
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+            if (i == BOT_SLOT_OFFHAND)
+            {
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[i]))
+                {
+                    if (proto->Class == ITEM_CLASS_WEAPON)
+                    {
+                        me->SetAttackTime(OFF_ATTACK, _botclass == BOT_CLASS_ROGUE ? 1400 : 1800);
+                        me->SetCanDualWield(true);
+                    }
+                    else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    {
+                        if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                            const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+                    }
+                }
+            }
+        }
+    }
+}
+
+void bot_ai::ToggleRole(uint16 role, bool force)
+{
+    if (!force && roleTimer > lastdiff)
+        return;
+
+    roleTimer = 350; //delay next attempt (prevent abuse)
+
+    HasRole(role) ? _roleMask &= ~role : _roleMask |= role;
+
+    BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_ROLES, &_roleMask);
+
+    //Update passives
+    shouldUpdateStats = true;
+}
+
+bool bot_ai::IsTank(Unit const* unit) const
+{
+    if (!unit || unit == me)
+        return HasRole(BOT_ROLE_TANK);
+
+    //TODO: pet case
+    if (Creature const* bot = unit->ToCreature())
+        return bot->GetBotAI() && bot->GetBotAI()->HasRole(BOT_ROLE_TANK);
+
+    //Maybe use highest hp? TODO: a way to find multiple tanks
+    if (Player const* player = unit->ToPlayer())
+    {
+        if (Group const* gr = player->GetGroup())
+        {
+            /*//player role in lfg group
+            if (gr->isLFGGroup())
+            {
+                if (sLFGMgr->GetRoles(unit->GetGUID()) & lfg::PLAYER_ROLE_TANK)
+                    return true;
+            }
+            //raid group Main Tank (/mt)
+            else */if (gr->isRaidGroup())
+            {
+                Group::MemberSlotList const& slots = gr->GetMemberSlots();
+                for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
+                    if (itr->guid == unit->GetGUID())
+                        return itr->flags & MEMBER_FLAG_MAINTANK;
+            }
+        }
+    }
+
+    return false;
+}
+
+void bot_ai::FindMaster(bool force)
+{
+    if (!force)
+    {
+        //totally free
+        if (!_ownerGuid)
+            return;
+        if (!_atHome || _evadeMode)
+            return;
+
+        //delay
+        if (checkMasterTimer > lastdiff)
+            return;
+
+        checkMasterTimer = urand(5000, 15000);
+    }
+
+    //already have master
+    if (!IAmFree())
+        return;
+    if (IsDuringTeleport())
+        return;
+
+    if (Player* player = sObjectMgr->GetPlayerByLowGUID(_ownerGuid))
+    {
+        //prevent bot being screwed up because of wrong flags
+        if (player->IsGameMaster() || player->GetSession()->isLogingOut())
+            return;
+
+        SetBotOwner(player);
+
+        //fail
+        if (master != player)
+            return;
+
+        //if (!IsTempBot())
+        //    BotWhisper("Hey...", master);
+        return;
+    }
+}
+
+bool bot_minion_ai::IAmFree() const
+{
+    if (!_ownerGuid)
+        return true;
+    if (_ownerGuid != master->GetGUID())
+        return true;
+    //if (!me->HasUnitTypeMask(UNIT_MASK_MINION))
+    //    return true;
+
+    return false;
+    //return (!_ownerGuid || _ownerGuid != master->GetGUID() || !me->HasUnitTypeMask(UNIT_MASK_MINION));
+    //        //has owner   and   //owner is found          and        //bound to owner
+}
+
+//UTILITIES
+void bot_ai::_AddItemTemplateLink(Player const* forPlayer, ItemTemplate const* item, std::ostringstream &str) const
+{
+    //color
+    str << "|c";
+    switch (item->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << uint32(item->ItemId) << ':';
+
+    //permanent enchantment, 3 gems, 4 unknowns, reporter_level (9)
+    str << "0:0:0:0:0:0:0:0:0";
+
+    //name
+    std::string name = item->Name1;
+    _LocalizeItem(forPlayer, name, item->ItemId);
+    str << "|h[" << name << "]|h|r";
+
+    //max in stack
+    if (item->BuyCount > 1)
+        str<< "|cff009900x" << item->BuyCount << ".|r";
+    else
+        str << "|cff009900.|r";
+}
+// |TInterface\\Icons\\INV_<iconName>:<iconSize>|t|color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:random_property:suffix_factor:reporter_level|h[name]|h|r
+// |TInterface\\Icons\\INV_Misc_Staff_01:16|t|cffa335ee|Hitem:812:0:0:0:0:0:0:0:70|h[Glowing Brightwood Staff]|h|r
+void bot_ai::_AddItemLink(Player const* forPlayer, Item const* item, std::ostringstream &str, bool addIcon) const
+{
+    ItemTemplate const* proto = item->GetTemplate();
+    ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+    uint32 g1 = 0, g2 = 0, g3 = 0;
+    //uint32 bpoints = 0;
+    std::string name = proto->Name1;
+    std::string suffix = "";
+
+    //icon
+    if (addIcon)
+    {
+        ItemDisplayInfoEntry const* itemDisplayEntry = sItemDisplayInfoStore.LookupEntry(item->GetTemplate()->DisplayInfoID);
+        if (itemDisplayEntry)
+            str << "|TInterface\\Icons\\" << itemDisplayEntry->InventoryIcon << ":16|t";
+    }
+
+    //color
+    str << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << proto->ItemId << ':';
+
+    //permanent enchantment
+    str << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ':';
+    //gems 3
+    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot != SOCK_ENCHANTMENT_SLOT + MAX_ITEM_PROTO_SOCKETS; ++slot)
+    {
+        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
+
+        switch (slot - SOCK_ENCHANTMENT_SLOT)
+        {
+            case 0: g1 = eId;   break;
+            case 1: g2 = eId;   break;
+            case 2: g3 = eId;   break;
+        }
+    }
+    str << g1 << ':' << g2 << ':' << g3 << ':';
+    //always zero
+    str << 0 << ':';
+    //random property
+    str << item->GetItemRandomPropertyId() << ':';
+    str << item->GetItemSuffixFactor() << ':';
+
+    //reporter level
+    str << me->getLevel();
+
+    //name
+    _LocalizeItem(forPlayer, name, suffix, item);
+
+    str << "|h[" << name;
+    if (suffix.length() > 0)
+        str << ' ' << suffix;
+    str <<"]|h|r";
+
+    //quantity
+    if (item->GetCount() > 1)
+        str << "x" << item->GetCount() << ' ';
+
+    //TC_LOG_ERROR("entities.player", "bot_minion_ai::_AddItemLink(): %s", str.str().c_str());
+}
+//Unused
+void bot_ai::_AddQuestLink(Player const* forPlayer, Quest const* quest, std::ostringstream &str) const
+{
+    std::string questTitle = quest->GetTitle();
+    _LocalizeQuest(forPlayer, questTitle, quest->GetQuestId());
+    str << "|cFFEFFD00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+}
+//Unsused
+void bot_ai::_AddWeaponSkillLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|cff00ffff|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << " : " << master->GetSkillValue(skillid) << " /" << master->GetMaxSkillValue(skillid) << "]|h|r";
+}
+//|cff71d5ff|Hspell:21563|h[Command]|h|r
+void bot_ai::_AddSpellLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, bool color/* = true*/) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|c";
+
+    if (color)
+    {
+        switch (GetFirstSchoolInMask(spellInfo->GetSchoolMask()))
+        {
+            case SPELL_SCHOOL_NORMAL:       str << "ffffff00"; break; //YELLOW
+            case SPELL_SCHOOL_HOLY:         str << "ffffe680"; break; //LIGHT YELLOW
+            case SPELL_SCHOOL_FIRE:         str << "ffff8000"; break; //ORANGE
+            case SPELL_SCHOOL_NATURE:       str << "ff4dff4d"; break; //GREEN
+            case SPELL_SCHOOL_FROST:        str << "ff80ffff"; break; //LIGHT BLUE
+            case SPELL_SCHOOL_SHADOW:       str << "ff8080ff"; break; //DARK BLUE
+            case SPELL_SCHOOL_ARCANE:       str << "ffff80ff"; break; //LIGHT PURPLE
+            default:                        str << "ffffffff"; break; //UNK WHITE
+        }
+    }
+    else
+        str << "ffffffff"; //default white
+
+    str << "|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << "]|h|r";
+}
+//Unused
+void bot_ai::_AddProfessionLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const
+{
+    ASSERT(master->HasSkill(skillId));
+    // |cffffd000|Htrade:4037:1:150:1:6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA|h[Engineering]|h|r
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    SkillLineEntry const* skillInfo = sSkillLineStore.LookupEntry(skillId);
+    if (skillInfo)
+    {
+        uint32 curValue = master->GetPureSkillValue(skillId);
+        uint32 maxValue  = master->GetPureMaxSkillValue(skillId);
+        str << "|cffffd000|Htrade:" << spellInfo->Id << ':' << curValue << ':' << maxValue << ':' << master->GetGUIDLow() << ":6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA" << "|h[" << skillInfo->name[loc] << "]|h|r";
+    }
+}
+//Localization
+void bot_ai::_LocalizeItem(Player const* forPlayer, std::string &itemName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(entry);
+    if (!itemInfo)
+        return;
+
+    if (itemInfo->Name.size() > loc && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+}
+
+void bot_ai::_LocalizeItem(Player const* forPlayer, std::string &itemName, std::string &suffix, Item const* item) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(item->GetEntry());
+    if (loc > 0 && itemInfo && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+
+    int32 randomPropId = item->GetItemRandomPropertyId();
+    //TC_LOG_ERROR("entities.player", "bot_minion_ai::_LocalizeItem(): randomPropId = %i", randomPropId);
+    if (!randomPropId)
+        return;
+
+    if (randomPropId > 0)
+    {
+        if (ItemRandomPropertiesEntry const* item_rand = sItemRandomPropertiesStore.LookupEntry(randomPropId))
+        {
+            char* const* suffs = item_rand->nameSuffix;
+            if (suffs)
+            {
+                //for (uint8 i = 0; i != MAX_LOCALES; ++i)
+                //    TC_LOG_ERROR("entities.player", "bot_minion_ai::_LocalizeItem(): rand prop suffix for loc %u = %s", i, suffs[i]);
+                suffix = suffs[loc];
+            }
+        }
+    }
+    else
+    {
+        if (ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(-randomPropId))
+        {
+            char* const* suffs = item_rand->nameSuffix;
+            if (suffs)
+            {
+                //for (uint8 i = 0; i != MAX_LOCALES; ++i)
+                //    TC_LOG_ERROR("entities.player", "bot_minion_ai::_LocalizeItem(): rand suff suffix for loc %u = %s", i, suffs[i]);
+                suffix = suffs[loc];
+            }
+        }
+    }
+}
+
+void bot_ai::_LocalizeQuest(Player const* forPlayer, std::string &questTitle, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const* questInfo = sObjectMgr->GetQuestLocale(entry);
+    if (!questInfo)
+        return;
+
+    if (questInfo->Title.size() > loc && !questInfo->Title[loc].empty())
+    {
+        const std::string title = questInfo->Title[loc];
+        if (Utf8FitTo(title, wnamepart))
+            questTitle = title;
+    }
+}
+
+void bot_ai::_LocalizeCreature(Player const* forPlayer, std::string &creatureName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    CreatureLocale const* creatureInfo = sObjectMgr->GetCreatureLocale(entry);
+    if (!creatureInfo)
+        return;
+
+    if (creatureInfo->Name.size() > loc && !creatureInfo->Name[loc].empty())
+    {
+        const std::string title = creatureInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            creatureName = title;
+    }
+}
+
+void bot_ai::_LocalizeGameObject(Player const* forPlayer, std::string &gameobjectName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    GameObjectLocale const* gameObjectInfo = sObjectMgr->GetGameObjectLocale(entry);
+    if (!gameObjectInfo)
+        return;
+
+    if (gameObjectInfo->Name.size() > loc && !gameObjectInfo->Name[loc].empty())
+    {
+        const std::string title = gameObjectInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            gameobjectName = title;
+    }
+}
+
+void bot_minion_ai::BotJump(Position const* pos)
+{
+    ++_jumpCount;
+
+    me->BotStopMovement();
+    me->GetMotionMaster()->MoveJump(*pos, me->GetExactDist2d(pos->m_positionX, pos->m_positionY), 10.0f);
+
+    //float dx = pos->m_positionX - me->m_positionX;
+    //float dy = pos->m_positionY - me->m_positionY;
+    //float fdx = fabs(dx); float fdy = fabs(dy);
+    //float divider = fdx > 400 || fdy > 400 ? 5.0f : fdx > 200 || fdy > 200 ? 3.0f : fdx > 100 || fdy > 100 ? 2.0f : 1.5f;
+    //dx = dx / divider + me->m_positionX;
+    //dy = dy / divider + me->m_positionY;
+    //float z = me->GetMap()->GetHeight(dx, dy, std::max<float>(me->m_positionZ, pos->m_positionZ));
+
+    //if (z > INVALID_HEIGHT)
+    //    me->GetMotionMaster()->MoveJump(dx, dy, z, me->GetExactDist2d(dx, dy), 10.0f);
+}
+
+bool bot_minion_ai::UpdateImpossibleChase(Unit const* target)
+{
+    if (_chaseTimer > lastdiff || me->isMoving() || !IAmFree())
+        return false;
+
+    if (JumpingOrFalling())
+        return false;
+
+    if (!me->IsWithinDist(target, !HasRole(BOT_ROLE_RANGED) ? 50 : 75) || (me->GetDistance(target) < (!HasRole(BOT_ROLE_RANGED) ? 5 : 25)))
+    {
+        ResetChaseTimer(target);
+        me->GetMotionMaster()->MovePoint(me->GetMapId(), *target, false);
+        return true;
+    }
+
+    if (_jumpCount >= 3)
+    {
+        me->AttackStop();
+        Evade(true);
+        return true;
+    }
+
+    ResetChaseTimer(target);
+    BotJump(target);
+    return true;
+}
+
+void bot_minion_ai::ResetChaseTimer(Position const* /*pos*/)
+{
+    _chaseTimer = 10000;//std::max<uint32>(5000, me->GetDistance2d(pos->m_positionX, pos->m_positionY) * 400);
+    //me->GetDistance2d(pos->m_positionX, pos->m_positionY) * 1000 / me->GetSpeed(MOVE_WALK);
+}
+
+void bot_minion_ai::ResetChase(Position const* pos)
+{
+    if (!IAmFree())
+        return;
+
+    ResetChaseTimer(pos);
+    _jumpCount = 0;
+}
+
+void bot_minion_ai::OnStartAttack(Unit const* u)
+{
+    AdjustTankingPosition();
+
+    if (u->GetGUID() != _lastTargetGuid)
+    {
+        ResetChase(u);
+        _lastTargetGuid = u->GetGUID();
+    }
+}
+
+void bot_minion_ai::EnterCombat(Unit* u)
+{
+    _atHome = false;
+
+    //clear gossip during combat. See CheckAuras() for restore
+    if (me->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP))
+        me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+    //disable evade mode just in case
+    //me->ClearUnitState(UNIT_STATE_EVADE);
+    //if (Creature* pet = me->GetBotsPet())
+    //    pet->ClearUnitState(UNIT_STATE_EVADE);
+
+    if (!IAmFree())
+        return;
+
+    _evadeMode = false;
+    AbortTeleport();
+
+    ResetChase(u);
+}
+
+void bot_minion_ai::UpdateDeadAI(uint32 diff)
+{
+    //TODO: Soulstone emul
+}
+
+void bot_minion_ai::JustDied(Unit*)
+{
+    KillEvents(false);
+
+    if (IsTempBot())
+    {
+        //TC_LOG_ERROR("entities.player", "Unsummoning temp bot %s (guidLow: %u), owner: %s (guidLow: %u)...",
+        //    me->GetName().c_str(), me->GetGUIDLow(), master->GetName().c_str(), master->GetGUIDLow());
+
+        if (!IAmFree())
+            master->GetBotMgr()->RemoveBot(me->GetGUID(), BOT_REMOVE_UNSUMMON);
+
+        me->AddObjectToRemoveList();
+        return;
+    }
+    else if (!IAmFree())
+    {
+        if (Group* gr = master->GetGroup())
+            if (gr->IsMember(me->GetGUID()))
+                gr->SendUpdate();
+    }
+
+    _reviveTimer = IAmFree() ? 180000 : 60000; //3min/1min
+    _atHome = false;
+    _evadeMode = false;
+    spawned = false;
+
+    ++_deathsCount;
+}
+
+void bot_minion_ai::KilledUnit(Unit* u)
+{
+    ++_killsCount;
+    if (u->IsControlledByPlayer() || u->IsPvP())
+        ++_pvpKillsCount;
+    if (u->isType(TYPEMASK_PLAYER))
+        ++_playerKillsCount;
+}
+
+void bot_minion_ai::MoveInLineOfSight(Unit* /*u*/)
+{
+}
+
+void bot_ai::DamageDealt(Unit* victim, uint32& damage, DamageEffectType /*damageType*/)
+{
+    if (victim == me)
+        return;
+
+    if (damage)
+        if (Creature* cre = victim->ToCreature())
+            if (!cre->hasLootRecipient())
+                cre->SetLootRecipient(master);
+
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+        ResetChase(victim);
+}
+//This function is called after Spell::SendSpellCooldown() call for players
+void bot_ai::OnBotSpellGo(Spell const* spell)
+{
+    SpellInfo const* curInfo = spell->GetSpellInfo();
+
+    //Set cooldown
+    if (!curInfo->IsCooldownStartedOnEvent() && !curInfo->IsPassive())
+    {
+        uint32 rec = curInfo->RecoveryTime;
+        uint32 catrec = curInfo->CategoryRecoveryTime;
+
+        if (rec > 0)
+            ApplyBotSpellCooldownMods(curInfo, rec);
+        if (catrec > 0 && !(curInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS))
+            ApplyBotSpellCategoryCooldownMods(curInfo, catrec);
+
+        SetSpellCooldown(curInfo->GetFirstRankSpell()->Id, rec);
+        SetSpellCategoryCooldown(curInfo->GetFirstRankSpell(), catrec);
+    }
+
+    if (IsMinionAI())
+    {
+        if (curInfo->Id == PVPTRINKET)
+            SetSpellCooldown(PVPTRINKET, 120000);
+        if (ToMinionAI()->IsPotionSpell(curInfo->Id))
+            ToMinionAI()->StartPotionTimer();
+    }
+
+    OnClassSpellGo(curInfo);
+}
+
+void bot_ai::OnBotSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs)
+{
+    SpellInfo const* info;
+
+    for (BotSpellMap::iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        info = sSpellMgr->GetSpellInfo(itr->second->spellId);
+        if (!info || !(info->GetSchoolMask() & schoolMask)) continue;
+        if (info->IsCooldownStartedOnEvent()) continue;
+        if (info->PreventionType != SPELL_PREVENTION_TYPE_SILENCE) continue;
+
+        itr->second->cooldown += unTimeMs;
+        //TC_LOG_ERROR("entities.player", "OnBotSpellInterrupted(): Adding cooldown (%u, new: %u) to spell %s (id: %u, schoolmask: %u), reqSchoolMask = %u",
+        //    unTimeMs, itr->second.second, info->SpellName[0], info->Id, info->SchoolMask, schoolMask);
+    }
+
+    GC_Timer = 0; //reset global cooldown since cast is canceled
+}
+
+void bot_minion_ai::CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx)
+{
+    if (!target || !target->IsAlive() || target == me)
+        return;
+
+    if (!me->CanUseAttackType(attType))
+        return;
+
+    Item* item;
+    ItemTemplate const* proto;
+    int8 slot;
+    //int8 id = 1;
+    //EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        item = _equips[i];
+        if (!item)
+            continue;
+
+        //skip standard items
+        //if (i < BOT_SLOT_RANGED && einfo->ItemEntry[i] == item->GetEntry())
+        //    continue;
+
+        proto = item->GetTemplate();
+        if (!proto)
+            continue;
+
+        // Additional check for weapons
+        if (proto->Class == ITEM_CLASS_WEAPON)
+        {
+            // offhand item cannot proc from main hand hit etc
+            switch (attType)
+            {
+                case BASE_ATTACK:   slot = BOT_SLOT_MAINHAND;   break;
+                case OFF_ATTACK:    slot = BOT_SLOT_OFFHAND;    break;
+                case RANGED_ATTACK: slot = BOT_SLOT_RANGED;     break;
+                default:            slot = -1;                  break;
+            }
+            if (slot != i)
+                continue;
+        }
+
+        CastBotItemCombatSpell(target, attType, procVictim, procEx, item, proto);
+    }
+}
+
+void bot_minion_ai::CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto)
+{
+    //TODO: custom spell triggers maybe?
+
+    // Can do effect if any damage done to target
+    if (procVictim & PROC_FLAG_TAKEN_DAMAGE)
+    {
+        for (uint8 i = 0; i != MAX_ITEM_SPELLS; ++i)
+        {
+            _Spell const& spellData = proto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            // wrong triggering type
+            if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
+                continue;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+            if (!spellInfo)
+            {
+                //TC_LOG_ERROR("entities.player.items", "WORLD: unknown Item spellid %i", spellData.SpellId);
+                continue;
+            }
+
+            if (me->m_extraAttacks && spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
+                return;
+
+            float chance = (float)spellInfo->ProcChance;
+
+            if (spellData.SpellPPMRate)
+            {
+                uint32 WeaponSpeed = me->GetAttackTime(attType);
+                chance = me->GetPPMProcChance(WeaponSpeed, spellData.SpellPPMRate, spellInfo);
+            }
+            else if (chance > 100.0f)
+                chance = me->GetWeaponProcChance();
+
+            if (roll_chance_f(chance))
+                me->CastSpell(target, spellInfo->Id, true, item);
+        }
+    }
+
+    // item combat enchantments
+    for (uint8 e_slot = 0; e_slot != MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            if (pEnchant->type[s] != ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
+                continue;
+
+            SpellEnchantProcEntry const* entry = sSpellMgr->GetSpellEnchantProcEvent(enchant_id);
+
+            if (entry && entry->procEx)
+            {
+                // Check hit/crit/dodge/parry requirement
+                if ((entry->procEx & procEx) == 0)
+                    continue;
+            }
+            else
+            {
+                // Can do effect if any damage done to target
+                if (!(procVictim & PROC_FLAG_TAKEN_DAMAGE))
+                    continue;
+            }
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->spellid[s]);
+            if (!spellInfo)
+            {
+                //TC_LOG_ERROR("entities.player.items", "Player::CastItemCombatSpell(GUID: %u, name: %s, enchant: %i): unknown spell %i is casted, ignoring...",
+                //    GetGUIDLow(), GetName().c_str(), pEnchant->ID, pEnchant->spellid[s]);
+                continue;
+            }
+
+            float chance = pEnchant->amount[s] != 0 ? float(pEnchant->amount[s]) : me->GetWeaponProcChance();
+
+            if (entry)
+            {
+                if (entry->PPMChance)
+                {
+                    chance = me->GetPPMProcChance(proto->Delay, entry->PPMChance, spellInfo);
+                    //handle SPELLMOD_PROC_PER_MINUTE spellmods
+                    if (_botclass == BOT_CLASS_ROGUE)
+                    {
+                        //Improved Poisons
+                        if (me->getLevel() >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x2000))
+                            chance *= 1.5f;
+                    }
+                }
+                else if (entry->customChance)
+                    chance = (float)entry->customChance;
+            }
+
+            // Apply SPELLMOD_CHANCE_OF_SUCCESS spell mods
+            if (_botclass == BOT_CLASS_ROGUE)
+            {
+                //Improved Poisons
+                if (me->getLevel() >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x10000))
+                    chance += 20.f;
+            }
+
+            // Shiv has 100% chance to apply the poison
+            if (me->FindCurrentSpellBySpellId(5938) && e_slot == TEMP_ENCHANTMENT_SLOT)
+                chance = 100.0f;
+
+            if (roll_chance_f(chance))
+            {
+                if (spellInfo->IsPositive())
+                    me->CastSpell(me, spellInfo, true, item);
+                else
+                    me->CastSpell(target, spellInfo, true, item);
+            }
+        }
+    }
+}
+
+bool bot_minion_ai::GlobalUpdate(uint32 const diff)
+{
+    if (allBotsLoaded == false)
+        return false;
+
+    lastdiff = diff;
+
+    if (_updateTimerMedium <= diff)
+    {
+        _updateTimerMedium = 500;
+
+        //Medium-timed updates
+
+        //send stats update for group frames
+        if (me->IsInWorld() && !IAmFree())
+        {
+            if (Group const* gr = master->GetGroup())
+            {
+                if (gr->IsMember(me->GetGUID()))
+                {
+                    WorldPacket data;
+                    BuildGrouUpdatePacket(&data);
+
+                    Player* member;
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        member = itr->GetSource();
+                        if (member/* && !member->IsWithinDist(me, member->GetSightRange(), false)*/)
+                            member->GetSession()->SendPacket(&data);
+                    }
+                }
+            }
+
+            //update pvp state
+            if (me->GetByteValue(UNIT_FIELD_BYTES_2, 1) != master->GetByteValue(UNIT_FIELD_BYTES_2, 1))
+                me->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+        }
+    }
+
+    if (!me->IsAlive())
+        return false;
+
+    if (doHealth)
+    {
+        doHealth = false;
+        _OnHealthUpdate();
+    }
+    if (doMana)
+    {
+        doMana = false;
+        _OnManaUpdate();
+    }
+
+    //if (me->HasInvisibilityAura() || me->HasStealthAura())
+    //    return false;
+
+    if (_updateTimerEx1 <= diff && !IAmFree())
+    {
+        _updateTimerEx1 = urand(2000, 2500);
+
+        //Ex1-timed updates
+
+        //DEBUG
+        /*
+        Sometimes bots are affected by zone (instance) scripts
+        Good example is CoT: Battle for Mount Hyjal
+        */
+        //Faction
+        //ensure master is not controlled
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(master->getRace());
+        uint32 fac = rEntry ? rEntry->FactionID : 0;
+        if (me->getFaction() != master->getFaction() && master->getFaction() == fac)
+        {
+            //std::ostringstream msg;
+            //msg << "Something changed my faction (now " << me->getFaction() << "), changing back to " << fac << "!";
+            //BotWhisper(msg.str().c_str());
+            me->setFaction(fac);
+        }
+        //Visibility
+        if (!me->IsVisible() && master->IsVisible())
+        {
+            //BotWhisper("Something changed my visibility status! Making visible...");
+            me->SetVisible(true);
+        }
+        if (me->IsVisible() && !master->IsVisible())
+        {
+            //BotWhisper("Something changed my visibility status! Making invisible...");
+            me->SetVisible(false);
+        }
+        //end DEBUG
+
+        //Check if moving through air
+        //if (me->IsInWorld() && !JumpingFlyingOrFalling() &&
+        //    !me->HasUnitMovementFlag((MOVEMENTFLAG_ONTRANSPORT)|(MOVEMENTFLAG_DISABLE_GRAVITY)|(MOVEMENTFLAG_ROOT)|(MOVEMENTFLAG_SWIMMING)))
+        //{
+        //    //skip case such as moving back up from abyss (movement glitches)
+        //    float x,y,z;
+        //    if (!me->GetMotionMaster()->GetDestination(x,y,z) || z < me->GetPositionZ())
+        //    {
+        //        float groundz = me->GetMap()->GetHeight(me->GetPhaseMask(), me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), true, MAX_FALL_DISTANCE);
+        //        if (groundz > INVALID_HEIGHT)
+        //        {
+        //            me->GetMotionMaster()->MoveFall();
+        //        }
+        //        else if (m_botCommandState != COMMAND_STAY && !me->isMoving())
+        //        {
+        //            m_botCommandState = COMMAND_ABANDON; //reset movement after
+        //        }
+        //    }
+        //}
+
+        //Gathering
+        if (me->IsInWorld() && (_roleMask & BOT_ROLE_MASK_GATHERING) && !me->IsInCombat() && !master->IsInCombat() && !master->IsMounted() &&
+            !master->GetLootGUID() && !me->isMoving() && !master->isMoving() && master->IsStandState() && !Feasting() && !IsCasting() && !IsCasting(master))
+        {
+            //TC_LOG_ERROR("spells", "bot_ai:UpdateEx by %s, found free master, my skills: %u:", me->GetName().c_str(), uint32(_roleMask & BOT_ROLE_MASK_GATHERING));
+            std::list<WorldObject*> woList;
+            NearbyObjectBySkillCheck check(master, INTERACTION_DISTANCE - 1.0f, (_roleMask & BOT_ROLE_MASK_GATHERING));
+            Trinity::WorldObjectListSearcher<NearbyObjectBySkillCheck> searcher(me, woList, check, GRID_MAP_TYPE_MASK_CREATURE|GRID_MAP_TYPE_MASK_GAMEOBJECT);
+            me->VisitNearbyObject(20.f, searcher);
+            //TC_LOG_ERROR("spells", "bot_ai:UpdateEx: list is %s", woList.empty() ? "empty" : "not empty");
+            if (!woList.empty())
+            {
+                WorldObject* wo = Trinity::Containers::SelectRandomContainerElement(woList);
+                //TC_LOG_ERROR("spells", "bot_ai:UpdateEx: processing %s", wo->GetName().c_str());
+                if (me->GetDistance(wo) <= INTERACTION_DISTANCE * 0.5f && me->HasInArc(M_PI * 0.75f, wo))
+                {
+                    //cosmetic
+                    me->CastSpell(wo->GetTypeId() == TYPEID_UNIT ? wo->ToUnit() : me, 44079, true);
+
+                    master->SendLoot(wo->GetGUID(), LOOT_SKINNING);
+
+                    if (wo->GetTypeId() == TYPEID_UNIT)
+                        wo->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
+
+                    _updateTimerEx1 = urand(1500, 2100);
+                }
+                else
+                {
+                    std::ostringstream msg;
+                    std::string name = wo->GetName();
+                    if (wo->GetTypeId() == TYPEID_UNIT)
+                    {
+                        _LocalizeCreature(master, name, wo->GetEntry());
+                        msg << name << "..."; // TODO
+                    }
+                    else
+                    {
+                        _LocalizeGameObject(master, name, wo->GetEntry());
+                        msg << name << "!";
+                    }
+                    BotWhisper(msg.str().c_str());
+
+                    if (me->GetDistance(wo) > INTERACTION_DISTANCE * 0.5f)
+                    {
+                        Position pos;
+                        wo->GetNearPoint(me, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0.f, INTERACTION_DISTANCE * 0.5f, wo->GetAngle(me));
+                        me->GetMotionMaster()->MovePoint(me->GetMapId(), pos, false);
+                    }
+                    else
+                    {
+                        me->SetFacingTo(me->GetAngle(wo));
+                        _updateTimerEx1 = urand(1500, 1800);
+                    }
+                }
+            }
+        }
+    }
+
+    //Check current cast state: interrupt casts that became pointless
+    if (me->HasUnitState(UNIT_STATE_CASTING) && urand(1,100) <= 67)
+    {
+        bool interrupt;
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_MAX_SPELL; ++i)
+        {
+            interrupt = false;
+            Spell const* spell = me->GetCurrentSpell(CurrentSpellTypes(i));
+            if (!spell)
+                continue;
+            Unit const* target = spell->m_targets.GetUnitTarget();
+            if (!target)
+                continue;
+            SpellInfo const* info = spell->GetSpellInfo();
+            if (!info->CastTimeEntry)
+                continue;
+            if (!info->IsPositive())
+            {
+                if (!target->IsAlive())
+                    interrupt = true;
+                else if ((info->Mechanic == MECHANIC_POLYMORPH || info->Mechanic == MECHANIC_SHACKLE ||
+                    info->Mechanic == MECHANIC_DISORIENTED || info->Mechanic == MECHANIC_SLEEP ||
+                    info->Mechanic == MECHANIC_CHARM || info->Mechanic == MECHANIC_BANISH ||
+                    info->Mechanic == MECHANIC_STUN || info->Mechanic == MECHANIC_FREEZE) &&
+                    !target->getAttackers().empty() && !IsCasting(target))
+                    interrupt = true; //useless control
+                else if (target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && !IsCasting(target) &&
+                    (info->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE) && _botclass != BOT_CLASS_MAGE)
+                    interrupt = true; //useless control breaks immediately (skip glyphed poly)
+                else if (info->DmgClass == SPELL_DAMAGE_CLASS_MAGIC && !(info->Attributes & SPELL_ATTR0_ABILITY) &&
+                    !(info->AttributesEx & SPELL_ATTR1_CANT_BE_REFLECTED) &&
+                    !(info->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY) &&
+                    (target->HasAuraType(SPELL_AURA_REFLECT_SPELLS) || target->HasAuraType(SPELL_AURA_REFLECT_SPELLS_SCHOOL)))
+                    interrupt = true; // reflect
+                else if (
+                    info->Id != 64382 && //shattering throw
+                    info->Id != 32375 && //mass dispel
+                    target->IsImmunedToSpell(info))
+                    interrupt = true; // immune
+                else if (i != CURRENT_CHANNELED_SPELL && //channeled targeted spells will be interrupted in Spell::update()
+                    spell->GetCastTime() < spell->GetTimer() * 3 && // >=33% cast time remains
+                    !me->IsWithinLOSInMap(target))
+                    interrupt = true; //LoS
+                else if (info->Id == 64382 && !target->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD))
+                    interrupt = true; //Shattering Throw wasting
+            }
+            if (!interrupt && !(target == master && me->GetDistance(target) < INTERACTION_DISTANCE) &&
+                info->HasEffect(SPELL_EFFECT_HEAL) && GetHealthPCT(target) > 95)
+            {
+                bool isAreaSpell = false;
+                for (uint8 j = 0; j != 3 && isAreaSpell == false; ++j)
+                {
+                    if (info->Effects[j].IsEffect() && info->Effects[j].TargetA.GetTarget())
+                    {
+                        if (info->Effects[j].TargetA.GetSelectionCategory() == TARGET_SELECT_CATEGORY_NEARBY ||
+                            info->Effects[j].TargetA.GetSelectionCategory() == TARGET_SELECT_CATEGORY_AREA)
+                            isAreaSpell = true;
+                        if (!isAreaSpell)
+                        {
+                            switch (info->Effects[j].TargetA.GetTarget())
+                            {
+                            case TARGET_UNIT_CASTER_AREA_PARTY:
+                            case TARGET_DEST_CHANNEL_TARGET:
+                                isAreaSpell = true;
+                                break;
+                            case TARGET_UNIT_TARGET_CHAINHEAL_ALLY:
+                                //Healing Wave falls under TARGET_UNIT_TARGET_CHAINHEAL_ALLY
+                                if (info->GetFirstRankSpell()->Id == 331)
+                                    break;
+                                isAreaSpell = true;
+                                break;
+                            default:
+                                break;
+                            }
+                        }
+                        break;
+                    }
+                }
+
+                if (isAreaSpell == false)
+                {
+                    if (!IsTank(target) || target->getAttackers().empty())
+                        interrupt = true;
+                    else if (spell->GetTimer() * 3 <= spell->GetCastTime()) //<=33% cast time remains
+                        interrupt = true;
+                }
+            }
+            if (!interrupt && (info->HasEffect(SPELL_EFFECT_RESURRECT) || info->HasEffect(SPELL_EFFECT_RESURRECT_NEW)) &&
+                (target->IsAlive() || (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->isRessurectRequested())))
+                interrupt = true;
+
+            if (interrupt)
+            {
+                me->InterruptSpell(CurrentSpellTypes(i));
+                GC_Timer = 0;
+                break;
+            }
+        }
+    }
+
+    return true;
+}
+
+void bot_minion_ai::CommonTimers(uint32 diff)
+{
+    Events.Update(diff);
+    SpellTimers(diff);
+
+    if (GC_Timer > diff)            GC_Timer -= diff;
+    if (checkAurasTimer > diff)     checkAurasTimer -= diff;
+    if (waitTimer > diff)           waitTimer -= diff;
+    if (roleTimer > diff)           roleTimer -= diff;
+    if (checkMasterTimer > diff)    checkMasterTimer -= diff;
+
+    if (_powersTimer > diff)        _powersTimer -= diff;
+    if (_chaseTimer > diff)         _chaseTimer -= diff;
+
+    if (_potionTimer > diff && (_potionTimer < POTION_CD || !me->IsInCombat())) _potionTimer -= diff;
+
+    if (IAmFree())
+        UpdateReviveTimer(diff);
+
+    if (_bootTimer > int32(diff))   _bootTimer -= diff;
+
+    if (_updateTimerMedium > diff)  _updateTimerMedium -= diff;
+    if (_updateTimerEx1 > diff)     _updateTimerEx1 -= diff;
+}
+
+void bot_pet_ai::CommonTimers(uint32 diff)
+{
+    Events.Update(diff);
+    SpellTimers(diff);
+
+    if (GC_Timer > diff)            GC_Timer -= diff;
+    if (checkAurasTimer > diff)     checkAurasTimer -= diff;
+    if (waitTimer > diff)           waitTimer -= diff;
+    if (roleTimer > diff)           roleTimer -= diff;
+}
+
+void bot_minion_ai::UpdateReviveTimer(uint32 diff)
+{
+    if (me->IsAlive())
+        return;
+
+    if (_reviveTimer > diff)        _reviveTimer -= diff;
+    else
+    {
+        if (IAmFree())
+            BotMgr::ReviveBot(me);
+        else
+            if (_reviveTimer > 0)   _reviveTimer = 0;
+    }
+}
+
+void bot_minion_ai::EnterEvadeMode(bool /*force*/)
+{
+    if (_atHome && !_evadeMode)
+        return;
+    //if (me->IsInCombat())
+    //    return;
+    if (me->GetVictim())
+        return;
+    if (IsCasting())
+        return;
+    if (CCed(me, true))
+        return;
+
+
+    _atHome = true;
+
+    if (!IAmFree())
+    {
+        _evadeMode = false;
+        return;
+    }
+
+    Creature* pet = me->GetBotsPet();
+
+    //me->CombatStop();
+    //if (pet)
+    //    pet->CombatStop();
+
+    //if (!_evadeMode)
+    //{
+    //    ASSERT(!evadeEvent);
+    //    evadeEvent = new EvadeEvent(me->GetGUID(), true);
+    //    Events.AddEvent(evadeEvent, Events.CalculateTime(0));
+    //    Events.Update(0);
+    //}
+
+    uint16 mapid;
+    Position pos;
+    GetHomePosition(mapid, &pos);
+
+    if (mapid != me->GetMapId() || me->GetDistance(pos) > 2000.f || _evadeCount >= 3)
+    {
+        //TeleportHome();
+
+        if (!teleHomeEvent || teleHomeEvent->to_Abort)
+        {
+            teleHomeEvent = new TeleportHomeEvent(this);
+            Events.AddEvent(teleHomeEvent, Events.CalculateTime(5000));
+
+            //if bot has been removed manually and while in dungeon
+            if (mapid != me->GetMapId())
+            {
+                teleHomeEvent->to_Abort = true;
+                teleHomeEvent->Execute(0,0);
+            }
+        }
+        _evadeMode = false;
+        return;
+    }
+
+    float dist = me->GetDistance(pos);
+    if (dist > 1.5f)
+    {
+        if (!_evadeMode)
+            ++_evadeCount;
+        else if (me->isMoving() && Rand() > 10)
+            return;
+
+        _evadeMode = true;
+
+        //me->AddUnitState(UNIT_STATE_EVADE);
+        //if (pet)
+        //    pet->AddUnitState(UNIT_STATE_EVADE);
+
+        me->BotStopMovement();
+        if (pet)
+            pet->BotStopMovement();
+
+        bool farpoint = true;
+        if (dist > 50)
+        {
+            float dx = pos.m_positionX - me->m_positionX;
+            float dy = pos.m_positionY - me->m_positionY;
+            float fdx = fabs(dx); float fdy = fabs(dy);
+            float divider =
+                fdx > 1800 || fdy > 1800 ? 120.0f :
+                fdx > 900  || fdy > 900  ?  60.0f :
+                fdx > 600  || fdy > 600  ?  30.0f :
+                fdx > 400  || fdy > 400  ?  20.0f :
+                fdx > 200  || fdy > 200  ?  10.0f :
+                fdx > 100  || fdy > 100  ?   7.0f : 3.0f;
+            dx = dx / divider + me->m_positionX;
+            dy = dy / divider + me->m_positionY;
+            float z = me->GetMap()->GetHeight(dx, dy, me->m_positionZ);
+
+            if (z > INVALID_HEIGHT && fabs(me->m_positionZ - z) > 0.05f)
+            {
+                me->GetMotionMaster()->MovePoint(mapid, dx, dy, z + 0.1f, true);
+                farpoint = false;
+            }
+        }
+
+        if (farpoint)
+        {
+            me->GetMotionMaster()->MovePoint(mapid, pos);
+            if (pet)
+                pet->SetBotCommandState(COMMAND_FOLLOW, true);
+        }
+
+        return;
+    }
+
+    if (me->isMoving())
+        return;
+
+    _evadeMode = false;
+    _evadeCount = 0;
+
+    me->SetFacingTo(pos.GetOrientation());
+    //me->SetStandState(UNIT_STAND_STATE_SIT);
+
+    //if (evadeEvent)
+    //{
+    //    evadeEvent->to_Abort = true;
+    //    evadeEvent->Execute(evadeEvent->m_addTime, evadeEvent->m_execTime);
+    //}
+
+    //me->ClearUnitState(UNIT_STATE_EVADE);
+    //if (pet)
+    //    pet->ClearUnitState(UNIT_STATE_EVADE);
+
+    me->setFaction(me->GetCreatureTemplate()->faction_A);
+    if (pet)
+        pet->setFaction(pet->GetCreatureTemplate()->faction_A);
+
+    //RestorePositionMods();
+}
+//TeleportHome() ONLY CALLED THROUGH EVENTPROCESSOR
+void bot_minion_ai::TeleportHome()
+{
+    ASSERT(teleHomeEvent);
+    //ASSERT(IAmFree());
+
+    AbortTeleport();
+
+    uint16 mapid;
+    Position pos;
+    GetHomePosition(mapid, &pos);
+
+    Map* map = sMapMgr->CreateBaseMap(mapid);
+    ASSERT(map && !map->Instanceable());
+    BotMgr::TeleportBot(me, map, &pos);
+
+    spawned = false;
+    _evadeCount = 0;
+
+    //Reset();
+}
+//FinishTeleport(uint32, float, float, float, float) ONLY CALLED THROUGH EVENTPROCESSOR
+bool bot_minion_ai::FinishTeleport(/*uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/)
+{
+    ASSERT(teleFinishEvent);
+    //ASSERT(!IAmFree());
+    ASSERT(!me->IsInWorld());
+
+    AbortTeleport();
+
+    //1) Cannot teleport: master disappeared - return home
+    if (IAmFree()/* || master->GetSession()->isLogingOut()*/)
+    {
+        uint16 mapid;
+        Position pos;
+        GetHomePosition(mapid, &pos);
+
+        teleHomeEvent = new TeleportHomeEvent(this);
+        Events.AddEvent(teleHomeEvent, Events.CalculateTime(0)); //make sure event will be deleted
+        teleHomeEvent->to_Abort = true; //make sure event will not be executed twice
+        teleHomeEvent->Execute(0,0);
+        _evadeMode = false;
+
+        return false;
+    }
+
+    Map* map = master->FindMap();
+    //2) Cannot teleport: map not found or forbidden - delay teleport
+    if (!map || !master->IsAlive() || master->GetBotMgr()->RestrictBots(me, true))
+    {
+        //ChatHandler ch(master->GetSession());
+        //ch.PSendSysMessage("Your bot %s cannot teleport to you. Restricted bot access on this map...", me->GetName().c_str());
+        teleFinishEvent = new TeleportFinishEvent(this);
+        Events.AddEvent(teleFinishEvent, Events.CalculateTime(5000));
+        return false;
+    }
+
+    me->SetMap(map);
+    me->Relocate(master);
+    map->AddToMap(me);
+    me->BotStopMovement();
+    //bot->SetAI(oldAI);
+    me->IsAIEnabled = true;
+
+    //master->m_Controlled.insert(me);
+    me->CastSpell(me, COSMETIC_TELEPORT_EFFECT, true);
+    me->CastSpell(me, HONORLESS_TARGET, true);
+
+    //update group member online state
+    if (Group* gr = master->GetGroup())
+        if (gr->IsMember(me->GetGUID()))
+            gr->SendUpdate();
+
+    return true;
+}
+
+void bot_minion_ai::AbortTeleport()
+{
+    if (teleHomeEvent)
+    {
+        teleHomeEvent->to_Abort = true;
+        teleHomeEvent = NULL;
+    }
+
+    if (teleFinishEvent)
+    {
+        teleFinishEvent->to_Abort = true;
+        teleFinishEvent = NULL;
+    }
+
+    CancelBoot();
+}
+
+void bot_ai::GetHomePosition(uint16& mapid, Position* pos) const
+{
+    CreatureData const* data = me->GetCreatureData();
+    mapid = data->mapid;
+    pos->Relocate(data->posX, data->posY, data->posZ, data->orientation);
+}
+
+void bot_ai::KillEvents(bool force)
+{
+    Events.KillAllEvents(force);
+}
+
+int32 bot_ai::GetBotResistanceBonus(SpellSchoolMask mask) const
+{
+    int32 resist = 0;
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        if ((mask & (1 << i)) && (resist == 0 || resist > resistbonus[i-1]))
+            resist = resistbonus[i-1];
+
+    return resist;
+}
+
+bool bot_ai::IsBotImmuneToSpell(SpellInfo const* spellInfo) const
+{
+    if (spellInfo->_IsPositiveSpell())
+        return false;
+
+    if (_botclass >= BOT_CLASS_EX_START)
+    {
+        //bots of W3 classes will not be easily CCed
+        if (spellInfo->GetDuration() > 0 && spellInfo->GetDuration() <= 3000 &&
+            (spellInfo->HasAura(SPELL_AURA_MOD_STUN) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_CONFUSE) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_CHARM) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_FEAR) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_PACIFY) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_ROOT) ||
+            spellInfo->HasAura(SPELL_AURA_AOE_CHARM)))
+            return true;
+    }
+    return false;
+}
+
+MeleeHitOutcome bot_ai::BotRollCustomMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const
+{
+    if (GetNextAttackMeleeOutCome() != MELEE_HIT_CRUSHING)
+        return GetNextAttackMeleeOutCome();
+    return me->RollMeleeOutcomeAgainst(victim, attType);
+}
+
+void bot_ai::BotJumpInPlaceInFrontOf(Position const* pos, float speedXY, float maxHeight)
+{
+    float sign = (me->GetPositionX() < pos->GetPositionX()) ? 1.f : -1.f;
+    float x = me->GetPositionX() + 0.14f * sign;
+    sign = (me->GetPositionY() < pos->GetPositionY()) ? 1.f : -1.f;
+    float y = me->GetPositionY() + 0.14f * sign;
+    float z = me->GetPositionZ() - 0.01f;
+    //float floorz = Map::GetHeight(x, y, z, true, 5.f);
+
+    //me->AttackStop();
+    me->BotStopMovement();
+    me->GetMotionMaster()->MoveJump(x, y, z, speedXY, maxHeight);
+}
+
+void bot_ai::BuildGrouUpdatePacket(WorldPacket* data)
+{
+    uint32 mask = GROUP_UPDATE_FULL;
+
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)                // if update power type, update current/max power also
+        mask |= (GROUP_UPDATE_FLAG_CUR_POWER | GROUP_UPDATE_FLAG_MAX_POWER);
+
+    if (mask & GROUP_UPDATE_FLAG_PET_POWER_TYPE)            // same for pets
+        mask |= (GROUP_UPDATE_FLAG_PET_CUR_POWER | GROUP_UPDATE_FLAG_PET_MAX_POWER);
+
+    uint32 byteCount = 0;
+    for (uint8 i = 1; i < GROUP_UPDATE_FLAGS_COUNT; ++i)
+        if (mask & (1 << i))
+            byteCount += GroupUpdateLength[i];
+
+    data->Initialize(SMSG_PARTY_MEMBER_STATS, 8 + 4 + byteCount);
+    data->append(me->GetPackGUID());
+    *data << uint32(mask);
+
+    if (mask & GROUP_UPDATE_FLAG_STATUS)
+    {
+        uint16 playerStatus = MEMBER_STATUS_ONLINE;
+        if (me->IsPvP())
+            playerStatus |= MEMBER_STATUS_PVP;
+
+        if (!me->IsAlive())
+            playerStatus |= MEMBER_STATUS_DEAD;
+
+        if (me->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            playerStatus |= MEMBER_STATUS_PVP_FFA;
+
+        *data << uint16(playerStatus);
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_HP)
+        *data << uint32(me->GetHealth());
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_HP)
+        *data << uint32(me->GetMaxHealth());
+
+    Powers powerType = me->getPowerType();
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)
+        *data << uint8(powerType);
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_POWER)
+        *data << uint16(me->GetPower(powerType));
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_POWER)
+        *data << uint16(me->GetMaxPower(powerType));
+
+    if (mask & GROUP_UPDATE_FLAG_LEVEL)
+        *data << uint16(me->getLevel());
+
+    if (mask & GROUP_UPDATE_FLAG_ZONE)
+        *data << uint16(me->GetZoneId());
+
+    if (mask & GROUP_UPDATE_FLAG_POSITION)
+    {
+        *data << uint16(me->GetPositionX());
+        *data << uint16(me->GetPositionY());
+    }
+
+    //TODO: ...?
+    //if (mask & GROUP_UPDATE_FLAG_AURAS)
+    //{
+    //    uint64 auramask = player->GetAuraUpdateMaskForRaid();
+    //    *data << uint64(auramask);
+    //    for (uint32 i = 0; i < MAX_AURAS; ++i)
+    //    {
+    //        if (auramask & (uint64(1) << i))
+    //        {
+    //            AuraApplication const* aurApp = player->GetVisibleAura(i);
+    //            *data << uint32(aurApp ? aurApp->GetBase()->GetId() : 0);
+    //            *data << uint8(1);
+    //        }
+    //    }
+    //}
+
+    //if (mask & GROUP_UPDATE_FLAG_VEHICLE_SEAT)
+    //{
+    //    if (Vehicle* veh = me->GetVehicle())
+    //        *data << uint32(veh->GetVehicleInfo()->m_seatID[me->m_movementInfo.transport.seat]);
+    //    else
+    //        *data << uint32(0);
+    //}
+}
+
+//Moved from header
+uint8 bot_ai::GetBotStance() const
+{
+    return BOT_STANCE_NONE;
+}
+
+uint8 bot_ai::GetPlayerClass() const
+{
+    ASSERT(_botclass < BOT_CLASS_EX_START);
+    return _botclass;
+}
+
+uint8 bot_ai::GetBotComboPoints() const
+{
+    return uint8(GetAIMiscValue(BOTAI_MISC_COMBO_POINTS));
+}
+
+float bot_ai::GetBotAmmoDPS() const
+{
+    if (CanUseAmmo())
+        for (uint8 i = MAX_AMMO_LEVEL - 1; i >= 0; --i)
+            if (me->getLevel() >= AmmoDPSForLevel[i][0])
+                return float(AmmoDPSForLevel[i][1]);
+
+    return 0.0f;
+}
+
+bool bot_ai::IsMeleeClass(uint8 m_class)
+{
+    return
+        (m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE || m_class == CLASS_PALADIN ||
+        m_class == CLASS_DEATH_KNIGHT || m_class == BOT_CLASS_BM);
+}
+bool bot_ai::IsTankingClass(uint8 m_class)
+{
+    return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT);
+}
+bool bot_ai::IsBlockingClass(uint8 m_class)
+{
+    return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN || m_class == CLASS_SHAMAN);
+}
+bool bot_ai::IsCastingClass(uint8 m_class)
+{
+    //Class can benefit from spellpower
+    return (m_class == CLASS_PALADIN || m_class == CLASS_PRIEST ||
+        m_class == CLASS_SHAMAN || m_class == CLASS_MAGE ||
+        m_class == CLASS_WARLOCK || m_class == CLASS_DRUID);
+}
+
+bool bot_ai::IsMelee() const
+{
+    return !HasRole(BOT_ROLE_RANGED) && HasRole(BOT_ROLE_DPS|BOT_ROLE_TANK);
+}
+
+void bot_minion_ai::StartPotionTimer()
+{
+    _potionTimer = POTION_CD;
+}
+
+bool bot_ai::CanBlock() const
+{
+    if (IsMinionAI())
+        return !(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK) &&
+            me->CanUseAttackType(OFF_ATTACK);
+    return false;
+}
+bool bot_ai::CanParry() const
+{
+    if (IsMinionAI() && me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID) && me->CanUseAttackType(BASE_ATTACK))
+    {
+        switch (_botclass)
+        {
+            case BOT_CLASS_WARRIOR:
+            case BOT_CLASS_PALADIN:
+            case BOT_CLASS_ROGUE:
+            case BOT_CLASS_HUNTER:
+                return me->getLevel() >= 10;
+            case BOT_CLASS_SHAMAN:
+                return me->getLevel() >= 30;
+            case BOT_CLASS_DEATH_KNIGHT:
+                return me->getLevel() >= 55;
+            default:
+                return false;
+        }
+    }
+    return false;
+}
+bool bot_ai::CanDodge() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanCrit() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanMiss() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanHeal() const
+{
+    return
+        (_botclass == BOT_CLASS_PRIEST || _botclass == BOT_CLASS_DRUID ||
+        _botclass == BOT_CLASS_SHAMAN || _botclass == BOT_CLASS_PALADIN);
+}
+bool bot_ai::CanSheath() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanSit() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanDrink() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanMount() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanUseAmmo() const
+{
+    if ((_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE || _botclass == BOT_CLASS_WARRIOR) &&
+        ToMinionAI()->GetEquips(BOT_SLOT_RANGED))
+    {
+        ItemTemplate const* ranged = ToMinionAI()->GetEquips(BOT_SLOT_RANGED)->GetTemplate();
+        if (ranged->Class == ITEM_CLASS_WEAPON &&
+            (ranged->SubClass == ITEM_SUBCLASS_WEAPON_BOW ||
+            ranged->SubClass == ITEM_SUBCLASS_WEAPON_CROSSBOW ||
+            ranged->SubClass == ITEM_SUBCLASS_WEAPON_GUN))
+            return true;
+    }
+    return false;
+}
+bool bot_ai::RespectEquipsAttackTime() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanChangeEquip(uint8 slot) const
+{
+    if (IsMinionAI())
+        return _botclass != BOT_CLASS_BM || slot > BOT_SLOT_RANGED;
+    return false;
+}
+
+bool bot_ai::IsBotCustomSpell(uint32 spellId)
+{
+    return BotCustomSpells.find(spellId) != BotCustomSpells.end();
+}
+
+void bot_ai::InitBotCustomSpells()
+{
+    if (SPELLS_DEFINED)
+    {
+        //TC_LOG_ERROR("entities.player", "Bot custom spells initialization... fail...");
+        return;
+    }
+    //TC_LOG_ERROR("entities.player", "Bot custom spells initialization... success...");
+    SPELLS_DEFINED = true;
+
+    //see bot_ai.h::CommonValues::CUSTOM_SPELLS
+    //all ids must be here
+    //BotCustomSpells.insert(BLIZZARD_VISUAL_PERSISTENT_AURA);
+    //BotCustomSpells.insert(BLIZZARD_VISUAL_PROC);
+
+    //BotCustomSpells.insert(SPELL_COMBAT_SPECIAL_2H_ATTACK); //exclusive
+    BotCustomSpells.insert(SPELL_TRANSPARENCY_50);//3.1
+    BotCustomSpells.insert(SPELL_NETHERWALK);//3
+    BotCustomSpells.insert(SPELL_MIRROR_IMAGE_BM);//4
+
+    uint32 trig;
+    SpellInfo* trigInfo;
+    uint32 spellId;
+    SpellInfo* sinfo;
+
+    //1) BLIZZARD
+    //1.1) BLIZZARD PROC
+    //trig = BLIZZARD_VISUAL_PROC; //rain
+    //trigInfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(trig));
+
+    //trigInfo->Dispel = DISPEL_NONE;
+    //trigInfo->Mechanic = MECHANIC_NONE;
+    //trigInfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+
+    //trigInfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(1); //1 - instant //3 - 0.5 sec
+    //trigInfo->ManaCost = 0;
+    //trigInfo->ManaCostPercentage = 0;
+    //trigInfo->ManaCostPerlevel = 0;
+
+    //trigInfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    //trigInfo->Effects[0].BasePoints = 1;
+    //trigInfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_CHANNEL_TARGET);
+    //trigInfo->Effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ENEMY);
+    //trigInfo->Effects[0].ApplyAuraName = SPELL_AURA_NONE;
+    //trigInfo->Effects[0].Amplitude = 0;
+    //trigInfo->Effects[0].TriggerSpell = 0;
+    //trigInfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_8_YARDS); //14
+    ////1.1) END BLIZZARD PROC
+
+    //spellId = BLIZZARD_VISUAL_PERSISTENT_AURA; //34167, 34183
+    //sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    //sinfo->Dispel = DISPEL_NONE;
+    //sinfo->Mechanic = MECHANIC_NONE;
+    //sinfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+
+    //sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //3 - 0.5 sec
+    //sinfo->DurationEntry = sSpellDurationStore.LookupEntry(1); //1 - 10 sec //32 - 6 seconds
+    //sinfo->ManaCost = 0;
+    //sinfo->ManaCostPercentage = 74;
+    //sinfo->ManaCostPerlevel = 0;
+    //sinfo->AttributesEx2 |= SPELL_ATTR2_UNK22;
+    //sinfo->AttributesEx5 |= SPELL_ATTR5_HASTE_AFFECT_DURATION;
+    //sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+    //sinfo->InterruptFlags = 0x0000000F; //15
+    //sinfo->ChannelInterruptFlags = 0x00007C3C; //31788
+
+    //sinfo->Effects[0].Effect = SPELL_EFFECT_PERSISTENT_AREA_AURA;
+    //sinfo->Effects[0].BasePoints = 1;
+    //sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_DYNOBJ_ENEMY);
+    //sinfo->Effects[0].TargetB = SpellImplicitTargetInfo(0);
+    //sinfo->Effects[0].ApplyAuraName = SPELL_AURA_DUMMY;
+    //sinfo->Effects[0].Amplitude = 0;
+    //sinfo->Effects[0].TriggerSpell = 0;
+    //sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_8_YARDS); //14
+
+    //sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+    //sinfo->Effects[1].BasePoints = 1;
+    //sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    //sinfo->Effects[1].TargetB = SpellImplicitTargetInfo(0);
+    //sinfo->Effects[1].ApplyAuraName = SPELL_AURA_PERIODIC_TRIGGER_SPELL;
+    //sinfo->Effects[1].Amplitude = 2000;
+    //sinfo->Effects[1].TriggerSpell = trig;
+    //sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_8_YARDS); //14
+    //1) END BLIZZARD
+    {}
+    //2) SPELL_COMBAT_SPECIAL_2H_ATTACK
+    spellId = SPELL_COMBAT_SPECIAL_2H_ATTACK; //1132
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+    sinfo->Attributes &= ~(SPELL_ATTR0_CANT_USED_IN_COMBAT);
+    sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_DEAD;
+    //2) END SPELL_COMBAT_SPECIAL_2H_ATTACK
+
+    //3) WINDWALK
+    //3.1) TRANSPARENCY
+    trig = SPELL_TRANSPARENCY_50; //44816
+    trigInfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(trig));
+    trigInfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING);
+    trigInfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH);
+    trigInfo->AuraInterruptFlags =
+        AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+    trigInfo->CasterAuraStateNot = 0;
+    //3.1) END TRANSPARENCY
+
+
+    spellId = SPELL_NETHERWALK; //31599
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellLevel = 0;
+    sinfo->MaxLevel = 80;
+    sinfo->RecoveryTime = 5000;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->ManaCost = 75;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->Attributes &= ~(SPELL_ATTR0_UNK11);
+    sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY);
+    sinfo->AttributesEx &= ~SPELL_ATTR1_UNK11;
+    sinfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH | SPELL_ATTR1_NO_THREAT);
+    sinfo->AttributesEx2 |= SPELL_ATTR2_UNK1;
+    sinfo->AuraInterruptFlags =
+        AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+    sinfo->CasterAuraStateNot = 0;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[0].BasePoints = 100;
+    sinfo->Effects[0].RealPointsPerLevel = 2.5f;
+    sinfo->Effects[0].ValueMultiplier = 1.0f;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[0].ApplyAuraName = SPELL_AURA_MOD_INVISIBILITY;
+    sinfo->Effects[0].Amplitude = 0;
+    sinfo->Effects[0].TriggerSpell = 0;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+
+    sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[1].BasePoints = 10;
+    sinfo->Effects[1].RealPointsPerLevel = 0.5f;
+    sinfo->Effects[1].ValueMultiplier = 1.0f;
+    sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[1].TargetB = SpellImplicitTargetInfo(0);
+    sinfo->Effects[1].ApplyAuraName = SPELL_AURA_MOD_INCREASE_SPEED;
+    sinfo->Effects[1].Amplitude = 0;
+    sinfo->Effects[1].TriggerSpell = 0;
+    sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+
+    sinfo->Effects[2].Effect = SPELL_EFFECT_TRIGGER_SPELL;
+    sinfo->Effects[2].BasePoints = 0;
+    sinfo->Effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[2].TargetB = SpellImplicitTargetInfo(0);
+    sinfo->Effects[2].ApplyAuraName = SPELL_AURA_NONE;
+    sinfo->Effects[2].Amplitude = 0;
+    sinfo->Effects[2].TriggerSpell = trig;
+    sinfo->Effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+    //3) END WINDWALK
+
+    //4) MIRROR IMAGE (BLADEMASTER)
+    spellId = SPELL_MIRROR_IMAGE_BM; //69936
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //1 - self only //6 - 100 yds
+    sinfo->DurationEntry = sSpellDurationStore.LookupEntry(566); //566 - 0 sec //3 - 60 sec //1 - 10 sec //32 - 6 seconds
+    sinfo->RecoveryTime = 8000;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->ManaCost = 125;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT/* | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY*/);
+    sinfo->AttributesEx2 &= ~(SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS);
+    sinfo->AttributesEx3 |= SPELL_ATTR3_DONT_DISPLAY_RANGE;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[0].MiscValue = 0;
+    sinfo->Effects[0].MiscValueB = 0;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+    //4) END MIRROR IMAGE (BLADEMASTER)
+}
diff --git a/src/server/game/AI/NpcBots/bot_ai.h b/src/server/game/AI/NpcBots/bot_ai.h
new file mode 100644
index 0000000..10735e2
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.h
@@ -0,0 +1,543 @@
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+#include "ScriptedCreature.h"
+#include "botcommon.h"
+/*
+NpcBot System by Trickerer (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+*/
+
+struct PlayerClassLevelInfo;
+
+class TeleportHomeEvent;
+class TeleportFinishEvent;
+
+class bot_ai : public ScriptedAI
+{
+    friend class BotMgr;
+    friend class script_bot_commands;
+    friend class FarTauntUnitCheck;
+    private:
+        void SetBotOwnerGUID(uint32 guidlow) { _ownerGuid = guidlow; }
+    public:
+        virtual ~bot_ai();
+        bot_ai(Creature* creature);
+        //void OnCharmed(bool /*apply*/) {}
+        EventProcessor* GetEvents() { return &Events; }
+        uint32 GetBotOwnerGuid() const { return _ownerGuid; }
+        Player* GetBotOwner() const { return master; }
+        bool SetBotOwner(Player* newowner);
+        uint8 GetBotClass() const { return _botclass; }
+        uint32 GetLastDiff() const { return lastdiff; }
+        virtual void UpdateDeadAI(uint32 /*diff*/) {}
+        virtual void Reset() {}
+        virtual void EnterEvadeMode() {}
+        virtual void JustDied(Unit*) {}
+        virtual void EnterCombat(Unit*) {}
+        virtual void MoveInLineOfSight(Unit*) {}
+        virtual void ReturnHome() {}
+        virtual void CommonTimers(uint32 /*diff*/) = 0;
+        void ResetBotAI(uint8 resetType);
+        void KillEvents(bool force);
+        void FindMaster(bool force = false);
+        virtual bool IsMinionAI() const = 0;
+        virtual bool IsPetAI() const = 0;
+        virtual bool CanRespawn() = 0;
+        virtual void SetBotCommandState(CommandStates /*st*/, bool /*force*/ = false, Position* /*newpos*/ = NULL) = 0;
+        virtual bot_minion_ai const* GetMinionAI() const { return NULL; }
+        virtual bot_pet_ai const* GetPetAI() const { return NULL; }
+        //bot_minion_ai const* ToMinionAI() const { return IsMinionAI() ? GetMinionAI() : NULL; }
+        bot_minion_ai* ToMinionAI() const { return IsMinionAI() ? const_cast<bot_minion_ai*>(GetMinionAI()) : NULL; }
+        //bot_pet_ai const* ToPetAI() const { return IsPetAI() ? GetPetAI() : NULL; }
+        bot_pet_ai* ToPetAI() const { return IsPetAI() ? const_cast<bot_pet_ai*>(GetPetAI()) : NULL; }
+        bool IsInBotParty(Unit const* unit) const;
+        bool CanBotAttack(Unit const* target, int8 byspell = 0) const;
+        //bool InDuel(Unit const* target) const;
+        CommandStates GetBotCommandState() const { return m_botCommandState; }
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+        void ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const;
+        void ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const;
+        void ApplyBotSpellCostMods(SpellInfo const* spellInfo, int32& cost) const;
+        void ApplyBotSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const;
+        void ApplyBotSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const;
+        void ApplyBotSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const;
+        void ApplyBotSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const;
+        void ApplyBotSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const;
+        void ApplyBotSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const;
+        void ApplyBotSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const;
+        void ApplyBotSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const;
+        float CalcSpellMaxRange(uint32 spellId, bool enemy = true) const;
+        //inline void SendPartyEvadeAbort() const;
+        inline void SetShouldUpdateStats() { shouldUpdateStats = true; }
+        inline void UpdateHealth() { doHealth = true; }
+        inline void UpdateMana() { doMana = true; }
+        //inline float GetHitRating() const { return hit; }
+        inline int32 GetHaste() const { return haste; }
+        inline uint32 GetShieldBlockValue() const { return blockvalue; }
+        virtual uint8 GetBotStance() const;
+        inline uint16 GetBotRoles() const { return _roleMask; }
+        inline bool HasRole(uint16 role) const { return _roleMask & role; }
+        void ToggleRole(uint16 role, bool force);
+        char const* GetRoleString(uint16 role) const;
+
+        virtual void OnBotSummon(Creature* /*summon*/) {}
+        virtual void OnBotDespawn(Creature* /*summon*/) {}
+        virtual void UnsummonAll() {}
+
+        void ReceiveEmote(Player* player, uint32 emote);
+
+        static inline bool CCed(Unit const* target, bool root = false)
+        {
+            return target ? target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE) || (root && (target->HasUnitState(UNIT_STATE_ROOT) || target->isFrozen() || target->isInRoots())) : true;
+        }
+
+        virtual void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType);
+        virtual bool IAmFree() const { return false; }
+
+        virtual void SetStats(bool) = 0;
+        void DefaultInit();
+
+        void GetHomePosition(uint16& mapid, Position* pos) const;
+
+        virtual bool UpdateImpossibleChase(Unit const* /*target*/) { return false; }
+        virtual bool IsDuringTeleport() const { return false; }
+        virtual void AbortTeleport() {}
+        virtual void ResetChase(Position const* /*pos*/) {}
+
+        virtual uint8 GetPlayerClass() const;
+
+        float GetBotParryChance() const { return parry; }
+        float GetBotDodgeChance() const { return dodge; }
+        float GetBotBlockChance() const { return block; }
+        float GetBotCritChance() const { return crit; }
+        float GetBotMissChance() const { return -hit; }
+        bool CanBlock() const;
+        inline bool CanParry() const;
+        inline bool CanDodge() const;
+        inline bool CanCrit() const;
+        inline bool CanMiss() const;
+        inline bool CanHeal() const;
+        inline bool CanSheath() const;
+        inline bool CanSit() const;
+        inline bool CanDrink() const;
+        inline bool CanMount() const;
+        inline bool CanUseAmmo() const;
+        inline bool RespectEquipsAttackTime() const;
+        inline bool CanChangeEquip(uint8 slot) const;
+        virtual bool CanEat() const { return IsMinionAI(); }
+        virtual bool CanSeeEveryone() const { return false; }
+        virtual float GetBotArmorPenetrationCoef() const { return armor_pen; }
+        virtual uint32 GetAIMiscValue(uint32 /*data*/) const { return 0; }
+        virtual void SetAIMiscValue(uint32 /*data*/, uint32 /*value*/) {}
+        float GetBotDamageTakenMod() const { return dmg_taken; }
+        uint32 GetBotExpertise() const { return expertise; }
+        uint32 GetBotSpellPenetration() const { return spellpen; }
+        uint32 GetBotSpellPower() const { return spellpower; }
+        uint32 GetBotDefense() const { return defense; }
+        int32 GetBotResistanceBonus(SpellSchoolMask mask) const;
+        int32 GetBotResistanceBonus(uint8 school) const { return (school > SPELL_SCHOOL_NORMAL && school < MAX_SPELL_SCHOOL) ? resistbonus[school-1] : 0; }
+        uint8 GetBotComboPoints() const;
+        float GetBotAmmoDPS() const;
+
+        virtual bool IsBotImmuneToSpell(SpellInfo const* spellInfo) const;
+
+        MeleeHitOutcome BotRollCustomMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const;
+
+        virtual void CastBotItemCombatSpell(Unit* /*target*/, WeaponAttackType /*attType*/, uint32 /*procVictim*/, uint32 /*procEx*/) {}
+        void OnBotSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs);
+        void OnBotSpellGo(Spell const* spell);
+        virtual void OnClassSpellGo(SpellInfo const* /*spell*/) {}
+
+        static void InitBotCustomSpells();
+        static bool IsBotCustomSpell(uint32 spellId);
+
+        bool IsTempBot() const { return me->GetDBTableGUIDLow() == 0; }
+
+        void StartBoot() { _bootTimer = 60000; }
+        void CancelBoot() { _bootTimer = -1; }
+
+        bool IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD = true) const;
+        void SetSpellCooldown(uint32 basespell, uint32 msCooldown);
+        void SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown);
+        void ReleaseSpellCooldown(uint32 basespell);
+    protected:
+        static uint32 InitSpell(Unit const* caster, uint32 spell);
+        void InitSpellMap(uint32 basespell, bool forceadd = false, bool forwardRank = true);
+        uint32 GetSpell(uint32 basespell) const;
+        uint32 GetSpellCooldown(uint32 basespell) const;
+        void ResetSpellCooldown(uint32 basespell) { SetSpellCooldown(basespell, 0); }
+        void RemoveSpell(uint32 basespell);
+        void SpellTimers(uint32 diff);
+        static inline uint32 RaceSpellForClass(uint8 myrace, uint8 myclass);
+
+        virtual void InitRoles() = 0;
+        bool IsTank(Unit const* unit = NULL) const;
+
+        bool RefreshAura(uint32 spellId, int8 count = 1) const;
+        bool CheckAttackTarget(uint8 botClassOrPetType);
+        void MoveBehind(Unit const* target) const;
+
+        //everything cast-related
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false);
+        bool doCast(Unit* victim, uint32 spellId, TriggerCastFlags flags);
+        SpellCastResult CheckBotCast(Unit const* victim, uint32 spellId, uint8 botclass) const;
+        virtual bool removeShapeshiftForm() { return true; }
+
+        bool CanAffectVictim(uint32 schoolMask) const;
+        bool CanRemoveReflectSpells(Unit const* target, uint32 spellId) const;
+
+        inline bool JumpingFlyingOrFalling() const { return me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_SPLINE_ELEVATION|MOVEMENTFLAG_FALLING_SLOW); }
+        inline bool JumpingOrFalling() const { return me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_FALLING_SLOW); }
+        static bool IsMeleeClass(uint8 m_class);
+        static bool IsTankingClass(uint8 m_class);
+        static bool IsBlockingClass(uint8 m_class);
+        static bool IsCastingClass(uint8 m_class);
+        inline bool IsMelee() const;
+        inline bool IsChanneling(Unit const* u = NULL) const { if (!u) u = me; return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
+        inline bool IsCasting(Unit const* u = NULL) const { if (!u) u = me; return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCasted(false, false, true, false, false)); }
+
+        void GetInPosition(bool force, Unit* newtarget, Position* pos = NULL);
+        void OnSpellHit(Unit* caster, SpellInfo const* spell);
+        void CalculateAttackPos(Unit const* target, Position &pos) const;
+        virtual void CheckAttackState();
+        virtual void Evade(bool = false) {}
+
+        //Bot specific player-like mods hooks
+        virtual void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+        virtual void ApplyClassDamageMultiplierMelee(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& /*heal*/, SpellInfo const* /*spellInfo*/, DamageEffectType /*damagetype*/, uint32 /*stack*/) const {}
+        virtual void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& /*crit_chance*/, SpellInfo const* /*spellInfo*/, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const {}
+        virtual void ApplyClassSpellCostMods(SpellInfo const* /*spellInfo*/, int32& /*cost*/) const {}
+        virtual void ApplyClassSpellCastTimeMods(SpellInfo const* /*spellInfo*/, int32& /*casttime*/) const {}
+        virtual void ApplyClassSpellCooldownMods(SpellInfo const* /*spellInfo*/, uint32& /*cooldown*/) const {}
+        virtual void ApplyClassSpellCategoryCooldownMods(SpellInfo const* /*spellInfo*/, uint32& /*cooldown*/) const {}
+        virtual void ApplyClassSpellGlobalCooldownMods(SpellInfo const* /*spellInfo*/, float& /*cooldown*/) const {}
+        virtual void ApplyClassSpellRadiusMods(SpellInfo const* /*spellInfo*/, float& /*radius*/) const {}
+        virtual void ApplyClassSpellRangeMods(SpellInfo const* /*spellInfo*/, float& /*maxrange*/) const {}
+        virtual void ApplyClassSpellMaxTargetsMods(SpellInfo const* /*spellInfo*/, uint32& /*targets*/) const {}
+        virtual void ApplyClassSpellChanceOfSuccessMods(SpellInfo const* /*spellInfo*/, float& /*chance*/) const {}
+        virtual void CheckAuras(bool /*force*/ = false) = 0;
+        virtual void InitSpells() {}
+        virtual void InitPowers() {}
+        virtual void InitEquips() {}
+        virtual void InitOwner() {}
+        virtual void InitFaction() {}
+        virtual void ApplyRacials() {}
+        virtual void ApplyClassPassives() {}
+        virtual void _OnHealthUpdate() const = 0;
+        virtual void _OnManaUpdate() const = 0;
+        virtual void Regenerate() = 0;
+
+        virtual bool Feasting() const { return false; }
+
+        bool Wait();
+        inline float InitAttackRange(float origRange, bool ranged) const;
+        inline uint16 Rand() const;
+        void GenerateRand() const;
+        static inline uint32 GetLostHP(Unit const* unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
+        static inline uint8 GetHealthPCT(Unit const* u) { if (!u || !u->IsAlive() || !u->GetMaxHealth()) return 100; return uint8(((float(u->GetHealth()))/u->GetMaxHealth()) * 100); }
+        static inline uint8 GetManaPCT(Unit const* u) { if (!u || !u->IsAlive() || u->GetMaxPower(POWER_MANA) <= 1) return 100; return (u->GetPower(POWER_MANA)*100/(u->GetMaxPower(POWER_MANA))); }
+
+        virtual MeleeHitOutcome GetNextAttackMeleeOutCome() const { return MELEE_HIT_CRUSHING; }
+
+        //event helpers
+        void BotJumpInPlaceInFrontOf(Position const* pos, float speedXY, float maxHeight);
+
+        //utilities
+        void _AddItemTemplateLink(Player const* forPlayer, ItemTemplate const* item, std::ostringstream &str) const;
+        void _AddItemLink(Player const* forPlayer, Item const* item, std::ostringstream &str, bool addIcon = true) const;
+        void _AddQuestLink(Player const* forPlayer, Quest const* quest, std::ostringstream &str) const;
+        void _AddWeaponSkillLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const;
+        void _AddSpellLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, bool color = true) const;
+        void _AddProfessionLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const;
+        void _LocalizeItem(Player const* forPlayer, std::string &itemName, uint32 entry) const;
+        void _LocalizeItem(Player const* forPlayer, std::string &itemName, std::string &suffix, Item const* item) const;
+        void _LocalizeQuest(Player const* forPlayer, std::string &questTitle, uint32 entry) const;
+        void _LocalizeCreature(Player const* forPlayer, std::string &creatureName, uint32 entry) const;
+        void _LocalizeGameObject(Player const* forPlayer, std::string &gameobjectName, uint32 entry) const;
+
+        void BuildGrouUpdatePacket(WorldPacket* data);
+
+        void BotSay(char const* text, Player const* target = NULL) const;
+        void BotWhisper(char const* text, Player const* target = NULL) const;
+        void BotYell(char const* text, Player const* target = NULL) const;
+
+        struct BotSpell
+        {
+            BotSpell() : cooldown(0), enabled(true) {}
+            uint32 spellId;
+            uint32 cooldown;
+            bool enabled;
+        private:
+            BotSpell(BotSpell const&);
+        };
+        typedef UNORDERED_MAP<uint32 /*firstrankspellid*/, BotSpell* /*spell*/> BotSpellMap;
+
+        BotSpellMap const& GetSpellMap() const { return _spells; }
+
+        Player* master;
+        Unit* opponent;
+        CommandStates m_botCommandState;
+        SpellInfo const* m_botSpellInfo;
+        Position pos, attackpos;
+        uint64 aftercastTargetGuid;
+        uint32 GC_Timer, checkAurasTimer, checkMasterTimer, roleTimer, waitTimer, regenTimer;
+        bool doHealth, doMana, shouldUpdateStats;
+
+        //stats
+        float hit, parry, dodge, block, crit, dmg_taken, armor_pen;
+        uint32 expertise, spellpower, spellpen, defense, blockvalue;
+        int32 haste, resistbonus[6];
+
+        uint32 lastdiff;
+
+        uint8 _botclass;
+        uint16 _roleMask;
+        uint32 _ownerGuid;
+        bool feast_health, feast_mana;
+        bool spawned;
+        bool firstspawn;
+        bool _evadeMode;
+        bool _atHome;
+
+        int32 _bootTimer;
+        uint32 _updateTimerMedium, _updateTimerEx1;
+
+        //counters (this session)
+        uint16 _deathsCount;
+        uint16 _killsCount;
+        uint16 _pvpKillsCount;
+        uint16 _playerKillsCount;
+
+        EventProcessor Events;
+
+        TeleportHomeEvent* teleHomeEvent;
+        TeleportFinishEvent* teleFinishEvent;
+
+    private:
+        Unit* _getTarget(bool byspell, bool ranged, bool &reset) const;
+        void _listAuras(Player const* player, Unit const* unit) const;
+        bool _checkImmunities(Unit const* target, SpellInfo const* spellInfo) const;
+        static inline float _getAttackDistance(float distance) { return distance*0.72f; }
+
+        BotSpellMap _spells;
+};
+
+class bot_minion_ai : public bot_ai
+{
+    public:
+        virtual ~bot_minion_ai();
+        bot_minion_ai(Creature* creature);
+        virtual void UpdateDeadAI(uint32 diff);
+        virtual void Reset() {}
+        virtual void EnterEvadeMode() { EnterEvadeMode(false); }
+        void EnterEvadeMode(bool force);
+        virtual void JustDied(Unit*);
+        virtual void KilledUnit(Unit* u);
+        virtual void EnterCombat(Unit* u);
+        virtual void MoveInLineOfSight(Unit* u);
+        void ReturnHome() { _atHome = false; }
+        void CommonTimers(uint32 diff);
+        const bot_minion_ai* GetMinionAI() const { return this; }
+        bool IsMinionAI() const { return true; }
+        bool IsPetAI() const { return false; }
+        bool CanRespawn() { return IAmFree(); }
+        void SummonBotsPet(uint32 entry);
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        virtual bool HealTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        void CureGroup(uint32 cureSpell, uint32 diff);
+        void CheckAuras(bool force = false);
+        void SetStats(bool force);
+
+        static bool OnGossipHello(Player* player, Creature* creature, uint32 option);
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
+        bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code);
+
+        void InitSpells() {}
+        void InitPowers() {}
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate() const;
+        void _OnManaRegenUpdate() const;
+
+        void RemoveItemBonuses(uint8 slot);
+        void ApplyItemBonuses(uint8 slot);
+        void RemoveItemEnchantments(Item const* item);
+        void RemoveItemEnchantment(Item const* item, EnchantmentSlot eslot);
+        void RemoveItemClassEnchants();
+        void ApplyItemEnchantments(Item* item, uint8 slot);
+        void ApplyItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot);
+        void ApplyItemEquipSpell(Item* item, bool apply);
+        void ApplyItemEquipEnchantmentSpells(Item* item);
+        void ApplyItemsSpells();
+
+        void OnOwnerDamagedBy(Unit* attacker);
+
+        uint32 GetReviveTimer() const { return _reviveTimer; }
+        void SetReviveTimer(uint32 newtime) { _reviveTimer = newtime; }
+        void UpdateReviveTimer(uint32 diff);
+
+        bool IAmFree() const;
+        void TeleportHome();
+        bool FinishTeleport(/*uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/);
+
+        bool IsDuringTeleport() const { return teleFinishEvent || teleHomeEvent; }
+        void SetTeleportFinishEvent(TeleportFinishEvent* tfevent) { ASSERT(!teleFinishEvent); teleFinishEvent = tfevent; }
+        void AbortTeleport();
+
+        void ResetChase(Position const* pos);
+        void ResetChaseTimer(Position const* pos);
+        bool UpdateImpossibleChase(Unit const* target);
+        void BotJump(Position const* pos);
+
+        bool IsPotionSpell(uint32 spellId) const;
+        inline void StartPotionTimer();
+
+        void CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx);
+        void CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto);
+
+        float GetTotalBotStat(uint8 stat) const { return _getTotalBotStat(stat); }
+
+        Item* GetEquips(uint8 slot) const { return _equips[slot]; }
+        Item* GetEquipsByGuid(uint64 itemGuid) const;
+
+    protected:
+        bool GlobalUpdate(uint32 diff);
+
+        virtual bool CanUseManually(uint32 /*basespell*/) const { return false; }
+        virtual bool HasAbilitiesSpecifics() const { return false; }
+        virtual bool HasAblitiesAllowedList() const { return true; }
+        virtual void FillAbilitiesSpecifics(std::list<std::string> &/*specList*/) {}
+        void BuffAndHealGroup(uint32 diff);
+        void RezGroup(uint32 REZZ);
+
+        void Follow(bool force = false, Position* newpos = NULL)
+        {
+            if (force ||
+                (me->IsAlive() && (!me->IsInCombat() || !opponent) && m_botCommandState != COMMAND_STAY))
+                SetBotCommandState(COMMAND_FOLLOW, force, newpos);
+        }
+
+        void AdjustTankingPosition() const;
+        void Evade(bool force = false);
+        void OnStartAttack(Unit const* u);
+
+        virtual void BreakCC(uint32 diff);
+        void CheckRacials(uint32 diff);
+
+        void ApplyRacials();
+        void InitRoles();
+        void InitEquips();
+        void InitOwner();
+        void InitFaction();
+
+        virtual void RegenerateEnergy() {}
+        void Regenerate();
+        bool Feasting() const;
+        uint32 GetRation(bool drink) const;
+
+        void DrinkPotion(bool mana);
+        bool IsPotionReady() const;
+        uint32 GetPotion(bool mana) const;
+
+        WorldObject* GetNearbyRezTarget(float dist = 30) const;
+        Unit* FindImmunityShieldDispelTarget(float dist = 30) const;
+        Unit* FindHostileDispelTarget(float dist = 30, bool stealable = false) const;
+        Unit* FindAffectedTarget(uint32 spellId, uint64 caster = 0, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0) const;
+        Unit* FindPolyTarget(float dist = 30) const;
+        Unit* FindFearTarget(float dist = 30) const;
+        Unit* FindStunTarget(float dist = 20) const;
+        Unit* FindUndeadCCTarget(float dist, uint32 spellId, bool unattacked = true) const;
+        Unit* FindRootTarget(float dist, uint32 spellId) const;
+        Unit* FindCastingTarget(float maxdist = 10, float mindist = 0, uint32 spellId = 0, uint8 minHpPct = 0) const;
+        Unit* FindAOETarget(float dist = 30, bool checkbots = false, bool targetfriend = true) const;
+        Unit* FindSplashTarget(float dist = 5, Unit* To = NULL, float splashdist = 4) const;
+        Unit* FindSplashTarget(float dist, Unit* To, float splashdist, uint8 minTargets) const;
+        Unit* FindTranquilTarget(float mindist = 5, float maxdist = 35) const;
+        Unit* FindDistantTauntTarget(float maxdist = 30, bool ally = false) const;
+        void GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist = 10, bool forCC = false, WorldObject const* source = NULL) const;
+        void GetNearbyTargetsInConeList(std::list<Unit*> &targets, float maxdist = 10) const;
+        void GetNearbyFriendlyTargetsList(std::list<Unit*> &targets, float maxdist = 30) const;
+
+    private:
+        bool _canCureTarget(Unit const* target, uint32 cureSpell) const;
+        void _getBotDispellableAuraList(Unit const* target, Unit const* caster, uint32 dispelMask, std::list<Aura const*> &dispelList) const;
+        void _calculatePos(Position& pos);
+        void _updateMountedState();
+        void _updateStandState() const;
+        void _updateRations();
+        char const* _getNameForSlot(uint8 slot) const;
+        uint8 _onOffIcon(uint16 role) const;
+        void _updateEquips(uint8 slot, Item* item);
+
+        bool _canUseOffHand() const;
+        bool _canUseRanged() const;
+        bool _canEquip(ItemTemplate const* item, uint8 slot, bool ignoreItemLevel = false) const;
+        bool _unequip(uint8 slot);
+        bool _equip(uint8 slot, Item* newItem);
+        bool _resetEquipment(uint8 slot);
+
+        void _castBotItemUseSpell(Item const* item, SpellCastTargets const& targets, uint8 cast_count = 0, uint32 glyphIndex = 0);
+
+        typedef UNORDERED_MAP<uint32 /*stat*/, int32 /*statvalue*/> BotStat;
+        BotStat _stats[BOT_INVENTORY_SIZE];
+        Item* _equips[BOT_INVENTORY_SIZE];
+        float _getBotStat(uint8 slot, uint8 stat) const;
+        float _getTotalBotStat(uint8 stat) const;
+        float _getRatingMultiplier(CombatRating cr) const;
+
+        PlayerClassLevelInfo* _classinfo;
+        uint32 _reviveTimer, _powersTimer, _chaseTimer, _potionTimer;
+        uint8 _jumpCount;
+        uint8 _evadeCount;
+        uint64 _lastTargetGuid;
+};
+
+class bot_pet_ai : public bot_ai
+{
+    public:
+        virtual ~bot_pet_ai();
+        bot_pet_ai(Creature* creature);
+        virtual void Reset() {}
+        const bot_pet_ai* GetPetAI() const { return this; }
+        Creature* GetCreatureOwner() const { return m_creatureOwner; }
+        bool IsMinionAI() const { return false; }
+        bool IsPetAI() const { return true; }
+        bool CanRespawn() { return false; }
+        void CommonTimers(uint32 diff);
+        inline bool IAmDead() const { return (!master || !m_creatureOwner || !me->IsAlive()); }
+        //void SetCreatureOwner(Creature* newowner) { m_creatureOwner = newowner; }
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        //void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
+        //void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void SetStats(bool force);
+
+        static uint8 GetPetType(Creature const* pet);
+        static uint8 GetPetClass(Creature const* pet);
+        static uint32 GetPetOriginalEntry(uint32 entry);
+
+        void InitSpells() {}
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate() const;
+        void SetBaseArmor(uint32 armor) { basearmor = armor; }
+
+    protected:
+        void InitRoles();
+
+        void Regenerate();
+
+        Creature* m_creatureOwner;
+    private:
+        uint32 basearmor;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_bm_ai.cpp b/src/server/game/AI/NpcBots/bot_bm_ai.cpp
new file mode 100644
index 0000000..e5b5bd8
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_bm_ai.cpp
@@ -0,0 +1,974 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+//#include "WorldSession.h"
+/*
+Blademaster NpcBot (by Trickerer onlysuffering@gmail.com)
+Complete - Around 30%
+TODO: MIRROR IMAGE (ILLUSION), BLADESTORM
+*/
+
+#define MAX_ILLUSION_POSITIONS 4
+#define MIRROR_IMAGE_DURATION 90000
+
+class blademaster_bot : public CreatureScript
+{
+public:
+    blademaster_bot() : CreatureScript("blademaster_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new blademaster_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct blademaster_botAI : public bot_minion_ai
+    {
+    private:
+        //DelayedMeleeDamageEvent - Blademaster
+        //deals critical damage, resets attack timer and sends fake log
+        class DelayedMeleeDamageEvent : public BasicEvent
+        {
+            public:
+                DelayedMeleeDamageEvent(uint64 botGuid, uint64 targetGuid, bool windwalk) :
+                  _botGuid(botGuid), _targetGuid(targetGuid), _windwalk(windwalk), _dinfo(NULL) { }
+
+                void SetDamageInfo(CalcDamageInfo* dinfo)
+                {
+                    _dinfo = dinfo;
+                }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    if (Creature* bot = sObjectAccessor->GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                        (dynamic_cast<blademaster_botAI*>(bot->GetBotMinionAI()))->CriticalStrikeFinish(_targetGuid, _dinfo, _windwalk);
+
+                    if (_dinfo)
+                        delete _dinfo;
+                    return true;
+                }
+
+            private:
+                uint64 _botGuid;
+                uint64 _targetGuid;
+                bool _windwalk;
+                CalcDamageInfo* _dinfo;
+                DelayedMeleeDamageEvent(DelayedMeleeDamageEvent const&);
+        };
+
+        class EventTerminateEvent : public BasicEvent
+        {
+            public:
+                EventTerminateEvent(uint64 botGuid) : _botGuid(botGuid) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    if (Creature* bot = sObjectAccessor->GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                        (dynamic_cast<blademaster_botAI*>(bot->GetBotMinionAI()))->TerminateEvent();
+                    return true;
+                }
+
+            private:
+                uint64 _botGuid;
+                EventTerminateEvent(EventTerminateEvent const&);
+        };
+
+        class IllusionUnsummonEvent : public BasicEvent
+        {
+            public:
+                IllusionUnsummonEvent(uint64 botGuid) : _botGuid(botGuid) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    if (Creature* bot = sObjectAccessor->GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                        (dynamic_cast<blademaster_botAI*>(bot->GetBotMinionAI()))->UnsummonAll();
+
+                    return true;
+                }
+
+            private:
+                uint64 _botGuid;
+                IllusionUnsummonEvent(IllusionUnsummonEvent const&);
+        };
+
+        class DelayedIllusionSummonEvent : public BasicEvent
+        {
+            public:
+                DelayedIllusionSummonEvent(uint64 botGuid) : _botGuid(botGuid) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    if (Creature* bot = sObjectAccessor->GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                        (dynamic_cast<blademaster_botAI*>(bot->GetBotMinionAI()))->MirrorImageFinish();
+
+                    return true;
+                }
+
+            private:
+                uint64 _botGuid;
+                DelayedIllusionSummonEvent(DelayedIllusionSummonEvent const&);
+        };
+
+        class DisappearEvent : public BasicEvent
+        {
+            public:
+                DisappearEvent(uint64 botGuid) : _botGuid(botGuid) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    if (Creature* bot = sObjectAccessor->GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                        (dynamic_cast<blademaster_botAI*>(bot->GetBotMinionAI()))->MirrorImageMid();
+
+                    return true;
+                }
+
+            private:
+                uint64 _botGuid;
+                DisappearEvent(DisappearEvent const&);
+        };
+
+        void _calcIllusionPositions()
+        {
+            float x = me->m_positionX;
+            float y = me->m_positionY;
+            float o = me->m_orientation;
+
+            //X     X
+            //   C
+            //X     X
+            //
+            //C - caster (Blademaster)
+            //X - new positions (1-3 illusions + blademaster)
+
+            float dist = 2.f; //not too far - 2 for x and y seems to be way to go
+            for (uint8 i = 0; i != MAX_ILLUSION_POSITIONS; ++i)
+            {
+                _illusPos[i].m_positionX = x + ((i == 0 || i == 1) ? +dist : -dist); // +2+2-2-2
+                _illusPos[i].m_positionY = y + (!(i & 1) ? +dist : -dist);           // +2-2+2-2
+                _illusPos[i].m_orientation = o;
+            }
+        }
+
+    public:
+        blademaster_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_BM;
+            //Blademaster cannot be disarmed
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, SPELL_AURA_MOD_DISARM, true);
+        }
+
+        void IllusionsCheck(uint32 diff)
+        {
+            if (Illusions_Check_Timer > diff)
+                return;
+
+            Illusions_Check_Timer = 250;
+
+            if (_illusionGuids.empty())
+                return;
+
+            for (std::list<uint64>::const_iterator itr = _illusionGuids.begin(); itr != _illusionGuids.end(); ++itr)
+            {
+                Creature* ill = sObjectAccessor->GetObjectInWorld(*itr, (Creature*)NULL);
+                if (!ill)
+                {
+                    TC_LOG_ERROR("entities.player", "bm_bot::IllusionsCheck(): unit %u is not found in world!", GUID_LOPART(*itr));
+                    continue;
+                }
+
+                ill->SetCanModifyStats(false);
+                float hpct = ill->GetHealthPct();
+                float mpct = (float(ill->GetPower(POWER_MANA)) * 100.f) / float(ill->GetMaxPower(POWER_MANA));
+
+                ill->SetMaxHealth(me->GetMaxHealth());
+                ill->SetHealth(uint32(0.5f + float(ill->GetMaxHealth()) * hpct / 100.f));
+                ill->SetMaxPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+                ill->SetPower(POWER_MANA, uint32(0.5f + float(ill->GetMaxPower(POWER_MANA)) * mpct / 100.f));
+                ill->SetFloatValue(UNIT_FIELD_MINDAMAGE, me->GetFloatValue(UNIT_FIELD_MINDAMAGE));
+                ill->SetFloatValue(UNIT_FIELD_MAXDAMAGE, me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+                ill->m_modAttackSpeedPct[BASE_ATTACK] = me->m_modAttackSpeedPct[BASE_ATTACK];
+            }
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            //custom
+            if (_dmdevent)
+                return false;
+            if (IsTempBot()) //Illusion etc.
+                return false;
+
+            if (CheckBotCast(victim, spellId, BOT_CLASS_BM) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            IllusionsCheck(diff);
+            if (Wait())
+                return;
+            GenerateRand();
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (IsPotionReady())
+            {
+                if (me->GetPower(POWER_MANA) < 125)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            //CheckRacials(diff);
+
+            CheckWindWalk(diff);
+            CheckMirrorImage(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (!CheckAttackTarget(BOT_CLASS_BM))
+                return;
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force, u);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u) { bot_minion_ai::KilledUnit(u); }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+        uint8 GetPlayerClass() const { return BOT_CLASS_WARRIOR; }
+
+        bool CanEat() const { return Windwalk_Timer == 0 && !illusion_Fade; }
+        bool CanSeeEveryone() const { return Windwalk_Timer > 0; }
+
+        void BreakCC(uint32 diff)
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (IsSpellReady(WINDWALK_1, diff) && !IsTank(me) && Rand() < 30 &&
+                    doCast(me, GetSpell(WINDWALK_1)))
+                    return;
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 /*diff*/)
+        {
+            StartAttack(opponent, IsMelee());
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            //float dist = me->GetExactDist(opponent);
+            //float meleedist = me->GetDistance(opponent);
+            ////charge + warbringer
+            //if (IsSpellReady(CHARGE_1, diff, false) && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+            //    (me->getLevel() >= 50 ||
+            //    (!me->IsInCombat() && (battleStance || stanceChange(diff, 1)))))
+            //{
+            //    temptimer = GC_Timer;
+            //    if (me->getLevel() >= 29)
+            //        me->RemoveMovementImpairingAuras();
+            //    if (doCast(opponent, GetSpell(CHARGE_1), me->IsInCombat()))
+            //    {
+            //        SetSpellCooldown(CHARGE_1, 12000);
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+            //}
+            ////OVERPOWER
+            //if (IsSpellReady(OVERPOWER_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50 && getrage() > 50 && meleedist <= 5 &&
+            //    (battleStance || stancetimer <= diff))
+            //{
+            //    if (me->HasAura(TASTE_FOR_BLOOD_BUFF))
+            //    {
+            //        if (battleStance || stanceChange(diff, 1))
+            //        {
+            //            if (doCast(opponent, GetSpell(OVERPOWER_1)))
+            //            {
+            //                me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
+            //                return;
+            //            }
+            //        }
+            //    }
+            //}
+
+            MoveBehind(opponent);
+
+            //////PLACEHOLDER - BLADESTORM
+            ////BLADESTORM
+            //if (IsSpellReady(BLADESTORM_1, diff) && HasRole(BOT_ROLE_DPS) &&
+            //   getrage() >= 250 && (Rand() < 20 || me->HasAura(RECKLESSNESS_1)) &&
+            //   (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()))
+            //{
+            //    if (doCast(me, GetSpell(BLADESTORM_1)))
+            //    {
+            //        SetSpellCooldown(BLADESTORM_1, 60000);
+            //        return;
+            //    }
+            //}
+            //////PLACEHOLDER - SPELLCAST INTERRUPT POSSIBLE
+            ////PUMMEL
+            //if (IsSpellReady(PUMMEL_1, diff, false) && Rand() < 80 && getrage() > 100 && meleedist <= 5 &&
+            //    opponent->IsNonMeleeSpellCasted(false) &&
+            //    (berserkerStance || stancetimer <= diff))
+            //{
+            //    temptimer = GC_Timer;
+            //    if ((berserkerStance || stanceChange(diff, 3)) &&
+            //        doCast(opponent, GetSpell(PUMMEL_1)))
+            //    {
+            //        SetSpellCooldown(PUMMEL_1, 10000);
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+            //}
+        }
+
+        void DoBMMeleeAttackIfReady()
+        {
+            //Copied from UnitAI::DoMeleeAttackIfReady() with modifications
+            //cannot attack while casting or jumping
+            if (me->HasUnitState(UNIT_STATE_CASTING) || _dmdevent)
+                return;
+
+            Unit* victim = me->GetVictim();
+            //Make sure our attack is ready and we aren't currently casting before checking distance
+            if (me->isAttackReady() && me->IsWithinMeleeRange(victim))
+            {
+                if (!CCed(me, true) && !JumpingFlyingOrFalling())
+                {
+                    //Windwalk strike
+                    if (Windwalk_Timer)
+                    {
+                        CriticalStrike(victim, true);
+                        return;
+                    }
+                    //Critical Strike: 15% to deal x2,x3, etc... damage
+                    else if (criticalStikeMult >= 2 && !CCed(me, true) && roll_chance_f(15.f))
+                    {
+                        CriticalStrike(victim);
+                        return;
+                    }
+                }
+
+                me->AttackerStateUpdate(victim);
+                me->resetAttackTimer();
+                return;
+            }
+        }
+
+        void CheckAttackState()
+        {
+            if (me->GetVictim())
+            {
+                if (HasRole(BOT_ROLE_DPS))
+                    DoBMMeleeAttackIfReady();
+            }
+            else
+                Evade();
+        }
+
+        void CheckWindWalk(uint32 diff)
+        {
+            if (!IsSpellReady(WINDWALK_1, diff) || Windwalk_Timer || illusion_Fade || IsCasting() ||
+                Rand() > (10 + 20 * (me->IsInCombat() || master->IsInCombat())))
+                return;
+
+            if (!IAmFree() && master->isMoving())
+            {
+                if (me->GetDistance(master) > 30 &&
+                    doCast(me, GetSpell(WINDWALK_1)))
+                    return;
+
+                return;
+            }
+
+            if (!IsTank(me))
+            {
+                //unit to strike
+                Unit* u = IsMelee() ? me->GetVictim() : NULL;
+
+                if ((u && u->isMoving() && me->GetDistance(u) > 18 &&
+                    (u->GetVictim() != me || u->getAttackers().size() > uint8(u->IsControlledByPlayer() ? 0 : 1))) ||
+                    me->getAttackers().size() > 2)
+                {
+                    if (doCast(me, GetSpell(WINDWALK_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckMirrorImage(uint32 diff)
+        {
+            //only for controlled bot
+            if (IAmFree())
+                return;
+            if (!IsSpellReady(MIRROR_IMAGE_1, diff) || !me->IsInCombat() || !illusionsCount || illusion_Fade ||
+                !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 20)
+                return;
+
+            uint8 pct = GetHealthPCT(me);
+            uint8 size = uint8(me->getAttackers().size());
+            if (!size)
+                return;
+
+            if (pct > 25 && (size > 3 || pct < (80 + size * 5)))
+                if (doCast(me, GetSpell(MIRROR_IMAGE_1)))
+                    return;
+        }
+
+        void MirrorImageStart()
+        {
+            if (!illusionsCount)
+                return;
+
+            ASSERT(!illusion_Fade);
+            illusion_Fade = true;
+
+            //OKAY
+
+            //destroy existing illusions if any
+            UnsummonAll();
+            //mirror image renders BM invulnerable for a short period of time,
+            //removing all but passive auras
+            Unit::AuraMap const auras = me->GetOwnedAuras(); //copy
+            for (Unit::AuraMap::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
+            {
+                Aura* aura = iter->second;
+                if (aura->GetSpellInfo()->Attributes & (SPELL_ATTR0_PASSIVE))
+                    continue;
+                if (aura->GetId() == SPELL_BURNING_BLADE_BLADEMASTER)
+                    continue;
+                AuraApplication* aurApp = aura->GetApplicationOfTarget(me->GetGUID());
+                if (!aurApp)
+                    continue;
+                me->RemoveAura(aurApp, AURA_REMOVE_BY_DEFAULT);
+            }
+
+            me->BotStopMovement();
+            me->AttackStop();
+            me->HandleEmoteCommand(EMOTE_ONESHOT_NONE);
+            me->AddAura(BLACK_COLOR, me);//color
+            me->AddAura(STUN_FREEZE, me);//stop/immunity
+
+            //prepare to disappear
+            DisappearEvent* devent = new DisappearEvent(me->GetGUID());
+            Events.AddEvent(devent, Events.CalculateTime(300)); //immediatelly (almost)
+        }
+
+        void MirrorImageMid()
+        {
+            if (!me->IsInWorld() ||
+                !me->IsAlive()/* || CCed(me)*/) //this is just ensurance
+            {
+                me->RemoveAura(BLACK_COLOR);
+                me->RemoveAura(STUN_FREEZE);
+                illusion_Fade = false;
+                return;
+            }
+            //disappear
+            me->SetPhaseMask(0, true);
+
+            //INVISIBLE!
+            //EVENT
+            DelayedIllusionSummonEvent* disevent = new DelayedIllusionSummonEvent(me->GetGUID());
+            Events.AddEvent(disevent, Events.CalculateTime(1250)); //1000 ms disappear time + 250 ms buffer
+        }
+
+        void MirrorImageFinish()
+        {
+            illusion_Fade = false;
+            me->RemoveAura(BLACK_COLOR);
+            me->RemoveAura(STUN_FREEZE);
+            if (!me->IsInWorld() ||
+                !me->IsAlive()/* || CCed(me)*/) //this is just ensurance
+                return;
+
+            _calcIllusionPositions();
+
+            std::set<uint8> usedposs;
+
+            for (uint8 i = 0; i != illusionsCount; ++i)
+            {
+                Creature* illusion = me->SummonCreature(NPC_MIRROR_IMAGE, *me, TEMPSUMMON_MANUAL_DESPAWN);
+                if (!illusion)
+                    continue;
+
+                //DeafaultInit parts override
+                illusion->setFaction(master->getFaction()); //unneeded?
+
+                if (!IAmFree())
+                    master->GetBotMgr()->AddBot(illusion, false);
+
+                illusion->SetCreatorGUID(me->GetGUID()); //TempSummon* Map::SummonCreature()
+
+                //copy visuals
+                illusion->SetEntry(me->GetEntry());
+                illusion->SetLevel(me->getLevel());
+                illusion->SetDisplayId(me->GetDisplayId());
+                illusion->SetNativeDisplayId(me->GetDisplayId());
+                illusion->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0, me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0));
+
+                //copy stats
+                illusion->SetCanModifyStats(false);
+                illusion->SetMaxHealth(me->GetMaxHealth());
+                illusion->SetHealth(me->GetHealth());
+                illusion->SetMaxPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+                illusion->SetPower(POWER_MANA, me->GetPower(POWER_MANA));
+                illusion->SetFloatValue(UNIT_FIELD_MINDAMAGE, me->GetFloatValue(UNIT_FIELD_MINDAMAGE));
+                illusion->SetFloatValue(UNIT_FIELD_MAXDAMAGE, me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+                illusion->m_modAttackSpeedPct[BASE_ATTACK] = me->m_modAttackSpeedPct[BASE_ATTACK];
+
+                illusion->BotStopMovement();
+                while (true)
+                {
+                    //move illusion to a random corner
+                    uint8 j = urand(0, MAX_ILLUSION_POSITIONS - 1);
+                    if (usedposs.find(j) == usedposs.end())
+                    {
+                        illusion->GetMotionMaster()->MovePoint(me->GetMapId(), _illusPos[j]);
+                        //illusion->Relocate(_illusPos[j]);
+                        usedposs.insert(j);
+                        break;
+                    }
+                }
+
+                illusion->SetBotCommandState(COMMAND_ABANDON);
+
+                _illusionGuids.push_back(illusion->GetGUID());
+            }
+
+            me->SetBotCommandState(COMMAND_ABANDON);
+
+            for (uint8 i = 0; i != MAX_ILLUSION_POSITIONS; ++i)
+            {
+                if (usedposs.find(i) == usedposs.end())
+                {
+                    me->BotStopMovement();
+                    me->GetMotionMaster()->MovePoint(me->GetMapId(), _illusPos[i]);
+                    //me->Relocate(_illusPos[i]);
+                    //usedposs.insert(i);
+                    break;
+                }
+            }
+
+            uint8 counter = 0;
+            uint8 r = urand(0, uint8(_illusionGuids.size() - 1));
+
+            for (std::list<uint64>::const_iterator itr = _illusionGuids.begin(); itr != _illusionGuids.end(); ++itr)
+            {
+                if (Creature* illusion = sObjectAccessor->GetObjectInWorld(*itr, (Creature*)NULL))
+                    illusion->SetPhaseMask(master->GetPhaseMask(), true);
+
+                if (counter == r)
+                    me->SetPhaseMask(master->GetPhaseMask(), true);
+                else
+                    ++counter;
+            }
+
+            me->getHostileRefManager().deleteReferences();
+
+            if (me->GetPhaseMask() != master->GetPhaseMask())
+                me->SetPhaseMask(master->GetPhaseMask(), true);
+
+            //me->setAttackTimer(BASE_ATTACK, 3000);
+            waitTimer += 800;
+            SetSpellCooldown(MIRROR_IMAGE_1, 8000);
+
+            //EVENT
+            IllusionUnsummonEvent* unsevent = new IllusionUnsummonEvent(me->GetGUID());
+            Events.AddEvent(unsevent, Events.CalculateTime(MIRROR_IMAGE_DURATION));
+        }
+
+        void CriticalStrike(Unit* target, bool windwalk = false)
+        {
+            //Okay critical strike must have jump and strike animation, doing delayed damage
+            DelayedMeleeDamageEvent* dmdevent = new DelayedMeleeDamageEvent(me->GetGUID(), target->GetGUID(), windwalk);
+            SetDelayedMeleeDamageEvent(dmdevent);
+
+            //hack temp attack damage calc
+            float mindam = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            float maxdam = me->GetFloatValue(UNIT_FIELD_MAXDAMAGE);
+
+            if (windwalk)
+            {
+                me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam * 1.5f);
+                me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam * 1.5f);
+                me->RemoveAura(GetSpell(WINDWALK_1));
+                me->RemoveAura(TRANSPARENCY);
+            }
+            else
+            {
+                me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam * criticalStikeMult);
+                me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam * criticalStikeMult);
+            }
+
+            CalcDamageInfo* dinfo = new CalcDamageInfo();
+            me->CalculateMeleeDamage(target, 0, dinfo, BASE_ATTACK);
+
+            me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam);
+            me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam);
+
+            dmdevent->SetDamageInfo(dinfo);
+            Events.AddEvent(dmdevent, Events.CalculateTime(400));
+
+            BotJumpInPlaceInFrontOf(target, 0.32f, 4.1f); //jump - DO NOT CHANGE
+            me->CastSpell(target, SPELL_COMBAT_SPECIAL_2H_ATTACK, true); //strike anim
+            me->resetAttackTimer(BASE_ATTACK);
+        }
+
+        void CriticalStrikeFinish(uint64 targetGuid, CalcDamageInfo* dinfo, bool /*windwalk*/)
+        {
+            EventTerminateEvent* etevent = new EventTerminateEvent(me->GetGUID());
+            Events.AddEvent(etevent, Events.CalculateTime(750));
+
+            if (!me->IsInWorld() || !me->IsAlive() || CCed(me))
+            {
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            Unit* target = sObjectAccessor->GetUnit(*me, targetGuid);
+            if (!target || !target->IsAlive())
+            {
+                me->PlayDistanceSound(SOUND_MISS_WHOOSH_2H);
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            if (target->IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL))
+            {
+                //target became immune
+                me->SendSpellMiss(target, CRITICAL_STRIKE_1, SPELL_MISS_IMMUNE);
+                target->PlayDistanceSound(SOUND_ABSORB_GET_HIT);
+                Windwalk_Timer = 0;
+                return;
+            }
+            else if (!CanSeeEveryone() && !me->CanSeeOrDetect(target, false, false))
+            {
+                //target disappeared
+                me->SendSpellMiss(target, CRITICAL_STRIKE_1, SPELL_MISS_MISS/*SPELL_MISS_EVADE*/);
+                me->PlayDistanceSound(SOUND_MISS_WHOOSH_2H);
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            target->PlayDistanceSound(SOUND_AXE_2H_IMPACT_FLESH_CRIT);
+
+            me->SendSpellNonMeleeDamageLog(target, CRITICAL_STRIKE_1,
+                dinfo->damage + dinfo->absorb + dinfo->resist + dinfo->blocked_amount,
+                SPELL_SCHOOL_MASK_NORMAL, dinfo->absorb, dinfo->resist, true, dinfo->blocked_amount, true);
+            CleanDamage cl(0, 0, BASE_ATTACK, MELEE_HIT_CRIT);
+            me->DealDamage(target, dinfo->damage, &cl);
+            me->ProcDamageAndSpell(dinfo->target, dinfo->procAttacker, dinfo->procVictim, dinfo->procEx, dinfo->damage, dinfo->attackType);
+            me->CombatStart(target);
+
+            me->resetAttackTimer(BASE_ATTACK);
+            Windwalk_Timer = 0;
+        }
+
+        void SetDelayedMeleeDamageEvent(DelayedMeleeDamageEvent* dmdevent)
+        { _dmdevent = dmdevent; }
+
+        void TerminateEvent()
+        { _dmdevent = NULL; }
+
+        MeleeHitOutcome GetNextAttackMeleeOutCome() const
+        {
+            return _dmdevent ? MELEE_HIT_NORMAL : bot_ai::GetNextAttackMeleeOutCome();
+        }
+
+        bool IsBotImmuneToSpell(SpellInfo const* spellInfo) const
+        {
+            //PLACEHOLDER BLADESTORM
+            //return !spellInfo->HasEffect(SPELL_EFFECT_HEAL);
+            return bot_ai::IsBotImmuneToSpell(spellInfo);
+        }
+
+        float GetBotArmorPenetrationCoef() const
+        {
+            return 80.0f + bot_ai::GetBotArmorPenetrationCoef();
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(WINDWALK_1))
+            {
+                Windwalk_Timer = 30000; //TODO:
+                me->RemoveMovementImpairingAuras();
+                me->PlayDistanceSound(SOUND_FREEZE_IMPACT_WINDWALK, !IAmFree() ? master : NULL);
+
+                uint32 dur = 30000;
+                if (Aura* aura = me->GetAura(spellId))
+                {
+                    aura->SetDuration(dur);
+                    aura->SetMaxDuration(dur);
+                }
+                if (Aura* aura = me->GetAura(TRANSPARENCY))
+                {
+                    aura->SetDuration(dur);
+                    aura->SetMaxDuration(dur);
+                }
+
+                if (GetHealthPCT(me) < 25 || !HasRole(BOT_ROLE_DPS))
+                    me->AttackStop();
+
+                //SpellEffectSanctuary
+                me->getHostileRefManager().UpdateVisibility();
+                Unit::AttackerSet attackers = me->getAttackers();
+                for (Unit::AttackerSet::const_iterator itr = attackers.begin(); itr != attackers.end();)
+                {
+                    if (!(*itr)->CanSeeOrDetect(me))
+                        (*(itr++))->AttackStop();
+                    else
+                        ++itr;
+                }
+
+                me->m_lastSanctuaryTime = getMSTime();
+            }
+
+            if (spellId == GetSpell(MIRROR_IMAGE_1))
+            {
+                MirrorImageStart();
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* /*target*/, SpellInfo const* /*spell*/) { }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            //Illusions deal no damage
+            if (IsTempBot())
+            {
+                //manually add threat as if damage was done
+                if (victim->GetTypeId() == TYPEID_UNIT)
+                    victim->AddThreat(me, float(damage + damage));
+
+                damage = 0;
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage)
+        {
+            //illusions take twice as much damage
+            if (IsTempBot())
+            {
+                damage *= 2;
+                //return;
+            }
+            if (illusion_Fade)
+            {
+                damage = 0;
+                return;
+            }
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void JustDied(Unit* u)
+        {
+            if (IsTempBot())
+                if (IS_CREATURE_GUID(me->GetCreatorGUID()))
+                    if (Unit* bot = sObjectAccessor->FindUnit(me->GetCreatorGUID()))
+                        if (bot->ToCreature()->IsNPCBot())
+                            bot->ToCreature()->OnBotDespawn(me);
+
+            bot_minion_ai::JustDied(u);
+        }
+
+        void OnBotDespawn(Creature* summon)
+        {
+            if (!summon)
+                return;
+
+            for (std::list<uint64>::iterator itr = _illusionGuids.begin(); itr != _illusionGuids.end(); ++itr)
+            {
+                if (*itr == summon->GetGUID())
+                {
+                    _illusionGuids.erase(itr);
+                    return;
+                }
+            }
+        }
+
+        void UnsummonAll()
+        {
+            while (!_illusionGuids.empty())
+            {
+                std::list<uint64>::iterator itr = _illusionGuids.begin();
+                if (Creature* illusion = sObjectAccessor->GetObjectInWorld(*itr, (Creature*)NULL))
+                    illusion->AI()->JustDied(NULL);
+                else
+                    _illusionGuids.erase(itr);
+            }
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const
+        {
+            switch (data)
+            {
+                case CRITICAL_STRIKE_1:
+                    return criticalStikeMult;
+                case MIRROR_IMAGE_1:
+                    return illusionsCount;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset()
+        {
+            _dmdevent = NULL;
+            Windwalk_Timer = 0;
+            criticalStikeMult = 1;
+            illusionsCount = 0;
+            illusion_Fade = false;
+
+            me->setPowerType(POWER_MANA);
+            me->SetMaxPower(POWER_MANA, 75);
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Windwalk_Timer > diff)          Windwalk_Timer -= diff;
+            else if (Windwalk_Timer > 0)        Windwalk_Timer = 0;
+            if (Illusions_Check_Timer > diff)   Illusions_Check_Timer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+
+ /*Special*/lvl >= 10 ? InitSpellMap(WINDWALK_1) : RemoveSpell(WINDWALK_1);
+ /*Special*/lvl >= 20 ? InitSpellMap(MIRROR_IMAGE_1) : RemoveSpell(MIRROR_IMAGE_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = me->getLevel();
+
+            RefreshAura(SPELL_BURNING_BLADE_BLADEMASTER);
+
+            criticalStikeMult =
+                level < 10 ? 1 :
+                level < 30 ? 2 :
+                level < 50 ? 3 :
+                level < 82 ? 4 : 5;
+
+            illusionsCount =
+                level < 20 ? 0 :
+                level < 40 ? 1 :
+                level < 70 ? 2 : 3;
+                //level < 83 ? 3 : 4;
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case WINDWALK_1:
+                case MIRROR_IMAGE_1:
+                    return true;
+                default:
+                    break;
+            }
+
+            return false;
+        }
+
+    private:
+        DelayedMeleeDamageEvent* _dmdevent;
+        std::list<uint64> _illusionGuids;
+        Position _illusPos[MAX_ILLUSION_POSITIONS];
+
+        uint32 Windwalk_Timer;
+        uint32 Illusions_Check_Timer;
+        uint8 criticalStikeMult;
+        uint8 illusionsCount;
+        bool illusion_Fade;
+
+        enum BlademasterBaseSpells
+        {
+            WINDWALK_1                              = SPELL_NETHERWALK,
+            MIRROR_IMAGE_1                          = SPELL_MIRROR_IMAGE_BM,
+            CRITICAL_STRIKE_1                       = SPELL_CRITICAL_STRIKE
+        };
+        enum BlademasterPassives
+        {
+        //Talents
+        //other
+        };
+        enum BlademasterSpecial
+        {
+            NPC_MIRROR_IMAGE                        = 70302,
+            TRANSPARENCY                            = SPELL_TRANSPARENCY_50,
+            BLACK_COLOR                             = SPELL_VERTEX_COLOR_BLACK,
+            STUN_FREEZE                             = SPELL_STUN_FREEZE_ANIM
+        };
+    };
+};
+
+void AddSC_blademaster_bot()
+{
+    new blademaster_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
new file mode 100644
index 0000000..61ba82d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
@@ -0,0 +1,1588 @@
+#include "bot_ai.h"
+//#include "botmgr.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+//#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+/*
+Death Knight NpcBot by Trickerer onlysuffering@gmail.com
+Complete - around 55%
+Note: Rune system adapted from TC
+TODO: Tanking
+*/
+const RuneType runeSlotTypes[MAX_RUNES] =
+{
+    RUNE_BLOOD,
+    RUNE_BLOOD,
+    RUNE_UNHOLY,
+    RUNE_UNHOLY,
+    RUNE_FROST,
+    RUNE_FROST
+};
+struct BotRuneInfo
+{
+    uint8 BaseRune;
+    uint8 CurrentRune;
+    uint32 Cooldown;
+    //AuraEffect const* ConvertAura;
+};
+struct BotRunes
+{
+    BotRuneInfo runes[MAX_RUNES];
+    //uint8 runeState;          //UNUSED
+    //uint8 lastUsedRune;       //UNUSED
+
+    //void SetRuneState(uint8 index, bool set = true)
+    //{
+    //    if (set)
+    //        runeState |= (1 << index);    // usable
+    //    else
+    //        runeState &= ~(1 << index);   // on cooldown
+    //}
+};
+class death_knight_bot : public CreatureScript
+{
+public:
+    death_knight_bot() : CreatureScript("death_knight_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new death_knight_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct death_knight_botAI : public bot_minion_ai
+    {
+        death_knight_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_DEATH_KNIGHT;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_DEATH_KNIGHT) != SPELL_CAST_OK)
+                return false;
+
+            for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+                runeCost[i] = 0;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (!HaveRunes(spellInfo))
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+       }
+
+        bool HaveRunes(SpellInfo const* spellInfo)
+        {
+            if (spellInfo->PowerType != POWER_RUNE || !spellInfo->RuneCostID)
+                return true;
+
+            SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID);
+            if (!src || src->NoRuneCost())
+                return true;
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                runeCost[i] = src->RuneCost[i];
+            runeCost[RUNE_DEATH] = MAX_RUNES;
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                uint8 rune = _runes.runes[i].CurrentRune;
+                if (runeCost[rune] > 0 && _runes.runes[i].Cooldown == 0)
+                    runeCost[rune]--;
+            }
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                if (runeCost[i] > 0)
+                    runeCost[RUNE_DEATH] += runeCost[i];
+
+            if (runeCost[RUNE_DEATH] > MAX_RUNES)
+                return false;
+
+            //for debug
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                runeCost[i] = src->RuneCost[i];
+            runeCost[RUNE_DEATH] = 0;
+
+            return true;
+        }
+
+        bool HaveRunes(uint32 spellId)
+        {
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+            return (spellInfo && HaveRunes(spellInfo));
+        }
+
+        void SpendRunes(SpellInfo const* spellInfo)
+        {
+            if (spellInfo->PowerType != POWER_RUNE || !spellInfo->RuneCostID)
+                return;
+
+            SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID);
+            if (!src || src->NoRuneCost())
+                return;
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                runeCost[i] = src->RuneCost[i];
+            runeCost[RUNE_DEATH] = 0;
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                uint8 rune = _runes.runes[i].CurrentRune;
+                if (runeCost[rune] > 0 && _runes.runes[i].Cooldown == 0)
+                    if (SpendRune(rune))
+                        runeCost[rune]--;
+            }
+
+            runeCost[RUNE_DEATH] = runeCost[RUNE_BLOOD] + runeCost[RUNE_UNHOLY] + runeCost[RUNE_FROST];
+
+            if (runeCost[RUNE_DEATH] > 0)
+            {
+                for (uint8 i = 0; i != MAX_RUNES, runeCost[RUNE_DEATH] > 0; ++i)
+                {
+                    if (_runes.runes[i].CurrentRune == RUNE_DEATH && _runes.runes[i].Cooldown == 0)
+                        if (SpendRune(RUNE_DEATH))
+                            runeCost[RUNE_DEATH]--;
+                }
+            }
+
+            if (GetCooledRunesCount(RUNE_BLOOD) > 1)
+                me->CastSpell(me, BLADE_BARRIER_AURA, true);
+        }
+
+        bool SpendRune(uint8 runetype)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes.runes[i].CurrentRune == runetype && _runes.runes[i].Cooldown == 0)
+                {
+                    _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
+                    //_runes.lastUsedRune = _runes.runes[i].CurrentRune;        //UNUSED
+                    //_runes.SetRuneState(i, false);                            //UNUSED
+                    // Reduce base cooldown since we can't track spell misses yet
+                    // Spell hit: 10000, miss: 1500
+                    uint32 cooldown = RUNE_BASE_COOLDOWN / 2;
+
+                    //DK receives rune regen bonus from power regen percent
+                    Unit::AuraEffectList const& regenAura = me->GetAuraEffectsByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
+                    for (Unit::AuraEffectList::const_iterator itr = regenAura.begin(); itr != regenAura.end(); ++itr)
+                    {
+                        if ((*itr)->GetMiscValue() == POWER_RUNE && (*itr)->GetMiscValueB() == _runes.runes[i].BaseRune)
+                            cooldown = cooldown*(100-(*itr)->GetAmount())/100;
+                    }
+
+                    _runes.runes[i].Cooldown = cooldown;
+
+                    //std::ostringstream str;
+                    //str << "Spent rune " << uint32(i) << " (type: " << uint32(runetype) << ')';
+                    //me->MonsterWhisper(str.str().c_str(), master->GetGUID());
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        uint8 GetCooledRunesCount(uint8 runetype) const
+        {
+            uint8 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes.runes[i].BaseRune == runetype && _runes.runes[i].Cooldown > 0)
+                    ++count;
+
+            return count;
+        }
+
+        void ConvertRune(uint8 runetype, uint8 count)
+        {
+            if (runetype == RUNE_DEATH)
+                return;
+
+            uint8 failcount = 0;
+            for (uint8 i = 0; i != MAX_RUNES && count > 0; ++i)
+            {
+                if (_runes.runes[i].BaseRune == runetype)
+                {
+                    if (_runes.runes[i].CurrentRune == RUNE_DEATH)
+                    {
+                        ++failcount;
+                        continue;
+                    }
+
+                    if (_runes.runes[i].Cooldown > 3000)
+                        _runes.runes[i].Cooldown = 3000;
+
+                    _runes.runes[i].CurrentRune = RUNE_DEATH;
+                    --count;
+                }
+            }
+
+            if (!count && !failcount)
+                return;
+
+            //std::ostringstream str;
+            //str << "Failed to convert rune of type: " << uint32(runetype) << ")!";
+            //me->MonsterWhisper(str.str().c_str(), master->GetGUID());
+        }
+
+        void ActivateAllRunes()
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes.runes[i].Cooldown = 0;
+                //_runes.SetRuneState(i, true);       //UNUSED
+            }
+        }
+
+        void InitRunes()
+        {
+            //_runes.runeState = 0;                   //UNUSED
+            //_runes.lastUsedRune = RUNE_BLOOD;       //UNUSED
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes.runes[i].BaseRune = runeSlotTypes[i];
+                _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
+                _runes.runes[i].Cooldown = 0;
+                //_runes.runes[i].ConvertAura = NULL; //UNUSED
+                //_runes.SetRuneState(i, true);       //UNUSED
+            }
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force, u);
+        }
+
+        void RuneTimers(uint32 diff)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes.runes[i].Cooldown <= diff)
+                {
+                    _runes.runes[i].Cooldown = 0;
+                    //_runes.SetRuneState(i, true);     //UNUSED
+                }
+                else
+                    _runes.runes[i].Cooldown -= diff;
+            }
+        }
+
+        void modpower(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && runicpower < uint32(abs(mod)))
+            {
+                //debug set runic power to 0
+                mod = 0;
+                set = true;
+                return;
+            }
+
+            if (set)
+                runicpower = mod ? mod * 10 : 0;
+            else
+                runicpower += mod * 10;
+
+            me->SetPower(POWER_RUNIC_POWER, runicpower);
+        }
+
+        uint32 getpower()
+        {
+            runicpower = me->GetPower(POWER_RUNIC_POWER);
+            return runicpower;
+        }
+
+        uint8 GetBotStance() const { return Presence; }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void AttackStart(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+        void KilledUnit(Unit* u) { bot_minion_ai::KilledUnit(u); }
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || IsCasting() || Feasting() || Rand() > 20)
+                return;
+
+            //PATH OF FROST
+            if (GetSpell(PATH_OF_FROST_1) && HaveRunes(PATH_OF_FROST_1)/* && !me->IsMounted()*/) //works while mounted
+            {
+                if ((me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !me->HasAuraType(SPELL_AURA_WATER_WALK)) ||
+                    (master->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !master->HasAuraType(SPELL_AURA_WATER_WALK) && me->GetDistance(master) < 50))
+                {
+                    if (doCast(me, GetSpell(PATH_OF_FROST_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckHysteria(uint32 diff)
+        {
+            if (!IsSpellReady(HYSTERIA_1, diff) || IsCasting() || Rand() > 15)
+                return;
+
+            Unit* target = NULL;
+
+            if (master->IsAlive() && IsMeleeClass(master->getClass()) && master->IsInCombat() &&
+                GetHealthPCT(master) > 80 && me->GetDistance(master) < 30 &&
+                master->getAttackers().empty() && !CCed(master, true))
+            {
+                if (Unit* u = master->GetVictim())
+                    if (u->GetHealth() > me->GetMaxHealth() / 2)
+                        target = master;
+            }
+
+            if (!target && IsMeleeClass(_botclass) && GetHealthPCT(me) > 80 &&
+                me->getAttackers().empty() && !CCed(me, true))
+            {
+                if (Unit* u = me->GetVictim())
+                    if (u->GetHealth() > me->GetMaxHealth() / 2)
+                        target = me;
+            }
+
+            if (!target && !IAmFree())
+            {
+                Group const* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == master) continue;
+                        if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
+                        if (!IsMeleeClass(tPlayer->getClass()) || !tPlayer->IsInCombat()) continue;
+                        if (GetHealthPCT(tPlayer) < 80 || me->GetDistance(tPlayer) > 30) continue;
+                        if (!tPlayer->getAttackers().empty() || CCed(tPlayer, true)) continue;
+                        if (Unit* u = tPlayer->GetVictim())
+                        {
+                            if (u->GetHealth() > (me->GetMaxHealth() * 2) / 3)
+                            {
+                                target = tPlayer;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (target && doCast(target, GetSpell(HYSTERIA_1)))
+            {
+                if (target->GetTypeId() == TYPEID_PLAYER)
+                    BotWhisper("Hysteria on You!", target->ToPlayer());
+
+                GC_Timer = 1000;
+                return;
+            }
+
+            SetSpellCooldown(HYSTERIA_1, 2000); //fail
+        }
+
+        void CheckAntiMagicShell(uint32 diff)
+        {
+            if (!IsSpellReady(ANTI_MAGIC_SHELL_1, diff, false) || GetHealthPCT(me) > 55 ||
+                getpower() < 200 || IsCasting() || Rand() > 50)
+                return;
+
+            Unit::AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+                return;
+
+            bool cast = false;
+            uint8 count = 0;
+
+            for (Unit::AttackerSet::const_iterator itr = b_attackers.begin(); itr != b_attackers.end(); ++itr)
+            {
+                if (!(*itr) || !(*itr)->IsAlive()) continue;
+                if (Spell const* spell = (*itr)->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (spell->m_targets.GetUnitTargetGUID() == me->GetGUID())
+                    {
+                        if ((*itr)->ToCreature() && (*itr)->ToCreature()->isWorldBoss())
+                        {
+                            cast = true;
+                            break;
+                        }
+
+                        if (++count >= 3)
+                        {
+                            cast = true;
+                            break;
+                        }
+                    }
+                }
+            }
+
+            if (cast)
+            {
+                if (doCast(me, GetSpell(ANTI_MAGIC_SHELL_1)))
+                    return;
+            }
+
+            SetSpellCooldown(ANTI_MAGIC_SHELL_1, 500); //fail
+        }
+
+        void CheckPresence(uint32 diff)
+        {
+            if (presencetimer > diff || IsCasting() || Rand() > 30) //no GCD
+                return;
+
+            uint8 newpresence = IsTank() ? DEATH_KNIGHT_FROST_PRESENCE : DEATH_KNIGHT_BLOOD_PRESENCE;
+            if (Presence == newpresence)
+            {
+                presencetimer = 250;
+                return;
+            }
+
+            if (newpresence == DEATH_KNIGHT_FROST_PRESENCE && HaveRunes(FROST_PRESENCE_1))
+            {
+                if (doCast(me, FROST_PRESENCE_1))
+                    return;
+            }
+            else if (newpresence == DEATH_KNIGHT_BLOOD_PRESENCE && HaveRunes(BLOOD_PRESENCE_1))
+            {
+                if (doCast(me, BLOOD_PRESENCE_1))
+                    return;
+            }
+
+            presencetimer = 500; //fail
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (IsSpellReady(LICHBORNE_1, diff, false) &&/* Rand() < 75 &&*/
+                me->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+            {
+                if (doCast(me, GetSpell(LICHBORNE_1)))
+                    return;
+            }
+
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+
+            if (me->getPowerType() != POWER_RUNIC_POWER)
+                InitPowers();
+
+            if (runicpowertimer <= diff)
+            {
+                if (!me->IsInCombat())
+                {
+                    if (getpower() > uint32(30 * runicpowerLossMult))
+                        me->SetPower(POWER_RUNIC_POWER, runicpower - uint32(30 * runicpowerLossMult)); //-3 runic power every 2 sec
+                    else if (runicpower > 0)
+                        me->SetPower(POWER_RUNIC_POWER, 0);
+                }
+                runicpowertimer = 2000;
+            }
+            if (runicpowertimer2 <= diff)
+            {
+                if (me->IsInCombat())
+                {
+                    if (getpower() < me->GetMaxPower(POWER_RUNIC_POWER))
+                        me->SetPower(POWER_RUNIC_POWER, runicpower + uint32(20 * runicpowerIncomeMult)); //+2 runic power every 5 sec
+                    else if (runicpower < me->GetMaxPower(POWER_RUNIC_POWER))
+                        me->SetPower(POWER_RUNIC_POWER, me->GetMaxPower(POWER_RUNIC_POWER));
+                }
+                runicpowertimer2 = 5000;
+            }
+
+            CheckAuras();
+            if (Wait())
+                return;
+            GenerateRand();
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            CheckPresence(diff);
+
+            //HORN OF WINTER
+            if (IsSpellReady(HORN_OF_WINTER_1, diff) && Rand() < 30 &&
+                (me->IsInCombat() || (me->GetDistance(master) < 28 && master->IsWithinLOSInMap(me))))
+            {
+                Aura* horn = master->GetAura(GetSpell(HORN_OF_WINTER_1));
+                if (!horn || horn->GetDuration() < 5000)
+                {
+                    if (doCast(me, GetSpell(HORN_OF_WINTER_1)))
+                        return;
+                }
+            }
+            //BONE SHIELD
+            if (IsSpellReady(BONE_SHIELD_1, diff) && HaveRunes(BONE_SHIELD_1) && Rand() < 25)
+            {
+                Aura* bone = me->GetAura(GetSpell(BONE_SHIELD_1));
+                if (!bone || bone->GetCharges() < 2 || (!me->IsInCombat() && bone->GetDuration() < 60000))
+                {
+                    if (doCast(me, GetSpell(BONE_SHIELD_1)))
+                    {
+                        GC_Timer = 1000;
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(BONE_SHIELD_1, 1000); //fail
+            }
+
+            if (me->IsInCombat())
+            {
+                //ICEBOUND FORTITUDE
+                if (IsSpellReady(ICEBOUND_FORTITUDE_1, diff, false) && getpower() >= 200 &&
+                    GetHealthPCT(me) < std::min<uint32>(85, 45 + uint8(me->getAttackers().size()) * 7) &&
+                    Rand() < 40 + IsTank() * 50)
+                {
+                    if (doCast(me, GetSpell(ICEBOUND_FORTITUDE_1)))
+                    {}
+                }
+
+                CheckAntiMagicShell(diff);
+                CheckHysteria(diff);
+            }
+
+            if (IsCasting())
+                return;
+
+            if (!CheckAttackTarget(BOT_CLASS_DEATH_KNIGHT))
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            //SELFHEAL
+
+            //RUNE TAP
+            if (IsSpellReady(RUNE_TAP_1, diff) && GetHealthPCT(me) < 40 && Rand() < 50)
+            {
+                if (!HaveRunes(RUNE_TAP_1) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false))
+                {
+                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                        ActivateAllRunes();
+                }
+                if (doCast(me, GetSpell(RUNE_TAP_1)))
+                    return;
+            }
+            //VAMPIRIC BLOOD
+            if (IsSpellReady(VAMPIRIC_BLOOD_1, diff, false) && GetHealthPCT(me) < 26/* && Rand() < 75*/)
+            {
+                if (!HaveRunes(VAMPIRIC_BLOOD_1) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false))
+                {
+                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                        ActivateAllRunes();
+                }
+                if (doCast(me, GetSpell(VAMPIRIC_BLOOD_1)))
+                    return;
+            }
+            //END SELFHEAL
+
+            //MARK OF BLOOD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(MARK_OF_BLOOD_1, diff) && HaveRunes(MARK_OF_BLOOD_1) &&
+                u && GetHealthPCT(u) < 85 && opponent->GetHealth() > u->GetMaxHealth() / 3 &&
+                (IsTank(u) || u->GetTypeId() == TYPEID_PLAYER) &&
+                Rand() < 35 && !opponent->HasAura(MARK_OF_BLOOD_1) && IsInBotParty(u))
+            {
+                if (doCast(opponent, GetSpell(MARK_OF_BLOOD_1)))
+                {
+                    GC_Timer = 1000;
+                    return;
+                }
+            }
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //NON-DISEASE SECTION
+
+            //PLACEHOLDER: ARMY OF THE DEAD
+
+            //RANGED SECTION
+
+            //STRANGULATE
+            if (IsSpellReady(STRANGULATE_1, diff) && meleedist <= 30 && HaveRunes(STRANGULATE_1) &&
+                opponent->IsNonMeleeSpellCasted(false,false,true) && Rand() < 40)
+            {
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                if (doCast(opponent, GetSpell(STRANGULATE_1)))
+                {
+                    GC_Timer = 1000;
+                    return;
+                }
+
+                SetSpellCooldown(STRANGULATE_1, 500); //fail
+            }
+
+            //DARK COMMAND
+            if (IsSpellReady(DARK_COMMAND_1, diff, false) && dist < 30 && IsTank() &&
+                opponent->GetVictim() != me && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(DARK_COMMAND_1)))
+                    return;
+            }
+            ////DEATH GRIP - DISABLED
+            //if (DEATH_GRIP && DeathGrip_cd <= diff && dist < 30 &&
+            //    (tank == me && opponent->GetVictim() != me) ||
+            //    (opponent->GetVictim() == me && opponent->ToPlayer() && opponent->IsNonMeleeSpellCasted(false)) &&
+            //    Rand() < 75)
+            //{
+            //    if (doCast(opponent, DEATH_GRIP))
+            //    {
+            //        DeathGrip_cd = 25000;
+            //        return;
+            //    }
+
+            //    DeathGrip_cd = 1000; //fail
+            //}
+
+            uint32 diseases = GC_Timer <= diff ? opponent->GetDiseasesByCaster(me->GetGUID()) : 0;
+
+            if (CanAffectVictim(SPELL_SCHOOL_MASK_FROST|SPELL_SCHOOL_MASK_SHADOW))
+            {
+                //CHAINS OF ICE
+                if (uint32 CHAINS_OF_ICE = GetSpell(CHAINS_OF_ICE_1))
+                {
+                    if (GC_Timer <= diff && dist < 20 && HaveRunes(CHAINS_OF_ICE_1) && opponent->isMoving() &&
+                        !CCed(opponent) && !IsTank(opponent->GetVictim()) && IsInBotParty(opponent->GetVictim()) && Rand() < 25)
+                    {
+                        Aura* chains = opponent->GetAura(CHAINS_OF_ICE);
+                        if (!chains || chains->GetDuration() < chains->GetMaxDuration() / 4)
+                        {
+                            if (doCast(opponent, CHAINS_OF_ICE))
+                            {
+                                //Improved Chains of Ice: convert frost rune into death rune
+                                ConvertRune(RUNE_FROST, 1);
+                                return;
+                            }
+                        }
+                    }
+                }
+
+                //AOE SECTION
+
+                //DISEASE SECTION
+
+                //PESTILENCE //custom cd condition
+                if (IsSpellReady(PESTILENCE_1, diff) && pestilencetimer == 0 && HasRole(BOT_ROLE_DPS) &&
+                    diseases > 1 && meleedist <= 5 &&
+                    HaveRunes(PESTILENCE_1) && Rand() < 15)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 9.f);
+                    if (targets.size() > 2)
+                    {
+                        if (doCast(opponent, GetSpell(PESTILENCE_1)))
+                        {
+                            pestilencetimer = 5000;
+                            return;
+                        }
+                    }
+
+                    pestilencetimer = 1000; //fail
+                }
+
+                //HOWLING BLAST
+                if (IsSpellReady(HOWLING_BLAST_1, diff) && IsTank() && meleedist < 8 && HasRole(BOT_ROLE_DPS) &&
+                    me->getAttackers().size() > 2 && HaveRunes(HOWLING_BLAST_1) && Rand() < 50)
+                {
+                    if (doCast(me, GetSpell(HOWLING_BLAST_1)))
+                    {
+                        GC_Timer = 1000;
+                        return;
+                    }
+
+                    SetSpellCooldown(HOWLING_BLAST_1, 500); //fail
+                }
+                //BLOOD BOIL
+                if (IsSpellReady(BLOOD_BOIL_1, diff) && HasRole(BOT_ROLE_DPS) && HaveRunes(BLOOD_BOIL_1) && Rand() < (10 + 40 * IsTank()))
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 9.5f);
+                    if (targets.size() >= 5)
+                        if (doCast(me, GetSpell(BLOOD_BOIL_1)))
+                            return;
+                }
+                //DEATH AND DECAY
+                if (IsSpellReady(DEATH_AND_DECAY_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < (30 + 30 * IsTank()) &&
+                    HaveRunes(DEATH_AND_DECAY_1))
+                {
+                    if (Unit* target = FindAOETarget(30, true))
+                    {
+                        if (doCast(target, GetSpell(DEATH_AND_DECAY_1)))
+                            return;
+                    }
+
+                    SetSpellCooldown(DEATH_AND_DECAY_1, 500); //fail
+                }
+
+                //END AOE SECTION
+
+                //ICY TOUCH
+                if (IsSpellReady(ICY_TOUCH_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && HaveRunes(ICY_TOUCH_1) && Rand() < 25 &&
+                    !opponent->HasAura(FROST_FEVER_AURA, me->GetGUID()))
+                {
+                    if (doCast(opponent, GetSpell(ICY_TOUCH_1)))
+                        return;
+                }
+                //DEATH COIL //custom cd condition
+                if (GetSpell(DEATH_COIL_1) && GC_Timer <= 600 && dist < 20 && HasRole(BOT_ROLE_DPS) &&
+                    int32(getpower()) >= (400 + 200 * (GetSpell(RUNE_STRIKE_1) != 0 || GetSpell(MIND_FREEZE_1) != 0 || GetSpell(ANTI_MAGIC_SHELL_1) != 0) + 400 * (GetSpell(HUNGERING_COLD_1) != 0)) &&
+                    Rand() < 60)
+                {
+                    if (doCast(opponent, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+
+                //MELEE SECTION
+
+                //MIND FREEZE
+                if (IsSpellReady(MIND_FREEZE_1, diff, false) && meleedist <= 5 && getpower() >= 200 &&
+                    opponent->IsNonMeleeSpellCasted(false,false,true) && Rand() < 60)
+                {
+                    if (doCast(opponent, GetSpell(MIND_FREEZE_1)))
+                        return;
+                }
+                //HUNGERING COLD
+                if (IsSpellReady(HUNGERING_COLD_1, diff) && HasRole(BOT_ROLE_DPS) && getpower() >= 400 && Rand() < 20)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 9.f, true);
+                    if (targets.size() >= 3)
+                    {
+                        if (doCast(me, GetSpell(HUNGERING_COLD_1)))
+                            return;
+                    }
+
+                    SetSpellCooldown(HUNGERING_COLD_1, 500); //fail
+                }
+            }
+
+            MoveBehind(opponent);
+
+            if (CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+            {
+                //RUNE STRIKE
+                if (IsSpellReady(RUNE_STRIKE_1, diff, false) && runestriketimer > me->getAttackTimer(BASE_ATTACK) &&
+                    HasRole(BOT_ROLE_DPS) && meleedist <= 5 && getpower() >= 200/* && Rand() < 75*/)
+                {
+                    if (doCast(opponent, GetSpell(RUNE_STRIKE_1)))
+                        runestriketimer = 0; //do not remove aura, just disable ability
+                }
+                //PLAGUE STRIKE
+                if (IsSpellReady(PLAGUE_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && HaveRunes(PLAGUE_STRIKE_1) && Rand() < 35 &&
+                    !opponent->HasAura(BLOOD_PLAGUE_AURA, me->GetGUID()))
+                {
+                    if (doCast(opponent, GetSpell(PLAGUE_STRIKE_1)))
+                        return;
+                }
+
+                //DISEASE SECTION
+
+                //DEATH STRIKE
+                if (IsSpellReady(DEATH_STRIKE_1, diff) && diseases > 0 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                    HaveRunes(DEATH_STRIKE_1) && GetHealthPCT(me) < (91 - 10 * diseases) && Rand() < 70)
+                {
+                    if (doCast(opponent, GetSpell(DEATH_STRIKE_1)))
+                        return;
+                }
+                //OBLITERATE
+                if (IsSpellReady(OBLITERATE_1, diff) && diseases > 2 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                    HaveRunes(OBLITERATE_1) && Rand() < 20)
+                {
+                    if (doCast(opponent, GetSpell(OBLITERATE_1)))
+                        return;
+                }
+                //BLOOD STRIKE //custom
+                if (BLOOD_STRIKE && GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && diseases > 1 && meleedist <= 5 &&
+                    HaveRunes(BLOOD_STRIKE) && Rand() < 35)
+                {
+                    if (doCast(opponent, BLOOD_STRIKE))
+                        return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+
+            //Increased Plague Strike Crit (id 60130): 10% additional critical chance for Plague Strike
+            if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                crit_chance += 10.f;
+            //Glyph of Rune Strike: 10% additional critical chance for Rune Strike
+            if (spellId == GetSpell(RUNE_STRIKE_1))
+                crit_chance += 10.f;
+            //Subversion: 9% additional critical chance for Blood Strike, Scourge Strike, Heart Strike and Obliterate
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
+                /*spellId == GetSpell(SCOURGE_STRIKE_1) || */spellId == GetSpell(OBLITERATE_1))
+                crit_chance += 9.f;
+            //Improved Death Strike (part 2): 6% additional critical chance for Death Strike
+            if (spellId == GetSpell(DEATH_STRIKE_1))
+                crit_chance += 6.f;
+            //Rime (part 1 melee): 15% additional critical chance for Obliterate
+            if (lvl >= 68 && spellId == GetSpell(OBLITERATE_1))
+                crit_chance += 15.f;
+            //Vicious Strikes (part 1): 6% additional critical chance for Plague Strike and Scourge Strike
+            if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
+                crit_chance += 6.f;
+
+            //Annihilation: 3% additional critical chance for melee special abilities
+            if (lvl >= 57 && spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE)
+                crit_chance += 3.f;
+
+            //Rime (part 1 spell): 15% additional critical chance for Icy Touch
+            if (lvl >= 68 && spellId == GetSpell(ICY_TOUCH_1))
+                crit_chance += 15.f;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+
+                //Might of Mograine: 45% crit damage bonus for Blood Boil, Blood Strike, Death Strike and Heart Strike
+                if (lvl >= 68 &&
+                    (spellId == GetSpell(BLOOD_BOIL_1) || spellId == BLOOD_STRIKE ||
+                    spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(HEART_STRIKE_1)))
+                    pctbonus += 0.45f / 2.f;
+                //Guile of Gorefiend (part 1 melee): 45% crit damage bonus for Blood Strike, Frost Strike and Obliterate
+                if (lvl >= 69 &&
+                    (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
+                    spellId == GetSpell(OBLITERATE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
+                    pctbonus += 0.45f / 2.f;
+                //Vicious Strikes (part 2): 30% crit damage bonus for Plague Strike and Scourge Strike
+                if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
+                    pctbonus += 0.3f / 2.f;
+            }
+
+            //Glypg of Plague Strike: 20% bonus damage for Plague Strike
+            if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                pctbonus += 0.2f;
+            //Glyph of Blood Strike: 20% bonus damage for Blood Strike on snared targets (Heart Strike too for bots)
+            //warning unsafe
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+                if (damageinfo.target->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_SLOW_ATTACK)))
+                    pctbonus += 0.2f;
+            //Increased Blood Strike Damage: 90 bonus damage for Blood Strike and Heart Strike
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+                fdamage += 90.f;
+            //Glyph of Death Strike: 1% bonus damage for every runic power point (max 25) for Death Strike
+            if (spellId == GetSpell(DEATH_STRIKE_1) && me->GetPower(POWER_RUNIC_POWER) >= 10)
+            {
+                //10 to 250 * 0.001 = 10 to 250 / 1000 = 0.01 to 0.25
+                pctbonus += float(std::min<uint32>(me->GetPower(POWER_RUNIC_POWER), 250)) * 0.001f;
+            }
+            //Glyph of Obliterate: 25% bonus damage for Obliterate
+            if (spellId == GetSpell(OBLITERATE_1))
+                pctbonus += 0.25f;
+            //Bloody Strikes: 15% bonus damage for Blood Strike, 45% for Heart Strike and 30% for Blood Boil
+            if (lvl >= 60)
+            {
+                if (spellId == BLOOD_STRIKE)
+                    pctbonus += 0.15f;
+                else if (spellId == GetSpell(HEART_STRIKE_1))
+                    pctbonus += 0.45f;
+                else if (spellId == GetSpell(BLOOD_BOIL_1))
+                    pctbonus += 0.3f;
+            }
+            //Improved Death Strike (part 1): 30% bonus damage for Death Strike
+            if (spellId == GetSpell(DEATH_STRIKE_1))
+                pctbonus += 0.3f;
+            //Merciless Combat (melee): 12% bonus damage for Obliterate on targets with less than 35% hp
+            //warning unsafe
+            if (lvl >= 67 && spellId == GetSpell(OBLITERATE_1) && damageinfo.target->GetHealthPct() < 35)
+                pctbonus += 0.12f;
+            //Blood of the North (part 1): 10% bonus damage for Blood Strike and Frost Strike (make Heart strike too)
+            if (lvl >= 69 && (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
+                pctbonus += 0.1f;
+            //Tundra Stalker (melee): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
+            //warning unsafe
+            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
+                pctbonus += 0.2f;
+            //Outbreak: 30% bonus damage for Plague Strike and 20% for Scourge Strike
+            if (lvl >= 59)
+            {
+                if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                    pctbonus += 0.3f;
+                //else if (spellId == GetSpell(SCOURGE_STRIKE_1))
+                //    pctbonus += 0.2f;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+
+                //Guile of Gorefiend (part 1 spell): 45% crit damage bonus for Howling Blast
+                if (lvl >= 69 && spellId == GetSpell(HOWLING_BLAST_1))
+                    pctbonus += 0.45f / 1.5f;
+
+                //Runic Focus: 50% crit damage bonus for all spells
+                pctbonus += 0.5f / 1.5f;
+            }
+
+            //Improved Icy Touch: 15% bonus damage for Icy Touch
+            if (spellId == GetSpell(ICY_TOUCH_1))
+                pctbonus += 0.15f;
+            //Increased Icy Touch Damage (id 54800): 111 bonus damage for Icy Touch
+            if (spellId == GetSpell(ICY_TOUCH_1))
+                fdamage += 111.f;
+            //Increased Death Coil Damage (id 54807): 80 bonus damage for Death Coil
+            if (spellId == GetSpell(DEATH_COIL_1))
+                fdamage += 80.f;
+            //Black Ice: 10% bonus damage for all Shadow and Frost spells
+            if (lvl >= 58 &&
+                ((SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()) ||
+                (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask())))
+                pctbonus += 0.1f;
+            //Glacier Rot: 20% bonus damage for Icy Touch, Howling Blast and Frost Strike
+            //warning unsafe
+            if (lvl >= 63 && (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
+                damageinfo.target && damageinfo.target->GetDiseasesByCaster(me->GetGUID()) > 0)
+                pctbonus += 0.2f;
+            //Merciless Combat (spell): 12% bonus damage for Icy Touch, Howling Blast and Frost Strike on targets with less than 35% hp
+            //warning unsafe
+            if (lvl >= 67 &&
+                (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
+                damageinfo.target->GetHealthPct() < 35)
+                pctbonus += 0.12f;
+            //Tundra Stalker (spell): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
+            //warning unsafe
+            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
+                pctbonus += 0.2f;
+            //Morbidity: 15% damage bonus for Death Coil
+            if (lvl >= 58 && spellId == GetSpell(DEATH_COIL_1))
+                pctbonus += 0.15f;
+
+            //temp
+            if (spellId == GetSpell(RUNE_TAP_1))
+                pctbonus += 1.f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->getLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Unholy Presence
+            if (Presence == DEATH_KNIGHT_UNHOLY_PRESENCE &&
+                ((spellInfo->SpellFamilyFlags[0] & 0xFFDFFE7F) ||
+                (spellInfo->SpellFamilyFlags[0] & 0x480B11F7) ||
+                (spellInfo->SpellFamilyFlags[0] & 0x20)))
+                timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            ////Holy Reach
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Pestilence
+            if (baseId == PESTILENCE_1)
+                flatbonus += 5.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo)
+        {
+            uint32 spellId = spellInfo->Id;
+
+            //std::ostringstream str;
+            //str << "Casting " << spellInfo->SpellName[0];
+            //me->MonsterWhisper(str.str().c_str(), master->GetGUID());
+            //Set cooldown for runes
+
+            if (runeCost[0] || runeCost[1] || runeCost[2] || runeCost[3])
+            {
+                //debug
+                std::ostringstream str;
+                str << "Casted " << spellInfo->SpellName[0] << " cost"
+                    << " " << runeCost[0] << " " << runeCost[1] << " " << runeCost[2] << " " << runeCost[3];
+
+                SpendRunes(spellInfo); //if spell is triggered runeCost is empty
+
+                //debug
+                uint32 runesLeft[NUM_RUNE_TYPES] = { 0,0,0,0 };
+                for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+                    for (uint8 j = 0; j != MAX_RUNES; ++j)
+                        if (_runes.runes[j].CurrentRune == i && _runes.runes[j].Cooldown == 0)
+                            runesLeft[i]++;
+                str << " left" << " " << runesLeft[0] << " " << runesLeft[1] << " " << runesLeft[2] << " " << runesLeft[3];
+                BotWhisper(str.str().c_str());
+            }
+
+            ////debug
+            //for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+            //    if (runeCost[i])
+            //        TC_LOG_FATAL("entities.player", "doCast():: DK bot %s has casted spell %u (%s) without %u rune(s) (type %u)!",
+            //            me->GetName().c_str(), spellId, spellInfo->SpellName[0], runeCost[i], i);
+            //runic power gain: all dk spells are instant but some have no unit target so
+            //we gain runic power here instead of SpellHitTarget()
+            if (SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID))
+                me->ModifyPower(POWER_RUNIC_POWER, int32(src->runePowerGain * runicpowerIncomeMult));
+
+            //stances
+            if (spellId == FROST_PRESENCE_1)
+            {
+                Presence = DEATH_KNIGHT_FROST_PRESENCE;
+                presencetimer = 1000;
+            }
+            else if (spellId == BLOOD_PRESENCE_1)
+            {
+                Presence = DEATH_KNIGHT_BLOOD_PRESENCE;
+                presencetimer = 1000;
+            }
+         }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            //Glyph of Horn of Winter: 1 minute bonus duration (3 for bot)
+            if (baseId == HORN_OF_WINTER_1)
+            {
+                if (Aura* horn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = horn->GetDuration() + 180000;
+                    horn->SetDuration(dur);
+                    horn->SetMaxDuration(dur);
+                }
+
+                //Winter Veil addition
+                if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                    me->AddAura(44755, target); //snowflakes
+            }
+
+            if (target == me)
+                return;
+
+            //Epidemic: 10 sec bonus duration for all diseases
+            if (spellId == FROST_FEVER_AURA || spellId == BLOOD_PLAGUE_AURA ||
+                spellId == CRYPT_FEVER_AURA || spellId == EBON_PLAGUE_AURA)
+            {
+                if (Aura* fever = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = fever->GetDuration() + 10000;
+                    fever->SetDuration(dur);
+                    fever->SetMaxDuration(dur);
+                }
+            }
+            //Sudden Doom: 15% ctc Death Coil on Blood Strike or Heart Strike (up to 30% for bot)
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+            {
+                if (GetSpell(DEATH_COIL_1) && me->getLevel() >= 65 && irand(1,100) <= (me->getLevel() - 50))
+                {
+                    //debug: dk bot cannot cast without runic power even triggered spells
+                    //modpower(40);
+                    me->CastSpell(target, GetSpell(DEATH_COIL_1), true);
+                }
+            }
+            //Rime (part 2): Obliterate has 15% chance to reset Howling Blast cooldown (25% for bot, screw runes part)
+            if (spellId == GetSpell(OBLITERATE_1))
+            {
+                if (me->getLevel() >= 67 && urand(1,100) <= 25)
+                    ResetSpellCooldown(HOWLING_BLAST_1);
+            }
+            //Chillblains Improved: increase duration by 10 sec (disable on players)
+            if (spellId == ICY_CLUTCH)
+            {
+                if (target->GetTypeId() != TYPEID_PLAYER)
+                {
+                    if (Aura* chill = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = chill->GetDuration() + 10000;
+                        chill->SetDuration(dur);
+                        chill->SetMaxDuration(dur);
+                    }
+                }
+            }
+            //Blood of the North (part 2): Blood Strike and Pestilence convert Blood Rune to Dark Rune (make Heart Strike too)
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) || GetSpell(spellId == PESTILENCE_1))
+            {
+                if (me->getLevel() >= 69)
+                    ConvertRune(RUNE_BLOOD, 1);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == RUNE_STRIKE_ACIVATION_AURA)
+            {
+                //Rune Strike activation and timer set
+                runestriketimer = 10000;
+            }
+            if (spellId == GetSpell(ANTI_MAGIC_SHELL_1))
+            {
+                //Glyph of Anti-Magic Shell: 2 sec increased duration (5 for bot)
+                if (Aura* shell = me->GetAura(spellId))
+                {
+                    uint32 dur = shell->GetDuration() + 5000;
+                    shell->SetDuration(dur);
+                    shell->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(VAMPIRIC_BLOOD_1))
+            {
+                //Glyph of Vampiric Blood: 5 sec increased duration
+                if (Aura* blood = me->GetAura(spellId))
+                {
+                    uint32 dur = blood->GetDuration() + 5000;
+                    blood->SetDuration(dur);
+                    blood->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(BONE_SHIELD_1))
+            {
+                //Glyph of Bone Shield: 1 bonus charge (2 for bot, 7 for tank)
+                if (Aura* bone = me->GetAura(spellId))
+                {
+                    bone->SetCharges(bone->GetCharges() + (IsTank() ? 3 : 1));
+                }
+            }
+            if (spellId == ICY_TALONS_AURA1 || spellId == ICY_TALONS_AURA2 ||
+                spellId == ICY_TALONS_AURA3 || spellId == ICY_TALONS_AURA4 || spellId == ICY_TALONS_AURA5)
+            {
+                //Icy Talons: Synchronize with Epidemic, add 10 sec duration
+                if (Aura* talons = me->GetAura(spellId))
+                {
+                    uint32 dur = talons->GetDuration() + 10000;
+                    talons->SetDuration(dur);
+                    talons->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(OBLITERATE_1))
+            {
+                //Death Rune Mastery: convert Unholy and Frost Runes into Death Runes
+                ConvertRune(RUNE_UNHOLY, 1);
+                ConvertRune(RUNE_FROST, 1);
+            }
+            if (spellId == GetSpell(ICEBOUND_FORTITUDE_1))
+            {
+                //Guile of Gorefiend (part 2): Icebound Fortitude 6 sec increased duration (18 for bot)
+                if (Aura* fort = me->GetAura(spellId))
+                {
+                    uint32 dur = fort->GetDuration() + 18000;
+                    fort->SetDuration(dur);
+                    fort->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                //Blood Presence Heal
+                if (me->HasAura(IMPROVED_BLOOD_PRESENCE_AURA))
+                {
+                    int32 bp0 = int32(damage / 25); //4%
+                    me->CastCustomSpell(me, BLOOD_PRESENCE_HEAL_EFFECT, &bp0, NULL, NULL, true);
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            presencetimer = 0;
+            runicpowertimer = 2000;
+            runicpowertimer2 = 5000;
+            runestriketimer = 0;
+            pestilencetimer = 0;
+
+            Presence = me->HasAura(FROST_PRESENCE_1) ? DEATH_KNIGHT_FROST_PRESENCE :
+                me->HasAura(BLOOD_PRESENCE_1) ? DEATH_KNIGHT_BLOOD_PRESENCE :
+                BOT_STANCE_NONE;
+
+            runicpowerIncomeMult = sWorld->getRate(RATE_POWER_RUNICPOWER_INCOME);
+            runicpowerLossMult = sWorld->getRate(RATE_POWER_RUNICPOWER_LOSS);
+            me->setPowerType(POWER_RUNIC_POWER);
+            me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
+
+            DefaultInit();
+            InitRunes();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            RuneTimers(diff);
+
+            if (presencetimer > diff)               presencetimer -= diff;
+            if (runicpowertimer > diff)             runicpowertimer -= diff;
+            if (runicpowertimer2 > diff)            runicpowertimer2 -= diff;
+
+            if (runestriketimer > diff)             runestriketimer -= diff;
+            else                                    runestriketimer = 0;
+            if (pestilencetimer > diff)             pestilencetimer -= diff;
+            else                                    pestilencetimer = 0;
+        }
+
+        void InitPowers()
+        {
+            if (master->getLevel() >= 70)
+                RefreshAura(RUNIC_POWER_MASTERY,5);
+            else if (master->getLevel() >= 58)
+                RefreshAura(RUNIC_POWER_MASTERY,4);
+            else
+            {
+                RefreshAura(RUNIC_POWER_MASTERY,0);
+                me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
+            }
+
+            if (runicpower)
+                me->SetPower(POWER_RUNIC_POWER, runicpower);
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            //InitSpellMap(BLOOD_STRIKE_1);
+            InitSpellMap(ICY_TOUCH_1);
+            InitSpellMap(PLAGUE_STRIKE_1);
+            InitSpellMap(DEATH_STRIKE_1);
+            InitSpellMap(OBLITERATE_1);
+            InitSpellMap(RUNE_STRIKE_1);
+            InitSpellMap(BLOOD_BOIL_1);
+            InitSpellMap(DEATH_AND_DECAY_1);
+  /*Talent*/lvl >= 63 ? InitSpellMap(HOWLING_BLAST_1) : RemoveSpell(HOWLING_BLAST_1);
+            InitSpellMap(DEATH_COIL_1);
+            InitSpellMap(DEATH_GRIP_1, true);
+            InitSpellMap(PESTILENCE_1);
+            InitSpellMap(MIND_FREEZE_1);
+            InitSpellMap(STRANGULATE_1);
+            InitSpellMap(CHAINS_OF_ICE_1);
+            InitSpellMap(ICEBOUND_FORTITUDE_1);
+            InitSpellMap(DARK_COMMAND_1);
+            InitSpellMap(ANTI_MAGIC_SHELL_1);
+            InitSpellMap(ARMY_OF_THE_DEAD_1);
+  /*Talent*/InitSpellMap(LICHBORNE_1, true);
+  /*Talent*/lvl >= 60 ? InitSpellMap(HUNGERING_COLD_1) : RemoveSpell(HUNGERING_COLD_1);
+            InitSpellMap(PATH_OF_FROST_1);
+            InitSpellMap(HORN_OF_WINTER_1);
+  /*Talent*/InitSpellMap(RUNE_TAP_1, true);
+  /*Talent*/lvl >= 58 ? InitSpellMap(BONE_SHIELD_1) : RemoveSpell(BONE_SHIELD_1);
+            InitSpellMap(EMPOWER_RUNE_WEAPON_1);
+  /*Talent*/InitSpellMap(MARK_OF_BLOOD_1, true);
+  /*Talent*/InitSpellMap(VAMPIRIC_BLOOD_1, true);
+  /*Talent*/lvl >= 59 ? InitSpellMap(HYSTERIA_1) : RemoveSpell(HYSTERIA_1);
+
+            InitSpellMap(BLOOD_PRESENCE_1, true);
+            InitSpellMap(FROST_PRESENCE_1, true);
+            //InitSpellMap(UNHOLY_PRESENCE_1, true);
+
+  /*Custom*/BLOOD_STRIKE = InitSpell(me, HEART_STRIKE_1) ? HEART_STRIKE_1 : BLOOD_STRIKE_1;
+            RemoveSpell(HEART_STRIKE_1);
+            RemoveSpell(BLOOD_STRIKE_1);
+            InitSpellMap(BLOOD_STRIKE);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(GLYPH_OF_CHAINS_OF_ICE, level >= 58 ? 1 : 0);
+            RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH, level >= 80 ? 4 : level >= 77 ? 3 : level >= 68 ? 2 : level >= 58 ? 1 : 0);
+            RefreshAura(GLYPH_OF_HEART_STRIKE, level >= 65 ? 1 : 0);
+            RefreshAura(GLYPH_OF_RUNE_TAP, level >= 68 ? 2 : level >= 60 ? 1 : 0);
+            RefreshAura(GLYPH_OF_HOWLING_BLAST, level >= 63 ? 1 : 0);
+            RefreshAura(BUTCHERY, level >= 57 ? 1 : 0);
+            RefreshAura(SCENT_OF_BLOOD, level >= 58 ? 1 : 0);
+            RefreshAura(VENDETTA, level >= 59 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE3, level >= 65 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE2, level >= 60 && level < 65 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE1, level >= 57 && level < 60 ? 1 : 0);
+            RefreshAura(ABOMINATIONS_MIGHT, level >= 60 ? 1 : 0);
+            RefreshAura(IMPROVED_BLOOD_PRESENCE, level >= 67 ? 1 : 0);
+            RefreshAura(BLOODWORMS, level >= 65 ? 2 : 0);
+            //RefreshAura(IMPROVED_DEATH_STRIKE, level >= 66 ? 1 : 0);
+            RefreshAura(TOUGHNESS, level >= 57 ? 1 : 0);
+            RefreshAura(ANNIHILATION, level >= 57 ? 1 : 0);
+            RefreshAura(ICY_TALONS, level >= 60 ? 1 : 0);
+            RefreshAura(CHILL_OF_THE_GRAVE, level >= 68 ? 2 : level >= 58 ? 1 : 0);
+            RefreshAura(IMPROVED_ICY_TALONS, level >= 64 ? 1 : 0);
+            RefreshAura(CHILBLAINS, level >= 68 ? 1 : 0);
+            RefreshAura(ACCLIMATION, level >= 69 ? 1 : 0);
+            RefreshAura(NECROSIS5, level >= 63 ? 1 : 0);
+            RefreshAura(NECROSIS4, level >= 62 && level < 63 ? 1 : 0);
+            RefreshAura(NECROSIS3, level >= 61 && level < 62 ? 1 : 0);
+            RefreshAura(NECROSIS2, level >= 60 && level < 61 ? 1 : 0);
+            RefreshAura(NECROSIS1, level >= 59 && level < 60 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE3, level >= 65 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE2, level >= 62 && level < 65 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE1, level >= 60 && level < 62 ? 1 : 0);
+            RefreshAura(DIRGE, level >= 67 ? 2 : level >= 61 ? 1 : 0);
+            RefreshAura(UNHOLY_BLIGHT, level >= 61 ? 1 : 0);
+            RefreshAura(DESECRATION, level >= 62 ? 1 : 0);
+            RefreshAura(CRYPT_FEVER, level >= 64 ? 1 : 0);
+            RefreshAura(EBON_PLAGUEBRINGER, level >= 68 ? 1 : 0);
+            RefreshAura(WANDERING_PLAGUE, level >= 67 ? 1 : 0);
+
+            RefreshAura(FROST_FEVER);
+            RefreshAura(BLOOD_PLAGUE);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case LICHBORNE_1:
+                case PATH_OF_FROST_1:
+                case HORN_OF_WINTER_1:
+                case BONE_SHIELD_1:
+                case RUNE_TAP_1:
+                case EMPOWER_RUNE_WEAPON_1:
+                case VAMPIRIC_BLOOD_1:
+                case HYSTERIA_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 BLOOD_STRIKE;
+/*tmrs*/uint32 presencetimer, runicpowertimer, runicpowertimer2, runestriketimer, pestilencetimer;
+/*misc*/uint32 runicpower;
+/*misc*/uint32 runeCost[NUM_RUNE_TYPES];
+/*misc*/float runicpowerIncomeMult, runicpowerLossMult;
+/*Chck*/uint8 Presence;
+
+        BotRunes _runes;
+
+        enum DeathKnightBaseSpells
+        {
+            BLOOD_STRIKE_1                      = 45902,
+            ICY_TOUCH_1                         = 45477,
+            PLAGUE_STRIKE_1                     = 45462,
+            DEATH_STRIKE_1                      = 49998,
+            OBLITERATE_1                        = 49020,
+            RUNE_STRIKE_1                       = 56815,
+            HEART_STRIKE_1                      = 55050,
+
+            BLOOD_BOIL_1                        = 48721,
+            DEATH_AND_DECAY_1                   = 43265,
+            HOWLING_BLAST_1                     = 49184,
+
+            DEATH_COIL_1                        = 47541,
+            DEATH_GRIP_1                        = 49576,
+            PESTILENCE_1                        = 50842,
+            MIND_FREEZE_1                       = 47528,
+            STRANGULATE_1                       = 47476,
+            CHAINS_OF_ICE_1                     = 45524,
+            ICEBOUND_FORTITUDE_1                = 48792,
+            DARK_COMMAND_1                      = 56222,
+            ANTI_MAGIC_SHELL_1                  = 48707,
+            ARMY_OF_THE_DEAD_1                  = 42650,
+            LICHBORNE_1                         = 49039,
+            HUNGERING_COLD_1                    = 49203,
+
+            PATH_OF_FROST_1                     = 3714,
+            HORN_OF_WINTER_1                    = 57330,
+            BONE_SHIELD_1                       = 49222,
+            RUNE_TAP_1                          = 48982,
+            EMPOWER_RUNE_WEAPON_1               = 47568,
+            MARK_OF_BLOOD_1                     = 49005,
+            VAMPIRIC_BLOOD_1                    = 55233,
+            HYSTERIA_1                          = 49016,
+
+            BLOOD_PRESENCE_1                    = 48266,
+            FROST_PRESENCE_1                    = 48263
+            //UNHOLY_PRESENCE_1                   = 48265
+        };
+        enum DeathKnightPassives
+        {
+        //Talents
+            BUTCHERY                            = 49483,//rank 2
+            SCENT_OF_BLOOD                      = 49509,//rank 3
+            VENDETTA                            = 55136,//rank 3
+            BLOODY_VENGEANCE1                   = 48988,
+            BLOODY_VENGEANCE2                   = 49503,
+            BLOODY_VENGEANCE3                   = 49504,
+            ABOMINATIONS_MIGHT                  = 53138,//rank 2
+            IMPROVED_BLOOD_PRESENCE             = 50371,//rank 2
+            BLOODWORMS                          = 49543,//rank 3
+            IMPROVED_DEATH_STRIKE               = 62908,//rank 2
+            TOUGHNESS                           = 49789,//rank 5
+            ANNIHILATION                        = 51473,//rank 3
+            ICY_TALONS                          = 50887,//rank 5
+            CHILL_OF_THE_GRAVE                  = 50115,//rank 2
+            IMPROVED_ICY_TALONS                 = 55610,
+            CHILBLAINS                          = 50043,//rank 3
+            ACCLIMATION                         = 50152,//rank 3
+            NECROSIS1                           = 51459,
+            NECROSIS2                           = 51462,
+            NECROSIS3                           = 51463,
+            NECROSIS4                           = 51464,
+            NECROSIS5                           = 51465,
+            BLOOD_CAKED_BLADE1                  = 49219,
+            BLOOD_CAKED_BLADE2                  = 49627,
+            BLOOD_CAKED_BLADE3                  = 49628,
+            DIRGE                               = 51206,//rank 2
+            UNHOLY_BLIGHT                       = 49194,
+            DESECRATION                         = 55667,//rank 2
+            CRYPT_FEVER                         = 49632,//rank 3
+            EBON_PLAGUEBRINGER                  = 51161,//rank 3
+            WANDERING_PLAGUE                    = 49655,//rank 3
+        //Special
+  /*Talent*/RUNIC_POWER_MASTERY                 = 50147,//rank 2
+            FROST_FEVER                         = 59921,
+            BLOOD_PLAGUE                        = 59879,
+        //Other
+            GLYPH_OF_CHAINS_OF_ICE              = 58620,//damage proc
+            CHAINS_OF_ICE_FROST_RUNE_REFRESH    = 62459,//5 runic power gain
+            GLYPH_OF_HEART_STRIKE               = 58616,//snare 50% for 10 sec
+            GLYPH_OF_RUNE_TAP                   = 59327,//10% heal for party
+            GLYPH_OF_HOWLING_BLAST              = 63335 //frost fever on targets
+        };
+        enum DeathKnightSpecial
+        {
+            FROST_FEVER_AURA                    = 55095,
+            BLOOD_PLAGUE_AURA                   = 55078,
+            CRYPT_FEVER_AURA                    = 50510,//rank 3
+            EBON_PLAGUE_AURA                    = 51735,//rank 3
+
+            RUNE_STRIKE_ACIVATION_AURA          = 56817,
+
+            IMPROVED_BLOOD_PRESENCE_AURA        = 63611,
+            BLOOD_PRESENCE_HEAL_EFFECT          = 50475,
+            BLADE_BARRIER_AURA                  = 64859,//rank 5
+            UNHOLY_BLIGHT_AURA                  = 50536,
+
+            ICY_TALONS_AURA1                    = 50882,//rank 1
+            ICY_TALONS_AURA2                    = 58575,//rank 2
+            ICY_TALONS_AURA3                    = 58576,//rank 3
+            ICY_TALONS_AURA4                    = 58577,//rank 4
+            ICY_TALONS_AURA5                    = 58578,//rank 5
+
+            //DEATH_COIL_ENEMY                    = 47632,
+            ICY_CLUTCH                          = 50436 //rank 3 Chilblains proc
+        };
+        //enum RunePlacing
+        //{
+        //    RUNE_BLOOD_FIRST,
+        //    RUNE_BLOOD_SECOND,
+        //    RUNE_UNHOLY_FIRST,
+        //    RUNE_UNHOLY_SECOND,
+        //    RUNE_FROST_FIRST,
+        //    RUNE_FROST_SECOND,
+        //    NO_RUNE
+        //};
+    };
+};
+
+void AddSC_death_knight_bot()
+{
+    new death_knight_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_druid_ai.cpp b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
new file mode 100644
index 0000000..67bcd83
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
@@ -0,0 +1,2625 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+/*
+Druid NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 85-90%
+TODO: Resolve remaining bugs with wrong power type after death
+*/
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new bot_druid_ai(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct bot_druid_ai : public bot_minion_ai
+    {
+        bot_druid_ai(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_DRUID;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_DRUID) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u) { bot_minion_ai::KilledUnit(u); }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { removeShapeshiftForm(); bot_minion_ai::JustDied(u); }
+
+        uint8 GetBotStance() const
+        {
+            return _form;
+        }
+
+        bool removeShapeshiftForm()
+        {
+            BotStances myform = _form;
+            _form = BOT_STANCE_NONE;
+            //ShapeshiftForm form = me->GetShapeshiftForm();
+            //if (form != FORM_NONE)
+            {
+                switch (myform/*form*/)
+                {
+                    //case FORM_DIREBEAR:
+                    //case FORM_BEAR:
+                    case DRUID_BEAR_FORM:
+                        if (IsRegenActive())
+                            return false;
+                        me->RemoveAurasDueToSpell(GetSpell(BEAR_FORM_1));
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_BEAR_BUFF);
+                        me->RemoveAurasDueToSpell(NATURAL_REACTION);
+                        me->RemoveAurasDueToSpell(SURVIVAL_OF_THE_FITTEST_BUFF);
+                        me->RemoveAurasDueToSpell(SAVAGE_DEFENSE_PASSIVE);
+                        break;
+                    //case FORM_CAT:
+                    case DRUID_CAT_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(CAT_FORM_1));
+                        me->RemoveAurasDueToSpell(FERAL_SWIFTNESS);
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_CAT_BUFF);
+                        me->RemoveAurasDueToSpell(NURTURING_INSTINCT_BUFF);
+                        me->RemoveAurasDueToSpell(PREDATORY_INSTINCTS);
+                        break;
+                    //case FORM_MOONKIN:
+                    case DRUID_MOONKIN_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(MOONKIN_FORM_1));
+                        me->RemoveAurasDueToSpell(GetSpell(OWLKIN_FRENZY));
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_MOONKIN_BUFF);
+                        break;
+                    //case FORM_TREE:
+                    case DRUID_TREE_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(TREE_OF_LIFE_FORM_1));
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_TREE_BUFF);
+                        break;
+                    //case FORM_TRAVEL:
+                    case DRUID_TRAVEL_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(TRAVEL_FORM_1));
+                        break;
+                    //case FORM_AQUA:
+                    case DRUID_AQUATIC_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(AQUATIC_FORM_1));
+                        break;
+                    //case FORM_FLIGHT:
+                    //case FORM_FLIGHT_EPIC:
+                    default:
+                        break;
+                }
+
+                if (me->getPowerType() != POWER_MANA)
+                {
+                    //TC_LOG_ERROR("entities.player", "druid_bot::removeShapeshiftForm(): still has poweType %u!", uint32(me->getPowerType()));
+                    me->setPowerType(POWER_MANA);
+                }
+                if (me->GetShapeshiftForm() != FORM_NONE)
+                {
+                    //TC_LOG_ERROR("entities.player", "druid_bot::removeShapeshiftForm(): still speshifted into %u!", uint32(me->GetShapeshiftForm()));
+                    me->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT, me->GetGUID(), NULL, false);
+                }
+
+                setStats(BOT_STANCE_NONE);
+            }
+            return true;
+        }
+
+        //bool IsMelee() const
+        //{
+        //    return bot_ai::IsMelee() && (_form == DRUID_BEAR_FORM || _form == DRUID_CAT_FORM);
+        //}
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            if (_form == DRUID_BEAR_FORM && HasRole(BOT_ROLE_RANGED) && IsSpellReady(BASH_1, lastdiff, false))
+                return;
+            GetInPosition(force, u);
+        }
+
+        bool MassGroupHeal(Player* gPlayer, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (!gPlayer || GC_Timer > diff || IAmFree()) return false;
+            if (IsCasting()) return false; // if I'm already casting
+            if (Rand() > 30 + 50 * (me->GetMap()->IsRaid())) return false;
+
+            Group const* pGroup = gPlayer->GetGroup();
+            if (!pGroup) return false;
+            bool tranq = IsSpellReady(TRANQUILITY_1, diff, false);
+            bool growt = IsSpellReady(WILD_GROWTH_1, diff, false) && !HasRole(BOT_ROLE_DPS);
+            if (!tranq && !growt) return false;
+
+            uint8 LHPcount = 0;
+            uint8 pct = 100;
+            Unit* healTarget = NULL;
+            std::list<Unit*> groupUnits;
+            for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                    continue;
+                if (tPlayer->IsAlive() && me->GetDistance(tPlayer) < 40)
+                {
+                    if (growt)
+                        groupUnits.push_back(tPlayer);
+                    if (tranq && GetHealthPCT(tPlayer) < 80)
+                    {
+                        if (GetHealthPCT(tPlayer) < pct)
+                        {
+                            pct = GetHealthPCT(tPlayer);
+                            healTarget = tPlayer;
+                        }
+                        ++LHPcount;
+                        if (LHPcount > 2) break;
+                    }
+                }
+                if (tPlayer->HaveBot())
+                {
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && bot->IsInWorld() && bot->IsAlive() && bot->GetDistance(me) < 40)
+                        {
+                            if (growt)
+                                groupUnits.push_back(bot);
+                            if (tranq && GetHealthPCT(bot) < 80)
+                            {
+                                if (GetHealthPCT(bot) < pct)
+                                {
+                                    pct = GetHealthPCT(bot);
+                                    healTarget = bot;
+                                }
+                                ++LHPcount;
+                                if (LHPcount > 2) break;
+                            }
+                        }
+                    }
+                }
+            }
+            if (LHPcount > 2 && tranq &&
+                doCast(me, GetSpell(TRANQUILITY_1)))
+                return true;
+
+            healTarget = NULL;
+            for (std::list<Unit*>::const_iterator i = groupUnits.begin(); i != groupUnits.end(); ++i)
+            {
+                LHPcount = 0;
+                Unit* gUnit = *i;
+
+                for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap())
+                        continue;
+                    if (tPlayer->IsAlive() && !tPlayer->isPossessed() && !tPlayer->IsCharmed() &&
+                        gUnit->GetDistance(tPlayer) < 15 && (GetLostHP(tPlayer) > 2000 || GetHealthPCT(tPlayer) < 90))
+                        ++LHPcount;
+
+                    if (tPlayer->HaveBot())
+                    {
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (bot && bot->IsInWorld() && bot->IsAlive())
+                            {
+                                if (gUnit->GetDistance(bot) < 15 && (GetLostHP(bot) > 2000 || GetHealthPCT(bot) < 90))
+                                    ++LHPcount;
+                            }
+                        }
+                    }
+
+                    if (LHPcount >= 3)
+                        break;
+                }
+
+                if (LHPcount >= 3)
+                {
+                    healTarget = gUnit;
+                    break;
+                }
+            }
+
+            if (LHPcount >= 3 && growt && healTarget &&
+                doCast(healTarget, GetSpell(WILD_GROWTH_1)))
+                return true;
+
+            return false;
+        }
+
+        //Powers
+        //rage
+        void getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            if (me->FindCurrentSpellBySpellId(GetSpell(MAUL_1)))
+                rage = std::max<int32>(rage - 150, 0);
+        }
+
+        //energy
+        void getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+        }
+
+        //all
+        int32 acost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        bool IsRegenActive() const
+        {
+            return me->IsAlive() && me->IsInCombat() && rage > 100 && GetHealthPCT(me) < 90 &&
+                me->GetAuraEffect(SPELL_AURA_PERIODIC_DUMMY, SPELLFAMILY_DRUID, 0x0, 0x40000000, 0x0);
+        }
+
+        void CheckBarkskin(uint32 diff)
+        {
+            //No GCD
+            if (IsSpellReady(BARKSKIN_1, diff, false) && !IsCasting() && !me->getAttackers().empty() &&
+                Rand() < (25 + 20 * me->getAttackers().size()) &&
+                GetHealthPCT(me) < (IsTank() ? 67 : 70 + 25 * me->getAttackers().size()))
+            {
+                if (doCast(me, GetSpell(BARKSKIN_1)))
+                {}
+            }
+        }
+
+        void CheckHibery(uint32 diff)
+        {
+            if (hiberyCheckTimer <= diff)
+            {
+                hibery = FindAffectedTarget(GetSpell(HIBERNATE_1), me->GetGUID());
+                hiberyCheckTimer = 2000;
+            }
+        }
+
+        void CheckHibernate(uint32 diff)
+        {
+            if (!(_form == DRUID_MOONKIN_FORM || _form == BOT_STANCE_NONE))
+                return;
+            //Skip Tranquility, Hurricane
+            if (GC_Timer > diff || IsCasting() || Rand() > 35)
+                return;
+
+            if (hibery == false && IsSpellReady(HIBERNATE_1, diff))
+            {
+                if (Unit* target = FindStunTarget(30))
+                {
+                    if (doCast(target, GetSpell(HIBERNATE_1)))
+                        return;
+                }
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (!(_form == DRUID_MOONKIN_FORM || _form == BOT_STANCE_NONE))
+                return;
+            //Skip Tranquility, Hurricane
+            if (GC_Timer > diff || Rand() > 35 || IsChanneling() || (HasRole(BOT_ROLE_HEAL) && IsCasting()))
+                return;
+
+            if (IsSpellReady(CYCLONE_1, diff))
+            {
+                if (Unit* target = FindCastingTarget(20, 0, CYCLONE_1))
+                {
+                    bool cast = false;
+                    for (uint8 i = CURRENT_GENERIC_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                    {
+                        Spell const* spell = target->GetCurrentSpell(CurrentSpellTypes(i));
+                        if (spell && IsInBotParty(spell->m_targets.GetUnitTarget()) && spell->GetTimer() > 1500)
+                        {
+                            cast = true;
+                            break;
+                        }
+                    }
+                    if (cast)
+                    {
+                        me->InterruptNonMeleeSpells(false);
+                        if (doCast(target, GetSpell(CYCLONE_1)))
+                            return;
+                    }
+                }
+            }
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            if (me->getPowerType() == POWER_RAGE)
+            {
+                if (ragetimer <= diff)
+                {
+                    if (!me->IsInCombat() &&
+                        !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x00080000)
+                    /*!HasAuraName(me, ENRAGE_1)*/)
+                    {
+                        if (me->GetPower(POWER_RAGE) > uint32(10.f * rageLossMult))
+                            me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) - uint32(10.f * rageLossMult)); //-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0);
+                    }
+                    ragetimer = 1500;
+                }
+                getrage();
+            }
+            else if (me->getPowerType() == POWER_ENERGY)
+                getenergy();
+
+            CheckAuras();
+            if (Wait())
+                return;
+            GenerateRand();
+            CheckHibery(diff);
+            CheckBarkskin(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (IsPotionReady())
+            {
+                if (me->getPowerType() == POWER_MANA && GetManaPCT(me) < 33)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 35)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            //Innervate
+            doInnervate(diff);
+
+            MassGroupHeal(master, diff);
+            if (me->IsInCombat())
+                CheckBattleRez(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (HasRole(BOT_ROLE_RANGED) || !me->IsInCombat() || !me->GetVictim() ||
+                (_form != DRUID_BEAR_FORM && (_form != DRUID_CAT_FORM || !me->GetMap()->IsRaid())))
+                BuffAndHealGroup(diff);
+            if (_form != DRUID_BEAR_FORM && _form != DRUID_CAT_FORM)
+            {
+                CureGroup(GetSpell(CURE_POISON_1), diff);
+                CureGroup(GetSpell(REMOVE_CURSE_1), diff);
+            }
+
+            if (!CheckAttackTarget(BOT_CLASS_DRUID))
+            {
+                if (!me->IsInCombat() && Rand() < 5 && me->HasAuraType(SPELL_AURA_MOD_STEALTH))
+                    me->RemoveAurasDueToSpell(PROWL_1);
+                return;
+            }
+
+            CheckHibernate(diff);
+            Counter(diff);
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+
+            StartAttack(opponent, bot_ai::IsMelee());
+
+            //NOT all forms abilities (prioritized)
+            //Cat Instaheal
+            if (_form == DRUID_CAT_FORM && GC_Timer <= diff && Rand() < 60 &&
+                (HasRole(BOT_ROLE_HEAL) || IAmFree()) && GetHealthPCT(me) < 45 &&
+                (me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_DRUID, 0x0, 0x80000, 0x0) ||/*me->HasAura(PREDATORS_SWIFTNESS_BUFF)*/
+                (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) && doCast(me, GetSpell(NATURES_SWIFTNESS_1)))))
+            {
+                //TODO maybe istant spells if clearcast?
+                //heal myself with instant
+                //Healing Touch has same reqs
+                if ((GetSpell(REGROWTH_1) && !me->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x40, 0x0, 0x0) &&
+                    doCast(me, GetSpell(REGROWTH_1))) || doCast(me, GetSpell(HEALING_TOUCH_1)))
+                {
+                    Position pos;
+                    opponent->GetNearPoint(me, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0.f, 15.f, opponent->GetAngle(me));
+                    GetInPosition(true, opponent, &pos);
+                    return;
+                }
+            }
+            //Roots
+            if (_form != DRUID_BEAR_FORM && _form != DRUID_TREE_FORM && Rand() < 35 &&
+                (HasRole(BOT_ROLE_DPS) || IAmFree()) && IsSpellReady(ENTANGLING_ROOTS_1, diff) &&
+                (_form != DRUID_CAT_FORM || IAmFree() || me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_DRUID, 0x0, 0x80000, 0x0)
+                /*me->HasAura(PREDATORS_SWIFTNESS_BUFF)*/))
+                CheckRoots();
+
+            //ALL forms abilities
+            //Nature's Grasp (no shapeshift)
+            if (IsSpellReady(NATURES_GRASP_1, diff) && HasRole(BOT_ROLE_DPS) && HasRole(BOT_ROLE_RANGED) && Rand() < 70 &&
+                !me->getAttackers().empty())
+            {
+                if (doCast(me, GetSpell(NATURES_GRASP_1)))
+                    return;
+            }
+            //Survival Instincts
+            //No GCD, bear is lvl 10, SI is lvl 20
+            //Shapeshift into bear if needed
+            if (GetSpell(SURVIVAL_INSTINCTS_1) && GC_Timer <= diff && Rand() < 75 &&
+                (GetHealthPCT(me) < (30 + 20 * (me->getAttackers().size() > 1))) &&
+                (_form == DRUID_BEAR_FORM || doCast(me, GetSpell(BEAR_FORM_1))))
+            {
+                if (doCast(me, SURVIVAL_INSTINCTS_1))
+                {}
+            }
+            //Bash
+            //Assuming Furor is present which is lvl 10
+            //Shapeshift into bear if needed
+            //bear is lvl 10, bash is lvl 14
+            //Retreat is triggered only if hit (SpellHitTarget)
+            if (IsSpellReady(BASH_1, diff) && !CCed(opponent, !opponent->IsNonMeleeSpellCasted(false,false,true)) &&
+                opponent->IsWithinMeleeRange(me))
+            {
+                if (_form == DRUID_BEAR_FORM && rage >= acost(BASH_1))
+                {
+                    if (doCast(opponent, GetSpell(BASH_1)))
+                        return;
+                }
+                else if (_form != DRUID_BEAR_FORM && opponent->GetVictim() == me && Rand() < 25)
+                {
+                    if (doCast(me, GetSpell(BEAR_FORM_1)))
+                        return;
+                }
+            }
+
+            //Main mode
+            //Choose form. Mode should be selected considering bot_ai::CheckAttackTarget() positioning selection
+            //1 Tanking mode
+            if (IsTank() && GetSpell(BEAR_FORM_1))
+            {
+                if (_form == DRUID_BEAR_FORM ||
+                    (GC_Timer <= diff && doCast(me, GetSpell(BEAR_FORM_1))))
+                    doBearActions(diff);
+            }
+            //2 Melee (tanking cat impossible: cat lvl 20, bear lvl 10)
+            else if (bot_ai::IsMelee())
+            {
+                //if lvl < 20 then bot gonna just melee its targets
+                if (_form == DRUID_CAT_FORM ||
+                    (IsSpellReady(CAT_FORM_1, diff) && doCast(me, GetSpell(CAT_FORM_1))))
+                    doCatActions(diff);
+            }
+            //3 Ranged dps
+            else if (HasRole(BOT_ROLE_DPS))
+            {
+                //pure dps goes moonkin
+                if (_form == DRUID_MOONKIN_FORM ||
+                    (GC_Timer <= diff && !GetSpell(MOONKIN_FORM_1) && removeShapeshiftForm()) ||
+                    HasRole(BOT_ROLE_HEAL) ||
+                    (IsSpellReady(MOONKIN_FORM_1, diff) && doCast(me, GetSpell(MOONKIN_FORM_1))))
+                    doBalanceActions(diff);
+            }
+            //4 Healer
+            else if (HasRole(BOT_ROLE_HEAL))
+            {
+                //pure healer goes tree
+                if (_form == DRUID_TREE_FORM ||
+                    (GC_Timer <= diff && !GetSpell(TREE_OF_LIFE_FORM_1) && removeShapeshiftForm()) ||
+                    HasRole(BOT_ROLE_DPS) ||
+                    (IsSpellReady(TREE_OF_LIFE_FORM_1, diff) && doCast(me, GetSpell(TREE_OF_LIFE_FORM_1))))
+                {/*do nothing*/} //not a mistake
+            }
+        }
+
+        void doBearActions(uint32 diff)
+        {
+            //debug
+            if (me->getPowerType() != POWER_RAGE || (me->GetShapeshiftForm() != FORM_BEAR && me->GetShapeshiftForm() != FORM_DIREBEAR))
+                return;
+
+            //Enrage
+            if (IsSpellReady(ENRAGE_1, diff, false) && me->IsInCombat() && (rage < 400 || IsTank()) && Rand() < 40)
+            {
+                if (doCast(me, GetSpell(ENRAGE_1)))
+                    getrage();
+            }
+            //Frenzied Regeneration
+            if (IsSpellReady(FRENZIED_REGENERATION_1, diff) && rage > 700 && GetHealthPCT(me) < 70 && Rand() < 40)
+            {
+                if (doCast(me, GetSpell(FRENZIED_REGENERATION_1)))
+                    return;
+            }
+
+            float dist = me->GetDistance(opponent);
+            //GROWL //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(GROWL_1, diff, false) && u && u != me && Rand() < 40 && dist < 30 &&
+                opponent->GetTypeId() == TYPEID_UNIT && !opponent->IsControlledByPlayer() &&
+                !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) && IsInBotParty(u) &&
+                (!IsTank(u) || (IsTank() && GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                ((!IsTankingClass(u->getClass()) && GetHealthPCT(u) < 80) || IsTank()))
+            {
+                if (doCast(opponent, GetSpell(GROWL_1)))
+                    return;
+            }
+            //GROWL 2 (distant)
+            if (IsSpellReady(GROWL_1, diff, false) && u == me && IsTank() && Rand() < 20)
+            {
+                if (Unit* tUnit = FindDistantTauntTarget())
+                {
+                    if (doCast(tUnit, GetSpell(GROWL_1)))
+                        return;
+                }
+            }
+            //Challenging Roar
+            if (IsSpellReady(CHALLENGING_ROAR_1, diff) && rage > acost(CHALLENGING_ROAR_1))
+            {
+                u = opponent->GetVictim();
+                if (u && u != me && !IsTank(u) && IsInBotParty(u) && !CCed(opponent) && dist <= 10 && Rand() < 25 &&
+                    (!IsTankingClass(u->getClass()) || IsTank()))
+                {
+                    if (doCast(me, GetSpell(CHALLENGING_ROAR_1)))
+                        return;
+                }
+                if (IsTank() && Rand() < 20)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets);
+                    uint8 count = 0;
+                    for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                    {
+                        if (!((*itr)->GetVictim() && IsTank((*itr)->GetVictim())))
+                            if (++count > 1)
+                                break;
+                    }
+                    if (count > 1 && doCast(me, GetSpell(CHALLENGING_ROAR_1)))
+                        return;
+                }
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+                return;
+
+            //Feral Charge
+            if (IsSpellReady(FERAL_CHARGE_BEAR_1, diff, false) && rage > acost(FERAL_CHARGE_BEAR_1) &&
+                !CCed(opponent, true) && dist > 9 && dist < 25)
+            {
+                if (doCast(opponent, GetSpell(FERAL_CHARGE_BEAR_1)))
+                    return;
+            }
+
+            //Faerie Fire (Feral, Bear)
+            if (IsSpellReady(FAERIE_FIRE_FERAL_1, diff) && me->IsInCombat() && Rand() < 35 && dist < 30 &&
+                !opponent->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_DRUID, 0x400))
+            {
+                if (doCast(opponent, GetSpell(FAERIE_FIRE_FERAL_1)))
+                    return;
+            }
+
+            //range check (melee) to prevent fake casts
+            if (dist > 5) return;
+
+            //Berserk (Bear)
+            if (IsSpellReady(BERSERK_1, diff) && !HasRole(BOT_ROLE_HEAL) && rage > 400 && Rand() < 40 &&
+                me->getAttackers().size() > 2)
+            {
+                if (doCast(me, GetSpell(BERSERK_1)))
+                    return;
+            }
+
+            //BOT_ROLE_DPS is checked in Attack(uin32)
+            //if (!HasRole(BOT_ROLE_DPS)) return;
+
+            //frenzied regeneration check
+            //we don't need to spend too much rage if regening
+            bool isRegenActive = IsRegenActive();
+
+            //Mangle (Bear)
+            if (IsSpellReady(MANGLE_BEAR_1, diff) && rage >= acost(MANGLE_BEAR_1) + 200*isRegenActive)
+            {
+                if (me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40) ||
+                    (Rand() < 30 && !opponent->GetAuraEffect(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT, SPELLFAMILY_DRUID, 2312, 1)))
+                {
+                    if (doCast(opponent, GetSpell(MANGLE_BEAR_1)))
+                        return;
+                }
+            }
+            //Swipe (Bear)
+            if (IsSpellReady(SWIPE_BEAR_1, diff) && rage >= acost(SWIPE_BEAR_1) + 200*isRegenActive &&
+                me->getAttackers().size() > 2 && Rand() < 70)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 5);
+                if (targets.size() > 2)
+                    if (doCast(opponent, GetSpell(SWIPE_BEAR_1)))
+                        return;
+            }
+            //Lacerate
+            if (IsSpellReady(LACERATE_1, diff) && rage >= acost(LACERATE_1) + 200*isRegenActive &&
+                opponent->GetHealth() > me->GetMaxHealth() * 2 && Rand() < 45)
+            {
+                bool cast = rage >= 600;
+                if (!cast)
+                {
+                    AuraApplication const* lacera = opponent->GetAuraApplicationOfRankedSpell(LACERATE_1);
+                    cast = (!lacera || lacera->GetBase()->GetStackAmount() < 5 || lacera->GetBase()->GetDuration() < 6000);
+                }
+
+                if (cast && doCast(opponent, GetSpell(LACERATE_1)))
+                    return;
+            }
+
+            //skip if maul is active
+            if (me->GetCurrentSpell(CURRENT_MELEE_SPELL))
+                return;
+
+            //Maul //No GCD
+            if (IsSpellReady(MAUL_1, diff, false) && rage >= acost(MAUL_1) + 200 + 200*isRegenActive)
+            {
+                if (doCast(opponent, GetSpell(MAUL_1)))
+                    return;
+            }
+        }
+
+        void doCatActions(uint32 diff)
+        {
+            //debug
+            if (me->getPowerType() != POWER_ENERGY || me->GetShapeshiftForm() != FORM_CAT)
+                return;
+
+            //Prowl (for Cooldown handling see bot_ai::ReleaseSpellCooldown)
+            if (IsSpellReady(PROWL_1, diff, false) && !me->IsInCombat() && Rand() < 50 && me->GetDistance(opponent) < 28)
+            {
+                if (doCast(me, GetSpell(PROWL_1)))
+                {}
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+                return;
+
+            //Faerie Fire (Feral, Cat)
+            if (IsSpellReady(FAERIE_FIRE_FERAL_1, diff) && me->IsInCombat() && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+                Rand() < 35 && me->GetDistance(opponent) < 30 &&
+                !opponent->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_DRUID, 0x400))
+            {
+                if (doCast(opponent, GetSpell(FAERIE_FIRE_FERAL_1)))
+                    return;
+            }
+
+            if (!JumpingOrFalling() && !CCed(me, true))
+            {
+                //leap here
+                //Feral Charge (Cat)
+                if (IsSpellReady(FERAL_CHARGE_CAT_1, diff, false) && energy >= acost(FERAL_CHARGE_CAT_1) && !me->GetMap()->IsDungeon() &&
+                    !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && Rand() < 65 &&
+                    !me->GetAuraEffect(SPELL_AURA_MOD_INCREASE_SPEED, SPELLFAMILY_DRUID, 0x0, 0x0, 0x8) &&//not dashing
+                    me->GetDistance(opponent) > 10 && me->GetDistance(opponent) < 25)
+                {
+                    if (doCast(opponent, GetSpell(FERAL_CHARGE_CAT_1)))
+                        return; //no gcd but jump time
+                }
+
+                //Dash (no GCD)
+                if (IsSpellReady(DASH_1, diff, false) &&
+                    (me->HasAuraType(SPELL_AURA_MOD_STEALTH) || (me->IsInCombat() && !IsSpellReady(FERAL_CHARGE_CAT_1, diff, false))) &&
+                    Rand() < 85 && me->GetDistance(opponent) > 15)
+                {
+                    if (doCast(me, GetSpell(DASH_1)))
+                    {}
+                }
+                //Savage Roar
+                if (IsSpellReady(SAVAGE_ROAR_1, diff) && comboPoints >= 1 && (me->IsInCombat() || opponent->IsInCombat()) &&
+                    !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && energy >= acost(SAVAGE_ROAR_1) &&
+                    !me->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_DRUID, 0, 0x10000000, 0))
+                {
+                    if (doCast(opponent, GetSpell(SAVAGE_ROAR_1)))
+                        return;
+                }
+            }
+
+            MoveBehind(opponent);
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5)
+                return;
+
+            //Cower
+            if (opponent->CanHaveThreatList())
+            {
+                if (IsSpellReady(COWER_1, diff) && opponent->GetVictim() == me && energy >= acost(COWER_1) &&
+                    int32(opponent->getThreatManager().getThreatList().size()) > 1 &&
+                    int32(opponent->getAttackers().size()) > 1 && Rand() < 45)
+                {
+                    if (doCast(opponent, GetSpell(COWER_1)))
+                        return;
+                }
+            }
+            //Tiger's Fury (no GCD) cannot use while Berserk is active
+            if (IsSpellReady(TIGERS_FURY_1, diff, false) && opponent->GetHealth() > me->GetHealth() / 4 &&
+                (me->getLevel() < 55 || energy <= 40) && Rand() < 40 &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+            {
+                if (doCast(me, GetSpell(TIGERS_FURY_1)))
+                    getenergy();
+            }
+            //Berserk can be used After Tiger's Fury without dispelling it
+            //Berserk (Cat)
+            if (IsSpellReady(BERSERK_1, diff) && !HasRole(BOT_ROLE_HEAL) && (!me->HasAuraType(SPELL_AURA_MOD_STEALTH) || energy >= 40) && Rand() < 50 &&
+                (opponent->GetTypeId() == TYPEID_PLAYER || opponent->GetHealth() + 5000 > me->GetHealth()))
+            {
+                if (doCast(me, GetSpell(BERSERK_1)))
+                    return;
+            }
+
+            //Openers
+            if (me->HasAuraType(SPELL_AURA_MOD_STEALTH))
+            {
+                uint32 opener =
+                    GetSpell(POUNCE_1) &&
+                    !opponent->HasAuraType(SPELL_AURA_MOD_STUN) &&
+                    opponent->GetDiminishing(DIMINISHING_OPENING_STUN) < DIMINISHING_LEVEL_3 &&
+                    (opponent->GetTypeId() == TYPEID_PLAYER || (!IAmFree() && master->GetNpcBotsCount() > 1)) ? POUNCE_1 :
+                    GetSpell(RAVAGE_1) ? RAVAGE_1 :
+                    GetSpell(SHRED_1) ? SHRED_1 : 0;
+
+                //all opener spells disabled
+                if (!opener)
+                {
+                    me->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+                    return;
+                }
+
+                if (opener != POUNCE_1 && opponent->HasInArc(M_PI, me))
+                    return;
+
+                //We do not check combo points amount
+                if (IsSpellReady(opener, diff) && energy >= acost(opener))
+                {
+                    if (doCast(opponent, GetSpell(opener)))
+                        return;
+                }
+
+                return;
+            }
+
+            //Finishers
+            if (comboPoints > 0)
+            {
+                //Maim
+                if (IsSpellReady(MAIM_1, diff) && !CCed(opponent) && energy >= acost(MAIM_1) &&
+                    (comboPoints >= 4 || opponent->IsNonMeleeSpellCasted(false,false,true)))
+                {
+                    if (doCast(opponent, GetSpell(MAIM_1)))
+                        return;
+                }
+                //Ferocious Bite
+                if (IsSpellReady(FEROCIOUS_BITE_1, diff) && (comboPoints >= 4 || opponent->GetHealth() < me->GetMaxHealth() / 4) &&
+                    energy >= acost(FEROCIOUS_BITE_1) && Rand() < (50 + comboPoints * 20))
+                {
+                    if (doCast(opponent, GetSpell(FEROCIOUS_BITE_1)))
+                        return;
+                }
+                //Rip
+                if (IsSpellReady(RIP_1, diff) && (comboPoints < 4 || !GetSpell(FEROCIOUS_BITE_1)) &&
+                    energy >= acost(RIP_1) && opponent->GetHealth() > me->GetMaxHealth() / 4 &&
+                    Rand() < (50 + 40 * (opponent->GetTypeId() == TYPEID_PLAYER && IsMeleeClass(opponent->getClass()))) &&
+                    !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x800000, 0x0, 0x0, me->GetGUID()))
+                {
+                    if (doCast(opponent, GetSpell(RIP_1)))
+                        return;
+                }
+            }
+
+            //Combo points generating
+            //Swipe (Cat)
+            if (IsSpellReady(SWIPE_CAT_1, diff) && me->getAttackers().empty() && energy >= acost(SWIPE_CAT_1) && Rand() < (35 + 100 * (me->GetMap()->IsDungeon())))
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 5);
+                if (targets.size() > 2)
+                    if (doCast(opponent, GetSpell(SWIPE_CAT_1)))
+                        return;
+            }
+            //Shred
+            if (IsSpellReady(SHRED_1, diff) && comboPoints < 4 && energy >= acost(SHRED_1) && Rand() < 85 &&
+                !opponent->HasInArc(M_PI, me))
+            {
+                if (doCast(opponent, GetSpell(SHRED_1)))
+                    return;
+            }
+            //Mangle (Cat)
+            if (IsSpellReady(MANGLE_CAT_1, diff) && comboPoints < 5 && energy >= acost(MANGLE_CAT_1) &&
+                (Rand() < 35 || !opponent->GetAuraEffect(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT, SPELLFAMILY_DRUID, 2312, 1)))
+            {
+                if (doCast(opponent, GetSpell(MANGLE_CAT_1)))
+                    return;
+            }
+            //Rake
+            if (IsSpellReady(RAKE_1, diff) && comboPoints < 3 && energy >= acost(RAKE_1) && Rand() < 60 &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x1000, 0x0, 0x0, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(RAKE_1)))
+                    return;
+            }
+            //Claw
+            if (IsSpellReady(CLAW_1, diff) && comboPoints < 5 && Rand() < 50 && (!GetSpell(SHRED_1) || opponent->HasInArc(M_PI, me)) &&
+                energy >= acost(CLAW_1))
+            {
+                if (doCast(opponent, GetSpell(CLAW_1)))
+                    return;
+            }
+        }
+
+        void doBalanceActions(uint32 diff)
+        {
+            //debug
+            if (me->getPowerType() != POWER_MANA)
+                return;
+
+            if (HasRole(BOT_ROLE_HEAL) && GetManaPCT(me) < 25)
+                return;
+
+            //BOT_ROLE_DPS is checked in Attack(uint32)
+            if (me->GetDistance(opponent) > 30)
+                return;
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NATURE|SPELL_SCHOOL_MASK_ARCANE))
+                return;
+
+            //spell reflections
+            if (IsSpellReady(FAERIE_FIRE_NORMAL_1, diff) && CanRemoveReflectSpells(opponent, FAERIE_FIRE_NORMAL_1) &&
+                doCast(opponent, FAERIE_FIRE_NORMAL_1))
+                return;
+
+            //Starfall
+            if (IsSpellReady(STARFALL_1, diff) && Rand() < 40)
+            {
+                bool cast = (opponent->GetTypeId() == TYPEID_PLAYER || me->getAttackers().size() > 1);
+                if (!cast)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 30.f);
+                    if (targets.size() > 3)
+                        cast = true;
+                }
+
+                if (cast && doCast(me, GetSpell(STARFALL_1)))
+                    return;
+
+                SetSpellCooldown(STARFALL_1, 1500); //fail
+            }
+            //Hurricane
+            if (IsSpellReady(HURRICANE_1, diff) && !JumpingOrFalling() && Rand() < 30)
+            {
+                if (Unit* target = FindAOETarget(28, true))
+                {
+                    if (doCast(target, GetSpell(HURRICANE_1)))
+                        return;
+                }
+                SetSpellCooldown(HURRICANE_1, 1500); //fail
+            }
+            //Typhoon
+            if (IsSpellReady(TYPHOON_1, diff) && Rand() < 35)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 25);
+                if (targets.size() > 2)
+                    if (doCast(me, GetSpell(TYPHOON_1)))
+                        return;
+
+                SetSpellCooldown(TYPHOON_1, 1500); //fail
+            }
+
+            //Faerie Fire (non-feral): moonkin or non-shapeshifted
+            if (IsSpellReady(FAERIE_FIRE_NORMAL_1, diff) && opponent->getAttackers().size() > 2 && Rand() < 50 &&
+                !opponent->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_DRUID, 0x400)
+                /*!HasAuraName(opponent, FAERIE_FIRE_ANY)*/)
+            {
+                if (doCast(opponent, GetSpell(FAERIE_FIRE_NORMAL_1)))
+                    return;
+            }
+
+            Unit* u = opponent->GetVictim();
+            //Insect Swarm
+            if (IsSpellReady(INSECT_SWARM_1, diff) && u && opponent->GetDistance(u) < 8 && Rand() < 30 &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x200000, 0x0, 0x0, me->GetGUID())
+                /*!HasAuraName(opponent, INSECT_SWARM_1, me->GetGUID())*/)
+            {
+                if (doCast(opponent, GetSpell(INSECT_SWARM_1)))
+                    return;
+            }
+
+            if (IsSpellReady(MOONFIRE_1, diff) && Rand() < 60 &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x2, 0x0, 0x0, me->GetGUID())
+                /*!HasAuraName(opponent, MOONFIRE_1, me->GetGUID())*/)
+            {
+                if (doCast(opponent, GetSpell(MOONFIRE_1)))
+                    return;
+            }
+            //TODO: balance starfire/wrath frequency based on mana effeciency
+            if (IsSpellReady(STARFIRE_1, diff))
+            {
+                AuraEffect const* eclipeLunar = me->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_DRUID, 0x0, 0x0, 0x4000);
+                int32 rand = 30 + 100 * (eclipeLunar && eclipeLunar->GetBase()->GetDuration() > 3000);
+
+                if (Rand() < rand && doCast(opponent, GetSpell(STARFIRE_1)))
+                    return;
+            }
+            if (IsSpellReady(WRATH_1, diff))
+            {
+                if (doCast(opponent, GetSpell(WRATH_1)))
+                    return;
+            }
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (GC_Timer <= diff && Rand() < 35 && GetManaPCT(me) > 15 &&
+                (me->IsPolymorphed() || me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
+            {
+                uint32 sshift;
+                switch (_form)
+                {
+                    case DRUID_BEAR_FORM:
+                        sshift = IsTank() && !me->getAttackers().empty() &&
+                            (!me->GetVictim() || me->GetDistance(me->GetVictim()) < 5) ? 0 :
+                            GetSpell(BEAR_FORM_1); break;
+                    case DRUID_CAT_FORM:     sshift = GetSpell(CAT_FORM_1);         break;
+                    case DRUID_MOONKIN_FORM: sshift = GetSpell(MOONKIN_FORM_1);     break;
+                    case DRUID_TREE_FORM:    sshift = GetSpell(TREE_OF_LIFE_FORM_1);break;
+                    //case DRUID_FLIGHT_FORM:  sshift = GetSpell(FLIGHT_FORM_1);      break;
+                    case DRUID_TRAVEL_FORM:  sshift = GetSpell(TRAVEL_FORM_1);      break;
+                    case DRUID_AQUATIC_FORM: sshift = GetSpell(AQUATIC_FORM_1);     break;
+                    case BOT_STANCE_NONE:    sshift = GetSpell(TRAVEL_FORM_1);      break;
+                    default:                 sshift = 0;                            break;
+                }
+                if (sshift && doCast(me, sshift))
+                {
+                    GetInPosition(false, NULL);
+                    return;
+                }
+            }
+            if (IsSpellReady(BERSERK_1, diff) && Rand() < 10 && me->HasAuraWithMechanic(1<<MECHANIC_FEAR))
+            {
+                if (doCast(me, GetSpell(BERSERK_1)))
+                    return;
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        bool HealTarget(Unit* target, uint32 diff)
+        {
+            if (!target || !target->IsAlive() || me->GetDistance(target) > 40)
+                return false;
+            uint8 hp = GetHealthPCT(target);
+            if (hp > 95 &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+            if (Rand() > 50 + 40*target->IsInCombat() + 100*master->GetMap()->IsRaid())
+                return false;
+            if (IsTank() && hp > 35)
+                return false;
+            if (hp > 50 && !IsTank(target) && (_form == DRUID_BEAR_FORM || _form == DRUID_CAT_FORM))
+                return false; //do not waste heal if in feral or so
+
+            if (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) &&
+                (me->IsInCombat() || target->IsInCombat()) &&//may just revive
+                (hp < 15 || (hp < 30 && target->getAttackers().size() > 1)) &&
+                (target->GetTypeId() == TYPEID_PLAYER || IsTank(target) || target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(me, GetSpell(NATURES_SWIFTNESS_1)))
+                {
+                    if (doCast(target, GetSpell(HEALING_TOUCH_1)))
+                        return true;
+                }
+            }
+            if (IsSpellReady(NOURISH_1, diff) && (hp < 75 || GetLostHP(target) > 5000))
+            {
+                static uint8 minHots = 2;
+                uint8 hots = 0;
+                Unit::AuraEffectList const& effectList = target->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
+                for (Unit::AuraEffectList::const_iterator itr = effectList.begin(); itr != effectList.end(); ++itr)
+                {
+                    AuraEffect const* eff = *itr;
+                    if (eff->GetCasterGUID() != me->GetGUID())
+                        continue;
+                    SpellInfo const* spellInfo = eff->GetSpellInfo();
+                    if (spellInfo->SpellFamilyName != SPELLFAMILY_DRUID)
+                        continue;
+                    //rejuv,regro,lifeb,wildg
+                    if (!((spellInfo->SpellFamilyFlags[0] & 0x50) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                        continue;
+                    hots += eff->GetBase()->GetStackAmount();
+                    if (hots >= minHots)
+                        break;
+                }
+                if (hots >= minHots && doCast(target, GetSpell(NOURISH_1)))
+                    return true;
+            }
+            if (IsSpellReady(SWIFTMEND_1, diff, false) && !HasRole(BOT_ROLE_DPS) &&
+                (hp < 30 || GetLostHP(target) > 7000) &&
+                //rejuv,regro
+                target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x50, 0x0, 0x0, me->GetGUID())
+                /*(HasAuraName(target, REGROWTH_1) || HasAuraName(target, REJUVENATION_1))*/)
+            {
+                if (doCast(target, GetSpell(SWIFTMEND_1)))
+                    return true;
+            }
+            //maintain HoTs
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->ToCreature() && u->ToCreature()->isWorldBoss();
+            if (IsSpellReady(REGROWTH_1, diff) && (hp < 85 || GetLostHP(target) > 4500 || tanking) &&
+                (hp < 65 || !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x40, 0x0, 0x0, me->GetGUID()))
+                /*!HasAuraName(target, REGROWTH_1, me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(REGROWTH_1)))
+                    return true;
+            }
+            if (IsSpellReady(LIFEBLOOM_1, diff) && ((hp < 85 && hp > 50) || (hp < 95 && tanking)))
+            {
+                AuraEffect const* bloom = target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x0, 0x10, 0x0, me->GetGUID());
+                //Aura const* bloom = target->GetAura(GetSpell(LIFEBLOOM_1), me->GetGUID());
+                if ((!bloom || bloom->GetBase()->GetStackAmount() < 3 ||
+                    (bloom->GetBase()->GetDuration() < 2500 && target->getAttackers().size() > 1 && hp < 90)) &&
+                    doCast(target, GetSpell(LIFEBLOOM_1)))
+                    return true;
+            }
+            if (GC_Timer <= diff && (hp > 35 || !GetSpell(REGROWTH_1)) && (hp < 70 || tanking) &&
+                doCast(target, GetSpell(HEALING_TOUCH_1)))
+                return true;
+            if (IsSpellReady(REJUVENATION_1, diff) && hp > 35 &&
+                (hp < 90 || GetLostHP(target) > 500 || tanking || !target->getAttackers().empty()) &&
+                //rejuv
+                !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x10, 0x0, 0x0, me->GetGUID())
+                /*!HasAuraName(target, REJUVENATION_1, me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(REJUVENATION_1)))
+                    return true;
+            }
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (uint32 MARK_OF_THE_WILD = GetSpell(MARK_OF_THE_WILD_1))
+            {
+                if (!target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_DRUID, 0x40000)
+                    /*!HasAuraName(target, MARK_OF_THE_WILD_1)*/)
+                    if (doCast(target, MARK_OF_THE_WILD))
+                        return true;
+            }
+            if (uint32 THORNS = GetSpell(THORNS_1))
+            {
+                if (IsTank(target) &&
+                    !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_DAMAGE_SHIELD, SPELLFAMILY_DRUID, 0x100)
+                    /*!HasAuraName(target, THORNS_1)*/)
+                    if (doCast(target, THORNS))
+                        return true;
+            }
+
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(REVIVE_1));
+
+            if (!IAmFree() && m_botCommandState == COMMAND_FOLLOW && !master->IsMounted() && Rand() < 35)
+            {
+                int32 dist = int32(me->GetDistance(master));
+                if (me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+                {
+                    if (_form != DRUID_AQUATIC_FORM && dist > 30 && GetSpell(AQUATIC_FORM_1) &&
+                        doCast(me, GetSpell(AQUATIC_FORM_1)))
+                        return;
+                }
+                //if (me->HasUnitMovementFlag(MOVEMENTFLAG_FLYING))
+                //{
+                //    if (_form != DRUID_AQUATIC_FORM && dist > 30 && GetSpell(AQUATIC_FORM_1) &&
+                //        doCast(me, GetSpell(AQUATIC_FORM_1)))
+                //        return;
+                //}
+                else if (_form != DRUID_TRAVEL_FORM && dist > 30 && GetSpell(TRAVEL_FORM_1))
+                {
+                    if (doCast(me, GetSpell(TRAVEL_FORM_1)))
+                        return;
+                }
+                else if (_form == DRUID_AQUATIC_FORM)
+                    removeShapeshiftForm();
+            }
+        }
+
+        void doInnervate(uint32 diff)
+        {
+            if (!IsSpellReady(INNERVATE_1, diff) || Rand() > 25)
+                return;
+            if (_form != BOT_STANCE_NONE && _form != DRUID_MOONKIN_FORM && _form != DRUID_TREE_FORM &&
+                (IsTank() || me->getAttackers().size() > 3))
+                return;
+
+            static uint8 minmanaval = 20;
+            Unit* iTarget = NULL;
+
+            if (master->IsInCombat() && master->getPowerType() == POWER_MANA &&
+                GetManaPCT(master) < minmanaval && !master->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                iTarget = master;
+            else if (me->IsInCombat() && me->getPowerType() == POWER_MANA &&
+                GetManaPCT(me) < minmanaval && !me->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                iTarget = me;
+
+            if (!IAmFree())
+            {
+                Group* group = master->GetGroup();
+                if (!iTarget && !group) //first check master's bots
+                {
+                    BotMap const* map = master->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        Creature* bot = itr->second;
+                        if (!bot || !bot->IsInCombat() || !bot->IsAlive() || bot->IsTempBot()) continue;
+                        if (bot->getPowerType() != POWER_MANA) continue;
+                        if (me->GetExactDist(bot) > 30) continue;
+                        if (GetManaPCT(bot) < minmanaval && !bot->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                        {
+                            iTarget = bot;
+                            break;
+                        }
+                    }
+                }
+                if (!iTarget && group) //cycle through player members...
+                {
+                    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == NULL || !tPlayer->IsInWorld() || !tPlayer->IsInCombat() || !tPlayer->IsAlive()) continue;
+                        if (tPlayer->getPowerType() != POWER_MANA) continue;
+                        if (me->GetExactDist(tPlayer) > 30) continue;
+                        if (GetManaPCT(tPlayer) < minmanaval && !tPlayer->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                        {
+                            iTarget = tPlayer;
+                            break;
+                        }
+                        if (iTarget)
+                            break;
+                    }
+                }
+                if (!iTarget && group) //... and their bots.
+                {
+                    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (!bot || !bot->IsInCombat() || !bot->IsAlive() || bot->IsTempBot()) continue;
+                            if (bot->getPowerType() != POWER_MANA) continue;
+                            if (me->GetExactDist(bot) > 30) continue;
+                            if (GetManaPCT(bot) < minmanaval && !bot->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                            {
+                                iTarget = bot;
+                                break;
+                            }
+                        }
+                        if (iTarget)
+                            break;
+                    }
+                }
+            }
+
+            if (iTarget && doCast(iTarget, INNERVATE_1))
+            {
+                if (iTarget->GetTypeId() == TYPEID_PLAYER)
+                    BotWhisper("Innervate on You!", iTarget->ToPlayer());
+                else if (!IAmFree())
+                {
+                    std::ostringstream msg;
+                    msg << "Innervate on " << (iTarget == me ? "myself" : iTarget->GetName()) << '!';
+                    BotWhisper(msg.str().c_str());
+                }
+
+                return;
+            }
+
+            SetSpellCooldown(INNERVATE_1, 1500); //fail
+        }
+
+        void CheckRoots()
+        {
+            if (uint32 ENTANGLING_ROOTS = GetSpell(ENTANGLING_ROOTS_1))
+            {
+                if (FindAffectedTarget(ENTANGLING_ROOTS, me->GetGUID(), 60))
+                    return;
+                if (Unit* target = FindRootTarget(30, ENTANGLING_ROOTS))
+                    if (doCast(target, ENTANGLING_ROOTS))
+                        return;
+            }
+        }
+
+        void CheckBattleRez(uint32 diff)
+        {
+            if (!IsSpellReady(REBIRTH_1, diff, false) || IAmFree() || me->IsMounted() ||
+                IsTank() || IsCasting() || Rand() > 20) return;
+
+            Group const* gr = master->GetGroup();
+            std::list<Unit*> targets;
+            if (!gr)
+            {
+                Unit* target = master;
+                if (master->IsAlive()) return;
+                if (master->isRessurectRequested()) return; //ressurected
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)master->GetCorpse();
+                if (!target || !target->IsInWorld())
+                    return;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+                    SetSpellCooldown(REBIRTH_1, 1500);
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    BotWhisper("Rezzing You");
+                    return;
+                }
+            }
+            else
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    Unit* target = tPlayer;
+                    if (!tPlayer || tPlayer->IsAlive()) continue;
+                    if (tPlayer->isRessurectRequested()) continue; //ressurected
+                    if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                        target = (Unit*)tPlayer->GetCorpse();
+                    if (!target || !target->IsInWorld()) continue;
+                    if (master->GetMap() != target->FindMap()) continue;
+                    if (me->GetDistance(target) > 100) continue;
+                    targets.push_back(target);
+                }
+            }
+
+            BotMap const* botMap = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = botMap->begin(); itr != botMap->end(); ++itr)
+            {
+                Creature* bot = itr->second;
+                if (bot && bot->IsInWorld() && !bot->IsAlive() && IsTank(bot) && me->GetDistance(bot) < 80)
+                    targets.push_back(bot);
+            }
+
+            if (Unit* targetOrCorpse = !targets.empty() ? Trinity::Containers::SelectRandomContainerElement(targets) : NULL)
+            {
+                if (me->GetExactDist(targetOrCorpse) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(targetOrCorpse->GetMapId(), *targetOrCorpse);
+                    return;
+                }
+                else if (!targetOrCorpse->IsWithinLOSInMap(me))
+                    me->Relocate(*targetOrCorpse);
+
+                if (doCast(targetOrCorpse, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    if (targetOrCorpse->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Rezzing You", targetOrCorpse->ToPlayer());
+                    if (targetOrCorpse != master)
+                    {
+                        std::string rezstr = "Rezzing ";
+                        rezstr += targetOrCorpse->GetName();
+                        if (targetOrCorpse->GetTypeId() == TYPEID_UNIT)
+                            rezstr += " (bot tank)";
+                        BotWhisper(rezstr.c_str());
+                    }
+                    return;
+                }
+            }
+        }
+
+        void setStats(BotStances form)
+        {
+            _form = form;
+            switch (form)
+            {
+                case DRUID_BEAR_FORM:
+                    if (me->getPowerType() != POWER_RAGE)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_RAGE");
+                        me->setPowerType(POWER_RAGE);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_BEAR_BUFF, me->getLevel() >= 20);
+                    RefreshAura(NATURAL_REACTION, me->getLevel() >= 35);
+                    RefreshAura(SURVIVAL_OF_THE_FITTEST_BUFF, me->getLevel() >= 35);
+                    RefreshAura(SAVAGE_DEFENSE_PASSIVE, me->getLevel() >= 40);
+                    break;
+                case DRUID_CAT_FORM:
+                    if (me->getPowerType() != POWER_ENERGY)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_ENERGY");
+                        me->setPowerType(POWER_ENERGY);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_CAT_BUFF, me->getLevel() >= 20);
+                    RefreshAura(FERAL_SWIFTNESS, me->getLevel() >= 20); //talents ignore forms for creatures so put that here
+                    RefreshAura(NURTURING_INSTINCT_BUFF, me->getLevel() >= 30);
+                    RefreshAura(PREDATORY_INSTINCTS, me->getLevel() >= 45);
+                    break;
+                case DRUID_MOONKIN_FORM:
+                    if (me->getPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (moonkin)");
+                        me->setPowerType(POWER_MANA);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_MOONKIN_BUFF, me->getLevel() >= 20);
+                    RefreshAura(OWLKIN_FRENZY, me->getLevel() >= 45);
+                    break;
+                case DRUID_TREE_FORM:
+                    if (me->getPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (tree)");
+                        me->setPowerType(POWER_MANA);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_TREE_BUFF, me->getLevel() >= 20);
+                    break;
+                case DRUID_TRAVEL_FORM:
+                    if (me->getPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (travel)");
+                        me->setPowerType(POWER_MANA);
+                    }
+                    break;
+                case DRUID_AQUATIC_FORM:
+                    if (me->getPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (aquatic)");
+                        me->setPowerType(POWER_MANA);
+                    }
+                    break;
+                //case DRUID_FLIGHT_FORM:
+                //    if (me->getPowerType() != POWER_MANA)
+                //    {
+                //        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (flight)");
+                //        me->setPowerType(POWER_MANA);
+                //    }
+                //    break;
+                case BOT_STANCE_NONE:
+                    if (me->getPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (deshape)");
+                        me->setPowerType(POWER_MANA);
+                    }
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "druid_bot::setStats(): NYI form %u", uint32(form));
+                    setStats(BOT_STANCE_NONE);
+                    return;
+            }
+
+            SetShouldUpdateStats();
+            SetStats(false);
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+        {
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+
+            if (damageinfo.hitOutCome == MELEE_HIT_CRIT)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Primal Fury (white attacks): 100% to gain 5 rage at crit in (Dire) Bear Form
+                if (lvl >= 25 && _form == DRUID_BEAR_FORM)
+                    me->CastSpell(me, PRIMAL_FURY_EFFECT_ENERGIZE, true);
+                //Predatory Instincts (part 1): 10% additional crit damage bonus for melee attacks in Cat form
+                if (lvl >= 45 && _form == DRUID_CAT_FORM)
+                    pctbonus += 0.05f;
+            }
+
+            damage = damage * (1.0f + pctbonus);
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                ////Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                //if (lvl >= 21)
+                //    pctbonus += 0.25f;
+            }
+
+            //Feral Aggression: 15% bonus damage for Ferocious Bite
+            if (lvl >= 10 && baseId == FEROCIOUS_BITE_1)
+                pctbonus += 0.15f;
+            //Feral Instinct: 30% bonus damage for Swipe (Bear)
+            if (lvl >= 15 && baseId == SWIPE_BEAR_1)
+                pctbonus += 0.3f;
+            //Savage Fury: 20% bonus damage for Claw, Rake, Mangle (Cat), Mangle (Bear) and Maul
+            if (lvl >= 15 &&
+                (baseId == CLAW_1 ||
+                baseId == RAKE_1 ||
+                baseId == MANGLE_CAT_1 ||
+                baseId == MANGLE_BEAR_1 ||
+                baseId == MAUL_1))
+                pctbonus += 0.2f;
+            //Rend and Tear: 20% bonus damage on bleeding targets for Maul and Shred
+            if (lvl >= 55 && damageinfo.target && damageinfo.target->HasAuraState(AURA_STATE_BLEEDING) &&
+                (baseId == MAUL_1 || baseId == SHRED_1))
+                pctbonus += 0.2f;
+            //Glyph of Mangle: 10% bonus damage for Mangle (all)
+            if (lvl >= 50 && (baseId == MANGLE_BEAR_1 || baseId == MANGLE_CAT_1))
+                pctbonus += 0.1f;
+
+            //Primal Fury (yellow attacks): 100% to gain 5 rage at crit in (Dire) Bear Form
+            //Primal Fury (yellow attacks): 100% to gain 1 combo point at crit in Cat Form
+            if (_form == DRUID_BEAR_FORM && crit && lvl >= 25)
+                me->CastSpell(me, PRIMAL_FURY_EFFECT_ENERGIZE, true);
+            if (_form == DRUID_CAT_FORM &&
+                (baseId == CLAW_1 || baseId == MANGLE_CAT_1 || baseId == POUNCE_1 ||
+                baseId == RAKE_1 || baseId == RAVAGE_1 || baseId == SHRED_1))
+                static_cast<bool>(primalFuryProc) = crit && lvl >= 25;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Nature's bounty: 25% additional critical chance for Regrowth and Nourish
+            if (lvl >= 35 && (baseId == REGROWTH_1 || baseId == NOURISH_1))
+                crit_chance += 25.f;
+            //Rend and Tear (part 2): 25% additional critical chance on bleeding targets for Ferocious Bite (handled in Unit.cpp)
+            //if (lvl >= 55 && victim->HasAuraState(AURA_STATE_BLEEDING) && baseId == FEROCIOUS_BITE_1)
+            //    crit_chance += 25.f;
+            //Improved Moonfire
+            if (lvl >= 15 && baseId == MOONFIRE_1)
+                crit_chance += 10.f;
+            //Nature's Majesty: 4% additional critical chance for Wrath, Starfire, Starfall, Nourish and Healing Touch
+            if (lvl >= 15 && ((spellInfo->SpellFamilyFlags[0] & 0x25) || (spellInfo->SpellFamilyFlags[1] & 0x2800000)))
+                crit_chance += 4.f;
+            //Eclipse (Lunar): 40% additional critical chance for Starfire
+            if (lvl >= 50 && baseId == STARFIRE_1 && me->HasAura(ECLIPSE_LUNAR_BUFF))
+                crit_chance += 40.f;
+            //Natural Perfection: 3% additional critical chance for all spells
+            if (lvl >= 40)
+                crit_chance += 3.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Vengeance: 100% additional crit damage bonus for Starfire, Starfall, Moonfire and Wrath
+                if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x7) || (spellInfo->SpellFamilyFlags[1] & 0x800000)))
+                    pctbonus += 0.333f;
+            }
+            //Genesis: 5% bonus damage for Dots
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x6002D2) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                pctbonus += 0.05f;
+            //Improved Insect Swarm: SpellEffects.cpp, Unit.cpp
+            //Brambles: 75% bonus damage for Throns and Entangling Roots (Thorns are handled in Unit.cpp)
+            if (lvl >= 20 && (spellInfo->SpellFamilyFlags[0] & 0x200))
+                pctbonus += 0.75f;
+            //Moonfury: 10% bonus damage for Starfire, Moonfire and Wrath
+            if (lvl >= 35 && (spellInfo->SpellFamilyFlags[0] & 0x7))
+                pctbonus += 0.1f;
+            //Glyph of Focus (part 1): 10% bonus damage for Starfall
+            if (lvl >= 70 && (spellInfo->SpellFamilyFlags[1] & 0x800000))
+                pctbonus += 0.1f;
+            //Wrath of Cenarius: 20%/10% Increased spellpower bonus for Starfire/Wrath
+            if (lvl >= 45)
+            {
+                if (baseId == STARFIRE_1)
+                    fdamage += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * 1.88f * me->CalculateLevelPenalty(spellInfo);
+                if (baseId == WRATH_1)
+                    fdamage += spellpower * 0.1f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * 1.88f * me->CalculateLevelPenalty(spellInfo);
+            }
+            //Eclipse (Solar): 40% bonus damage for Wrath
+            if (lvl >= 50 && baseId == WRATH_1 && me->HasAura(ECLIPSE_SOLAR_BUFF))
+                pctbonus += 0.4f;
+            //Gale Winds: 30% bonus damage for Hurricane and Typhoon
+            if (lvl >= 50 && ((spellInfo->SpellFamilyFlags[0] & 0x400000) || (spellInfo->SpellFamilyFlags[1] & 0x1000000)))
+                pctbonus += 0.3f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Genesis: 5% bonus healing for Hots
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x6002D2) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                pctbonus += 0.05f;
+            //Improved Rejuvenation: 15% bonus healing for Rejuvenation
+            if (lvl >= 25 && baseId == REJUVENATION_1)
+                pctbonus += 0.15f;
+            //Improved Rejuvenation (17114,17115): 27% bonus healing for Rejuvenation
+            //if (baseId == REJUVENATION_1)
+            //    pctbonus += 0.27f;
+            //Gift of Nature: 10% bonus healing for all spells
+            if (lvl >= 30)
+                pctbonus += 0.1f;
+            //Empowered Touch: 40% bonus (from spellpower) for Healing Touch and 20% bonus (from spellpower) for Nourish
+            if (lvl >= 35)
+            {
+                if (baseId == HEALING_TOUCH_1)
+                    flat_mod += spellpower * 0.4f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+                else if (baseId == NOURISH_1)
+                    flat_mod += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            }
+            //Empowered Rejuvenation: 20% bonus healing for healing over time effects
+            if (lvl >= 45 && ((spellInfo->SpellFamilyFlags[0] & 0xD0) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                flat_mod += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Clearcasting: -100% mana/rage/energy cost for any spell
+            if (AuraEffect const* eff = me->GetAuraEffect(OMEN_OF_CLARITY_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+
+            //percent mods
+            //Tree of Life Passive (5420) (activates when learned):
+            if (lvl >= 50 && ((spellInfo->SpellFamilyFlags[0] & 0x50) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                pctbonus += 0.5f;
+            //Glyph of the Wild:
+            if (lvl >= 15 && baseId == MARK_OF_THE_WILD_1)
+                pctbonus += 0.5f;
+            //Natural Shapeshifter:
+            if (lvl >= 15 &&
+                spellInfo->Effects[0].Effect == SPELL_EFFECT_APPLY_AURA &&
+                spellInfo->Effects[0].ApplyAuraName == SPELL_AURA_MOD_SHAPESHIFT)
+                pctbonus += 0.3f;
+            //King of the Jungle part 3:
+            if (lvl >= 15 && (spellInfo->SpellFamilyFlags[0] & 0xC0000000))
+                pctbonus += 0.6f;
+            //Tranquil Spirit:
+            if (lvl >= 25 &&
+                (baseId == HEALING_TOUCH_1 || baseId == NOURISH_1 || baseId == TRANQUILITY_1))
+                pctbonus += 0.1f;
+            //Moonglow:
+            if (lvl >= 15 && ((spellInfo->SpellFamilyFlags[0] & 0x77) || (spellInfo->SpellFamilyFlags[1] & 0x2800000)))
+                pctbonus += 0.09f;
+            //Berserk part 2:
+            if (lvl >= 60 && _form == DRUID_CAT_FORM &&
+                //((spellInfo->SpellFamilyFlags[0] & 0x839000) ||
+                //(spellInfo->SpellFamilyFlags[1] & 0x30000480) ||
+                //(spellInfo->SpellFamilyFlags[2] & 0x40420)) &&
+                 me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+                pctbonus += 0.5f;
+
+            //flat mods
+            //Shredding Attacks:
+            if (lvl >= 25)
+            {
+                if (spellInfo->SpellFamilyFlags[0] & 0x8000)
+                    flatbonus += 18;
+                else if (spellInfo->SpellFamilyFlags[1] & 0x100)
+                    flatbonus += 20;
+            }
+            //Ferocity:
+            if (lvl >= 10)
+            {
+                if ((spellInfo->SpellFamilyFlags[0] & 0x800) || (spellInfo->SpellFamilyFlags[1] & 0x100040))
+                    flatbonus += 50;
+                else if ((spellInfo->SpellFamilyFlags[0] & 0x1000) ||
+                    (spellInfo->SpellFamilyFlags[1] & 0x400) ||
+                    (spellInfo->SpellFamilyFlags[2] & 0x40400))
+                    flatbonus += 5;
+            }
+            //Improved Mangle part 2:
+            if (lvl >= 50 && (spellInfo->SpellFamilyFlags[1] & 0x400))
+                flatbonus += 6;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+        {
+            //casttime is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Elune's Wrath: -100% cast time for Starfire
+            AuraEffect const* elun = me->GetAuraEffect(ELUNES_WRATH_BUFF, 0);
+            //Predator's Swiftness: -100% cast time
+            AuraEffect const* pred = me->GetAuraEffect(PREDATORS_SWIFTNESS_BUFF, 0);
+            //Nature's Swiftness: -100% cast time
+            AuraEffect const* natu = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0);
+            if ((elun && elun->IsAffectedOnSpell(spellInfo)) ||
+                (pred && pred->IsAffectedOnSpell(spellInfo)) ||
+                (natu && natu->IsAffectedOnSpell(spellInfo)))
+                pctbonus += 1.0f;
+
+            //pct mods
+            //Celestial Focus: 3% haste
+            if (lvl >= 25)
+                pctbonus += 0.03f;
+
+            //flat mods
+            //Starlight Wrath: -0.5 sec cast time for Wrath and Starfire
+            if (lvl >= 10 && (baseId == WRATH_1 || baseId == STARFIRE_1))
+                timebonus += 500;
+            //Naturalist: -0.5 sec cast time for Healing Touch
+            if (lvl >= 15 && baseId == HEALING_TOUCH_1)
+                timebonus += 500;
+            //Regrowth bonus (ids:21872,46834): -0.2 x2 sec cast time for Regrowth
+            if (lvl >= 68 && baseId == REGROWTH_1)
+                timebonus += 400;
+
+            casttime = std::max<int32>((float(casttime) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Improved Tranquility: -60% cooldown for Tanquility
+            if (lvl >= 30 && baseId == TRANQUILITY_1)
+                pctbonus += 0.6f;
+
+            //flat mods
+            //Glyph of Turn Evil: +8 sec cooldown for Turn Evil (3 sec for bots)
+            //if (lvl >= 24 && spellId == GetSpell(TURN_EVIL_1))
+            //    timebonus -= 3000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Dash: -20% cooldown for Dash
+            if (lvl >= 16 && baseId == DASH_1)
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Genesis Rebirth Bonus (26106): -5 min cooldown for Rebirth
+            if (baseId == REBIRTH_1)
+                timebonus += 300000;
+            //Improved Mangle part 1: -1.5 sec cooldown for Mangle (Bear)
+            if (lvl >= 50 && baseId == MANGLE_BEAR_1)
+                timebonus += 1500;
+            //Berserk part 1:
+            if (lvl >= 60 && _form == DRUID_BEAR_FORM && (spellInfo->SpellFamilyFlags[1] & 0x40) &&
+                me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+                timebonus += 6000;
+            //Brutal Impact: -30 sec cooldown for Bash
+            if (lvl >= 30 && baseId == BASH_1)
+                timebonus += 30000;
+            //Glyph of Typhoon: -3 sec cooldown for Typhoon
+            if (lvl >= 70 && baseId == TYPHOON_1)
+                timebonus += 3000;
+            //Starfall: increase cooldown for bots
+            if (baseId == STARFALL_1)
+                timebonus -= 90000; //x2
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct bonus
+            //Gift of the Earthmother part 2:
+            if (lvl >= 55 && baseId == LIFEBLOOM_1)
+                pctbonus += 0.1f;
+
+            //flat bonus
+            ////Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+            //    timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+        {
+            uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+
+            //flat mods
+            //Starfall
+            if (spellId == STARFALL_DUMMY_AOE_4)
+                flatbonus -= 10.f; //20 = 36 talented - 18 glyphed + 2 custom
+            if (spellId == STARFALL_DAMAGE_AOE_4)
+                flatbonus += 4.f; //5 nominal + 4 custom
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const
+        {
+            uint32 bonusTargets = 0;
+
+            //Glyph of Maul: + 1 target
+            if (spellInfo->SpellFamilyFlags[0] & 0x800)
+                bonusTargets += 1;
+            //Glyph of Wild Growth: + 1 target
+            if (spellInfo->SpellFamilyFlags[1] & 0x4000000)
+                bonusTargets += 1;
+            //Berserk: + 2 Mangle (Bear) targets
+            if (spellInfo->SpellFamilyFlags[1] & 0x40 &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+                bonusTargets += 2;
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo)
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //Nature's Swiftness: notify master
+            if (baseId == NATURES_SWIFTNESS_1)
+            {
+                BotWhisper("Nature's Swiftness used!");
+            }
+
+            //On next attack spells cooldown handle
+            //if (baseId == MAUL_1)
+            //    SetSpellCooldown(baseId, me->getAttackTimer(BASE_ATTACK) - 250);
+
+            //Handle clearcasting
+            //Notes: bugged with hurricane (periodic)
+            if (AuraEffect const* eff = me->GetAuraEffect(OMEN_OF_CLARITY_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo) && !spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(HURRICANE_DAMAGE_1)))
+                    me->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+
+            //Elune's Wrath: -100% takes priority since only Starfire
+            AuraEffect const* elun = me->GetAuraEffect(ELUNES_WRATH_BUFF, 0);
+            //Predator's Swiftness takes priority since duration
+            AuraEffect const* pred = me->GetAuraEffect(PREDATORS_SWIFTNESS_BUFF, 0);
+            //Nature's Swiftness
+            AuraEffect const* natu = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0);
+            if (elun && elun->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(ELUNES_WRATH_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            else if (pred && pred->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(PREDATORS_SWIFTNESS_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            else if (natu && natu->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(NATURES_SWIFTNESS_1, 0, 0, AURA_REMOVE_BY_EXPIRE);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            if (_form == DRUID_CAT_FORM)
+            {
+                //Combo point generating
+                if (baseId == CLAW_1 || baseId == MANGLE_CAT_1 || baseId == POUNCE_1 ||
+                    baseId == RAKE_1 || baseId == RAVAGE_1 || baseId == SHRED_1)
+                {
+                    comboPoints++;
+                    //debug
+                    //TC_LOG_ERROR("entities.player", "druid_bot CP GEN: %s adds 1, now %u", spell->SpellName[0], uint32(comboPoints));
+                    if (primalFuryProc)
+                    {
+                        comboPoints++;
+                        //debug
+                        //TC_LOG_ERROR("entities.player", "druid_bot CP EX: now %u", uint32(comboPoints));
+                    }
+                    if (comboPoints > 5)
+                    {
+                        comboPoints = 5;
+                        //debug
+                        //TC_LOG_ERROR("entities.player", "druid_bot CP NOR: now %u", uint32(comboPoints));
+                    }
+                }
+                //Combo point spending
+                //else if (baseId == FEROCIOUS_BITE_1 || baseId == MAIM_1 || baseId == RIP_1 || baseId == SAVAGE_ROAR_1)
+                else if (spell->NeedsComboPoints())
+                {
+                    //debug
+                    //TC_LOG_ERROR("entities.player", "druid_bot CP SPEND1: %u to 0", uint32(comboPoints));
+                    if (lvl >= 25 && comboPoints > 0)
+                    {
+                        if (urand(1,100) <= uint32(comboPoints * 20))
+                        {
+                            me->CastSpell(me, PREDATORS_SWIFTNESS_BUFF, true);
+                            //debug
+                            //TC_LOG_ERROR("entities.player", "druid_bot CP SPEND1: PS proc!");
+                        }
+                    }
+                    comboPoints = 0;
+                }
+
+                //Maim helper
+                if (baseId == MAIM_1)
+                    MoveBehind(target);
+            }
+
+            //Hibernate helper
+            if (spellId == GetSpell(HIBERNATE_1))
+            {
+                hibery = true;
+                hiberyCheckTimer = 2000;
+            }
+
+            //Bash desperate use (ranged): retreat
+            //Only if hit
+            if (baseId == BASH_1 && HasRole(BOT_ROLE_RANGED))
+            {
+                //if (GC_Timer <= lastdiff && GetSpell(TRAVEL_FORM_1))
+                //    doCast(me, GetSpell(TRAVEL_FORM_1));
+                GetInPosition(true, target);
+            }
+
+            //Infected Wound: handle proc
+            if (baseId == SHRED_1 || baseId == MAUL_1 || baseId == MANGLE_BEAR_1 || baseId == MANGLE_CAT_1)
+            {
+                if (lvl >= 45)
+                    target->CastSpell(target, INFECTED_WOUNDS_EFFECT, true, NULL, NULL, me->GetGUID());
+            }
+
+            //Brutal Impact: +1 sec duration for Bash and Pounce stun
+            if (baseId == BASH_1 || baseId == POUNCE_1)
+            {
+                if (Aura* stu = target->GetAura(spellId))
+                {
+                    //1 extra second on creatures
+                    uint32 dur = stu->GetDuration() + target->GetTypeId() == TYPEID_PLAYER ? 1000 : 2000;
+                    stu->SetDuration(dur);
+                    stu->SetMaxDuration(dur);
+                }
+            }
+
+            //Glyph of Starfire: Increase max duration of Moonfire and refresh
+            if (baseId == STARFIRE_1 && GetSpell(MOONFIRE_1))
+            {
+                if (lvl >= 20)
+                {
+                    if (Aura* aur = target->GetAura(GetSpell(MOONFIRE_1), me->GetGUID()))
+                    {
+                        //extra 9 sec base + 3 sec Nature's Splendor
+                        if (aur->GetMaxDuration() < spell->GetMaxDuration() + 12000)
+                        {
+                            aur->SetDuration(aur->GetDuration() + 3000);
+                            aur->SetMaxDuration(aur->GetMaxDuration() + 3000);
+                        }
+                    }
+                }
+            }
+            //Nature's Splendor: Increased duraion for
+            //Moonfire (3 sec), Rejuvenation (3 sec, let 6), Regrowth (6 sec, let 9),
+            //Insect Swarm (2 sec) and Lifebloom (2 sec)
+            if (baseId == MOONFIRE_1 || baseId == REJUVENATION_1 || baseId == REGROWTH_1 ||
+                baseId == INSECT_SWARM_1 || baseId == LIFEBLOOM_1)
+            {
+                if (lvl >= 20)
+                {
+                    if (Aura* aur = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = aur->GetDuration();
+
+                        switch (baseId)
+                        {
+                            case MOONFIRE_1:
+                                dur += 3000;
+                                break;
+                            case REJUVENATION_1:
+                                dur += 6000;
+                                break;
+                            case REGROWTH_1:
+                                dur += 9000;
+                                break;
+                            case INSECT_SWARM_1:
+                            case LIFEBLOOM_1:
+                                dur += 2000;
+                                break;
+                            default:
+                                break;
+                        }
+
+                        aur->SetDuration(dur);
+                        aur->SetMaxDuration(dur);
+                    }
+                }
+            }
+
+            if (baseId == THORNS_1)
+            {
+                //30 min duration for Thorns
+                if (Aura* thorn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = 30 * MINUTE * IN_MILLISECONDS;
+                    thorn->SetDuration(dur);
+                    thorn->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == MARK_OF_THE_WILD_1)
+            {
+                //1 hour duration for Mark of the Wild
+                if (Aura* mark = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = 1 * HOUR * IN_MILLISECONDS;
+                    mark->SetDuration(dur);
+                    mark->SetMaxDuration(dur);
+
+                    //Improved Mark of the Wild: +40% effect
+                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                        if (AuraEffect* app = mark->GetEffect(i))
+                            app->ChangeAmount((app->GetAmount() * 14) / 10);
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Savage Roar duration
+            if (spellId == SAVAGE_ROAR_BUFF || spellId == SAVAGE_ROAR_1)
+            {
+                if (Aura* sav = me->GetAura(spellId))
+                {
+                    uint32 dur = sav->GetDuration() + 6000;
+                    sav->SetDuration(dur);
+                    sav->SetMaxDuration(dur);
+                }
+                //Glyph of Savage Roar: 3% increase (20 for bot)
+                if (spellId == SAVAGE_ROAR_BUFF)
+                {
+                    AuraEffect* sav = me->GetAuraEffect(spellId, EFFECT_0);
+                    if (sav)
+                        sav->ChangeAmount(sav->GetAmount() + 20);
+                }
+            }
+
+            //Glyph of Berserk: duration
+            if (baseId == BERSERK_1)
+            {
+                if (Aura* ber = me->GetAura(spellId))
+                {
+                    uint32 dur = ber->GetDuration() + 5000;
+                    ber->SetDuration(dur);
+                    ber->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Survival Instincts
+            if (lvl >= 20 && spellId == SURVIVAL_INSTINCTS_1)
+            {
+                AuraEffect* sur = me->GetAuraEffect(spellId, EFFECT_0);
+                if (sur)
+                    sur->ChangeAmount(sur->GetAmount() + 15);
+            }
+            //Starfall: duration
+            if (baseId == STARFALL_1)
+            {
+                if (Aura* sta = me->GetAura(spellId))
+                {
+                    uint32 dur = sta->GetDuration() * 3;
+                    sta->SetDuration(dur);
+                    sta->SetMaxDuration(dur);
+                }
+            }
+            //Predatoe's Swiftness: duration
+            if (spellId == PREDATORS_SWIFTNESS_BUFF)
+            {
+                if (Aura* swi = me->GetAura(spellId))
+                {
+                    swi->SetDuration(15000);
+                    swi->SetMaxDuration(15000);
+                }
+            }
+            //Eclipse (helper): cooldown
+            if (spellId == ECLIPSE_SOLAR_BUFF || spellId == ECLIPSE_LUNAR_BUFF)
+                SetSpellCooldown(spellId, 30000);
+            //Improved Leader of the Pack: handle SPELLMOD_EFFECT_2
+            if (spellId == LEADER_OF_THE_PACK_BUFF)
+            {
+                AuraEffect* lea = me->GetAuraEffect(spellId, EFFECT_1, me->GetGUID());
+                if (lea)
+                    lea->ChangeAmount(lea->GetAmount() + 4);
+            }
+            //Improved Barkskin: 10% additional damage reduction
+            if (baseId == BARKSKIN_1)
+            {
+                AuraEffect* bar = me->GetAuraEffect(spellId, EFFECT_1, me->GetGUID());
+                if (bar)
+                    bar->ChangeAmount(bar->GetAmount() - 10);
+            }
+
+            //Forms helper
+            if (baseId == BEAR_FORM_1)
+                setStats(DRUID_BEAR_FORM);
+            else if (baseId == CAT_FORM_1)
+                setStats(DRUID_CAT_FORM);
+            else if (baseId == MOONKIN_FORM_1)
+                setStats(DRUID_MOONKIN_FORM);
+            else if (baseId == TREE_OF_LIFE_FORM_1)
+                setStats(DRUID_TREE_FORM);
+            else if (baseId == TRAVEL_FORM_1)
+                setStats(DRUID_TRAVEL_FORM);
+            else if (baseId == AQUATIC_FORM_1)
+                setStats(DRUID_AQUATIC_FORM);
+            //else if (baseId == FLIGHT_FORM_1)
+            //    setStats(DRUID_FLIGHT_FORM);
+
+            //Cat Form: delay prowl just a little bit
+            if (baseId == CAT_FORM_1 && GetSpell(PROWL_1) && GetSpellCooldown(PROWL_1) > 300)
+                SetSpellCooldown(PROWL_1, 300);
+
+            //Leader of the Pack helper
+            if (baseId == CAT_FORM_1 || baseId == BEAR_FORM_1)
+            {
+                if (lvl >= 40 && !HasRole(BOT_ROLE_HEAL))
+                    me->CastSpell(me, LEADER_OF_THE_PACK_BUFF, true);
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_COMBO_POINTS:
+                    return comboPoints;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset()
+        {
+            //_form = BOT_STANCE_NONE;
+            rage = 0;
+            removeShapeshiftForm();
+
+            energy = 0;
+            comboPoints = 0;
+            primalFuryProc = false;
+
+            hibery = false;
+            hiberyCheckTimer = 0;
+
+            me->SetMaxPower(POWER_ENERGY, 100); //for regeneration
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+
+            ragetimer = 0;
+
+            energyFraction = 0.f;
+            energyGainMult = sWorld->getRate(RATE_POWER_ENERGY);
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (ragetimer > diff)                   ragetimer -= diff;
+
+            if (hiberyCheckTimer > diff)            hiberyCheckTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+
+            InitSpellMap(MARK_OF_THE_WILD_1);
+            InitSpellMap(THORNS_1);
+            InitSpellMap(HEALING_TOUCH_1);
+            InitSpellMap(REGROWTH_1);
+            InitSpellMap(REJUVENATION_1);
+            InitSpellMap(LIFEBLOOM_1);
+            InitSpellMap(NOURISH_1);
+     /*tal*/lvl >= 60 ? InitSpellMap(WILD_GROWTH_1) : RemoveSpell(WILD_GROWTH_1);
+     /*tal*/lvl >= 40 ? InitSpellMap(SWIFTMEND_1) : RemoveSpell(SWIFTMEND_1);
+            InitSpellMap(TRANQUILITY_1);
+            InitSpellMap(REVIVE_1);
+            InitSpellMap(REBIRTH_1);
+            InitSpellMap(BEAR_FORM_1);
+            InitSpellMap(SWIPE_BEAR_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_BEAR_1) : RemoveSpell(MANGLE_BEAR_1);
+            InitSpellMap(BASH_1);
+            InitSpellMap(MAUL_1);
+     /*tal*/lvl >= 30 ? InitSpellMap(FERAL_CHARGE_BEAR_1) : RemoveSpell(FERAL_CHARGE_BEAR_1);
+            InitSpellMap(CHALLENGING_ROAR_1);
+            InitSpellMap(ENRAGE_1);
+            InitSpellMap(FRENZIED_REGENERATION_1);
+            InitSpellMap(GROWL_1);
+            InitSpellMap(LACERATE_1);
+            InitSpellMap(SURVIVAL_INSTINCTS_1);
+            InitSpellMap(FAERIE_FIRE_FERAL_1);
+     /*tal*/lvl >= 60 ? InitSpellMap(BERSERK_1) : RemoveSpell(BERSERK_1);
+            InitSpellMap(CAT_FORM_1);
+            InitSpellMap(CLAW_1);
+            InitSpellMap(RAKE_1);
+            InitSpellMap(SHRED_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_CAT_1) : RemoveSpell(MANGLE_CAT_1);
+            InitSpellMap(POUNCE_1);
+            InitSpellMap(RAVAGE_1);
+            InitSpellMap(RIP_1);
+            InitSpellMap(FEROCIOUS_BITE_1);
+            InitSpellMap(MAIM_1);
+            InitSpellMap(SWIPE_CAT_1);
+            InitSpellMap(SAVAGE_ROAR_1);
+     /*tal*/lvl >= 30 ? InitSpellMap(FERAL_CHARGE_CAT_1) : RemoveSpell(FERAL_CHARGE_CAT_1);;
+            InitSpellMap(TIGERS_FURY_1);
+            InitSpellMap(COWER_1);
+            InitSpellMap(DASH_1);
+  /*custom*/lvl >= 22 ? InitSpellMap(PROWL_1) : RemoveSpell(PROWL_1); //base lvl 20
+     /*tal*/lvl >= 40 ? InitSpellMap(MOONKIN_FORM_1) : RemoveSpell(MOONKIN_FORM_1);
+            InitSpellMap(MOONFIRE_1);
+            InitSpellMap(STARFIRE_1);
+            InitSpellMap(WRATH_1);
+            InitSpellMap(HURRICANE_1);
+            InitSpellMap(FAERIE_FIRE_NORMAL_1);
+     /*tal*/lvl >= 30 ? InitSpellMap(INSECT_SWARM_1) : RemoveSpell(INSECT_SWARM_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(TYPHOON_1) : RemoveSpell(TYPHOON_1);
+     /*tal*/lvl >= 60 ? InitSpellMap(STARFALL_1) : RemoveSpell(STARFALL_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(TREE_OF_LIFE_FORM_1) : RemoveSpell(TREE_OF_LIFE_FORM_1);
+            InitSpellMap(TRAVEL_FORM_1);
+            InitSpellMap(AQUATIC_FORM_1);
+            InitSpellMap(CURE_POISON_1);
+            InitSpellMap(ABOLISH_POISON_1);
+            InitSpellMap(ENTANGLING_ROOTS_1);
+            InitSpellMap(CYCLONE_1);
+            InitSpellMap(HIBERNATE_1);
+            InitSpellMap(BARKSKIN_1);
+            InitSpellMap(NATURES_GRASP_1);
+            InitSpellMap(INNERVATE_1);
+     /*tal*/lvl >= 30 ? InitSpellMap(NATURES_SWIFTNESS_1) : RemoveSpell(NATURES_SWIFTNESS_1);
+
+ ///*SPECIAL*/InitSpellMap(ECLIPSE_SOLAR_BUFF, true);
+ ///*SPECIAL*/InitSpellMap(ECLIPSE_LUNAR_BUFF, true);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(NATURAL_PERFECTION3, level >= 45 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION2, level >= 43 && level < 45 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION1, level >= 41 && level < 43 ? 1 : 0);
+            RefreshAura(LIVING_SEED3, level >= 50 ? 1 : 0);
+            RefreshAura(LIVING_SEED2, level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(LIVING_SEED1, level >= 46 && level < 48 ? 1 : 0);
+            RefreshAura(REVITALIZE3, level >= 70 ? 2 : level >= 55 ? 1 : 0);
+            RefreshAura(REVITALIZE2, level >= 53 && level < 55 ? 1 : 0);
+            RefreshAura(REVITALIZE1, level >= 51 && level < 53 ? 1 : 0);
+            RefreshAura(NATURALIST, level >= 15 ? 1 : 0);
+            RefreshAura(IMPROVED_MARK_OF_THE_WILD, level >= 10 ? 1 : 0);
+            RefreshAura(FUROR, level >= 10 ? 1 : 0);
+            RefreshAura(INTENSITY, level >= 20 ? 1 : 0);
+            RefreshAura(LIVING_SPIRIT, level >= 40 ? 1 : 0);
+            RefreshAura(GIFT_OF_THE_EARTHMOTHER, level >= 55 ? 1 : 0);
+            RefreshAura(OMEN_OF_CLARITY, level >= 80 ? 3 : level >= 70 ? 2 : level >= 20 ? 1 : 0);
+            RefreshAura(NATURESGRACE, level >= 20 ? 1 : 0);
+            RefreshAura(ECLIPSE, level >= 50 ? 1 : 0);
+            RefreshAura(EARTH_AND_MOON, level >= 55 ? 1 : 0);
+            RefreshAura(SURVIVAL_OF_THE_FITTEST, level >= 55 ? 1 : 0);
+            RefreshAura(DREAMSTATE, level >= 30 ? 1 : 0);
+            RefreshAura(BALANCE_OF_POWER, level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_MOONKIN_FORM, level >= 40 ? 1 : 0);
+            RefreshAura(PRIMAL_PRECISION, level >= 25 ? 1 : 0);
+            RefreshAura(IMPROVED_LEADER_OF_THE_PACK, level >= 40 ? 1 : 0);
+            RefreshAura(PRIMAL_TENACITY, level >= 40 ? 1 : 0);
+            RefreshAura(KING_OF_THE_JUNGLE, level >= 50 ? 1 : 0);
+            RefreshAura(PRIMAL_GORE, level >= 55 ? 1 : 0);
+            RefreshAura(GLYPH_NOURISH, level >= 80 ? 1 : 0);
+            RefreshAura(GLYPH_SWIFTMEND, level >= 45 ? 1 : 0);
+            RefreshAura(GLYPH_INNERVATE, level >= 40 ? 1 : 0);
+            RefreshAura(GLYPH_RAPID_REJUVENATION, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_REGROWTH, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_REJUVENATION, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_FRENZIED_REGENERATION, level >= 36 ? 1 : 0);
+            RefreshAura(GLYPH_BARKSKIN, level >= 44 ? 1 : 0);
+            RefreshAura(GLYPH_RAKE, level >= 24 ? 1 : 0);
+            RefreshAura(GLYPH_SHRED, level >= 22 ? 1 : 0);
+            RefreshAura(T10_RESTO_P4_BONUS, level >= 80 ? 1 : 0);
+            RefreshAura(T9_RESTO_P4_BONUS, level >= 80 ? 1 : 0);
+            RefreshAura(T8_RESTO_P4_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T9_BALANCE_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_BALANCE_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_BALANCE_P4_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T8_FERAL_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_FERAL_P4_BONUS, level >= 80 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case MARK_OF_THE_WILD_1:
+                case THORNS_1:
+                case HEALING_TOUCH_1:
+                case REJUVENATION_1:
+                case LIFEBLOOM_1:
+                case REGROWTH_1:
+                case NOURISH_1:
+                case WILD_GROWTH_1:
+                case SWIFTMEND_1:
+                case TRANQUILITY_1:
+                case HURRICANE_1:
+                case INNERVATE_1:
+                case ABOLISH_POISON_1:
+                case NATURES_GRASP_1:
+                case BARKSKIN_1:
+                case BEAR_FORM_1:
+                case CAT_FORM_1:
+                case TRAVEL_FORM_1:
+                    return true;
+                case AQUATIC_FORM_1:
+                    return me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && me->IsUnderWater();
+                case TYPHOON_1:
+                case STARFALL_1:
+                case MOONKIN_FORM_1:
+                    return (GetBotRoles() & BOT_ROLE_MASK_MAIN) == (BOT_ROLE_DPS|BOT_ROLE_RANGED);
+                case TREE_OF_LIFE_FORM_1:
+                    return ((GetBotRoles() & BOT_ROLE_MASK_MAIN) & ~BOT_ROLE_RANGED) == BOT_ROLE_HEAL;
+                case SURVIVAL_INSTINCTS_1:
+                case FRENZIED_REGENERATION_1:
+                case ENRAGE_1:
+                case CHALLENGING_ROAR_1:
+                    return _form == DRUID_BEAR_FORM;
+                case TIGERS_FURY_1:
+                case DASH_1:
+                case PROWL_1:
+                    return _form == DRUID_CAT_FORM;
+                case BERSERK_1:
+                    return (_form == DRUID_BEAR_FORM || _form == DRUID_CAT_FORM) &&
+                        (((GetBotRoles() & BOT_ROLE_MASK_MAIN) & BOT_ROLE_TANK) || (GetBotRoles() & BOT_ROLE_MASK_MAIN) == BOT_ROLE_DPS);
+                default:
+                    return false;
+            }
+        }
+
+        void RegenerateEnergy()
+        {
+            uint32 curValue = me->GetPower(POWER_ENERGY);
+            uint32 maxValue = me->GetMaxPower(POWER_ENERGY);
+
+            if (curValue < maxValue)
+            {
+                float addvalue = 0.01f * lastdiff * energyGainMult;
+                Unit::AuraEffectList const& ModPowerRegenPCTAuras = me->GetAuraEffectsByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
+                for (Unit::AuraEffectList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
+                    if (Powers((*i)->GetMiscValue()) == POWER_ENERGY)
+                        AddPct(addvalue, (*i)->GetAmount());
+
+                //not present in db
+                //addvalue += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_ENERGY) * lastdiff / 5000;
+                //me->ModifyPower(POWER_ENERGY, int32(addvalue));
+
+                addvalue += energyFraction;
+
+                if (addvalue == 0x0) //only if world rate for enegy is 0
+                    return;
+
+                uint32 integerValue = uint32(fabs(addvalue));
+
+                curValue += integerValue;
+
+                if (curValue > maxValue)
+                {
+                    curValue = maxValue;
+                    energyFraction = 0.f;
+                }
+                else
+                    energyFraction = addvalue - float(integerValue);
+
+                //if (regenTimer >= REGEN_CD || curValue == maxValue)
+                    me->SetPower(POWER_ENERGY, curValue);
+                //else
+                //    me->UpdateUInt32Value(UNIT_FIELD_POWER1 + POWER_ENERGY, curValue);
+            }
+        }
+
+    private:
+        //Timers/other
+/*Form*/BotStances _form;
+/*Misc*/bool primalFuryProc;
+/*Misc*/uint8 comboPoints;
+/*Misc*/uint32 ragetimer;
+        bool hibery;
+        uint32 hiberyCheckTimer;
+/*Misc*/int32 rage, energy;
+/*Misc*/float rageLossMult;
+
+        float energyFraction;
+        float energyGainMult;
+
+        enum DruidBaseSpells
+        {
+            MARK_OF_THE_WILD_1                  = 1126,
+            THORNS_1                            = 467,
+            HEALING_TOUCH_1                     = 5185,
+            REGROWTH_1                          = 8936,
+            REJUVENATION_1                      = 774,
+            LIFEBLOOM_1                         = 33763,
+            NOURISH_1                           = 50464,
+     /*tal*/WILD_GROWTH_1                       = 48438,
+     /*tal*/SWIFTMEND_1                         = 18562,
+            TRANQUILITY_1                       = 740,
+            REVIVE_1                            = 50769,
+            REBIRTH_1                           = 20484,
+   /*quest*/BEAR_FORM_1                         = 5487,
+            SWIPE_BEAR_1                        = 779,
+     /*tal*/MANGLE_BEAR_1                       = 33878,
+            BASH_1                              = 5211,
+            MAUL_1                              = 6807,
+     /*tal*/FERAL_CHARGE_BEAR_1                 = 16979,
+            CHALLENGING_ROAR_1                  = 5209,
+            ENRAGE_1                            = 5229,
+            FRENZIED_REGENERATION_1             = 22842,
+            GROWL_1                             = 6795,
+            LACERATE_1                          = 33745,
+     /*tal*/SURVIVAL_INSTINCTS_1                = 61336,
+            FAERIE_FIRE_FERAL_1                 = 16857,//chains threat and damage spell regardless of bot feral form
+     /*tal*/BERSERK_1                           = 50334,
+  /*quest?*/CAT_FORM_1                          = 768,
+            CLAW_1                              = 1082,
+            RAKE_1                              = 1822,
+            SHRED_1                             = 5221,
+     /*tal*/MANGLE_CAT_1                        = 33876,
+            RIP_1                               = 1079,
+            FEROCIOUS_BITE_1                    = 22568,
+            POUNCE_1                            = 9005,
+            RAVAGE_1                            = 6785,
+            MAIM_1                              = 22570,
+            SWIPE_CAT_1                         = 62078,
+            SAVAGE_ROAR_1                       = 52610,
+     /*tal*/FERAL_CHARGE_CAT_1                  = 49376,
+            COWER_1                             = 8998,
+            DASH_1                              = 1850,
+            TIGERS_FURY_1                       = 5217,
+            PROWL_1                             = 5215,
+            MOONFIRE_1                          = 8921,
+            STARFIRE_1                          = 2912,
+            WRATH_1                             = 5176,
+            HURRICANE_1                         = 16914,
+            FAERIE_FIRE_NORMAL_1                = 770,
+     /*tal*/INSECT_SWARM_1                      = 5570,
+     /*tal*/TYPHOON_1                           = 50516,
+     /*tal*/STARFALL_1                          = 48505,
+   ///*tal*/FORCE_OF_NATURE_1                   = 33831,//Crashes Client at cast 55
+     /*tal*/MOONKIN_FORM_1                      = 24858,
+     /*tal*/TREE_OF_LIFE_FORM_1                 = 33891,
+  /*quest?*/TRAVEL_FORM_1                       = 783,
+  /*quest?*/AQUATIC_FORM_1                      = 1066,
+   /*quest*///FLIGHT_FORM_1                       = 0,//niy
+            ABOLISH_POISON_1                    = 2893,//manual use only
+            CURE_POISON_1                       = 8946,
+            REMOVE_CURSE_1                      = 2782,
+            ENTANGLING_ROOTS_1                  = 339,
+            CYCLONE_1                           = 33786,
+            HIBERNATE_1                         = 2637,
+            BARKSKIN_1                          = 22812,
+            NATURES_GRASP_1                     = 16689,
+            INNERVATE_1                         = 29166,
+     /*tal*/NATURES_SWIFTNESS_1                 = 17116
+        };
+        enum DruidPassives
+        {
+        //Talents
+            OMEN_OF_CLARITY                     = 16864,//clearcast
+            NATURESGRACE                        = 61346,//rank 3
+            NATURAL_PERFECTION1                 = 33881,
+            NATURAL_PERFECTION2                 = 33882,
+            NATURAL_PERFECTION3                 = 33883,
+            LIVING_SEED1                        = 48496,
+            LIVING_SEED2                        = 48499,
+            LIVING_SEED3                        = 48500,
+            REVITALIZE1                         = 48539,
+            REVITALIZE2                         = 48544,
+            REVITALIZE3                         = 48545,
+            NATURALIST                          = 17073,//rank 5
+            IMPROVED_MARK_OF_THE_WILD           = 17051,//rank 2
+            FUROR                               = 17061,//rank 5
+            INTENSITY                           = 17108,//rank 3
+            LIVING_SPIRIT                       = 34153,//rank 3
+            GIFT_OF_THE_EARTHMOTHER             = 51183,//rank 5
+            ECLIPSE                             = 48525,//rank 3
+            EARTH_AND_MOON                      = 48511,//rank 3
+            SURVIVAL_OF_THE_FITTEST             = 33856,//rank 3
+            DREAMSTATE                          = 33956,//rank 3
+            BALANCE_OF_POWER                    = 33596,//rank 2
+            IMPROVED_MOONKIN_FORM               = 48396,//rank 3
+            OWLKIN_FRENZY                       = 48393,//rank 3 NOT REFRESHAURABLE
+            FERAL_SWIFTNESS                     = 24866,//rank 2 NOT REFRESHAURABLE
+            PRIMAL_PRECISION                    = 48410,//rank 2 expertise only, refund handled in Spell.cpp
+            NATURAL_REACTION                    = 57881,//rank 3 NOT REFRESHAURABLE
+            IMPROVED_LEADER_OF_THE_PACK         = 34300,//rank 2
+            PRIMAL_TENACITY                     = 33957,//rank 3
+            PREDATORY_INSTINCTS                 = 33867,//rank 3 NOT REFRESHAURABLE
+            KING_OF_THE_JUNGLE                  = 48495,//rank 3
+            PRIMAL_GORE                         = 63503,//rank 1
+        //Glyphs
+            GLYPH_NOURISH                       = 62971,
+            GLYPH_SWIFTMEND                     = 54824,//no consumption
+            GLYPH_INNERVATE                     = 54832,//self regen
+            GLYPH_RAPID_REJUVENATION            = 71013,
+            GLYPH_REGROWTH                      = 54743,
+            GLYPH_REJUVENATION                  = 54754,
+            GLYPH_FRENZIED_REGENERATION         = 54810,
+            GLYPH_BARKSKIN                      = 63057,
+            GLYPH_RAKE                          = 54821,
+            GLYPH_SHRED                         = 54815,
+        //other
+            T10_RESTO_P4_BONUS                  = 70664,//rejuve jump
+            T9_RESTO_P4_BONUS                   = 67128,//rejuve crits
+            T8_RESTO_P4_BONUS                   = 64760,//rejuve init heal
+
+            T8_BALANCE_P4_BONUS                 = 64824,//insect swarm periodic starfire instacast trigger
+            T9_BALANCE_P2_BONUS                 = 67125,//moonfire crits
+            T10_BALANCE_P2_BONUS                = 70718,//omen of doom (15%)
+            T10_BALANCE_P4_BONUS                = 70723,//Languish(DOT)
+
+            T10_FERAL_P4_BONUS                  = 70726,//rake crit, enraged defense
+            T8_FERAL_P2_BONUS                   = 64752,//periodic clearcast trigger
+        };
+        enum DruidSpecial
+        {
+            STARFALL_DAMAGE_AOE_4               = 53190,//for radius mods
+            //STARFALL_DAMAGE_DIRECT_4            = 53195,
+            STARFALL_DUMMY_AOE_4                = 53198,//for radius mods
+
+            HURRICANE_DAMAGE_1                  = 42231,
+            //TRANQUILITY_HEAL_1                  = 44203,
+            //TYPHOON_DAMAGE_1                    = 61391,
+
+            SAVAGE_ROAR_BUFF                    = 62071,//hidden buff
+  /*Talent*/PREDATORS_SWIFTNESS_BUFF            = 69369,
+  /*Talent*/LEADER_OF_THE_PACK_BUFF             = 24932,
+  /*Talent*/NURTURING_INSTINCT_BUFF             = 47180,//rank 2 hidden NOT REFRESHAURABLE
+  /*Talent*/SURVIVAL_OF_THE_FITTEST_BUFF        = 62069,//hidden buff
+            SAVAGE_DEFENSE_PASSIVE              = 62600,//class passive lvl 40
+            SAVAGE_DEFENSE_BUFF                 = 62606,
+            MASTER_SHAPESHIFTER_BEAR_BUFF       = 48418,
+            MASTER_SHAPESHIFTER_CAT_BUFF        = 48420,
+            MASTER_SHAPESHIFTER_MOONKIN_BUFF    = 48421,
+            MASTER_SHAPESHIFTER_TREE_BUFF       = 48422,
+            //NATURESGRACEBUFF                    = 16886,
+            ECLIPSE_SOLAR_BUFF                  = 48517,// from Starfire to Wrath
+            ECLIPSE_LUNAR_BUFF                  = 48518,// from Wrath to Starfire
+            ELUNES_WRATH_BUFF                   = 64823,//Starfire instacast
+            OMEN_OF_CLARITY_BUFF                = 16870,
+
+            //FERAL_CHARGE_EFFECT_BEAR_ROOT       = 45334,
+            //FERAL_CHARGE_EFFECT_CAT_DAZE        = 50259,
+            INFECTED_WOUNDS_EFFECT              = 58181,//rank 3
+            PRIMAL_FURY_EFFECT_ENERGIZE         = 16959 //5 rage
+        };
+    };
+};
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
new file mode 100644
index 0000000..d2bc9e8
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
@@ -0,0 +1,2065 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+/*
+Hunter NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - around 75%
+TODO: pet-related abilities
+*/
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new hunter_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct hunter_botAI : public bot_minion_ai
+    {
+        hunter_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_HUNTER;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_HUNTER) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force, u);
+        }
+
+        void EnterCombat(Unit* u) { aspectTimer = 0; bot_minion_ai::EnterCombat(u); }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u) { bot_minion_ai::KilledUnit(u); }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { Aspect = 0; bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void CheckAspects(uint32 diff) //HUGE TODO
+        {
+            if (aspectTimer > diff || me->IsMounted() || Feasting() || IsCasting() || Rand() > 35)
+                return;
+
+            aspectTimer = urand(10000, 15000);
+
+            if (Aspect == ASPECT_VIPER && GetManaPCT(me) < 50)
+                return;
+
+            uint32 ASPECT_OF_THE_MONKEY = GetSpell(ASPECT_OF_THE_MONKEY_1);
+            uint32 ASPECT_OF_THE_HAWK = GetSpell(ASPECT_OF_THE_HAWK_1);
+            uint32 ASPECT_OF_THE_CHEETAH = GetSpell(ASPECT_OF_THE_CHEETAH_1);
+            uint32 ASPECT_OF_THE_VIPER = GetSpell(ASPECT_OF_THE_VIPER_1);
+            //uint32 ASPECT_OF_THE_BEAST = GetSpell(ASPECT_OF_THE_BEAST_1);
+            uint32 ASPECT_OF_THE_PACK = GetSpell(ASPECT_OF_THE_PACK_1);
+            uint32 ASPECT_OF_THE_WILD = GetSpell(ASPECT_OF_THE_WILD_1);
+            uint32 ASPECT_OF_THE_DRAGONHAWK = GetSpell(ASPECT_OF_THE_DRAGONHAWK_1);
+
+            std::map<uint32 /*baseid*/, uint32 /*curid*/> idMap;
+            uint32 mask = _getAspectsMask(idMap);
+
+            if (Aspect == ASPECT_WILD) //manual
+            {
+                if (idMap[ASPECT_OF_THE_WILD_1] != ASPECT_OF_THE_WILD)
+                    if (doCast(me, ASPECT_OF_THE_WILD))
+                        return;
+                return;
+            }
+
+            if (ASPECT_OF_THE_VIPER && GetManaPCT(me) < 20)
+            {
+                if (doCast(me, ASPECT_OF_THE_VIPER))
+                    return;
+                return;
+            }
+
+            if (IAmFree())
+            {
+                if (ASPECT_OF_THE_DRAGONHAWK && Aspect != ASPECT_DRAGONHAWK)
+                    if (doCast(me, ASPECT_OF_THE_DRAGONHAWK))
+                        return;
+                return;
+            }
+
+            //Group const* gr = master->GetGroup();
+            //choose movement aspect first
+            if (!master->GetBotMgr()->IsPartyInCombat())
+            {
+                if (!(mask & SPECIFIC_ASPECT_PACK))
+                {
+                    uint32 movFlags;
+                    if (ASPECT_OF_THE_PACK)
+                    {
+                        movFlags = master->m_movementInfo.GetMovementFlags();
+                        if ((movFlags & MOVEMENTFLAG_FORWARD) && !(movFlags & (MOVEMENTFLAG_FALLING_FAR)))
+                        {
+                            if (doCast(me, ASPECT_OF_THE_PACK))
+                                return;
+                        }
+                    }
+                    if (ASPECT_OF_THE_CHEETAH && Aspect != ASPECT_CHEETAH)
+                    {
+                        movFlags = me->m_movementInfo.GetMovementFlags();
+                        if ((movFlags & MOVEMENTFLAG_FORWARD) && !(movFlags & (MOVEMENTFLAG_FALLING_FAR)) &&
+                            me->GetDistance(master) > 20)
+                        {
+                            if (doCast(me, ASPECT_OF_THE_CHEETAH))
+                                return;
+                        }
+                    }
+                }
+
+                return;
+            }
+            else if (Aspect == ASPECT_PACK)
+            {
+                me->RemoveAurasDueToSpell(ASPECT_OF_THE_PACK_1, me->GetGUID());
+                Aspect = ASPECT_NONE;
+            }
+            //else if (Aspect == ASPECT_CHEETAH)
+            //{
+            //    me->RemoveAurasDueToSpell(ASPECT_OF_THE_CHEETAH_1, me->GetGUID());
+            //    Aspect = ASPECT_NONE;
+            //}
+
+            if ((Aspect == ASPECT_DRAGONHAWK && idMap[ASPECT_OF_THE_DRAGONHAWK_1] == ASPECT_OF_THE_DRAGONHAWK) ||
+                (!ASPECT_OF_THE_DRAGONHAWK && ((Aspect == ASPECT_HAWK && idMap[ASPECT_OF_THE_HAWK_1] == ASPECT_OF_THE_HAWK) ||
+                Aspect == ASPECT_MONKEY)))
+                return;
+
+            if (ASPECT_OF_THE_DRAGONHAWK &&
+                (Aspect != ASPECT_DRAGONHAWK || idMap[ASPECT_OF_THE_DRAGONHAWK_1] != ASPECT_OF_THE_DRAGONHAWK))
+            {
+                if (doCast(me, ASPECT_OF_THE_DRAGONHAWK))
+                    return;
+                return;
+            }
+            if (ASPECT_OF_THE_HAWK && (!IsTank() || (!ASPECT_OF_THE_MONKEY && !ASPECT_OF_THE_DRAGONHAWK)) &&
+                (Aspect != ASPECT_HAWK || idMap[ASPECT_OF_THE_HAWK_1] != ASPECT_OF_THE_HAWK))
+            {
+                if (doCast(me, ASPECT_OF_THE_HAWK))
+                    return;
+                return;
+            }
+            if (ASPECT_OF_THE_MONKEY && Aspect != ASPECT_MONKEY)
+            {
+                if (doCast(me, ASPECT_OF_THE_MONKEY))
+                    return;
+                return;
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting() || Rand() > 35)
+                return;
+
+            Unit* target = NULL;
+
+            if (IsSpellReady(SCATTER_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(CalcSpellMaxRange(SCATTER_SHOT_1), 0, SCATTER_SHOT_1);
+                if (target && doCast(target, GetSpell(SCATTER_SHOT_1)))
+                    return;
+            }
+            if (!target && IsSpellReady(WYVERN_STING_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(CalcSpellMaxRange(WYVERN_STING_1), 5, WYVERN_STING_1);
+                if (target && doCast(target, GetSpell(WYVERN_STING_1)))
+                    return;
+            }
+            //if (!target && IsSpellReady(FREEZING_ARROW_1, diff))
+            //{
+            //    target = FindCastingTarget(40, 0, false, FREEZING_ARROW_1);
+            //    if (target && doCast(target, GetSpell(FREEZING_ARROW_1)))
+            //        return;
+            //}
+            //if (!target && IsSpellReady(SCARE_BEAST_1, diff))
+            //{
+            //    target = FindCastingTarget(30, 0, SCARE_BEAST_1);
+            //    if (target && doCast(target, GetSpell(SCARE_BEAST_1)))
+            //        return;
+            //}
+            if (!target && IsSpellReady(SILENCING_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(CalcSpellMaxRange(SILENCING_SHOT_1), 5, SILENCING_SHOT_1);
+                if (target && doCast(target, GetSpell(SILENCING_SHOT_1)))
+                    return;
+            }
+        }
+
+        void CheckScatter(uint32 diff)
+        {
+            if (!IsSpellReady(SCATTER_SHOT_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 50)
+                return;
+
+            if (opponent->GetVictim() == me && opponent->GetDistance(me) < 10 &&
+                !opponent->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && opponent->getAttackers().size() <= 1)
+            {
+                if (doCast(opponent, GetSpell(SCATTER_SHOT_1)))
+                {
+                    GetInPosition(true, NULL);
+                    return;
+                }
+            }
+            if (Unit* target = FindStunTarget(CalcSpellMaxRange(SCATTER_SHOT_1)))
+            {
+                if (doCast(target, GetSpell(SCATTER_SHOT_1)))
+                    return;
+            }
+        }
+
+        void CheckWyvernSting(uint32 diff)
+        {
+            if (!IsSpellReady(WYVERN_STING_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 50)
+                return;
+
+            if (Unit* target = FindStunTarget(CalcSpellMaxRange(WYVERN_STING_1)))
+            {
+                if (doCast(target, GetSpell(WYVERN_STING_1)))
+                    return;
+            }
+        }
+
+        void CheckFreezingArrow(uint32 diff)
+        {
+            //Freezing Trap shares cooldown with frosty traps
+            if (!IsSpellReady(FREEZING_ARROW_1, diff) || Rand() > 35)
+                return;
+
+            if (Unit* target = FindStunTarget(25))
+            {
+                if (doCast(target, GetSpell(FREEZING_ARROW_1)))
+                    return;
+            }
+        }
+
+        void CheckTraps(uint32 diff)
+        {
+            if (trapTimer > diff || IsCasting() || Rand() > 35)
+                return;
+
+            trapTimer = urand(1000, 2000);
+
+            //trap summon spell is 2yd radius
+            std::list<Unit*> targets;
+            GetNearbyTargetsInConeList(targets, 4);
+            if (targets.empty())
+                return;
+
+            //frost trap, freezing trap, freezing arrow: cat 411
+            if (IsSpellReady(FROST_TRAP_1, diff) && !IsTank())
+            {
+                //uint8 movingCount = 0;
+                //for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                //{
+                //    if ((*itr)->isMoving() || ((*itr)->GetVictim() && !IsTank((*itr)->GetVictim())))
+                //    {
+                //        if (++movingCount >= 2)
+                        //if (targets.size() > 1)
+                //        {
+                            if (doCast(me, GetSpell(FROST_TRAP_1)))
+                                return;
+                //            break;
+                //        }
+                //    }
+                //}
+            }
+            //only if taming beast (or manual)
+            if (IsSpellReady(FREEZING_TRAP_1, diff) && !HasRole(BOT_ROLE_DPS) && !IAmFree() &&
+                master->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_GENERIC, 255, 2))
+            {
+                if (doCast(me, GetSpell(FREEZING_TRAP_1)))
+                    return;
+            }
+            //black arrow, immolation trap, explosive trap: cat 1250
+            if (IsSpellReady(EXPLOSIVE_TRAP_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                if (targets.size() > 1)
+                {
+                    if (doCast(me, GetSpell(EXPLOSIVE_TRAP_1)))
+                        return;
+                }
+            }
+            if (IsSpellReady(IMMOLATION_TRAP_1, diff) && HasRole(BOT_ROLE_DPS) && !(*targets.begin())->IsControlledByPlayer())
+            {
+                if (targets.size() > 1)
+                {
+                    if (doCast(me, GetSpell(IMMOLATION_TRAP_1)))
+                        return;
+                }
+            }
+            //snake trap: cat 1249
+            //if (IsSpellReady(SNAKE_TRAP_1, diff) && HasRole(BOT_ROLE_DPS) && (*targets.begin())->IsControlledByPlayer())
+            //{
+            //    if (doCast(me, GetSpell(SNAKE_TRAP_1)))
+            //        return;
+            //}
+        }
+
+        void CheckScare(uint32 diff)
+        {
+            if (!IsSpellReady(SCARE_BEAST_1, diff) || IsCasting() || Rand() > 25)
+                return;
+
+            if (FindAffectedTarget(GetSpell(SCARE_BEAST_1), me->GetGUID(), 60))
+            {
+                SetSpellCooldown(SCARE_BEAST_1, 2000);
+                return;
+            }
+
+            if (Unit* scareTarget = FindFearTarget())
+            {
+                if (doCast(scareTarget, GetSpell(SCARE_BEAST_1)))
+                    return;
+            }
+
+            SetSpellCooldown(SCARE_BEAST_1, 1500); //fail
+        }
+
+        void doDefend(uint32 diff)
+        {
+            if (IsTank() || Rand() > 55)
+                return;
+
+            bool feignReady = IsSpellReady(FEIGN_DEATH_1, diff, false);
+            bool deterReady = IsSpellReady(DETERRENCE_1, diff, false);
+            if (!feignReady && !deterReady)
+                return;
+
+            Unit::AttackerSet b_attackers = me->getAttackers();
+            if (b_attackers.empty())
+                return;
+
+            bool cast = false;
+
+            if (b_attackers.size() == 1)
+            {
+                if (Creature* cre = (*b_attackers.begin())->ToCreature())
+                    if (cre->isWorldBoss() || cre->IsDungeonBoss() || cre->GetMaxHealth() > me->GetMaxHealth() * 10)
+                        cast = true;
+            }
+            else
+                cast = (uint8(b_attackers.size()) > (GetHealthPCT(me) > 20 ? 1 : 0));
+
+            if (!cast)
+                return;
+
+            if (feignReady && (*b_attackers.begin())->getAttackers().size() > 1)
+            {
+                if (doCast(me, GetSpell(FEIGN_DEATH_1)))
+                    return;
+            }
+
+            if (deterReady)
+            {
+                if (doCast(me, GetSpell(DETERRENCE_1)))
+                    return;
+            }
+        }
+
+        void CheckTranquil(uint32 diff)
+        {
+            if (!IsSpellReady(TRANQ_SHOT_1, diff) || Rand() > 20)
+                return;
+
+            //First check current target
+            if (me->GetDistance(opponent) > 5 && me->GetDistance(opponent) < CalcSpellMaxRange(TRANQ_SHOT_1) &&
+                !opponent->IsImmunedToSpell(sSpellMgr->GetSpellInfo(TRANQ_SHOT_1)))
+            {
+                AuraApplication const* aurApp;
+                SpellInfo const* spellInfo;
+                Unit::AuraMap const &auras = opponent->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                {
+                    spellInfo = itr->second->GetSpellInfo();
+                    if (spellInfo->Dispel != DISPEL_MAGIC && spellInfo->Dispel != DISPEL_ENRAGE) continue;
+                    if (spellInfo->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    //if (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                    aurApp = itr->second->GetApplicationOfTarget(opponent->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        if (doCast(opponent, GetSpell(TRANQ_SHOT_1)))
+                            return;
+                    }
+                }
+            }
+
+            Unit* target = FindTranquilTarget(5, CalcSpellMaxRange(TRANQ_SHOT_1));
+            if (target && doCast(target, GetSpell(TRANQ_SHOT_1)))
+                return;
+        }
+
+        void CheckMisdirect(uint32 diff)
+        {
+            if (!IsSpellReady(MISDIRECTION_1, diff) || misdirectionTimer > diff || IAmFree() ||
+                !master->GetGroup() || Rand() > 20)
+                return;
+
+            misdirectionTimer = urand(3000, 6000);
+
+            //find tank
+            //stacks
+            std::list<Unit*> tanks;
+            Group const* gr = master->GetGroup();
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || me->GetMap() != player->FindMap())
+                    continue;
+
+                if (player->IsAlive() && player->IsInCombat() && IsTank(player) && player->GetVictim())
+                    tanks.push_back(player);
+
+                if (!player->HaveBot())
+                    continue;
+
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    if (itr->second == me)
+                        continue;
+                    if (!gr->IsMember(itr->first))
+                        continue;
+
+                    Unit* u = itr->second;
+                    if (u->IsInWorld() && u->IsAlive() && u->IsInCombat() && IsTank(u) &&
+                        (u->GetVictim() || !u->getAttackers().empty()))
+                        tanks.push_back(u);
+                }
+            }
+
+            if (tanks.empty())
+                return;
+
+            Unit* target = tanks.size() == 1 ? *tanks.begin() : Trinity::Containers::SelectRandomContainerElement(tanks);
+            if (doCast(target, GetSpell(MISDIRECTION_1)))
+                return;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (Wait())
+                return;
+            GenerateRand();
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            //Scare Beast interrupt
+            Spell const* spell = me->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+            if (spell && spell->GetSpellInfo()->Id == GetSpell(SCARE_BEAST_1))
+            {
+                if (spell->m_targets.GetUnitTarget() &&
+                    spell->m_targets.GetUnitTarget()->HasAuraType(SPELL_AURA_MOD_FEAR))
+                    me->InterruptSpell(CURRENT_GENERIC_SPELL);
+            }
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 10)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                doDefend(diff);
+
+            CheckAspects(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+                CheckScare(diff);
+
+            if (IsCasting())
+                return;
+
+            //Deterrence check
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
+            {
+                if (!me->isMoving())
+                    GetInPosition(true, NULL);
+                return;
+            }
+
+            if (!CheckAttackTarget(BOT_CLASS_HUNTER))
+            {
+                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                return;
+            }
+
+            CheckFlare(diff);
+            CheckReadiness(diff);
+
+            DoRangedAttack(diff);
+        }
+
+        void DoRangedAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            Counter(diff);
+            CheckTranquil(diff);
+
+            float dist = me->GetDistance(opponent);
+            float maxRangeLong = me->getLevel() >= 10 ? 51.f : 45.f;
+            float maxRangeNormal = me->getLevel() >= 10 ? 41.f : 35.f;
+
+            bool inpostion = !opponent->HasAuraType(SPELL_AURA_MOD_CONFUSE) || dist > maxRangeNormal - 10.f;
+
+            //Auto Shot
+            if (Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id == AUTO_SHOT_1 && (shot->m_targets.GetUnitTarget() != opponent || !inpostion))
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+            else if (HasRole(BOT_ROLE_DPS) && dist > 5 && dist < maxRangeNormal)
+            {
+                if (doCast(opponent, AUTO_SHOT_1))
+                {}
+            }
+
+            CheckScatter(diff);
+            CheckFreezingArrow(diff);
+            CheckWyvernSting(diff);
+
+            //TRAPS
+            CheckTraps(diff);
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+                return;
+
+            //scatter pvp
+            if (IsSpellReady(SCATTER_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetTypeId() == TYPEID_PLAYER && dist < 10 && Rand() < 60)
+            {
+                if (doCast(opponent, GetSpell(SCATTER_SHOT_1)))
+                {
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                    me->AttackStop();
+                    GetInPosition(true, opponent);
+                    return;
+                }
+            }
+
+            //DISENGAGE
+            if (IsSpellReady(DISENGAGE_1, diff, false) && me->IsInCombat() && !IsTank() && Rand() < 70 &&
+                !me->getAttackers().empty() && me->GetDistance(*me->getAttackers().begin()) < 5 &&
+                me->HasInArc(M_PI, *me->getAttackers().begin()))
+            {
+                if (doCast(me, GetSpell(DISENGAGE_1)))
+                    return;
+            }
+
+            //MELEE SECTION
+            if (dist < 5)
+            {
+                //MONGOOSE BITE
+                if (IsSpellReady(MONGOOSE_BITE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+                {
+                    if (doCast(opponent, GetSpell(MONGOOSE_BITE_1)))
+                        return;
+                }
+                //COUNTERATTACK
+                if (IsSpellReady(COUNTERATTACK_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                    me->HasReactive(REACTIVE_HUNTER_PARRY) && Rand() < 90)
+                {
+                    if (doCast(opponent, GetSpell(COUNTERATTACK_1)))
+                        return;
+                }
+                //WING CLIP
+                if (IsSpellReady(WING_CLIP_1, diff) && (!IsTank() || opponent->isMoving()) &&
+                    Rand() < 80 && !CCed(opponent, true) && !opponent->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+                {
+                    if (doCast(opponent, GetSpell(WING_CLIP_1)))
+                        return;
+                }
+                //RAPTOR STRIKE
+                if (IsSpellReady(RAPTOR_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 40 &&
+                    !me->GetCurrentSpell(CURRENT_MELEE_SPELL))
+                {
+                    if (doCast(opponent, GetSpell(RAPTOR_STRIKE_1)))
+                        return;
+                }
+
+                return; //don't try to do anything else in melee
+            }
+
+            //RANGED SECTION
+
+            //HUNTERS MARK //100 yd range so don't check it
+            if (IsSpellReady(HUNTERS_MARK_1, diff) && Rand() < 65 &&
+                !opponent->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STALKED, SPELLFAMILY_HUNTER, 0x400))
+            {
+                if (doCast(opponent, GetSpell(HUNTERS_MARK_1)))
+                    return;
+            }
+
+            CheckMisdirect(diff);
+
+            //attack range check 1
+            if (dist > maxRangeLong)
+                return;
+
+            //KILL SHOT
+            if (IsSpellReady(KILL_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                opponent->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT) && Rand() < 125)
+            {
+                if (doCast(opponent, GetSpell(KILL_SHOT_1)))
+                    return;
+            }
+
+            //attack range check 2
+            if (dist > maxRangeNormal)
+                return;
+
+            if (!inpostion && me->getAttackers().empty())
+                return;
+
+            //CONCUSSIVE SHOT
+            if (IsSpellReady(CONCUSSIVE_SHOT_1, diff) && Rand() < 35 &&
+                !CCed(opponent, true) && !opponent->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+            {
+                if (doCast(opponent, GetSpell(CONCUSSIVE_SHOT_1)))
+                    return;
+            }
+            //DISTRACTING SHOT
+            Unit const* u = opponent->GetVictim();
+            if (IsSpellReady(DISTRACTING_SHOT_1, diff) && u && u != me && IsTank() && !CCed(opponent) &&
+                IsInBotParty(u) && Rand() < 75 && (!IsTank(u) || (dist > 25 && GetHealthPCT(u) < 25)))
+            {
+                if (doCast(opponent, GetSpell(DISTRACTING_SHOT_1)))
+                    return;
+            }
+            //MULTI-SHOT shares cd with aimed shot
+            if (IsSpellReady(MULTISHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 60)
+            {
+                if (Rand() < 20 || !GetSpell(STEADY_SHOT_1) || FindSplashTarget(maxRangeNormal, opponent, 5))
+                {
+                    if (doCast(opponent, GetSpell(MULTISHOT_1)))
+                        return;
+                }
+            }
+            //VOLLEY
+            if (IsSpellReady(VOLLEY_1, diff) && HasRole(BOT_ROLE_DPS) && !JumpingOrFalling() && Rand() < 25)
+            {
+                if (Unit* target = FindAOETarget(maxRangeNormal, true, false))
+                {
+                    if (doCast(target, GetSpell(VOLLEY_1)))
+                        return;
+                }
+            }
+            //RAPID FIRE
+            if (IsSpellReady(RAPID_FIRE_1, diff, false) && HasRole(BOT_ROLE_DPS) && !me->isMoving() && Rand() < 25 &&
+                (opponent->GetHealth() > me->GetMaxHealth() * (1 + opponent->getAttackers().size()) ||
+                opponent->GetTypeId() == TYPEID_PLAYER))
+            {
+                if (doCast(me, GetSpell(RAPID_FIRE_1)))
+                {}
+            }
+            //BLACK ARROW
+            //Black Arrow shares cooldown with fire traps
+            if (IsSpellReady(BLACK_ARROW_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetMaxHealth()/4 * (1 + opponent->getAttackers().size()) && Rand() < 75)
+            {
+                if (doCast(opponent, GetSpell(BLACK_ARROW_1)))
+                    return;
+            }
+            //CHIMERA SHOT: no viper
+            if (IsSpellReady(CHIMERA_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
+            {
+                //Serpent
+                if (opponent->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0, me->GetGUID()))
+                {
+                    if (doCast(opponent, GetSpell(CHIMERA_SHOT_1)))
+                        return;
+                }
+                //Scorpid
+                else if (opponent->GetAuraEffect(SPELL_AURA_MOD_HIT_CHANCE, SPELLFAMILY_HUNTER, 0x8000, 0x0, 0x0, me->GetGUID()))
+                {
+                    if (!opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                        (opponent->GetTypeId() == TYPEID_PLAYER || opponent->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID)))
+                    {
+                        if (doCast(opponent, GetSpell(CHIMERA_SHOT_1)))
+                            return;
+                    }
+                }
+
+                SetSpellCooldown(CHIMERA_SHOT_1, 1500); //fail
+            }
+            //STING
+            if (GetSpellCooldown(SERPENT_STING_1) <= diff && stingTimer <= diff && Rand() < 50)
+            {
+                uint32 STING = 0;
+                AuraEffect const* sting = NULL;
+                if (!STING && GetSpell(SCORPID_STING_1) && opponent->GetTypeId() == TYPEID_UNIT &&
+                    opponent->ToCreature()->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL)
+                {
+                    sting = opponent->GetAuraEffect(SPELL_AURA_MOD_HIT_CHANCE, SPELLFAMILY_HUNTER, 0x8000, 0x0, 0x0);
+                    if (!sting || sting->GetBase()->GetCasterGUID() == me->GetGUID())
+                        STING = SCORPID_STING_1;
+                }
+                //VIPER STING: pvp only
+                if (!STING && GetSpell(VIPER_STING_1) && opponent->GetTypeId() == TYPEID_PLAYER &&
+                    opponent->getPowerType() == POWER_MANA && opponent->GetHealth() > me->GetMaxHealth()/2 &&
+                    opponent->GetMaxPower(POWER_MANA) > me->GetMaxPower(POWER_MANA))
+                {
+                    sting = opponent->GetAuraEffect(SPELL_AURA_PERIODIC_MANA_LEECH, SPELLFAMILY_HUNTER, 0x0, 0x80, 0x0, me->GetGUID());
+                    if (!sting)
+                        STING = VIPER_STING_1;
+                }
+                if (!STING && GetSpell(SERPENT_STING_1) && HasRole(BOT_ROLE_DPS) &&
+                    opponent->GetHealth() > me->GetMaxHealth()/2 * (1 + opponent->getAttackers().size()))
+                {
+                    sting = opponent->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0, me->GetGUID());
+                    if (!sting)
+                        STING = SERPENT_STING_1;
+                }
+
+                if (sting && sting->GetBase()->GetCasterGUID() == me->GetGUID() &&
+                    sting->GetBase()->GetDuration() >= 3000)
+                {
+                    stingTimer = 3000;
+                }
+                else
+                {
+                    if (STING && doCast(opponent, GetSpell(STING)))
+                    {
+                        stingTimer = 8000;
+                        return;
+                    }
+                }
+            }
+            //EXPLOSIVE SHOT: replaces Arcane Shot at 60
+            if (IsSpellReady(EXPLOSIVE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 135)
+            {
+                if (doCast(opponent, GetSpell(EXPLOSIVE_SHOT_1)))
+                    return;
+            }
+            //ARCANE SHOT: shares cd with Explosive Shot
+            if (IsSpellReady(ARCANE_SHOT_1, diff) && !GetSpell(EXPLOSIVE_SHOT_1) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(ARCANE_SHOT_1)))
+                    return;
+            }
+            //AIMED SHOT shares cd with multishot
+            if (IsSpellReady(AIMED_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 100)
+            {
+                if (doCast(opponent, GetSpell(AIMED_SHOT_1)))
+                    return;
+            }
+            //STEADY SHOT
+            if (IsSpellReady(STEADY_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                if (doCast(opponent, GetSpell(STEADY_SHOT_1)))
+                    return;
+            }
+        }
+
+        void CheckFlare(uint32 diff)
+        {
+            if (!IsSpellReady(FLARE_1, diff) || flareTimer > diff || me->IsMounted() || Rand() > 25)
+                return;
+
+            flareTimer = urand(2000, 4000);
+
+            Unit* attacker = me->GetVictim();
+            if (attacker)
+            {
+                if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->getClass() == CLASS_ROGUE :
+                    attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                    attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                {
+                    if (doCast(attacker, GetSpell(FLARE_1)))
+                        return;
+                }
+            }
+
+            if (IAmFree())
+            {
+                Unit::AttackerSet const& b_attackers = me->getAttackers();
+                if (b_attackers.empty())
+                    return;
+
+                for (Unit::AttackerSet::const_iterator itr = b_attackers.begin(); itr != b_attackers.end(); ++itr)
+                {
+                    attacker = *itr;
+                    if (me->GetDistance(attacker) > 15)
+                        continue;
+
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->getClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(me, GetSpell(FLARE_1)))
+                            return;
+
+                        break;
+                    }
+                }
+
+                return;
+            }
+
+            attacker = master->GetVictim();
+            if (attacker && me->GetDistance(attacker) < 30)
+            {
+                if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->getClass() == CLASS_ROGUE :
+                    attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                    attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                {
+                    if (doCast(attacker, GetSpell(FLARE_1)))
+                        return;
+                }
+            }
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                if (me->GetDistance(master) > 30)
+                    return;
+
+                Unit::AttackerSet const& m_attackers = master->getAttackers();
+                if (m_attackers.empty())
+                    return;
+
+                for (Unit::AttackerSet::const_iterator itr = m_attackers.begin(); itr != m_attackers.end(); ++itr)
+                {
+                    attacker = *itr;
+                    if (master->GetDistance(attacker) > 15 || me->GetDistance(attacker) > 30)
+                        continue;
+
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->getClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(urand(1,100) <= 50 ? master : attacker, GetSpell(FLARE_1)))
+                            return;
+
+                        break;
+                    }
+                }
+
+                return;
+            }
+            
+            std::list<Unit*> targets6;
+            bool Bots = false;
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (tPlayer == NULL) continue;
+                if (me->GetMap() != tPlayer->FindMap()) continue;
+                if (!Bots)
+                    Bots = true;
+                if (!tPlayer->IsAlive()) continue;
+                if (me->GetDistance(tPlayer) > 30) continue;
+                attacker = tPlayer->GetVictim();
+                if (attacker && me->GetDistance(attacker) < 30)
+                {
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->getClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(attacker, GetSpell(FLARE_1)))
+                            return;
+                    }
+                }
+                Unit::AttackerSet const& p_attackers = tPlayer->getAttackers();
+                if (p_attackers.empty())
+                    continue;
+
+                for (Unit::AttackerSet::const_iterator itr = p_attackers.begin(); itr != p_attackers.end(); ++itr)
+                {
+                    attacker = *itr;
+                    if (tPlayer->GetDistance(attacker) > 15 || me->GetDistance(attacker) > 30)
+                        continue;
+
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->getClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(urand(1,100) <= 50 ? tPlayer : attacker, GetSpell(FLARE_1)))
+                            return;
+
+                        break;
+                    }
+                }
+            }
+            if (Bots)
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player const* gPlayer = itr->GetSource();
+                    if (gPlayer == NULL) continue;
+                    if (me->GetMap() != gPlayer->FindMap()) continue;
+                    if (!gPlayer->HaveBot())
+                        continue;
+
+                    BotMap const* map = gPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        Unit* u = itr->second;
+                        if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                            u->IsTotem() || me->GetDistance(u) > 30)
+                            continue;
+
+                        attacker = u->GetVictim();
+                        if (attacker && me->GetDistance(attacker) < 30)
+                        {
+                            if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->getClass() == CLASS_ROGUE :
+                                attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                                attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                            {
+                                if (doCast(attacker, GetSpell(FLARE_1)))
+                                    return;
+                            }
+                        }
+                        Unit::AttackerSet const& u_attackers = u->getAttackers();
+                        if (u_attackers.empty())
+                            continue;
+
+                        for (Unit::AttackerSet::const_iterator itr = u_attackers.begin(); itr != u_attackers.end(); ++itr)
+                        {
+                            attacker = *itr;
+                            if (u->GetDistance(attacker) > 15 || me->GetDistance(attacker) > 30)
+                                continue;
+
+                            if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->getClass() == CLASS_ROGUE :
+                                attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                                attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                            {
+                                if (doCast(urand(1,100) <= 50 ? u : attacker, GetSpell(FLARE_1)))
+                                    return;
+
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        //TODO check for level 80
+        void CheckReadiness(uint32 diff)
+        {
+            //if (!IsSpellReady(READINESS_1, diff) || !me->IsInCombat() || me->IsMounted() || Rand() > 10)
+            //    return;
+
+            //TODO: recheck priorities
+            //uint32 needFactor = 0;
+            //uint32 cooldown;
+            //cooldown = GetSpellCooldown(EVASION_1);
+            //needFactor += !cooldown ? 0 : 3 * cooldown / 1200; //1-100 x3
+            //cooldown = GetSpellCooldown(SPRINT_1);
+            //needFactor += !cooldown ? 0 : 1 * cooldown / 1200; //1-100
+            //cooldown = GetSpellCooldown(VANISH_1);
+            //needFactor += !cooldown ? 0 : 3 * cooldown / 1200; //1-100 x3
+            //cooldown = GetSpellCooldown(COLD_BLOOD_1);
+            //needFactor += !cooldown ? 0 : 2 * cooldown / 1800; //1-100 x2
+            //cooldown = GetSpellCooldown(SHADOWSTEP_1);
+            //needFactor += !cooldown ? 0 : 2 * cooldown / 200;  //1-100 x2
+            //cooldown = GetSpellCooldown(BLADE_FLURRY_1);
+            //needFactor += !cooldown ? 0 : 1 * cooldown / 1200; //1-100
+            //cooldown = GetSpellCooldown(DISMANTLE_1);
+            //needFactor += !cooldown ? 0 : 1 * cooldown / 600;  //1-100
+            ////0-1300
+            ////ignore Kick
+
+            //if (needFactor >= 800 && doCast(me, GetSpell(PREPARATION_1)))
+            //    return;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Glyph of Explosive Shot: 4% additional critical chance for Explosive Shot
+            if (lvl >= 60 && (baseId == EXPLOSIVE_SHOT_1 || baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA))
+                crit_chance += 4.f;
+            //Point of No Escape: 6% additional critical chance on targets affected by frosty traps
+            if (lvl >= 50)
+            {
+                if (victim->GetAuraEffect(SPELL_AURA_MOD_CRIT_CHANCE_FOR_CASTER, SPELLFAMILY_HUNTER, 0x18, 0x0, 0x0, me->GetGUID()))
+                    crit_chance += 6.f;
+            }
+            //Sniper Training (part 1): 15% additional critical chance for Kill Shot
+            if (lvl >= 50 && baseId == KILL_SHOT_1)
+                crit_chance += 15.f;
+            //Improved Steady Shot (37505): 5% additional critical chance for Steady Shot
+            if (lvl >= 50 && baseId == STEADY_SHOT_1)
+                crit_chance += 5.f;
+            //Glyph of TrueShot Aura (req lvl 40): 10% additional critical chance for Aimed Shot
+            if (lvl >= 40 && baseId == AIMED_SHOT_1)
+                crit_chance += 10.f;
+            //Improved Barrage: 12% additional critical chance for Multi-Shot and Aimed Shot
+            if (lvl >= 40 && (baseId == AIMED_SHOT_1 || baseId == MULTISHOT_1))
+                crit_chance += 12.f;
+            //Survival Instincts: 4% additional critical chance for Arcane Shot, Steady Shot and Explosive Shot
+            if (lvl >= 15 && (baseId == ARCANE_SHOT_1 || baseId == STEADY_SHOT_1 || baseId == EXPLOSIVE_SHOT_1 ||
+                baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA))
+                crit_chance += 4.f;
+            //Savage Strikes: 20% additional critical chance for Raptor Strike, Mongoose Bite and Counterattack
+            if (lvl >= 10 && (baseId == RAPTOR_STRIKE_1 || baseId == MONGOOSE_BITE_1 || baseId == COUNTERATTACK_1))
+                crit_chance += 20.f;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            ////do nothing with autoshot
+            //if (baseId == AUTO_SHOT_1)
+            //    return;
+
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Mortal Shots: 30% crit damage bonus for all ranged abilities
+                if (lvl >= 15 && baseId != AUTO_SHOT_1)
+                    pctbonus += 0.15f;
+                //Marked for Death (part 2): 10% crit damage bonus for Aimed Shot, Arcane Shot, Steady Shot, Kill Shot and Chimera Shot
+                if (lvl >= 55 &&
+                    (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == STEADY_SHOT_1 ||
+                    baseId == KILL_SHOT_1 || baseId == CHIMERA_SHOT_1))
+                    pctbonus += 0.05f;
+            }
+
+            //Improved Tracking: 5% bonus damage versus tracked types (all for bots)
+            if (lvl >= 10)
+                pctbonus += 0.05f;
+            //Focused Fire: 2% bonus damage while pet is active
+            if (lvl >= 15 && me->GetBotsPet())
+                pctbonus += 0.02f;
+            //Ranged Weapon Specialization: 5% bonus damage for ranged attacks
+            if (lvl >= 35)
+                pctbonus += 0.05f;
+            //Improved Arcane Shot: 15% bonus damage for Arcane Shot
+            if (lvl >= 20 && baseId == ARCANE_SHOT_1)
+                pctbonus += 0.15f;
+            //Rapid Killing (buff): 20% bonus damage for Aimed Shot, Arcane Shot or Chimera Shot (removed in SpellHitTarget())
+            if (lvl >= 20 && (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1))
+            {
+                if (AuraEffect const* rapi = me->GetAuraEffect(RAPID_KILLING_BUFF, 0))
+                    if (rapi->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.2f;
+            }
+            //Barrage: 12% bonus damage for Aimed Shot, Multi-Shot or Volley
+            if (lvl >= 30 && (spellInfo->SpellFamilyFlags[0] & 0x23000))
+                pctbonus += 0.12f;
+            //Marked for Death (part 1): 5% bonus damage for all ranged shots on marked target
+            if (lvl >= 55 && damageinfo.target &&
+                damageinfo.target->GetAuraEffect(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS, SPELLFAMILY_HUNTER, 0x400, 0x0, 0x0/*, me->GetGUID()*/))
+                pctbonus += 0.05f;
+            //T.N.T: 6% bonus damage for Explosive Shot, Explosive Trap, Immolation Trap and Black Arrow
+            if (lvl >= 25 &&
+                (baseId == EXPLOSIVE_SHOT_1 || baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA ||
+                baseId == EXPLOSIVE_TRAP_AURA_1 || baseId == IMMOLATION_TRAP_AURA_1 || baseId == BLACK_ARROW_1))
+                pctbonus += 0.06f;
+            //Ferocious Inspiration part 2: 9% bonus damage for Arcane Shot and Steady Shot
+            if (lvl >= 40 && (baseId == ARCANE_SHOT_1 || baseId == STEADY_SHOT_1))
+                pctbonus += 0.09f;
+            //Improved Steady Shot (38392): 10% bonus damage for Steady Shot
+            if (lvl >= 50 && baseId == STEADY_SHOT_1)
+                pctbonus += 0.1f;
+            //Glyph of Steady Shot: 10% bonus damage for Steady Shot if affected by Serpent Sting
+            if (lvl >= 62 && baseId == STEADY_SHOT_1 && damageinfo.target &&
+                damageinfo.target->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0/*, me->GetGUID()*/))
+                pctbonus += 0.1f;
+            //The Beast Within part 1: 10% bonus damage for all abilities
+            if (lvl >= 50)
+                pctbonus += 0.1f;
+            //Sniper Training part 2: 6% bonus damage for Steady Shot, Aimed Shot, Black Arrow and Explosive Shot
+            if (lvl >= 50 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x20000) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x8000001) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x200)))
+            {
+                if (Aura const* snip = me->GetAura(SNIPER_TRAINING_BUFF))
+                {
+                    if (snip->GetEffect(0)->IsAffectedOnSpell(spellInfo) ||
+                        snip->GetEffect(1)->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.06f;
+                }
+            }
+            //Improved Steady Shot part 1: 15% bonus damage for Steady Shot, Aimed Shot, Arcane Arrow and Chimera Shot
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* stea = me->GetAuraEffect(IMPROVED_STEADY_SHOT_BUFF, 0))
+                    if (stea->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.15f;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            float flat_mod = 0.f;
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //    //!!!spell damage is not yet critical and will be multiplied by 1.5
+            //    //so we should put here bonus damage mult /1.5
+            //    //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+            //    if (lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+            //        pctbonus += 0.16f;
+            //}
+            //Trap Mastery part 2: 30% bonus damage for Immolation Trap, Explosive Trap and Black Arrow
+            if (lvl >= 15 && (baseId == IMMOLATION_TRAP_AURA_1 || baseId == EXPLOSIVE_TRAP_AURA_1 || baseId == BLACK_ARROW_1))
+                pctbonus += 0.3f;
+            //T.N.T: 6% bonus damage for Explosive Shot, Explosive Trap, Immolation Trap and Black Arrow
+            if (lvl >= 25 &&
+                (baseId == EXPLOSIVE_SHOT_1 || baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA ||
+                baseId == EXPLOSIVE_TRAP_AURA_1 || baseId == IMMOLATION_TRAP_AURA_1 || baseId == BLACK_ARROW_1))
+                pctbonus += 0.06f;
+            //The Beast Within part 1: 10% bonus damage for all abilities
+            if (lvl >= 50)
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus) + flat_mod);
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Improved Hunter's Mark: -100% mana cost for Hunter's Mark
+            if (lvl >= 15 && baseId == HUNTERS_MARK_1)
+                pctbonus += 1.0f;
+            //Lock and Load: mana cost
+            if (baseId == ARCANE_SHOT_1 || baseId == EXPLOSIVE_SHOT_1)
+            {
+                AuraEffect const* lock = me->GetAuraEffect(LOCK_AND_LOAD_BUFF, 0);
+                if (lock && lock->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+            }
+
+            //Efficiency: -15% mana cost for Stings and Shots
+            if (lvl >= 25 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x7FA00) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x88801081) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x1)))
+                pctbonus += 0.15f;
+            //Resourcefulness: -60% mana cost for Traps, melee spells and Black Arrow
+            if (lvl >= 35 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0xDE) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x84000)))
+                pctbonus += 0.6f;
+            //Glyph of Volley: -20% mana cost for Volley
+            if (lvl >= 40 && baseId == VOLLEY_1)
+                pctbonus += 0.2f;
+            //Master Marksman: -25% mana cost for Steady Shot, Aimed Shot and Chimera Shot
+            if (lvl >= 45 && (baseId == STEADY_SHOT_1 || baseId == AIMED_SHOT_1 || baseId == CHIMERA_SHOT_1))
+                pctbonus += 0.25f;
+            //Improved Steady Shot part 2: -20% mana cost for Steady Shot, Aimed Shot, Arcane Arrow and Chimera Shot
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* stea = me->GetAuraEffect(IMPROVED_STEADY_SHOT_BUFF, 1))
+                    if (stea->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.2f;
+            }
+
+            //flat mods
+            //!1 rage = 10 pts!
+            //Improved Heroic Strike: -3 rage cost for Heroic Strike
+            //if (lvl >= 10 && baseId == HEROIC_STRIKE_1)
+            //    flatbonus += 30;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            //if (lvl >= 40 && spellId == GetSpell(CHARGE_1))
+            //    pctbonus += 0.07f;
+
+            //flat mods
+            //Survival Tactics: -4 sec cooldown for Disengage
+            //Glyph of Disengage: -5 sec cooldown for Disengage
+            if (lvl >= 20 && baseId == DISENGAGE_1)
+                timebonus += 9000;
+            //Glyph of Feign Death: -5 sec cooldown for Feign Death
+            //Improved Feign Death (24432): -2 sec cooldown for Feign Death
+            if (lvl >= 30 && baseId == FEIGN_DEATH_1)
+                timebonus += 7000;
+            //Tranquilizing Shot Cooldown reduction (61255): -2 sec cooldown for Tranquilizing Shot
+            if (lvl >= 60 && baseId == TRANQ_SHOT_1)
+                timebonus += 2000;
+            //Glyph of Deterrence: -10 sec cooldown for Deterrence
+            if (lvl >= 60 && baseId == DETERRENCE_1)
+                timebonus += 10000;
+            //Glyph of Chimera Shot: -1 sec cooldown for Chimera Shot
+            if (lvl >= 60 && baseId == CHIMERA_SHOT_1)
+                timebonus += 1000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Lock and Load: cooldown
+            if (baseId == ARCANE_SHOT_1 || baseId == EXPLOSIVE_SHOT_1)
+            {
+                AuraEffect const* lock = me->GetAuraEffect(LOCK_AND_LOAD_BUFF, 0);
+                if (lock && lock->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+            }
+
+            //Rapid Killing part 1: -2 min cooldown for Rapid Fire
+            if (baseId == RAPID_FIRE_1)
+                timebonus += 120000;
+            //Glyph of Aimed Shot: -2 sec cooldown for Aimed Shot
+            if (baseId == AIMED_SHOT_1)
+                timebonus += 2000;
+            //Glyph of Multi-Shot: -1 sec cooldown for Multi-Shot
+            //Improved Multi-Shot (44292): -1 sec cooldown for Multi-Shot
+            if (baseId == MULTISHOT_1)
+                timebonus += 2000;
+            //Trap Cooldown (37481): -4 sec cd for Traps
+            //Trap Cooldown Reduction: -2 sec cd for Traps
+            if (spellInfo->SpellFamilyFlags[0] & 0x80)
+                timebonus += 6000;
+            //Resourcefulness: -6 sec cd for Traps and Black Arrow
+            if (lvl >= 35 && (spellInfo->SpellFamilyFlags[0] & 0x80))
+                timebonus += 6000;
+            //Catlike Reflexes part 3: -30 sec cd for Kill Command
+            if (lvl >= 40 && (spellInfo->SpellFamilyFlags[1] & 0x800))
+                timebonus += 30000;
+            //Glyph of Kill Shot: -6 sec cooldown for Kill Shot
+            if (lvl >= 40 && baseId == KILL_SHOT_1)
+                timebonus += 6000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            ////Holy Reach
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Frost Trap
+            if (baseId == FROST_TRAP_AURA)
+                flatbonus += 2.f;
+            //Glyph of the Pack
+            if (baseId == ASPECT_OF_THE_PACK_1)
+                flatbonus += 15.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Booming Voice
+            //if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+            //    pctbonus += 1.0f;
+
+            //flat mods
+            //Hawk Eye: +6 yd range for Ranged Abilities
+            if (lvl >= 10 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x7FA01) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x88801081) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x401)))
+                flatbonus += 6.f;
+            //Glyph of Scatter Shot
+            if (lvl >= 20 && baseId == SCATTER_SHOT_1)
+                flatbonus += 3.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+
+            //Improved Aspect of the Hawk: 10% chance
+            if (lvl >= 10 && (baseId == ASPECT_OF_THE_HAWK_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_1))
+                chance += 10.f;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo)
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //Rapid Killing: use up buff manually
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* rapi = me->GetAuraEffect(RAPID_KILLING_BUFF, 0))
+                    if (rapi->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAura(RAPID_KILLING_BUFF);
+            }
+            //Glyph of Arcane Shot
+            if (baseId == ARCANE_SHOT_1)
+            {
+                Unit const* victim = me->GetVictim();
+                if (victim &&
+                    (victim->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_PERIODIC_MANA_LEECH, SPELLFAMILY_HUNTER, 0x0, 0x80, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_MOD_HIT_CHANCE, SPELLFAMILY_HUNTER, 0x8000, 0x0, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_MOD_STUN, SPELLFAMILY_HUNTER, 0x0, 0x1000, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_HUNTER, 0x0, 0x100, 0x0, me->GetGUID())))
+                {
+                    int32 cost = spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+                    me->CastCustomSpell(me, GLYPH_OF_ARCANE_SHOT_ENERGIZE, &cost, NULL, NULL, true);
+                }
+            }
+            //Lock and Load: consume charge
+            if (baseId == ARCANE_SHOT_1 || baseId == EXPLOSIVE_SHOT_1)
+            {
+                AuraEffect const* lock = me->GetAuraEffect(LOCK_AND_LOAD_BUFF, 0);
+                if (lock && lock->IsAffectedOnSpell(spellInfo))
+                    lock->GetBase()->DropCharge();
+            }
+            if (baseId == READINESS_1)
+            {
+                SpellInfo const* cdInfo;
+                BotSpellMap const& myspells = GetSpellMap();
+                for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+                {
+                    if (itr->first == spellInfo->Id || itr->first == BESTIAL_WRATH_1 || itr->first == GIFT_OF_NAARU_HUNTER)
+                        continue;
+                    if (itr->second->enabled && itr->second->spellId != 0 && itr->second->cooldown > lastdiff)
+                    {
+                        cdInfo = sSpellMgr->GetSpellInfo(itr->first);
+                        if (cdInfo && cdInfo->SpellFamilyName == SPELLFAMILY_HUNTER && cdInfo->GetRecoveryTime() > 0)
+                            ResetSpellCooldown(itr->first);
+                    }
+                }
+            }
+            //Improved Steady Shot: consume buff
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* stea = me->GetAuraEffect(IMPROVED_STEADY_SHOT_BUFF, 0))
+                    if (stea->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(IMPROVED_STEADY_SHOT_BUFF);
+            }
+
+            //Aspect helper
+            switch (baseId)
+            {
+                case ASPECT_OF_THE_MONKEY_1:
+                    Aspect = ASPECT_MONKEY;
+                    break;
+                case ASPECT_OF_THE_HAWK_1:
+                    Aspect = ASPECT_HAWK;
+                    break;
+                case ASPECT_OF_THE_CHEETAH_1:
+                    Aspect = ASPECT_CHEETAH;
+                    break;
+                case ASPECT_OF_THE_VIPER_1:
+                    Aspect = ASPECT_VIPER;
+                    break;
+                case ASPECT_OF_THE_BEAST_1:
+                    Aspect = ASPECT_BEAST;
+                    break;
+                case ASPECT_OF_THE_PACK_1:
+                    Aspect = ASPECT_PACK;
+                    break;
+                case ASPECT_OF_THE_WILD_1:
+                    Aspect = ASPECT_WILD;
+                    break;
+                case ASPECT_OF_THE_DRAGONHAWK_1:
+                    Aspect = ASPECT_DRAGONHAWK;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            if (target == me)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            if (baseId == HUNTERS_MARK_1)
+            {
+                //Hunter's Mark helper
+                if (AuraEffect* mark = target->GetAuraEffect(spell->Id, 1, me->GetGUID()))
+                {
+                    //Glyph of Hunter's Mark: +20% effect
+                    //Improved Hunter's Mark: +30% effect
+                    if (lvl >= 15)
+                        mark->ChangeAmount(mark->GetAmount() + mark->GetAmount() / 2);
+                    else if (lvl >= 10)
+                        mark->ChangeAmount(mark->GetAmount() * 13 / 10);
+                }
+            }
+            //Improved Stings part 1: +30% damage
+            if (lvl >= 25 && (baseId == SERPENT_STING_1 || baseId == WYVERN_STING_DOT_AURA_1))
+            {
+                if (AuraEffect* stin = target->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    stin->ChangeAmount(stin->GetAmount() * 13 / 10);
+                }
+            }
+            //Improved Stings part 2: +30% effect: not working?
+            //Trap Mastery part 1
+            if (lvl >= 15 && (baseId == FROST_TRAP_AURA || baseId == FREEZING_TRAP_AURA_1))
+            {
+                if (Aura* freez = target->GetAura(spell->Id, me->GetGUID()))
+                {
+                    int32 dur = freez->GetDuration() * 13 / 10;
+                    freez->SetDuration(dur);
+                    freez->SetMaxDuration(dur);
+                }
+            }
+            if (lvl >= 16 && baseId == IMMOLATION_TRAP_AURA_1)
+            {
+                if (AuraEffect* immo = target->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    //Glyph of Immolation Trap: -6 sec duration, +100% effect
+                    immo->ChangeAmount(immo->GetAmount() * 2);
+                    int32 dur = immo->GetBase()->GetDuration() - 6000;
+                    immo->GetBase()->SetDuration(dur);
+                    immo->GetBase()->SetMaxDuration(dur);
+                }
+            }
+            if (lvl >= 15 && baseId == SERPENT_STING_1)
+            {
+                if (Aura* sting = target->GetAura(spell->Id, me->GetGUID()))
+                {
+                    //Glyph of Serpent Sting: +6 sec duration
+                    //Improved Serpent Sting (24467): +3 sec duration
+                    int32 dur = sting->GetDuration() + 6000;
+                    if (lvl >= 60)
+                        dur += 3000;
+                    sting->SetDuration(dur);
+                    sting->SetMaxDuration(dur);
+                }
+            }
+            if (lvl >= 30 && baseId == WING_CLIP_1)
+            {
+                //zzzOLD Improved Wing Clip (only on creatures): 30% to root target with Wing Clip
+                //normal creatures are rooted for 10 sec, elites+ for 6 sec
+                if (target->GetTypeId() == TYPEID_UNIT)
+                {
+                    if (urand(1,100) <= 30)
+                    {
+                        uint32 clip = target->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_NORMAL ? IMPROVED_WING_CLIP_NORMAL : IMPROVED_WING_CLIP_EX;
+                        me->CastSpell(target, clip, true);
+                    }
+                }
+            }
+            if (lvl >= 10 && baseId == CONCUSSIVE_SHOT_1)
+            {
+                //Improved Concussion Shot rank 2: 2 sec increased daze duration
+                if (Aura* concus = target->GetAura(spell->Id, me->GetGUID()))
+                {
+                    int32 dur = concus->GetDuration() + 2000;
+                    concus->SetDuration(dur);
+                    concus->SetMaxDuration(dur);
+                }
+
+                //zzzOLD Improved Concussion Shot: chance to stun target for 3 sec
+                if (urand(1,100) <= 15)
+                {
+                    me->CastSpell(target, IMPROVED_CONCUSSION, true);
+                }
+            }
+            if (lvl >= 50 && baseId == STEADY_SHOT_1)
+            {
+                //Improved Steady Shot: 15% chance
+                if (urand(1,100) <= 15)
+                {
+                    me->CastSpell(me, IMPROVED_STEADY_SHOT_BUFF, true);
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Rapid Recuperation (Rapid Killing) hackfix: trigger 2% energize
+            if (baseId == RAPID_RECUPERATION_ENERGIZE)
+            {
+                me->CastSpell(me, RAPID_RECUPERATION_ENERGIZE_PCT_1, true);
+            }
+            //Rapid Recuperation (Rapid Fire): match duration
+            if (baseId == RAPID_RECUPERATION_BUFF)
+            {
+                if (GetSpell(RAPID_FIRE_1))
+                if (Aura const* rapi = me->GetAura(GetSpell(RAPID_FIRE_1)))
+                {
+                    if (Aura* recu = me->GetAura(spell->Id))
+                    {
+                        uint32 dur = rapi->GetDuration();
+                        recu->SetDuration(dur);
+                        recu->SetMaxDuration(dur);
+                    }
+                }
+            }
+            //Rapid Recuperation (Rapid Fire)
+            if (baseId == RAPID_FIRE_1 && me->getLevel() >= 45)
+            {
+                me->CastSpell(me, RAPID_RECUPERATION_BUFF, true);
+            }
+            //Rapid Recuperation (Rapid Killing)
+            if (baseId == RAPID_KILLING_BUFF && me->getLevel() >= 45)
+            {
+                me->CastSpell(me, RAPID_RECUPERATION_BUFF2, true);
+            }
+            if (baseId == RAPID_FIRE_1 && lvl >= 26)
+            {
+                //Rapid Fire (id 28755): 4 sec increased duration
+                //Glyph of Rapid Fire: +8% haste
+                if (AuraEffect* rapi = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    rapi->ChangeAmount(rapi->GetAmount() + 8);
+
+                    uint32 dur = rapi->GetBase()->GetDuration() + 4000;
+                    rapi->GetBase()->SetDuration(dur);
+                    rapi->GetBase()->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == QUICK_SHOTS_BUFF)
+            {
+                if (AuraEffect* quic = me->GetAuraEffect(QUICK_SHOTS_BUFF, 0))
+                {
+                    //base 15% haste
+                    int32 newAmount = quic->GetAmount() + 15;
+                    //Glyph of the Hawk: +6% effect flat
+                    if (lvl >= 15)
+                        newAmount += 6;
+
+                    quic->ChangeAmount(newAmount);
+                }
+            }
+            if ((baseId == ASPECT_OF_THE_CHEETAH_1 || baseId == ASPECT_OF_THE_PACK_1) && caster == me && lvl >= 20)
+            {
+                //Pathfinding: +8% increased effect
+                if (AuraEffect* spee = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    spee->ChangeAmount(spee->GetAmount() + 8);
+                }
+            }
+            if ((baseId == ASPECT_OF_THE_MONKEY_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_MONKEY) && lvl >= 15)
+            {
+                //Improved Aspect of The Monkey: +6% dodge chance
+                if (AuraEffect* monk = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    monk->ChangeAmount(monk->GetAmount() + 6);
+                }
+            }
+            //Aspect Mastery
+            if (lvl >= 20)
+            {
+                if (baseId == ASPECT_OF_THE_VIPER_1)
+                {
+                    if (AuraEffect* vipe = me->GetAuraEffect(spell->Id, 1, me->GetGUID()))
+                    {
+                        //part 1: 10% reduced damage penalty
+                        vipe->ChangeAmount(vipe->GetAmount() + 10);
+                    }
+                }
+                if (baseId == ASPECT_OF_THE_MONKEY_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_MONKEY)
+                {
+                    if (AuraEffect* monk = me->GetAuraEffect(spell->Id, 1, me->GetGUID()))
+                    {
+                        //part 2: 5% reduced damage
+                        monk->ChangeAmount(monk->GetAmount() - 5);
+                    }
+                }
+                if (baseId == ASPECT_OF_THE_HAWK_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_1)
+                {
+                    if (AuraEffect* hawk = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                    {
+                        //part 3: 30% attack power bonus
+                        hawk->ChangeAmount(hawk->GetAmount() * 13 / 10);
+                    }
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            trapTimer = 0;
+            stingTimer = 0;
+            aspectTimer = 0;
+            flareTimer = 0;
+            misdirectionTimer = 0;
+
+            Aspect = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (trapTimer > diff)                   trapTimer -= diff;
+            if (stingTimer > diff)                  stingTimer -= diff;
+            if (aspectTimer > diff)                 aspectTimer -= diff;
+            if (flareTimer > diff)                  flareTimer -= diff;
+            if (misdirectionTimer > diff)           misdirectionTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(AUTO_SHOT_1);
+            InitSpellMap(ARCANE_SHOT_1);
+            InitSpellMap(TRANQ_SHOT_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(BLACK_ARROW_1) : RemoveSpell(BLACK_ARROW_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(SILENCING_SHOT_1) : RemoveSpell(SILENCING_SHOT_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(CHIMERA_SHOT_1) : RemoveSpell(CHIMERA_SHOT_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(AIMED_SHOT_1) : RemoveSpell(AIMED_SHOT_1);
+            InitSpellMap(STEADY_SHOT_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(EXPLOSIVE_SHOT_1) : RemoveSpell(EXPLOSIVE_SHOT_1);
+            InitSpellMap(KILL_SHOT_1);
+            InitSpellMap(MULTISHOT_1);
+            InitSpellMap(VOLLEY_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(SCATTER_SHOT_1) : RemoveSpell(SCATTER_SHOT_1);
+            InitSpellMap(CONCUSSIVE_SHOT_1);
+            InitSpellMap(DISTRACTING_SHOT_1);
+            InitSpellMap(SERPENT_STING_1);
+            InitSpellMap(SCORPID_STING_1);
+            InitSpellMap(VIPER_STING_1);
+            InitSpellMap(RAPID_FIRE_1);
+            InitSpellMap(FLARE_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(WYVERN_STING_1) : RemoveSpell(WYVERN_STING_1);
+            InitSpellMap(WING_CLIP_1);
+            InitSpellMap(RAPTOR_STRIKE_1);
+            InitSpellMap(MONGOOSE_BITE_1);
+            InitSpellMap(COUNTERATTACK_1);
+            InitSpellMap(DISENGAGE_1);
+            InitSpellMap(IMMOLATION_TRAP_1);
+            InitSpellMap(FREEZING_TRAP_1);
+            InitSpellMap(FROST_TRAP_1);
+            InitSpellMap(EXPLOSIVE_TRAP_1);
+            InitSpellMap(FREEZING_ARROW_1);
+            InitSpellMap(HUNTERS_MARK_1);
+            InitSpellMap(SCARE_BEAST_1);
+            InitSpellMap(FEIGN_DEATH_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(READINESS_1) : RemoveSpell(READINESS_1);
+            InitSpellMap(DETERRENCE_1);
+            InitSpellMap(MISDIRECTION_1);
+
+            InitSpellMap(ASPECT_OF_THE_MONKEY_1);
+            InitSpellMap(ASPECT_OF_THE_HAWK_1);
+            InitSpellMap(ASPECT_OF_THE_CHEETAH_1);
+            InitSpellMap(ASPECT_OF_THE_VIPER_1);
+            //InitSpellMap(ASPECT_OF_THE_BEAST_1);
+            InitSpellMap(ASPECT_OF_THE_PACK_1);
+            InitSpellMap(ASPECT_OF_THE_WILD_1);
+            InitSpellMap(ASPECT_OF_THE_DRAGONHAWK_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(SUREFOOTED, level >= 15 ? 1 : 0);
+            RefreshAura(ENTRAPMENT, level >= 15 ? 1 : 0);
+            RefreshAura(RAPID_KILLING, level >= 20 ? 1 : 0);
+            RefreshAura(LOCK_AND_LOAD, level >= 25 ? 1 : 0);
+            RefreshAura(CONCUSSIVE_BARRAGE, level >= 30 ? 1 : 0);
+            RefreshAura(PIERCING_SHOTS, level >= 40 ? 1 : 0);
+            RefreshAura(TRUESHOT_AURA, level >= 40 ? 1 : 0);
+            RefreshAura(EXPOSE_WEAKNESS, level >= 40 ? 1 : 0);
+            RefreshAura(THRILL_OF_THE_HUNT, level >= 40 ? 1 : 0);
+            RefreshAura(MASTER_MARKSMAN, level >= 45 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN5, level >= 50 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN4, level >= 49 && level < 50 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN3, level >= 48 && level < 49 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN2, level >= 47 && level < 48 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN1, level >= 46 && level < 47 ? 1 : 0);
+            RefreshAura(NOXIOUS_STINGS, level >= 45 ? 1 : 0);
+            RefreshAura(WILD_QUIVER, level >= 50 ? 1 : 0);
+            RefreshAura(SNIPER_TRAINING, level >= 50 ? 1 : 0);
+
+            RefreshAura(GLYPH_RAPTOR_STRIKE, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_ASPECT_OF_THE_VIPER, level >= 20 ? 1 : 0);
+            RefreshAura(GLYPH_FREEZING_TRAP, level >= 20 ? 1 : 0);
+            RefreshAura(GLYPH_EXPLOSIVE_TRAP, level >= 34 ? 1 : 0);
+
+            RefreshAura(HUNTER_T8_P2, level >= 70 ? 1 : 0);
+            RefreshAura(HUNTER_T10_P2, level >= 75 ? 1 : 0);
+            RefreshAura(HUNTER_T10_P4, level >= 80 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                //case RAPID_FIRE_1:
+                case FLARE_1:
+                case IMMOLATION_TRAP_1:
+                case FREEZING_TRAP_1:
+                case FROST_TRAP_1:
+                case EXPLOSIVE_TRAP_1:
+                case VOLLEY_1:
+                //case ASPECT_OF_THE_MONKEY_1:
+                //case ASPECT_OF_THE_HAWK_1:
+                //case ASPECT_OF_THE_CHEETAH_1:
+                //case ASPECT_OF_THE_VIPER_1:
+                //case ASPECT_OF_THE_BEAST_1:
+                case ASPECT_OF_THE_PACK_1:
+                case ASPECT_OF_THE_WILD_1:
+                //case ASPECT_OF_THE_DRAGONHAWK_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        bool HasAbilitiesSpecifics() const { return true; }
+        void FillAbilitiesSpecifics(std::list<std::string> &specList)
+        {
+            std::ostringstream msg1;
+            msg1 << "Aspect: ";
+            switch (Aspect)
+            {
+                case ASPECT_MONKEY:
+                    msg1 << "Monkey";
+                    break;
+                case ASPECT_HAWK:
+                    msg1 << "Hawk";
+                    break;
+                case ASPECT_CHEETAH:
+                    msg1 << "Cheetah";
+                    break;
+                case ASPECT_VIPER:
+                    msg1 << "Viper";
+                    break;
+                case ASPECT_BEAST:
+                    msg1 << "Beast";
+                    break;
+                case ASPECT_PACK:
+                    msg1 << "Pack";
+                    break;
+                case ASPECT_WILD:
+                    msg1 << "Wild";
+                    break;
+                case ASPECT_DRAGONHAWK:
+                    msg1 << "Dragonhawk";
+                    break;
+               default:
+                    msg1 << "No Aspect";
+                    break;
+            }
+            specList.push_back(msg1.str());
+        }
+
+    private:
+        uint32 trapTimer, stingTimer, aspectTimer, flareTimer, misdirectionTimer;
+        uint8 Aspect;
+
+        //Scans target for hunter's aspects
+        //returns applied aspects mask
+        //used for finding out which aspects target lacks
+        uint32 _getAspectsMask(std::map<uint32 /*type*/, uint32 /*curId*/>& idMap) const
+        {
+            uint32 mask = 0;
+
+            uint32 baseId;
+            bool isAspect;
+            Unit::AuraApplicationMap const& aurapps = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                isAspect = true;
+                baseId = itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id;
+                switch (baseId)
+                {
+                    //case ASPECT_OF_THE_MONKEY_1:
+                    //    mask |= SPECIFIC_ASPECT_MONKEY;
+                    //    break;
+                    case ASPECT_OF_THE_HAWK_1:
+                        mask |= SPECIFIC_ASPECT_HAWK;
+                        break;
+                    //case ASPECT_OF_THE_CHEETAH_1:
+                    //    mask |= SPECIFIC_ASPECT_CHEETAH;
+                    //    break;
+                    //case ASPECT_OF_THE_VIPER_1:
+                    //    mask |= SPECIFIC_ASPECT_VIPER;
+                    //    break;
+                    //case ASPECT_OF_THE_BEAST_1:
+                    //    mask |= SPECIFIC_ASPECT_BEAST;
+                    //    break;
+                    case ASPECT_OF_THE_PACK_1:
+                        mask |= SPECIFIC_ASPECT_PACK;
+                        break;
+                    case ASPECT_OF_THE_WILD_1:
+                        mask |= SPECIFIC_ASPECT_WILD;
+                        break;
+                    case ASPECT_OF_THE_DRAGONHAWK_1:
+                        mask |= SPECIFIC_ASPECT_DRAGONHAWK;
+                        break;
+                    default:
+                        isAspect = false; //next aura
+                        break;
+                }
+
+                if (isAspect)
+                {
+                    idMap[baseId] = itr->first;
+                    if (itr->second->GetBase()->GetCasterGUID() == me->GetGUID())
+                        mask |= SPECIFIC_ASPECT_MY_ASPECT;
+                }
+            }
+
+            return mask;
+        }
+
+        enum HunterBaseSpells
+        {
+            AUTO_SHOT_1                         = 75,
+            ARCANE_SHOT_1                       = 3044,
+            TRANQ_SHOT_1                        = 19801,
+            BLACK_ARROW_1                       = 3674,
+            SILENCING_SHOT_1                    = 34490,
+            CHIMERA_SHOT_1                      = 53209,
+            AIMED_SHOT_1                        = 19434,
+            STEADY_SHOT_1                       = 56641,
+            EXPLOSIVE_SHOT_1                    = 53301,
+            KILL_SHOT_1                         = 53351,
+            MULTISHOT_1                         = 2643,
+            VOLLEY_1                            = 1510,
+            SCATTER_SHOT_1                      = 19503,
+            CONCUSSIVE_SHOT_1                   = 5116,
+            DISTRACTING_SHOT_1                  = 20736,
+            SERPENT_STING_1                     = 1978,
+            SCORPID_STING_1                     = 3043,
+            VIPER_STING_1                       = 3034,
+            RAPID_FIRE_1                        = 3045,
+            FLARE_1                             = 1543,
+            WYVERN_STING_1                      = 19386,
+            WING_CLIP_1                         = 2974,
+            RAPTOR_STRIKE_1                     = 2973,
+            MONGOOSE_BITE_1                     = 1495,
+            COUNTERATTACK_1                     = 19306,
+            DISENGAGE_1                         = 781,
+            IMMOLATION_TRAP_1                   = 13795,
+            FREEZING_TRAP_1                     = 1499,
+            FROST_TRAP_1                        = 13809,
+            EXPLOSIVE_TRAP_1                    = 13813,
+            FREEZING_ARROW_1                    = 60192,
+            SNAKE_TRAP_1                        = 34600,//NIY
+            HUNTERS_MARK_1                      = 1130,
+            SCARE_BEAST_1                       = 1513,
+            FEIGN_DEATH_1                       = 5384,
+            READINESS_1                         = 23989,
+            DETERRENCE_1                        = 19263,
+            MISDIRECTION_1                      = 34477,
+
+            ASPECT_OF_THE_MONKEY_1              = 13163,
+            ASPECT_OF_THE_HAWK_1                = 13165,
+            ASPECT_OF_THE_CHEETAH_1             = 5118,
+            ASPECT_OF_THE_VIPER_1               = 34074,
+            ASPECT_OF_THE_BEAST_1               = 13161,//NIY
+            ASPECT_OF_THE_PACK_1                = 13159,
+            ASPECT_OF_THE_WILD_1                = 20043,
+            ASPECT_OF_THE_DRAGONHAWK_1          = 61846
+        };
+
+        enum HunterPassives
+        {
+        //Talents
+            SUREFOOTED                          = 24283,//rank 3
+            ENTRAPMENT                          = 19388,//rank 3
+            RAPID_KILLING                       = 34949,//rank 2
+            LOCK_AND_LOAD                       = 56344,//rank 3
+            CONCUSSIVE_BARRAGE                  = 35102,//rank 2
+            PIERCING_SHOTS                      = 53238,//rank 3
+            TRUESHOT_AURA                       = 19506,
+            EXPOSE_WEAKNESS                     = 34503,//rank 3
+            THRILL_OF_THE_HUNT                  = 34499,//rank 3
+            MASTER_MARKSMAN                     = 34489,//rank 5
+            MASTER_TACTICIAN1                   = 34506,
+            MASTER_TACTICIAN2                   = 34507,
+            MASTER_TACTICIAN3                   = 34508,
+            MASTER_TACTICIAN4                   = 34838,
+            MASTER_TACTICIAN5                   = 34839,
+            NOXIOUS_STINGS                      = 53297,//rank 3
+            WILD_QUIVER                         = 53217,//rank 3
+            SNIPER_TRAINING                     = 53304,//rank 3
+
+            GLYPH_RAPTOR_STRIKE                 = 63086,
+            GLYPH_ASPECT_OF_THE_VIPER           = 56851,
+            GLYPH_FREEZING_TRAP                 = 56845,
+            GLYPH_EXPLOSIVE_TRAP                = 63068,
+
+            HUNTER_T8_P2                        = 67150,//serpent sting crits
+            HUNTER_T10_P2                       = 70727,//autoshot 15% dmg proc
+            HUNTER_T10_P4                       = 70730 //sting 20% ap proc
+        };
+
+        enum HunterSpecial
+        {
+            ASPECT_NONE                         = 0,
+            ASPECT_MONKEY                       = 1,
+            ASPECT_HAWK                         = 2,
+            ASPECT_CHEETAH                      = 3,
+            ASPECT_VIPER                        = 4,
+            ASPECT_BEAST                        = 5,
+            ASPECT_PACK                         = 6,
+            ASPECT_WILD                         = 7,
+            ASPECT_DRAGONHAWK                   = 8,
+
+            SPECIFIC_ASPECT_MONKEY              = 0x001,
+            SPECIFIC_ASPECT_HAWK                = 0x002,
+            SPECIFIC_ASPECT_CHEETAH             = 0x004,
+            SPECIFIC_ASPECT_VIPER               = 0x008,
+            SPECIFIC_ASPECT_BEAST               = 0x010,
+            SPECIFIC_ASPECT_PACK                = 0x020,
+            SPECIFIC_ASPECT_WILD                = 0x040,
+            SPECIFIC_ASPECT_DRAGONHAWK          = 0x080,
+            SPECIFIC_ASPECT_MY_ASPECT           = 0x100,
+            //SPECIFIC_ASPECT_ALL_AREA_AUTOUSE    = (SPECIFIC_ASPECT_PACK),
+
+            IMPROVED_CONCUSSION                 = 28445,
+            IMPROVED_WING_CLIP_NORMAL           = 47168,
+            IMPROVED_WING_CLIP_EX               = 35963,
+
+            VOLLEY_DAMAGE_1                     = 42243,//rank 1
+            //EXPLOSIVE_TRAP_DAMAGE_1             = 13812,//same as EXPLOSIVE_TRAP_AURA_1
+
+            QUICK_SHOTS_BUFF                    = 6150,
+            RAPID_KILLING_BUFF                  = 35099,//rank 2
+            LOCK_AND_LOAD_BUFF                  = 56453,//rank 3
+            SNIPER_TRAINING_BUFF                = 64420,//rank 3
+            RAPID_RECUPERATION_BUFF             = 54227,//rank 2, rapid fire, hidden
+            RAPID_RECUPERATION_BUFF2            = 58882,//rapid killing, 6 sec
+            IMPROVED_STEADY_SHOT_BUFF           = 53220,
+
+            FROST_TRAP_AURA                     = 13810,
+            FREEZING_TRAP_AURA_1                = 3355,
+            IMMOLATION_TRAP_AURA_1              = 13797,
+            EXPLOSIVE_TRAP_AURA_1               = 13812,//same as EXPLOSIVE_TRAP_DAMAGE_1
+            WYVERN_STING_DOT_AURA_1             = 24131,
+            FREEZING_ARROW_AURA                 = 60210,
+            EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA  = 53352,
+
+            ASPECT_OF_THE_DRAGONHAWK_MONKEY     = 61848, //linked, hidden
+
+            GLYPH_OF_ARCANE_SHOT_ENERGIZE       = 61389,
+            RAPID_RECUPERATION_ENERGIZE         = 58883,//rapid killing
+            RAPID_RECUPERATION_ENERGIZE_PCT_1   = 64180,//rank 1, 2%
+
+            BESTIAL_WRATH_1                     = 19574,
+            GIFT_OF_NAARU_HUNTER                = 59543
+        };
+    };
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_mage_ai.cpp b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
new file mode 100644
index 0000000..ddc3b23
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
@@ -0,0 +1,1470 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+//#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+/*
+Mage NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 80-90%
+TODO: arcane spec, arcane power, power of mind, slow, mana shield
+*/
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new mage_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct mage_botAI : public bot_minion_ai
+    {
+        mage_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_MAGE;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_MAGE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void EnterCombat(Unit* u) { canFrostWard = false; canFireWard = false; bot_minion_ai::EnterCombat(u); }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u) { bot_minion_ai::KilledUnit(u); }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force, u);
+        }
+
+        void Counter(uint32 diff)
+        {
+            //skip if evocation, blizzard
+            if (IsChanneling() || Rand() > 30)
+                return;
+
+            if (IsSpellReady(COUNTERSPELL_1, diff, false))
+            {
+                if (Unit* target = FindCastingTarget(30, 0, COUNTERSPELL_1))
+                {
+                    me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(COUNTERSPELL_1)))
+                        return;
+                }
+            }
+            if (IsSpellReady(DEEP_FREEZE_1, diff) && me->HasAura(FINGERS_OF_FROST_BUFF))
+            {
+                if (Unit* target = FindCastingTarget(30, 0, DEEP_FREEZE_1))
+                {
+                    me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(DEEP_FREEZE_1)))
+                        return;
+                }
+            }
+            if (IsSpellReady(FIRE_BLAST_1, diff) && me->HasAura(IMPACT_BUFF))
+            {
+                if (Unit* target = FindCastingTarget(20, 0, FIRE_BLAST_1))
+                {
+                    me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(FIRE_BLAST_1)))
+                        return;
+                }
+            }
+            if (!IsCasting() && IsSpellReady(POLYMORPH_1, diff))
+            {
+                if (Unit* target = FindCastingTarget(30, 0, POLYMORPH_1, 75))
+                {
+                    if (doCast(target, GetSpell(POLYMORPH_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckSpellSteal(uint32 diff)
+        {
+            if (!IsSpellReady(SPELLSTEAL_1, diff) || IsCasting() || Rand() > 15)
+                return;
+
+            Unit* target = FindHostileDispelTarget(30, true);
+            if (target && doCast(target, GetSpell(SPELLSTEAL_1)))
+                return;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || Feasting() || Rand() > 25)
+                return;
+
+            //slow fall
+            if (GetSpell(SLOW_FALL_1) && !IAmFree())
+            {
+                Player* fPlayer = NULL;
+                Group const* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference const* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+                    {
+                        Player* pl = ref->GetSource();
+                        if (pl && pl->IsAlive() && pl->FindMap() == me->GetMap() && pl->GetDistance(me) < 30 &&
+                            pl->IsFalling() && pl->m_movementInfo.fallTime > 1000 &&
+                            !pl->HasAuraType(SPELL_AURA_FEATHER_FALL))
+                        {
+                            fPlayer = pl;
+                            break;
+                        }
+                    }
+                }
+                else if (master->IsAlive() && master->GetDistance(me) < 30 && master->IsFalling() &&
+                    master->m_movementInfo.fallTime > 1000 && !master->HasAuraType(SPELL_AURA_FEATHER_FALL))
+                    fPlayer = master;
+
+                if (fPlayer && doCast(fPlayer, GetSpell(SLOW_FALL_1)))
+                    return;
+            }
+
+            //ARMOR
+            uint32 MOLTENARMOR = HasRole(BOT_ROLE_DPS) ? GetSpell(MOLTEN_ARMOR_1) : GetSpell(ICE_ARMOR_1);
+            uint32 ICEARMOR = GetSpell(ICE_ARMOR_1) ? GetSpell(ICE_ARMOR_1) : GetSpell(FROST_ARMOR_1);
+            uint32 ARMOR = !MOLTENARMOR ? ICEARMOR : me->GetMap()->IsDungeon() ? MOLTENARMOR : ICEARMOR;
+            if (ARMOR && !me->HasAura(ARMOR))
+            {
+                if (doCast(me, ARMOR))
+                    return;
+            }
+
+            if (GetSpell(CONJURE_MANA_GEM_1))
+            {
+                if (manaGemCharges == 0 &&
+                    doCast(me, GetSpell(CONJURE_MANA_GEM_1)))
+                    return;
+            }
+            if (GetSpell(DAMPENMAGIC_1))
+            {
+                if (!me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_DAMAGE_TAKEN, SPELLFAMILY_MAGE, 0x2000)
+                    /*!HasAuraName(me, DAMPENMAGIC_1)*/ &&
+                    doCast(me, GetSpell(DAMPENMAGIC_1)))
+                    return;
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (GetSpell(ARCANEINTELLECT_1) && target->GetMaxPower(POWER_MANA) > 1 &&
+                !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STAT, SPELLFAMILY_MAGE, 0x400)
+                /*!HasAuraName(target, ARCANEINTELLECT_1)*/)
+            {
+                if (doCast(target, GetSpell(ARCANEINTELLECT_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (Wait())
+                return;
+            GenerateRand();
+            CheckPoly(diff);
+            CheckBlink(diff);
+            BreakCC(diff);
+            CheckIceBlock(diff);
+            if (CCed(me)) return;
+
+            CheckPots(diff);
+
+            CheckRacials(diff);
+
+            CheckShield(diff);
+            CureGroup(GetSpell(REMOVE_CURSE_1), diff);
+            CheckWard(diff);
+
+            CheckFocusMagic(diff);
+            BuffAndHealGroup(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_MAGE))
+                return;
+
+            CheckPolymorph(diff);//this should go AFTER getting target
+
+            Counter(diff);
+            CheckSpellSteal(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+
+            StartAttack(opponent, IsMelee());
+
+            //mage
+            if (me->HasInvisibilityAura()) return;
+            if (!HasRole(BOT_ROLE_DPS)) return;
+
+            Unit::AttackerSet m_attackers = master->getAttackers();
+            Unit::AttackerSet b_attackers = me->getAttackers();
+
+            float dist = me->GetDistance(opponent);
+
+            //COMBUSTION (no GCD)
+            if (IsSpellReady(COMBUSTION_1, diff, false) && GetManaPCT(me) > 20 &&
+                (opponent->GetMaxHealth() > master->GetMaxHealth() * 4 ||
+                m_attackers.size() > 1 || b_attackers.size() > 1) &&
+                Rand() < 45 &&
+                !me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x04000000, 0x0)
+                /*!HasAuraName(me, COMBUSTION_1)*/)
+            {
+                if (doCast(me, GetSpell(COMBUSTION_1)))
+                    return;
+            }
+            //ICY VEINS (no GCD)
+            if (IsSpellReady(ICY_VEINS_1, diff, false) && GetManaPCT(me) > 20 &&
+                (opponent->GetMaxHealth() > master->GetMaxHealth() * 2 ||
+                (opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL)) &&
+                Rand() < 45)
+            {
+                if (doCast(me, GetSpell(ICY_VEINS_1)))
+                    return;
+            }
+            //DAMAGE
+            //Cheap check
+            if (GC_Timer > diff) //!ensure none spells below ignore GCD!
+                return;
+            //NOVAS
+            if (IsSpellReady(FROST_NOVA_1, diff) || IsSpellReady(BLAST_WAVE_1, diff) && Rand() < 85)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 8.5f); //both are radius 10 yd
+                if (!targets.empty())
+                {
+                    bool oneOnOne = (*targets.begin()) == opponent;
+                    //Blast Wave
+                    if (IsSpellReady(BLAST_WAVE_1, diff) && (targets.size() > 1 || oneOnOne))
+                    {
+                        if (doCast(me, GetSpell(BLAST_WAVE_1)))
+                            return;
+                    }
+                    //Frost Nova
+                    else if (IsSpellReady(FROST_NOVA_1, diff) && (targets.size() > 1 || oneOnOne))
+                    {
+                        if (doCast(me, GetSpell(FROST_NOVA_1)))
+                        {
+                            GetInPosition(true, opponent);
+                            return;
+                        }
+                    }
+                }
+            }
+            //CONES
+            if (fbCasted && (IsSpellReady(CONE_OF_COLD_1, diff) || IsSpellReady(DRAGON_BREATH_1, diff) && Rand() < 65))
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 8); //both are radius 10 yd
+                //Cone of Cold
+                if (IsSpellReady(CONE_OF_COLD_1, diff) && targets.size() > 0)
+                {
+                    if (doCast(me, GetSpell(CONE_OF_COLD_1)))
+                    {
+                        //GetInPosition(true); //causes silly misses due to bot turning around during cast phase
+                        return;
+                    }
+                }
+                //Dragon's Breath
+                else if (IsSpellReady(DRAGON_BREATH_1, diff) && targets.size() > 0)
+                {
+                    if (doCast(me, GetSpell(DRAGON_BREATH_1)))
+                        return;
+                }
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_FROST|SPELL_SCHOOL_MASK_FIRE))
+                return;
+
+            //spell reflections
+            //TODO: low-level fire blast maybe?
+            if (IsSpellReady(ICE_LANCE_1, diff) && dist < 30 && CanRemoveReflectSpells(opponent, ICE_LANCE_1) &&
+                doCast(opponent, ICE_LANCE_1))
+                return;
+
+            //Pyroblast TODO: PoM
+            if (IsSpellReady(PYROBLAST_1, diff) &&
+                dist < 35/* && Rand() < 75*/ && ((opponent->IsPolymorphed() &&
+                (b_attackers.size() < 2 || (*b_attackers.begin()) == opponent)) || me->HasAura(HOT_STREAK_BUFF)))
+            {
+                if (doCast(opponent, GetSpell(PYROBLAST_1)))
+                    return;
+            }
+            //Living Bomb
+            if (fbCasted && IsSpellReady(LIVING_BOMB_1, diff) && dist < 35 &&
+                opponent->GetHealth() > me->GetHealth() / 2 * opponent->getAttackers().size() &&
+                Rand() < 25 && !opponent->HasAura(GetSpell(LIVING_BOMB_1), me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(LIVING_BOMB_1)))
+                    return;
+            }
+            //Fire Blast (do not waste mana in raids)
+            if (IsSpellReady(FIRE_BLAST_1, diff) && dist < 20 && opponent->GetHealth() < me->GetMaxHealth()*4 &&
+                (fbCasted || opponent->GetHealth() < me->GetMaxHealth() / 4) &&
+                Rand() < (30 + 40*fbCasted + 80*(!opponent->isFrozen() && !opponent->HasUnitState(UNIT_STATE_STUNNED) && me->HasAura(IMPACT_BUFF))))
+            {
+                if (doCast(opponent, GetSpell(FIRE_BLAST_1)))
+                    return;
+            }
+            //Deep Freeze (damage only)
+            if (fbCasted && IsSpellReady(DEEP_FREEZE_1, diff) && dist < 30 && Rand() < 30 &&
+                opponent->IsImmunedToSpellEffect(sSpellMgr->GetSpellInfo(DEEP_FREEZE_1), 0) && (opponent->isFrozen() || me->HasAura(FINGERS_OF_FROST_BUFF)))
+            {
+                if (doCast(opponent, GetSpell(DEEP_FREEZE_1)))
+                    return;
+            }
+            //Flamestrike (instant cast only)
+            if (/*fbCasted && */IsSpellReady(FLAMESTRIKE_1, diff) && dist < 30 && Rand() < 80 && me->HasAura(FIRESTARTER_BUFF))
+            {
+                if (doCast(opponent, GetSpell(FLAMESTRIKE_1)))
+                    return;
+            }
+            //Fireball or Frostfire Bolt (instant cast or combustion use up)
+            if (/*fbCasted && */IsSpellReady(FROSTFIREBOLT, diff) && dist < 30 && Rand() < 120 &&
+                ((((CCed(opponent, true) || b_attackers.empty()) && me->HasAura(COMBUSTION_BUFF)) || me->HasAura(BRAIN_FREEZE_BUFF)) ||
+                !GetSpell(FROSTBOLT_1))) //level 1-3
+            {
+                if (doCast(opponent, GetSpell(FROSTFIREBOLT)))
+                    return;
+            }
+            //Ice Lance (no cd, only GCD)
+            if (fbCasted && /*IsSpellReady(ICE_LANCE_1, diff) && */dist < 30 &&
+                Rand() < 80*(opponent->isFrozen() || me->HasAura(FINGERS_OF_FROST_BUFF)))
+            {
+                if (doCast(opponent, GetSpell(ICE_LANCE_1)))
+                    return;
+            }
+            //Blizzard
+            if (IsSpellReady(BLIZZARD_1, diff) && !JumpingOrFalling() && Rand() < 50)
+            {
+                if (Unit* blizztarget = FindAOETarget(30, true))
+                {
+                    if (doCast(blizztarget, GetSpell(BLIZZARD_1)))
+                        return;
+                }
+
+                SetSpellCooldown(BLIZZARD_1, 1500); //fail
+            }
+            //Arcane Missiles (special condition for BWL)
+            if (IsSpellReady(ARCANEMISSILES_1, diff) && dist < 30 &&
+                ((opponent->GetTypeId() == TYPEID_UNIT && opponent->GetEntry() == CREATURE_ENTRY_CHROMAGGUS) || (b_attackers.empty() && Rand() < 3)))
+            {
+                if (doCast(opponent, GetSpell(ARCANEMISSILES_1)))
+                    return;
+            }
+            //Frostbolt (default attack spell)
+            if (IsSpellReady(FROSTBOLT_1, diff) && dist < 30)
+            {
+                if (doCast(opponent, GetSpell(FROSTBOLT_1)))
+                    return;
+            }
+        }
+
+        void CheckPoly(uint32 diff)
+        {
+            if (polyCheckTimer <= diff)
+            {
+                poly = FindAffectedTarget(GetSpell(POLYMORPH_1), me->GetGUID());
+                polyCheckTimer = 2000;
+            }
+        }
+
+        void CheckPolymorph(uint32 diff)
+        {
+            if (poly == false && IsSpellReady(POLYMORPH_1, diff) && !IsCasting())
+            {
+                if (Unit* target = FindPolyTarget(30))
+                {
+                    if (doCast(target, GetSpell(POLYMORPH_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckPots(uint32 diff)
+        {
+            if (me->IsMounted() || IsCasting())
+                return;
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+            if (GetManaPCT(me) < 35 && Rand() < 35)
+            {
+                if (IsSpellReady(EVOCATION_1, diff) && uint8(me->getAttackers().size()) < (shielded ? 3 : 1))
+                {
+                    if (doCast(me, GetSpell(EVOCATION_1)))
+                        return;
+                }
+                if (manaGemCharges > 0 && IsSpellReady(MANA_GEM_1, diff, false))
+                {
+                    if (doCast(me, GetSpell(MANA_GEM_1)))
+                        return;
+                }
+                if (IsPotionReady())
+                    DrinkPotion(true);
+            }
+        }
+
+        void CheckBlink(uint32 diff)
+        {
+            if (GetBotCommandState() == COMMAND_STAY || me->IsMounted())
+                return;
+            if (!IsSpellReady(BLINK_1, diff) || IsCasting() || Rand() > 70)
+                return;
+
+            if (!IAmFree())
+            {
+                if (!me->IsInCombat() && me->GetExactDist2d(master) > std::max<uint8>(master->GetBotFollowDist(), 35) &&
+                    me->HasInArc(M_PI*0.67f, master))
+                {
+                    if (doCast(me, GetSpell(BLINK_1)))
+                        return;
+                }
+                //if (!me->getAttackers().empty() && me->GetExactDist2d(master) > 15)
+                //{
+                //    if (Unit const* op = me->SelectNearestTarget(7))
+                //    {
+                //        if (op->GetVictim() == me)
+                //        {
+                //            me->SetFacingTo(me->GetAngle(master));
+                //            if (doCast(me, GetSpell(BLINK_1)))
+                //                return;
+                //        }
+                //    }
+                //}
+            }
+            if (me->IsInCombat() && !me->getAttackers().empty() && HasRole(BOT_ROLE_RANGED))
+            {
+                bool cast = me->HasAuraWithMechanic((1<<MECHANIC_STUN)|(1<<MECHANIC_ROOT));
+                Unit* u = NULL;
+                if (!cast)
+                {
+                    u = me->SelectNearestTarget(7);
+                    cast = (u && u->GetVictim() == me && u->IsWithinLOSInMap(me));
+                }
+                if (!cast)
+                {
+                    u = (*me->getAttackers().begin());
+                    cast = (u && (!CCed(u, true) || me->getAttackers().size() > 1) && u->GetDistance(me) < 5.f &&
+                        u->IsWithinLOSInMap(me));
+                }
+                if (cast)
+                {
+                    if (u)
+                    {
+                        //turn away from target
+                        me->AttackStop();
+                        //me->SetFacingTo(me->GetAngle(u) + M_PI);
+                        me->SetOrientation(me->GetAngle(u) + M_PI);
+                    }
+                    if (doCast(me, GetSpell(BLINK_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckFocusMagic(uint32 diff)
+        {
+            if (fmCheckTimer > diff || GC_Timer > diff || IAmFree() || me->getLevel() < 20 || IsCasting() || Rand() > 50)
+                return;
+
+            uint32 FOCUSMAGIC = GetSpell(FOCUS_MAGIC_1);
+            if (!FOCUSMAGIC)
+                return;
+
+            if (Unit* target = FindAffectedTarget(FOCUSMAGIC, me->GetGUID(), 70, 3))
+            {
+                fmCheckTimer = 15000;
+                return;
+            }
+            else
+            {
+                Group* pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (master->getPowerType() == POWER_MANA && me->GetExactDist(master) < 30 &&
+                        !master->HasAura(FOCUSMAGIC))
+                        target = master;
+                }
+                else
+                {
+                    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->IsAlive()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (pPlayer->getPowerType() == POWER_MANA && me->GetExactDist(pPlayer) < 30 &&
+                            !pPlayer->HasAura(FOCUSMAGIC))
+                        {
+                            target = pPlayer;
+                            break;
+                        }
+                    }
+                    //damaging bots
+                    if (!target)
+                    {
+                        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                            {
+                                Creature* cre = it->second;
+                                if (!cre || !cre->IsInWorld() || cre == me || !cre->IsAlive() ||
+                                    cre->getPowerType() != POWER_MANA || cre->GetBotAI()->HasRole(BOT_ROLE_TANK) ||
+                                    cre->GetBotClass() == BOT_CLASS_BM || cre->GetBotClass() == BOT_CLASS_HUNTER) continue;
+                                if (cre->GetBotAI()->HasRole(BOT_ROLE_DPS) && me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(FOCUSMAGIC))
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    //any bot
+                    if (!target)
+                    {
+                        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                            {
+                                Creature* cre = it->second;
+                                if (!cre || !cre->IsInWorld() || cre == me || !cre->IsAlive() ||
+                                    cre->getPowerType() != POWER_MANA || cre->GetBotAI()->HasRole(BOT_ROLE_TANK) ||
+                                    cre->GetBotClass() == BOT_CLASS_BM || cre->GetBotClass() == BOT_CLASS_HUNTER) continue;
+                                if (me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(FOCUSMAGIC))
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (target && doCast(target, FOCUSMAGIC))
+                {
+                    fmCheckTimer = 30000;
+                    return;
+                }
+            }
+
+            fmCheckTimer = 5000; //fail
+        }
+
+        void CheckIceBlock(uint32 diff)
+        {
+            if (GC_Timer > diff || !GetSpell(ICE_BLOCK_1) || Rand() > 60)
+                return;
+
+            if (iceblockCheckTimer <= diff)
+            {
+                if (me->getAttackers().empty() && (!me->IsInCombat() || (GetManaPCT(me) > 45 && GetHealthPCT(me) > 80)))
+                {
+                    me->RemoveAurasDueToSpell(GetSpell(ICE_BLOCK_1));
+                    return;
+                }
+                iceblockCheckTimer = std::numeric_limits<uint32>::max();
+            }
+
+            if (!IsSpellReady(ICE_BLOCK_1, diff))
+                return;
+
+            if (me->IsInCombat() && !me->getAttackers().empty() &&
+                (CCed(me, true) || me->getAttackers().size() > 2 || GetHealthPCT(me) < 40))
+            {
+                if (doCast(me, GetSpell(ICE_BLOCK_1)))
+                    return;
+            }
+        }
+
+        void CheckShield(uint32 diff)
+        {
+            //TODO: Mana Shield
+            if (!GetSpell(ICE_BARRIER_1))
+                return;
+
+            if (shieldCheckTimer <= diff)
+            {
+                shieldCheckTimer = 1500;
+                shielded = me->HasAura(GetSpell(ICE_BARRIER_1));
+            }
+
+            if (shielded || !IsSpellReady(ICE_BARRIER_1, diff) || IsCasting())
+                return;
+
+            if ((me->IsInCombat() && me->GetMap()->Instanceable()) ||
+                !me->getAttackers().empty() || GetHealthPCT(me) < 90)
+            {
+                if (doCast(me, GetSpell(ICE_BARRIER_1)))
+                    return;
+            }
+        }
+
+        void CheckWard(uint32 diff)
+        {
+            if ((!me->IsInCombat() && !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                !IsSpellReady(FROST_WARD_1, diff) || IsCasting())
+                return;
+
+            uint32 FROSTWARD = canFrostWard ? GetSpell(FROST_WARD_1) : 0;
+            uint32 FIREWARD = canFireWard ? GetSpell(FIRE_WARD_1) : 0;
+
+            if (FIREWARD && doCast(me, FIREWARD))
+                return;
+
+            if (FROSTWARD && doCast(me, FROSTWARD))
+                return;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+
+            //Shatter
+            //SHATTER IS HANDLED IN Unit::isSpCrit()
+
+            //Arcane Potency: 15%/30% additional crit chance for All spells
+            if (me->HasAura(ARCANE_POTENCY_BUFF2))
+                crit_chance += 30.f;
+            else if (me->HasAura(ARCANE_POTENCY_BUFF1))
+                crit_chance += 15.f;
+
+            //Combustion: 10% additional critical chance for fire spells per stack
+            if (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask())
+                if (Aura* combustion = me->GetAura(COMBUSTION_BUFF))
+                    crit_chance += float(combustion->GetStackAmount() * 10);
+            //Winter's chill part 1: 3% additional crit chance for Frostbolt
+            if (lvl >= 25 && spellId == GetSpell(FROSTBOLT_1))
+                crit_chance += 3.f;
+            //Incineration: 6% additional crit chance for Fire Blast, Scorch, Arcane Blast and Cone of Cold
+            if (lvl >= 10 &&
+                (spellId == GetSpell(FIRE_BLAST_1) || /*spellId == GetSpell(SCORCH_1) ||
+                spellId == GetSpell(ARCANE_BLAST_1) || */spellId == GetSpell(CONE_OF_COLD_1)))
+                crit_chance += 6.f;
+            //World In Flames: 6% additional critical chance for
+            //Flamestrike, Pyroblast, Blast Wave, Dragon's Breath, Living Bomb, Blizzard and Arcane Explosion
+            if (lvl >= 15 &&
+                (spellId == GetSpell(FLAMESTRIKE_1) || spellId == GetSpell(PYROBLAST_1) ||
+                spellId == GetSpell(BLAST_WAVE_1) || spellId == GetSpell(DRAGON_BREATH_1) ||
+                spellId == GetSpell(BLIZZARD_DAMAGE_1)/* || spellId == ARCANEXPLOSION*/ ||
+                spellId == GetSpell(LIVING_BOMB_1) || spellId == GetSpell(LIVING_BOMB_DAMAGE_1)))
+                crit_chance += 6.f;
+            //Critical Mass: 6% additional critical chance for Fire spells
+            if (lvl >= 30 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                crit_chance += 6.f;
+            //Pyromaniac part 1: 6% additional critical chance for All spells
+            if (lvl >= 40)
+                crit_chance += 3.f;
+            //Glyph of Frostfire Bolt part 2: 2% additional critical chance for Frostfire Bolt
+            if (lvl >= 75 && spellId == GetSpell(FROSTFIRE_BOLT_1))
+                crit_chance += 2.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Burnout: 50% additional crit damage bonus for All spells
+                //well it's gonna be a little too much eh? skipped
+                //Spell Power: 50% additional crit damage bonus for All spells
+                if (lvl >= 55)
+                    pctbonus += 0.333f;
+                //Ice Shards: 50% additional crit damage bonus for Frost spells
+                if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                    pctbonus += 0.333f;
+                //Combustion: 50% additional crit damage bonus for Fire spells
+                if ((SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()) &&
+                    me->HasAura(GetSpell(COMBUSTION_1)))
+                    pctbonus += 0.333f;
+            }
+            //Improved Cone of Cold: 35% bonus damage for Cone of Cold
+            if (lvl >= 30 && spellId == GetSpell(CONE_OF_COLD_1))
+                pctbonus += 0.35f;
+            //Fire Power: 10% bonus damage for Fire spells
+            if (lvl >= 35 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                pctbonus += 0.1f;
+            //Piercing Ice: 6% bonus damage for Frost spells
+            if (lvl >= 20 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                pctbonus += 0.06f;
+            //Arctic Winds: 5% bonus damage for Frost spells
+            if (lvl >= 30 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                pctbonus += 0.05f;
+            //Chilled to the Bone part 1: 5% bonus damage for Frostbolt, Frostfire Bolt and Ice Lance
+            if (lvl >= 30 &&
+                (spellId == GetSpell(FROSTBOLT_1) ||
+                spellId == GetSpell(FROSTFIRE_BOLT_1) ||
+                spellId == GetSpell(ICE_LANCE_1)))
+                pctbonus += 0.05f;
+            //Molten Fury: 12% bonus damage for All spells against target with less than 35% hp
+            if (lvl >= 40 && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT)) //safe
+                pctbonus += 0.12f;
+            //Spell Impact: 6% bonus damage for Arcne Explosion, Arcane Blast, Scorch, Fireball, Ice Lance and Cone of Cold
+            if (lvl >= 20 &&
+                (/*spellId == GetSpell(ARCANE_EXPLOSION_1) || spellId == GetSpell(ARCANE_BLAST_1) ||
+                spellId == GetSpell(SCORCH_1) || */spellId == GetSpell(FIREBALL_1) ||
+                spellId == GetSpell(ICE_LANCE_1) || spellId == GetSpell(CONE_OF_COLD_1)))
+                pctbonus += 0.06f;
+            //Glyph of Frostfire Bolt part 1: 2% bonus damage for Frostfire Bolt
+            if (lvl >= 75 && spellId == GetSpell(FROSTFIRE_BOLT_1))
+                pctbonus += 0.02f;
+
+            //flat mods
+            //Empowered Frostbolt part 1: 10% of spellpower to Frostbolt damage
+            if (lvl >= 45 && spellId == GetSpell(FROSTBOLT_1))
+                fdamage += 0.1f * float(GetBotSpellPower());
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+        {
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Firestarter part 2: -100% mana cost for Flamestrike
+            if (spellId == GetSpell(FLAMESTRIKE_1))
+                if (me->HasAura(FIRESTARTER_BUFF))
+                    pctbonus += 1.0f;
+            //Brain Freeze buff: -100% mana cost for Fireball and Frostfire Bolt while active
+            //we can check spellFamilyFlags or just use ids, going easy way here
+            if (spellId == GetSpell(FROSTFIRE_BOLT_1) || spellId == GetSpell(FIREBALL_1))
+                if (me->HasAura(BRAIN_FREEZE_BUFF))
+                    pctbonus += 1.0f;
+            //Clearcasting: -100% mana cost for damaging spells
+            if (AuraEffect const* eff = me->GetAuraEffect(ARCANE_CONCENTRATION_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+
+            //pct mods
+            //Frost Channeling: -10% mana cost for frost spells
+            if (lvl >= 25 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                pctbonus += 0.1f;
+            //Precision part 1: -3% mana cost for All spells
+            if (lvl >= 15)
+                pctbonus += 0.03f;
+            //Improved Blink part 1: -50% mana cost for Blink
+            if (lvl >= 30 && spellId == GetSpell(BLINK_1))
+                pctbonus += 0.5f;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+        {
+            //casttime is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Firestarter part 1: -100% cast time for Flamestrike
+            if (spellId == GetSpell(FLAMESTRIKE_1))
+                if (me->HasAura(FIRESTARTER_BUFF))
+                    timebonus += casttime;
+            //Brain Freeze: -100% cast time for Fireball of Frostfire Bolt
+            //we can check spellFamilyFlags or just use ids, going easy way here
+            if (spellId == GetSpell(FROSTFIRE_BOLT_1) || spellId == GetSpell(FIREBALL_1))
+                if (me->HasAura(BRAIN_FREEZE_BUFF))
+                    timebonus += casttime;
+            //Hot Streak: -100% cast time for Pyroblast
+            if (spellId == GetSpell(PYROBLAST_1))
+                if (me->HasAura(HOT_STREAK_BUFF))
+                    timebonus += casttime;
+
+            //flat mods
+            //Improved Frostbolt: -0.5 sec cast time for Frostbolt
+            if (lvl >= 10 && spellId == GetSpell(FROSTBOLT_1))
+                timebonus += 500;
+            //Empowered Frostbolt part 2: -0.2 sec cast time for Frostbolt
+            if (lvl >= 45 && spellId == GetSpell(FROSTBOLT_1))
+                timebonus += 200;
+            //Improved Fireball: -0.5 sec cast time for Fireball
+            if (lvl >= 10 && spellId == GetSpell(FIREBALL_1))
+                timebonus += 500;
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Ice Floes: -20% cooldown for Frost Nova, Cone of Cold, Ice Block and Icy Veins
+            if (lvl >= 10 && (spellId == GetSpell(FROST_NOVA_1) || spellId == GetSpell(CONE_OF_COLD_1) ||
+                spellId == GetSpell(ICE_BLOCK_1) || spellId == GetSpell(ICY_VEINS_1)))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Improved Fire Blast: -2 sec cooldown for Fire Blast
+            if (lvl >= 10 && spellId == GetSpell(FIRE_BLAST_1))
+                timebonus += 2000;
+            //Arcane Flows part 2: -2 min cooldown for Evocation
+            if (lvl >= 45 && spellId == GetSpell(EVOCATION_1))
+                timebonus += 120000;
+
+            ////Pyroblast (special): ensure no double pyroblast casts
+            //if (spellId == GetSpell(PYROBLAST_1))
+            //    timebonus -= 3000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Increased Area (AhnQ set bonus?) 23549
+            if (lvl >= 60 && (spellInfo->SpellFamilyFlags[0] & 0x1084))
+                pctbonus += 0.25f;
+            //Arctic Reach
+            if (lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x240))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Blink
+            if (lvl >= 15 && baseId == BLINK_1)
+                flatbonus += 5.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo)
+        {
+            uint32 spellId = spellInfo->Id;
+
+            //DEBUG
+            //if (!IAmFree())
+            //{
+            //    std::ostringstream msg;
+            //    msg << "OnClassSpellGo: " << spellInfo->SpellName[0] << " (" << spellId << ")!";
+            //    BotWhisper(msg.str().c_str());
+            //}
+
+            //Mana gem conjure and use
+            if (spellId == GetSpell(CONJURE_MANA_GEM_1))
+            {
+                //ItemTemplate const* gem = sObjectMgr->GetItemTemplate(spellInfo->Effects[0].ItemType);
+                //ASSERT(gem);
+                //manaGemCharges = uint8(abs(gem->Spells[1].SpellCharges)); //at index 1
+
+                //Do not bother with this crap
+                manaGemCharges = 3;
+            }
+            if (spellId == GetSpell(MANA_GEM_1))
+            {
+                //spell cd is 1 min, item cd is 2 min, correct here
+                SetSpellCooldown(MANA_GEM_1, 120000);
+                manaGemCharges -= 1;
+            }
+
+            //special cases
+            //Pyroblast (special): ensure no double pyroblast casts
+            if (spellId == GetSpell(PYROBLAST_1))
+                SetSpellCooldown(PYROBLAST_1, 3000);
+
+            if (spellId == GetSpell(ICE_BLOCK_1))
+            {
+                //Glyph of Iceblock: reset Frost Nova cd
+                ResetSpellCooldown(FROST_NOVA_1);
+                iceblockCheckTimer = 4000;
+            }
+
+            //custom things
+            if (spellId == GetSpell(ICE_BARRIER_1))
+                shieldCheckTimer = 5000;
+
+            //check for minor rotation thingy (skip common triggered on-hit spells
+            /*if (spellId != FROSTBITE_TRIGGERED && spellId != WINTERS_CHILL_TRIGGERED && spellId != IGNITE_TRIGGERED &&
+                spellId != ARCANE_CONCENTRATION_BUFF && spellId != ARCANE_POTENCY_BUFF1 && spellId != ARCANE_POTENCY_BUFF2 &&
+                spellId != FIRESTARTER_BUFF && spellId != BRAIN_FREEZE_BUFF && spellId != HOT_STREAK_BUFF)*/
+                fbCasted = (spellId == GetSpell(FROSTBOLT_1) || spellId == GetSpell(FROSTFIRE_BOLT_1));
+
+            //Handle clearcasting
+            if (AuraEffect const* eff = me->GetAuraEffect(ARCANE_CONCENTRATION_BUFF, 0, me->GetGUID()))
+            {
+                if (eff->IsAffectedOnSpell(spellInfo))
+                {
+                    //if (int32 cost = spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+                    {
+                        //me->ModifyPower(POWER_MANA, cost > 0 ? cost : 0);
+                        me->RemoveAurasDueToSpell(ARCANE_CONCENTRATION_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+                    }
+                    //arcane potency has the same affection (damaging spells only)
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF1, 0, 0, AURA_REMOVE_BY_EXPIRE);
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF2, 0, 0, AURA_REMOVE_BY_EXPIRE);
+                }
+            }
+            //Firestarter
+            if (spellId == GetSpell(FLAMESTRIKE_1)/* && me->HasAura(FIRESTARTER_BUFF)*/)
+            {
+                FIRESTARTER = false; // TODO:
+                me->RemoveAurasDueToSpell(FIRESTARTER_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+            //Brain Freeze (Fireball!)
+            if (spellId == GetSpell(FROSTFIRE_BOLT_1) || spellId == GetSpell(FIREBALL_1))
+            {
+                BRAINFREEZE = false; // TODO:
+                me->RemoveAurasDueToSpell(BRAIN_FREEZE_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+            //Hot Streak
+            if (spellId == GetSpell(PYROBLAST_1))
+            {
+                HOTSTREAK = false; // TODO:
+                me->RemoveAurasDueToSpell(HOT_STREAK_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+            //TODO: Presence of mind
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            if (aftercastTargetGuid != 0)
+            {
+                //only players for now
+                if (!IS_PLAYER_GUID(aftercastTargetGuid))
+                {
+                    aftercastTargetGuid = 0;
+                    return;
+                }
+
+                Player* pTarget = sObjectAccessor->FindPlayer(aftercastTargetGuid);
+                aftercastTargetGuid = 0;
+
+                if (!pTarget/* || me->GetDistance(pTarget) > 15*/)
+                    return;
+
+                //handle effects
+                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                {
+                    switch (spell->Effects[i].Effect)
+                    {
+                        case SPELL_EFFECT_CREATE_ITEM:
+                        case SPELL_EFFECT_CREATE_ITEM_2:
+                        {
+                            uint32 newitemid = spell->Effects[i].ItemType;
+                            if (newitemid)
+                            {
+                                ItemPosCountVec dest;
+                                ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(newitemid);
+                                if (!pProto)
+                                    return;
+                                uint32 count = pProto->GetMaxStackSize();
+                                uint32 no_space = 0;
+                                InventoryResult msg = pTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, count, &no_space);
+                                if (msg != EQUIP_ERR_OK)
+                                {
+                                    if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
+                                        count -= no_space;
+                                    else
+                                    {
+                                        // if not created by another reason from full inventory or unique items amount limitation
+                                        pTarget->SendEquipError(msg, NULL, NULL, newitemid);
+                                        continue;
+                                    }
+                                }
+                                if (count)
+                                {
+                                    Item* pItem = pTarget->StoreNewItem(dest, newitemid, true, 0);
+                                    if (!pItem)
+                                    {
+                                        pTarget->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+                                        continue;
+                                    }
+                                    //unsafe possible
+                                    pItem->SetUInt32Value(ITEM_FIELD_CREATOR, me->GetGUIDLow());
+
+                                    pTarget->SendNewItem(pItem, count, true, false, true);
+                                }
+                            }
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+
+                return;
+            }
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            if (baseId == ARCANEINTELLECT_1)
+            {
+                if (Aura* arc = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    arc->SetDuration(dur);
+                    arc->SetMaxDuration(dur);
+                }
+            }
+
+            //Spells with chill effect
+            //chill amount by spell family mask
+            //00100000 00000000 00000000 chilled (blizzard)
+            //00000200 00000000 00000000 conecold
+            //00000020 00000000 00000000 frbolt
+            //00000000 00001000 00000008 ffbolt
+            //00100220 00001000 00000000 permafrst
+            //00100220 00001000 00000000 cttbn
+            if (spell->SpellFamilyName == SPELLFAMILY_MAGE &&
+                ((spell->SpellFamilyFlags[0] & 0x100220) || (spell->SpellFamilyFlags[1] & 0x1000)))
+            {
+                //frostbolt, cone of cold, blizzard chill, frostfire bolt
+                Aura* chill = target->GetAura(spellId, me->GetGUID());
+                if (chill)
+                {
+                    //Permafrost: chill effects duration + 3 sec
+                    if (me->getLevel() >= 15)
+                    {
+                        uint32 dur = chill->GetDuration() + 3000;
+                        chill->SetDuration(dur);
+                        chill->SetMaxDuration(dur);
+                    }
+                    //chill effect is at index 0
+                    AuraEffect* chillEff = chill->GetEffect(0);
+                    if (chillEff)
+                    {
+                        int32 amount = chillEff->GetAmount();
+                        if (me->getLevel() >= 15)
+                            amount -= 10; //permafrost
+                        if (me->getLevel() >= 60)
+                            amount -= 10; //chilled to the bone
+                        chillEff->ChangeAmount(amount);
+                    }
+                }
+            }
+
+            //Custom things
+            if (spellId == GetSpell(POLYMORPH_1))
+            {
+                poly = true;
+                polyCheckTimer = 2000;
+            }
+
+            //Winter Veil addition
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+            {
+                if (SPELL_SCHOOL_MASK_FROST & spell->GetSchoolMask())
+                    me->AddAura(44755, target); //snowflakes
+
+                if (spellId == GetSpell(FROSTBOLT_1) && urand(1,100) <= 10)
+                    me->CastSpell(target, 25686, true); //10% super snowball
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Ward helper
+            if (!canFrostWard && !spell->IsPositive() && (spell->GetSchoolMask() & SPELL_SCHOOL_MASK_FROST))
+                canFrostWard = true;
+            if (!canFireWard && !spell->IsPositive() && (spell->GetSchoolMask() & SPELL_SCHOOL_MASK_FIRE))
+                canFireWard = true;
+
+            switch (spellId)
+            {
+                case FIRESTARTER_BUFF:
+                    FIRESTARTER = true; //TODO
+                    break;
+                case BRAIN_FREEZE_BUFF:
+                    BRAINFREEZE = true;
+                    break;
+                case HOT_STREAK_BUFF:
+                    HOTSTREAK = true;
+                    break;
+                default:
+                    break;
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            polyCheckTimer = 0;
+            fmCheckTimer = 0;
+            iceblockCheckTimer = 0;
+            shieldCheckTimer = 0;
+            manaGemCharges = 0;
+
+            poly = false;
+            shielded = false;
+            fbCasted = false;
+
+            FIRESTARTER = false;
+            BRAINFREEZE = false;
+            HOTSTREAK = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (polyCheckTimer > diff)              polyCheckTimer -= diff;
+            if (fmCheckTimer > diff)                fmCheckTimer -= diff;
+            if (iceblockCheckTimer > diff)          iceblockCheckTimer -= diff;
+            if (shieldCheckTimer > diff)            shieldCheckTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(DAMPENMAGIC_1);
+            InitSpellMap(AMPLIFYMAGIC_1);
+            InitSpellMap(ARCANEINTELLECT_1);
+            InitSpellMap(ARCANEMISSILES_1);
+            InitSpellMap(POLYMORPH_1);
+            InitSpellMap(COUNTERSPELL_1);
+            InitSpellMap(SPELLSTEAL_1);
+            InitSpellMap(EVOCATION_1);
+            InitSpellMap(BLINK_1);
+            InitSpellMap(REMOVE_CURSE_1);
+            InitSpellMap(INVISIBILITY_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(BLAST_WAVE_1) : RemoveSpell(BLAST_WAVE_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(DRAGON_BREATH_1) : RemoveSpell(DRAGON_BREATH_1);
+            InitSpellMap(FIRE_BLAST_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(PYROBLAST_1) : RemoveSpell(PYROBLAST_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(LIVING_BOMB_1) : RemoveSpell(LIVING_BOMB_1);
+            InitSpellMap(FLAMESTRIKE_1);
+            InitSpellMap(DAMPENMAGIC_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(COMBUSTION_1) : RemoveSpell(COMBUSTION_1);
+            InitSpellMap(FROSTBOLT_1);
+            InitSpellMap(FROST_NOVA_1);
+            InitSpellMap(CONE_OF_COLD_1);
+            InitSpellMap(BLIZZARD_1);
+            InitSpellMap(FROST_ARMOR_1);
+            InitSpellMap(ICE_ARMOR_1);
+            InitSpellMap(MOLTEN_ARMOR_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(ICE_BARRIER_1) : RemoveSpell(ICE_BARRIER_1);
+            InitSpellMap(ICE_BLOCK_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(FOCUS_MAGIC_1) : RemoveSpell(FOCUS_MAGIC_1);
+ /*Special*/InitSpellMap(BLIZZARD_DAMAGE_1); //important
+ /*Special*/InitSpellMap(LIVING_BOMB_DAMAGE_1); //important
+            InitSpellMap(SLOW_FALL_1);
+            InitSpellMap(ICE_LANCE_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(ICY_VEINS_1) : RemoveSpell(ICY_VEINS_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(DEEP_FREEZE_1) : RemoveSpell(DEEP_FREEZE_1);
+            InitSpellMap(FROST_WARD_1);
+            InitSpellMap(FIRE_WARD_1);
+
+ /*Special*/InitSpellMap(CONJURE_MANA_GEM_1);
+ /*Special*/InitSpellMap(MANA_GEM_1);
+
+            FROSTFIREBOLT = InitSpell(me, FROSTFIRE_BOLT_1) ? FROSTFIRE_BOLT_1 : FIREBALL_1;
+            RemoveSpell(FIREBALL_1);
+            RemoveSpell(FROSTFIRE_BOLT_1);
+            InitSpellMap(FROSTFIREBOLT);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(ARCTIC_WINDS, level >= 45 ? 2 : 0); //only miss chance
+            RefreshAura(WINTERS_CHILL3, level >= 30 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL2, level >= 25 && level < 30 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL1, level >= 20 && level < 25 ? 1 : 0);
+            RefreshAura(IMPROVED_BLIZZARD, level >= 45 ? 1 : 0);
+            RefreshAura(FROSTBITE3, level >= 60 ? 2 : level >= 20 ? 1 : 0);
+            RefreshAura(FROSTBITE2, level >= 15 && level < 20 ? 1 : 0);
+            RefreshAura(FROSTBITE1, level >= 10 && level < 15 ? 1 : 0);
+            RefreshAura(SHATTERED_BARRIER, level >= 45 ? 1 : 0);
+            //RefreshAura(ARCANE_INSTABILITY, level >= 65 ? 4 : level >= 55 ? 3 : level >= 45 ? 2 : level >= 35 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION3, level >= 50 ? 1 : 0); //confirmed working
+            RefreshAura(INCANTERS_ABSORPTION2, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION1, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(SHATTER3, level >= 35 ? 1 : 0);
+            RefreshAura(SHATTER2, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(SHATTER1, level >= 25 && level < 30 ? 1 : 0);
+            RefreshAura(ARCANE_CONCENTRATION, level >= 75 ? 3 : level >= 40 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(FINGERS_OF_FROST, level >= 45 ? 1 : 0);
+            RefreshAura(ARCANE_POTENCY2, level >= 40 ? 1 : 0);
+            RefreshAura(ARCANE_POTENCY1, level >= 35 && level < 40 ? 1 : 0);
+            RefreshAura(IGNITE, level >= 15 ? 1 : 0);
+            RefreshAura(IMPACT, level >= 60 ? 2 : level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_COUNTERSPELL2, level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_COUNTERSPELL1, level >= 25 && level < 35 ? 1 : 0);
+            RefreshAura(FIRESTARTER2, level >= 55 ? 1 : 0);
+            RefreshAura(FIRESTARTER1, level >= 45 && level < 55 ? 1 : 0);
+            RefreshAura(BRAIN_FREEZE3, level >= 65 ? 1 : 0);
+            RefreshAura(BRAIN_FREEZE2, level >= 55 && level < 65 ? 1 : 0);
+            RefreshAura(BRAIN_FREEZE1, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(HOT_STREAK, level >= 50 ? 1 : 0);
+            RefreshAura(ARCANE_EMPOWERMENT, level >= 40 ? 1 : 0);
+            RefreshAura(ARCANE_MEDITATION, level >= 25 ? 1 : 0); //mana regen 1
+            RefreshAura(PYROMANIAC, level >= 40 ? 1 : 0); //mana regen 2
+            RefreshAura(FROST_WARDING, level >= 60 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(MOLTEN_SHIELDS, level >= 70 ? 2 : level >= 25 ? 1 : 0);
+            RefreshAura(STUDENT_OF_THE_MIND, level >= 80 ? 3 : level >= 60 ? 2 : level >= 20 ? 1 : 0);
+            RefreshAura(GLYPH_LIVING_BOMB, GetSpell(LIVING_BOMB_1) ? 1 : 0);
+            RefreshAura(GLYPH_ICE_LANCE, GetSpell(ICE_LANCE_1) ? 1 : 0);
+            RefreshAura(GLYPH_ICY_VEINS, GetSpell(ICY_VEINS_1) ? 1 : 0);
+            RefreshAura(GLYPG_REMOVE_CURSE, GetSpell(REMOVE_CURSE_1) ? 1 : 0);
+            RefreshAura(GLYPH_POLYMORPH, GetSpell(POLYMORPH_1) ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case DAMPENMAGIC_1:
+                case AMPLIFYMAGIC_1:
+                case ARCANEINTELLECT_1:
+                case EVOCATION_1:
+                case REMOVE_CURSE_1:
+                case FOCUS_MAGIC_1:
+                case ICE_ARMOR_1:
+                case ICE_BARRIER_1:
+                case COMBUSTION_1:
+                case ICY_VEINS_1:
+                case BLAST_WAVE_1:
+                case FLAMESTRIKE_1:
+                case FROST_NOVA_1:
+                case BLIZZARD_1:
+                case ICE_BLOCK_1:
+                case INVISIBILITY_1:
+                case SLOW_FALL_1:
+                case CONJURE_MANA_GEM_1:
+                    return true;
+                case FROST_ARMOR_1:
+                    return !GetSpell(ICE_ARMOR_1);
+                //case MANA_GEM_1:
+                //    return manaGemCharges > 0;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Spells
+/*frst*/uint32 FROSTFIREBOLT;
+        //Timers
+/*exc.*/uint32 polyCheckTimer, fmCheckTimer, iceblockCheckTimer, shieldCheckTimer;
+        //Counters
+/*exc.*/uint8 manaGemCharges;
+        //Check
+/*exc.*/bool poly, shielded, fbCasted;
+/*exc.*/bool canFrostWard, canFireWard;
+/*exc.*/bool FIRESTARTER, BRAINFREEZE, HOTSTREAK;
+
+        enum MageBaseSpells
+        {
+            DAMPENMAGIC_1                       = 604,
+            AMPLIFYMAGIC_1                      = 1008,//manual use only
+            ARCANEINTELLECT_1                   = 1459,
+            ARCANEMISSILES_1                    = 5143,
+            POLYMORPH_1                         = 118,
+            COUNTERSPELL_1                      = 2139,
+            SPELLSTEAL_1                        = 30449,
+            EVOCATION_1                         = 12051,
+            BLINK_1                             = 1953,
+            REMOVE_CURSE_1                      = 475,
+            INVISIBILITY_1                      = 66,
+            BLAST_WAVE_1                        = 11113,
+            DRAGON_BREATH_1                     = 31661,
+            FIRE_BLAST_1                        = 2136,
+            PYROBLAST_1                         = 11366,
+            LIVING_BOMB_1                       = 44457,
+            FLAMESTRIKE_1                       = 2120,
+            COMBUSTION_1                        = 11129,
+            FROSTFIRE_BOLT_1                    = 44614,
+            FIREBALL_1                          = 133,
+            FROSTBOLT_1                         = 116,
+            FROST_NOVA_1                        = 122,
+            CONE_OF_COLD_1                      = 120,
+            BLIZZARD_1                          = 10,
+            FROST_ARMOR_1                       = 168,
+            ICE_ARMOR_1                         = 7302,
+            MOLTEN_ARMOR_1                      = 30482,
+            ICE_BARRIER_1                       = 11426,
+            ICE_BLOCK_1                         = 45438,
+            FOCUS_MAGIC_1                       = 54646,
+            SLOW_FALL_1                         = 130,
+            ICE_LANCE_1                         = 30455,
+            ICY_VEINS_1                         = 12472,
+            DEEP_FREEZE_1                       = 44572,
+            FROST_WARD_1                        = 6143,
+            FIRE_WARD_1                         = 543,
+            //Special
+            BLIZZARD_DAMAGE_1                   = 42208,
+            LIVING_BOMB_DAMAGE_1                = 44461,
+            CONJURE_MANA_GEM_1                  = 759,
+            MANA_GEM_1                          = 5405
+        };
+
+        enum MagePassives
+        {
+        //Talents
+            SHATTERED_BARRIER                   = 54787,//rank 2
+            ARCTIC_WINDS                        = 31678,//rank 5
+            WINTERS_CHILL1                      = 11180,
+            WINTERS_CHILL2                      = 28592,
+            WINTERS_CHILL3                      = 28593,
+            FROSTBITE1                          = 11071,
+            FROSTBITE2                          = 12496,
+            FROSTBITE3                          = 12497,
+            IMPROVED_BLIZZARD                   = 12488,//rank 3
+            ARCANE_CONCENTRATION                = 12577,//rank 5, clearcast
+            ARCANE_POTENCY1                     = 31571,
+            ARCANE_POTENCY2                     = 31572,
+            SHATTER1                            = 11170,
+            SHATTER2                            = 12982,
+            SHATTER3                            = 12983,
+            INCANTERS_ABSORPTION1               = 44394,
+            INCANTERS_ABSORPTION2               = 44395,
+            INCANTERS_ABSORPTION3               = 44396,
+            FINGERS_OF_FROST                    = 44545,//rank 2
+            //ARCANE_INSTABILITY                  = 15060,//rank 3
+            IMPROVED_COUNTERSPELL1              = 11255,
+            IMPROVED_COUNTERSPELL2              = 12598,
+            IGNITE                              = 12848,//rank 5
+            FIRESTARTER1                        = 44442,
+            FIRESTARTER2                        = 44443,
+            IMPACT                              = 12358,//rank 3
+            BRAIN_FREEZE1                       = 44546,
+            BRAIN_FREEZE2                       = 44548,
+            BRAIN_FREEZE3                       = 44549,
+            HOT_STREAK                          = 44448,//rank 3
+            ARCANE_EMPOWERMENT                  = 31583,//rank 3
+            ARCANE_MEDITATION                   = 18464,//rank 3
+            PYROMANIAC                          = 34296,//rank 3
+            FROST_WARDING                       = 28332,//rank 2
+            MOLTEN_SHIELDS                      = 13043,//rank 2
+            STUDENT_OF_THE_MIND                 = 44399,//rank 3
+            GLYPH_LIVING_BOMB                   = 63091,
+            GLYPH_ICE_LANCE                     = 56377,
+            GLYPH_ICY_VEINS                     = 56374,
+            GLYPG_REMOVE_CURSE                  = 56364,
+            GLYPH_POLYMORPH                     = 56375
+        };
+        enum MageSpecial
+        {
+            ARCANE_CONCENTRATION_BUFF           = 12536,
+            IMPACT_BUFF                         = 64343,
+            FIRESTARTER_BUFF                    = 54741,
+            ARCANE_POTENCY_BUFF1                = 57529,
+            ARCANE_POTENCY_BUFF2                = 57531,
+            COMBUSTION_BUFF                     = 28682,
+            BRAIN_FREEZE_BUFF                   = 57761,
+            HOT_STREAK_BUFF                     = 48108,
+            FINGERS_OF_FROST_BUFF               = 44544,
+            IMPROVED_BLIZZARD_CHILL             = 12486,//rank 3
+            FROSTBITE_TRIGGERED                 = 12494,
+            WINTERS_CHILL_TRIGGERED             = 12579,
+            IGNITE_TRIGGERED                    = 12654,
+            //creature
+            CREATURE_ENTRY_CHROMAGGUS           = 14020
+        };
+    };
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
new file mode 100644
index 0000000..b0b606d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
@@ -0,0 +1,2623 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+//#include "WorldSession.h"
+/*
+Paladin NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - Around 95%
+TODO:
+*/
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new paladin_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct paladin_botAI : public bot_minion_ai
+    {
+        paladin_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_PALADIN;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_PALADIN) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void CheckBeacon(uint32 diff)
+        {
+            if (checkBeaconTimer > diff || !IsSpellReady(BEACON_OF_LIGHT_1, diff) || IAmFree() || !master->GetGroup() ||
+                !HasRole(BOT_ROLE_HEAL|BOT_ROLE_RANGED) || IsCasting() || Rand() > 25)
+                return;
+
+            checkBeaconTimer = urand(2000, 5000);
+
+            if (FindAffectedTarget(GetSpell(BEACON_OF_LIGHT_1), me->GetGUID(), 60, 3))
+                return;
+
+            //find tank
+            //stacks
+            std::list<Unit*> tanks;
+            Group const* gr = master->GetGroup();
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || me->GetMap() != player->FindMap())
+                    continue;
+
+                if (player->IsAlive() && player->IsInCombat() && IsTank(player) &&
+                    (!player->getAttackers().empty() || GetHealthPCT(player) < 90) &&
+                    !player->GetAuraEffect(SPELL_AURA_PERIODIC_TRIGGER_SPELL, SPELLFAMILY_PALADIN, 0x0, 0x1000000, 0x0, me->GetGUID()))
+                    tanks.push_back(player);
+
+                if (!player->HaveBot())
+                    continue;
+
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    if (itr->second == me)
+                        continue;
+                    if (!gr->IsMember(itr->first))
+                        continue;
+
+                    Unit* u = itr->second;
+                    if (u->IsInWorld() && u->IsAlive() && u->IsInCombat() && IsTank(u) &&
+                        (!u->getAttackers().empty() || GetHealthPCT(u) < 90) &&
+                        !u->GetAuraEffect(SPELL_AURA_PERIODIC_TRIGGER_SPELL, SPELLFAMILY_PALADIN, 0x0, 0x1000000, 0x0, me->GetGUID()))
+                        tanks.push_back(u);
+                }
+            }
+
+            if (tanks.empty())
+                return;
+
+            Unit* target = tanks.size() == 1 ? *tanks.begin() : Trinity::Containers::SelectRandomContainerElement(tanks);
+            if (doCast(target, GetSpell(BEACON_OF_LIGHT_1)))
+                return;
+        }
+
+        void CheckSacrifice(uint32 diff)
+        {
+            if (!IsSpellReady(DIVINE_SACRIFICE_1, diff) || IAmFree() || me->IsMounted() ||
+                IsTank() || Feasting() || !CanBlock() || IsCasting() || Rand() > 25 || GetHealthPCT(me) < 50)
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                if (master->IsAlive() && GetHealthPCT(master) < 75 && me->GetDistance(master) < 30 && !master->getAttackers().empty() &&
+                    !master->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELLFAMILY_PALADIN, 3837, EFFECT_0))
+                {
+                    if (doCast(me, GetSpell(DIVINE_SACRIFICE_1)))
+                        return;
+                }
+            }
+            else
+            {
+                uint32 attacked = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player const* pl = itr->GetSource();
+                    if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap())
+                        continue;
+
+                    if (pl->IsAlive() && me->GetDistance(pl) < 30 && !pl->getAttackers().empty() &&
+                        !pl->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELLFAMILY_PALADIN, 3837, EFFECT_0))
+                    {
+                        if (++attacked > 3)
+                            break;
+                    }
+
+                    if (!pl->HaveBot())
+                        continue;
+
+                    BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature const* bot = it->second;
+                        if (bot && bot->IsInWorld() && me->GetMap() == bot->FindMap() && bot->IsAlive() &&
+                            !bot->IsTempBot() && me->GetDistance(bot) < 30 && !bot->getAttackers().empty() &&
+                            !bot->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELLFAMILY_PALADIN, 3837, EFFECT_0))
+                        {
+                            if (++attacked > 3)
+                                break;
+                        }
+                    }
+                }
+
+                if (attacked > 3 && doCast(me, GetSpell(DIVINE_SACRIFICE_1)))
+                    return;
+            }
+
+            SetSpellCooldown(DIVINE_SACRIFICE_1, 1000); //fail
+        }
+
+        void CheckHandOfSacrifice(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_SACRIFICE_1, diff) || IAmFree() || me->IsMounted() ||
+                IsTank() || Feasting() || !CanBlock() || IsCasting() || Rand() > 25 || GetHealthPCT(me) < 50)
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                if (master->IsAlive() && me->GetDistance(master) < 30 && !master->getAttackers().empty() &&
+                    (master->getAttackers().size() > 2 || GetHealthPCT(master) < 50) &&
+                    !master->GetAuraEffect(SPELL_AURA_SPLIT_DAMAGE_PCT, SPELLFAMILY_PALADIN, 0x2000, 0x0, 0x0))
+                {
+                    if (doCast(master, GetSpell(HAND_OF_SACRIFICE_1)))
+                        return;
+                }
+            }
+            else
+            {
+                Unit* u = NULL;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap())
+                        continue;
+
+                    if (pl->IsAlive() && me->GetDistance(pl) < 30 && !pl->getAttackers().empty() &&
+                        (pl->getAttackers().size() > 2 || GetHealthPCT(pl) < 50) &&
+                        !pl->GetAuraEffect(SPELL_AURA_SPLIT_DAMAGE_PCT, SPELLFAMILY_PALADIN, 0x2000, 0x0, 0x0))
+                    {
+                        u = pl;
+                        break;
+                    }
+
+                    if (!pl->HaveBot())
+                        continue;
+
+                    BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot->IsAlive() && me->GetDistance(bot) < 30 && !bot->getAttackers().empty() &&
+                            (bot->getAttackers().size() > 2 || GetHealthPCT(bot) < 50) &&
+                            !bot->GetAuraEffect(SPELL_AURA_SPLIT_DAMAGE_PCT, SPELLFAMILY_PALADIN, 0x2000, 0x0, 0x0))
+                        {
+                            u = bot;
+                            break;
+                        }
+                    }
+                }
+
+                if (u && doCast(u, GetSpell(HAND_OF_SACRIFICE_1)))
+                    return;
+            }
+
+            SetSpellCooldown(HAND_OF_SACRIFICE_1, 2000); //fail
+        }
+
+        void ShieldGroup(uint32 diff)
+        {
+            if (checkShieldTimer > diff || !IsSpellReady(SACRED_SHIELD_1, diff) ||
+                me->IsMounted() || Feasting() || IsCasting() || Rand() > 50)
+                return;
+
+            checkShieldTimer = 1500;
+
+            Unit* u;
+            if (IAmFree())
+            {
+                u = me;
+                if (u->IsInCombat() && (!u->getAttackers().empty() || u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) &&
+                    !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                {
+                    if (doCast(u, GetSpell(SACRED_SHIELD_1)))
+                    {}
+                }
+
+                return;
+            }
+
+            if (IsTank())
+            {
+                if (Rand() > 15)
+                    return;
+            }
+            else if (!HasRole(BOT_ROLE_HEAL) && Rand() > 10)
+                return;
+
+            if (FindAffectedTarget(GetSpell(SACRED_SHIELD_1), me->GetGUID(), 70, 3))
+                return;
+
+            bool foundTank = false;
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                u = master;
+                if (u->IsAlive() && u->IsInCombat() && IsTank(u) && me->GetDistance(u) < 30 &&
+                    !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                    foundTank = true;
+
+                if (!foundTank)
+                {
+                    BotMap const* map = master->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        u = itr->second;
+                        if (u != me && IsTank())
+                            continue;
+                        if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                            u->ToCreature()->IsTempBot() || !IsTank(u) || me->GetDistance(u) > 30 ||
+                            u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                            continue;
+
+                        foundTank = true;
+                        break;
+                    }
+                }
+                if (!foundTank)
+                {
+                    for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+                    {
+                        u = *itr;
+                        if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                            !IsTank(u) || me->GetDistance(u) > 30 ||
+                            u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                            continue;
+
+                        foundTank = true;
+                        break;
+                    }
+                }
+                if (!foundTank)
+                {
+                    u = master;
+                    if (u->IsAlive() && u->IsInCombat() && !u->getAttackers().empty() && me->GetDistance(u) < 30 &&
+                        !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                        foundTank = true;
+                }
+
+                if (foundTank && doCast(u, GetSpell(SACRED_SHIELD_1)))
+                    return;
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                    !IsTank(u) || me->GetDistance(u) > 30 ||
+                    u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                    continue;
+
+                foundTank = true;
+                break;
+            }
+            if (!foundTank)
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap())
+                        continue;
+
+                    if (pl->HaveBot())
+                    {
+                        BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            u = it->second;
+                            if (u != me && IsTank())
+                                continue;
+                            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                                it->second->IsTempBot() || !IsTank(u) || me->GetDistance(u) > 30 ||
+                                u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                                continue;
+
+                            foundTank = true;
+                            break;
+                        }
+                    }
+                    if (!foundTank)
+                    {
+                        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+                        {
+                            u = *itr;
+                            if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                                !IsTank(u) || me->GetDistance(u) > 30 ||
+                                u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                                continue;
+
+                            foundTank = true;
+                            break;
+                        }
+                    }
+                    if (foundTank)
+                        break;
+                }
+            }
+            if (!foundTank)
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    u = itr->GetSource();
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap())
+                        continue;
+
+                    if (u->IsAlive() && u->IsInCombat() && !u->getAttackers().empty() && me->GetDistance(u) < 30 &&
+                        !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                    {
+                        foundTank = true;
+                        break;
+                    }
+
+                    if (!u->ToPlayer()->HaveBot())
+                        continue;
+
+                    BotMap const* map = u->ToPlayer()->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        if (it->second->IsTempBot())
+                            continue;
+
+                        u = it->second;
+                        if (u->IsAlive() && u->IsInCombat() && !u->getAttackers().empty() && me->GetDistance(u) < 30 &&
+                            !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                        {
+                            foundTank = true;
+                            break;
+                        }
+                    }
+                    if (foundTank)
+                        break;
+                }
+            }
+
+            if (foundTank && doCast(u, GetSpell(SACRED_SHIELD_1)))
+                return;
+        }
+
+        void HOPGroup(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_PROTECTION_1, diff) || IAmFree() || me->IsMounted() || Feasting() || IsCasting() ||
+                Rand() > 30)
+                return;
+
+            Unit* u;
+            Player* player = master;
+            Group const* gr = player->GetGroup();
+            if (!gr)
+            {
+                u = player;
+                if (u->IsInWorld() && me->GetMap() == u->FindMap())
+                {
+                    if (HOPTarget(u, diff))
+                        return;
+                }
+
+                for (Unit::ControlList::const_iterator itr = player->m_Controlled.begin(); itr != player->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        u->isType(TYPEMASK_PLAYER) || !u->ToCreature()->IsNPCBot() || u->ToCreature()->IsTempBot() ||
+                        IsTank(u) || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOPTarget(u, diff))
+                        return;
+                }
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                    IsTank(u) || me->GetDistance(u) > 30)
+                    continue;
+                if (HOPTarget(u, diff))
+                    return;
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* pl = itr->GetSource();
+                if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap() || !pl->HaveBot())
+                    continue;
+
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    u = it->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        it->second->IsTempBot() || IsTank(u) || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOPTarget(u, diff))
+                        return;
+                }
+            }
+        }
+
+        bool HOPTarget(Unit* target, uint32 diff)
+        {
+            if (target == me ||
+                (target->GetTypeId() == TYPEID_PLAYER ? target->getClass() == BOT_CLASS_PALADIN :
+                target->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN))
+                return false; //paladins should use their own damn bubble
+            if (target->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 1) ||
+                target->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+                return false; //immune to physical (hop or smth is present)
+            if (target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 25))
+                return false; //forbearance
+            if (target->getAttackers().empty())
+                return false; //HOP only saves from physical, these aoe are rare and on bosses they are ultimate anyway
+
+            if (GetHealthPCT(target) < 15 + 5*(uint32)target->getAttackers().size())
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(HAND_OF_PROTECTION_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Hand of Protection on you!", target->ToPlayer());
+                    if (target != master)
+                    {
+                        std::ostringstream msg;
+                        msg << "Hand of Protection on " << target->GetName() << '!';
+                        BotWhisper(msg.str().c_str());
+                    }
+                }
+                return true;
+            }
+
+            return false;
+        }
+
+        void HOFGroup(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_FREEDOM_1, diff) || me->IsMounted() || Feasting() || IsCasting() || Rand() > 20)
+                return;
+
+            if (IAmFree())
+            {
+                HOFTarget(me, diff);
+                return;
+            }
+
+            Unit* u;
+            Player* player = master;
+            Group const* gr = player->GetGroup();
+            if (!gr)
+            {
+                u = player;
+                if (u->IsInWorld() && me->GetMap() == u->FindMap() &&
+                    HOFTarget(u, diff))
+                    return;
+
+                for (Unit::ControlList::const_iterator itr = player->m_Controlled.begin(); itr != player->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        u->isType(TYPEMASK_PLAYER) || (!u->IsPet() && !u->ToCreature()->IsNPCBot()) ||
+                        u->ToCreature()->IsTempBot() || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOFTarget(u, diff))
+                        return;
+                }
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || me->GetDistance(u) > 30)
+                    continue;
+                if (HOFTarget(u, diff))
+                    return;
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* pl = itr->GetSource();
+                if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap() || !pl->HaveBot())
+                    continue;
+
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    u = it->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        it->second->IsTempBot() || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOFTarget(u, diff))
+                        return;
+                }
+            }
+        }
+
+        bool HOFTarget(Unit* target, uint32 diff)
+        {
+            if (target->HasAuraType(SPELL_AURA_MECHANIC_IMMUNITY))
+            {
+                if (target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 11) &&
+                    target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 7))
+                    return false; //immune to root and snares
+                if (me->getLevel() >= 35 && target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 12))
+                    return false; //immune to stuns
+            }
+
+            SpellInfo const* spellInfo;
+            AuraApplication const* app;
+            Unit::AuraApplicationMap const& auras = target->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator i = auras.begin(); i != auras.end(); ++i)
+            {
+                app = i->second;
+                if (!app || app->IsPositive() || app->GetBase()->IsPassive() || app->GetBase()->GetDuration() < 2000)
+                    continue;
+                spellInfo = app->GetBase()->GetSpellInfo();
+                if (spellInfo->Attributes & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+                //if (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                if (spellInfo->GetAllEffectsMechanicMask() &
+                    ((1<<MECHANIC_SNARE) | (1<<MECHANIC_ROOT) | (me->getLevel() < 35 ? 0 : (1<<MECHANIC_STUN))))
+                {
+                    uint32 dispel = spellInfo->Dispel;
+                    uint32 spell;
+                    //Hand of Freedom is level 12, Purify is 8, Cleanse is 42
+                    if (!GetSpell(CLEANSE))
+                        spell = (dispel == DISPEL_DISEASE || dispel == DISPEL_POISON) ?
+                        GetSpell(PURIFY_1) : GetSpell(HAND_OF_FREEDOM_1);
+                    else
+                        spell = (dispel == DISPEL_MAGIC || dispel == DISPEL_DISEASE || dispel == DISPEL_POISON) ?
+                        GetSpell(CLEANSE_1) : GetSpell(HAND_OF_FREEDOM_1);
+
+                    if (doCast(target, spell))
+                        return true;
+                }
+            }
+            return false;
+        }
+
+        void HOSGroup(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_SALVATION_1, diff) || IsCasting() || Rand() > 40)
+                return;
+
+            Unit* u;
+
+            if (me->getLevel() >= 26 && (IAmFree() || IsTank()))
+            {
+                u = me;
+                if (u->IsInCombat() && !u->getAttackers().empty() &&
+                    GetHealthPCT(u) < std::max<int32>(80 - 5 * u->getAttackers().size(), 25))
+                    if (doCast(u, GetSpell(HAND_OF_SALVATION_1)))
+                    {}
+                return;
+            }
+
+            if (IAmFree())
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+                 return;
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                    IsTank(u) || (IsTankingClass(u->getClass()) && !me->GetMap()->IsRaid()) || me->GetDistance(u) > 30)
+                    continue;
+
+                if (HOSTarget(u, diff))
+                    return;
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* pl = itr->GetSource();
+                if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap() || !pl->HaveBot())
+                    continue;
+
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    u = it->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() || it->second->IsTempBot() ||
+                        IsTank(u) || (IsTankingClass(u->ToCreature()->GetBotClass()) && !me->GetMap()->IsRaid()) || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOSTarget(u, diff))
+                        return;
+                }
+            }
+        }
+
+        bool HOSTarget(Unit* target, uint32 diff)
+        {
+            if (target->HasAuraTypeWithFamilyFlags(SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE, SPELLFAMILY_PALADIN, 0x100))
+                return false;
+
+            Unit::AttackerSet const& t_attackers = target->getAttackers();
+            if (t_attackers.empty())
+                return false;
+
+            for (Unit::AttackerSet::const_iterator iter = t_attackers.begin(); iter != t_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if (!(*iter)->CanHaveThreatList()) continue;
+                if ((*iter)->getAttackers().size() < 3) continue; //would be useless
+                if (target->GetDistance((*iter)) < 15)
+                {
+                    if (doCast(target, GetSpell(HAND_OF_SALVATION_1)))
+                        return true;
+
+                    break; //do not try more than once on the same target
+                }
+            }
+            return false;
+        }
+
+        bool HealTarget(Unit* target, uint32 diff)
+        {
+            if (!target || !target->IsAlive() || me->GetDistance(target) > 40)
+                return false;
+            uint8 hp = GetHealthPCT(target);
+            if (hp > 90 &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+            if (Rand() > 50 + 40*target->IsInCombat() + 100*master->GetMap()->IsRaid())
+                return false;
+
+            //Lay on Hands
+            if (IsSpellReady(LAY_ON_HANDS_1, diff, !IsCasting()) && (target != me || shieldDelayTimer <= diff) &&
+                (target->IsInCombat() || !target->getAttackers().empty()) &&
+                (hp < 15 + 5*(uint32)target->getAttackers().size()) && Rand() < 60 &&
+                !target->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(LAY_ON_HANDS_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Lay on Hands on you!", target->ToPlayer());
+                    if (target != master)
+                    {
+                        std::ostringstream msg;
+                        msg << "Lay on Hands on " << (target == me ? "myself" : target->GetName()) << '!';
+                        BotWhisper(msg.str().c_str());
+                    }
+                    return true;
+                }
+            }
+
+            //try to preserve heal if Divine Plea is active
+            if (hp > 50 && me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1))
+                return false;
+
+            //Holy Shock
+            if (IsSpellReady(HOLY_SHOCK_1, diff, !IsCasting()) && !(target->IsCharmed() || target->isPossessed()) &&
+                (hp < 67 || GetLostHP(target) > 6000))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (hp < 25 && IsSpellReady(DIVINE_FAVOR_1, diff, false) && !target->getAttackers().empty())
+                    if (doCast(me, GetSpell(DIVINE_FAVOR_1)))
+                    {}
+                if (doCast(target, GetSpell(HOLY_SHOCK_1)))
+                    return true;
+            }
+
+            if (IsCasting()) return false;
+
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->ToCreature() && u->ToCreature()->isWorldBoss();
+
+            if (IsSpellReady(DIVINE_ILLUMINATION_1, diff, false) && GetManaPCT(me) <= 50 && Rand() < 50 + 50*tanking)
+                if (doCast(me, GetSpell(DIVINE_ILLUMINATION_1)))
+                {}
+
+            //Holy Light (always available)
+            if (GC_Timer <= diff && (hp > 40 || !GetSpell(FLASH_OF_LIGHT_1)) && (hp < 75 || GetLostHP(target) > 12000))
+            {
+                //Aura Mastery
+                if (hp < 60 && _aura == CONCENTRATIONAURA && IsSpellReady(AURA_MASTERY_1, diff, false) && Rand() < 90 &&
+                    ((!me->getAttackers().empty() && (*me->getAttackers().begin())->GetTypeId() == TYPEID_PLAYER) ||
+                    me->GetMap()->Instanceable() || tanking))
+                    if (doCast(me, GetSpell(AURA_MASTERY_1)))
+                    {}
+                if (doCast(target, GetSpell(HOLY_LIGHT_1)))
+                    return true;
+            }
+            //Flash of Light
+            if (IsSpellReady(FLASH_OF_LIGHT_1, diff)/* &&
+                (tanking || hp > 75 || hp < 40 || GetLostHP(target) > 3500)*/)
+            {
+                if (doCast(target, GetSpell(FLASH_OF_LIGHT_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force, u);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u) { bot_minion_ai::KilledUnit(u); }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+
+        void BreakCC(uint32 diff)
+        {
+            if (me->getLevel() >= 35 && IsSpellReady(HAND_OF_FREEDOM_1, diff) && Rand() < 30 && me->HasAuraWithMechanic(1<<MECHANIC_STUN))
+            {
+                if (me->IsMounted())
+                    me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+                if (doCast(me, GetSpell(HAND_OF_FREEDOM_1)))
+                    return;
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (Wait())
+                return;
+            GenerateRand();
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 30)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 60)
+                    DrinkPotion(false);
+            }
+            else if (GetManaPCT(me) < 40 && IsSpellReady(DIVINE_PLEA_1, diff) && Rand() < 30 &&
+                !me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1))
+            {
+                if (doCast(me, GetSpell(DIVINE_PLEA_1)))
+                    return;
+            }
+
+            CheckRacials(diff);
+
+            HOPGroup(diff);
+            CheckBeacon(diff);
+            BuffAndHealGroup(diff);
+            CheckHandOfSacrifice(diff);
+            ShieldGroup(diff);
+            CureGroup(GetSpell(CLEANSE), diff);
+
+            CheckSacrifice(diff);
+            HOFGroup(diff);
+            HOSGroup(diff);
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 50)
+                    DrinkPotion(true);
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            CheckSeal(diff);
+            CheckAura(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_PALADIN))
+                return;
+
+            Repentance(diff);
+            Counter(diff);
+            TurnEvil(diff);
+
+            CheckDivineIntervention(diff);
+            if (!me->IsAlive())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(REDEMPTION_1));
+        }
+
+        void CheckSeal(uint32 diff)
+        {
+            if (checkSealTimer > diff || GC_Timer > diff || me->IsMounted() ||
+                IsCasting() || Feasting() || Rand() > 30)
+                return;
+
+            checkSealTimer = 10000;
+
+            Unit const* victim = me->GetVictim();
+
+            uint32 COMMAND = GetSpell(SEAL_OF_COMMAND_1);
+            uint32 LIGHT = GetSpell(SEAL_OF_LIGHT_1);
+            uint32 RIGHT = GetSpell(SEAL_OF_RIGHTEOUSNESS_1);
+            uint32 WISDOM = GetSpell(SEAL_OF_WISDOM_1);
+            uint32 JUSTICE = GetSpell(SEAL_OF_JUSTICE_1);
+            uint32 VENGEANCE = (me->getRaceMask() & RACEMASK_ALLIANCE) ? GetSpell(SEAL_OF_VENGEANCE_1) : GetSpell(SEAL_OF_CORRUPTION_1);
+
+            if (VENGEANCE && victim &&
+                (victim->GetMaxHealth() > me->GetMaxHealth() * (2 + victim->getAttackers().size() / 2) ||
+                victim->getClass() == CLASS_ROGUE))
+                COMMAND = VENGEANCE;
+
+            uint32 SEAL = 0;
+
+            if (IsTank())
+            {
+                if (JUSTICE && me->getAttackers().size() > 1)
+                    JUSTICE = 0;
+                if (JUSTICE && victim)
+                {
+                    Creature const* cre = victim->ToCreature();
+                    if (cre && cre->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL &&
+                        (cre->GetCreatureTemplate()->MechanicImmuneMask & (1 << MECHANIC_STUN)))
+                        JUSTICE = 0;
+                }
+                SEAL = COMMAND ? COMMAND : JUSTICE ? JUSTICE : RIGHT;
+            }
+            else if (HasRole(BOT_ROLE_DPS))
+            {
+                SEAL = WISDOM && HasRole(BOT_ROLE_HEAL) ? WISDOM : COMMAND ? COMMAND : RIGHT;
+            }
+            else if (HasRole(BOT_ROLE_HEAL))
+                SEAL = WISDOM ? WISDOM : LIGHT ? LIGHT : RIGHT;
+
+            if (SEAL && !me->HasAura(SEAL))
+                if (doCast(me, SEAL))
+                    return;
+        }
+
+        void CheckAura(uint32 diff)
+        {
+            if (checkAuraTimer > diff || GC_Timer > diff || IsCasting() ||
+                /*me->GetExactDist(master) > 40 || me->IsMounted() || Feasting() || */Rand() > 20)
+                return;
+
+            checkAuraTimer = urand(3000, 6000);
+
+            //7 paladins in group?
+            uint32 DEVOTION_AURA = GetSpell(DEVOTION_AURA_1);
+            uint32 CONCENTRATION_AURA = GetSpell(CONCENTRATION_AURA_1);
+            uint32 FIRE_RESISTANCE_AURA = GetSpell(FIRE_RESISTANCE_AURA_1);
+            uint32 FROST_RESISTANCE_AURA = GetSpell(FROST_RESISTANCE_AURA_1);
+            uint32 SHADOW_RESISTANCE_AURA = GetSpell(SHADOW_RESISTANCE_AURA_1);
+            uint32 RETRIBUTION_AURA = GetSpell(RETRIBUTION_AURA_1);
+            //uint32 CRUSADER_AURA = GetSpell(CRUSADER_AURA_1);
+
+            bool pureHealer = HasRole(BOT_ROLE_HEAL) && HasRole(BOT_ROLE_RANGED) && !HasRole(BOT_ROLE_TANK);
+
+            std::map<uint32 /*baseid*/, uint32 /*curid*/> idMap;
+            uint32 mask = _getAurasMask(idMap);
+
+            //for Aura Mastery allow every pure healer paladin to have their own C aura
+            //SPECIFIC_AURA_MY_AURA check still works so no spam
+            if (pureHealer)
+                mask &= ~SPECIFIC_AURA_CONCENTRATION;
+
+            //if (CRUSADER_AURA && !(mask & SPECIFIC_AURA_CRUSADER) &&
+            //    (master->IsMounted() || me->IsMounted()))
+            //{
+            //    if (doCast(me, CRUSADER_AURA))
+            //        return;
+            //}
+
+            //Has own aura or has all auras
+            if (mask & SPECIFIC_AURA_MY_AURA)
+                return;
+            else if ((mask & SPECIFIC_AURA_ALL_AUTOUSE) == SPECIFIC_AURA_ALL_AUTOUSE)
+                return;
+
+            //TODO: priority?
+            if (DEVOTION_AURA &&
+                (!(mask & SPECIFIC_AURA_DEVOTION) || idMap[DEVOTION_AURA_1] < DEVOTION_AURA) &&
+                (!RETRIBUTION_AURA || IsTank(master) || IsTank()))
+            {
+                if (doCast(me, DEVOTION_AURA))
+                    return;
+            }
+            if (CONCENTRATION_AURA && !(mask & SPECIFIC_AURA_CONCENTRATION) &&
+                (master->getClass() == BOT_CLASS_MAGE || master->getClass() == BOT_CLASS_PRIEST ||
+                master->getClass() == BOT_CLASS_WARLOCK || master->getClass() == BOT_CLASS_DRUID ||
+                (!IAmFree() && master->getClass() == BOT_CLASS_PALADIN) || pureHealer))
+            {
+                if (doCast(me, CONCENTRATION_AURA))
+                    return;
+            }
+            if (RETRIBUTION_AURA &&
+                (!(mask & SPECIFIC_AURA_RETRIBUTION) || idMap[RETRIBUTION_AURA_1] < RETRIBUTION_AURA) &&
+                (IsMeleeClass(master->getClass()) || IsMelee()))
+            {
+                if (doCast(me, RETRIBUTION_AURA))
+                    return;
+            }
+            if (FIRE_RESISTANCE_AURA &&
+                (!(mask & SPECIFIC_AURA_FIRE_RES) || idMap[FIRE_RESISTANCE_AURA_1] < FIRE_RESISTANCE_AURA))
+            {
+                if (doCast(me, FIRE_RESISTANCE_AURA))
+                    return;
+            }
+            if (FROST_RESISTANCE_AURA &&
+                (!(mask & SPECIFIC_AURA_FROST_RES) || idMap[FROST_RESISTANCE_AURA_1] < FROST_RESISTANCE_AURA))
+            {
+                if (doCast(me, FROST_RESISTANCE_AURA))
+                    return;
+            }
+            if (SHADOW_RESISTANCE_AURA &&
+                (!(mask & SPECIFIC_AURA_SHADOW_RES) || idMap[SHADOW_RESISTANCE_AURA_1] < SHADOW_RESISTANCE_AURA))
+            {
+                if (doCast(me, SHADOW_RESISTANCE_AURA))
+                    return;
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (target == me)
+            {
+                if (uint32 rFury = GetSpell(RIGHTEOUS_FURY_1))
+                {
+                    if (IsTank())
+                    {
+                        if (!me->HasAura(rFury) && doCast(me, rFury))
+                            return true;
+                    }
+                    else if (me->HasAura(rFury))
+                        me->RemoveAurasDueToSpell(rFury);
+                }
+            }
+
+            uint32 mask = _getBlessingsMask(target);
+
+            //already has my blessing
+            if (mask & SPECIFIC_BLESSING_MY_BLESSING)
+                return false;
+
+            uint32 BLESSING_OF_WISDOM = GetSpell(BLESSING_OF_WISDOM_1);
+            uint32 BLESSING_OF_KINGS = GetSpell(BLESSING_OF_KINGS_1);
+            uint32 BLESSING_OF_SANCTUARY = GetSpell(BLESSING_OF_SANCTUARY_1);
+            uint32 BLESSING_OF_MIGHT = GetSpell(BLESSING_OF_MIGHT_1);
+
+            bool wisdom = (mask & SPECIFIC_BLESSING_WISDOM);
+            bool kings = (mask & SPECIFIC_BLESSING_KINGS);
+            bool sanctuary = (mask & SPECIFIC_BLESSING_SANCTUARY);
+            bool might = (mask & SPECIFIC_BLESSING_MIGHT);
+
+            if (IsTank(target))
+            {
+                if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                    return true;
+                else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                    return true;
+                else if (BLESSING_OF_WISDOM && !wisdom && target->GetMaxPower(POWER_MANA) > 1 && doCast(target, BLESSING_OF_WISDOM))
+                    return true;
+                else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                    return true;
+
+                return false;
+            }
+
+            uint8 Class = 0;
+            if (target->GetTypeId() == TYPEID_PLAYER)
+                Class = target->getClass();
+            else if (Creature* cre = target->ToCreature())
+                Class = cre->GetBotAI() ? cre->GetBotAI()->GetBotClass() : cre->getClass();
+
+            switch (Class)
+            {
+                case BOT_CLASS_BM:
+                    if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    else if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    break;
+                case CLASS_PRIEST:
+                    if (BLESSING_OF_WISDOM && !wisdom && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    break;
+                case CLASS_MAGE:
+                case CLASS_WARLOCK:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    break;
+                case CLASS_DEATH_KNIGHT:
+                case CLASS_WARRIOR:
+                case CLASS_PALADIN:
+                case CLASS_ROGUE:
+                case CLASS_HUNTER:
+                case CLASS_SHAMAN:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    break;
+                default:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->GetMaxPower(POWER_MANA) > 1 && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    break;
+            }
+            return false;
+        }
+
+        void Repentance(uint32 diff, Unit* target = NULL)
+        {
+            if (target)
+            {
+                if (IsSpellReady(REPENTANCE_1, diff) && doCast(target, GetSpell(REPENTANCE_1)))
+                    return;
+            }
+            else if (IsSpellReady(REPENTANCE_1, diff))
+            {
+                Unit* u = FindStunTarget();
+                if (u && u->GetVictim() != me && doCast(u, GetSpell(REPENTANCE_1)))
+                    return;
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+            if (Rand() > 60)
+                return;
+
+            Unit* target = IsSpellReady(REPENTANCE_1, diff) ? FindCastingTarget(20, 0, REPENTANCE_1) : NULL;
+            if (target)
+                Repentance(diff, target); //first check repentance
+            if (!target && IsSpellReady(TURN_EVIL_1, diff))
+            {
+                target = FindCastingTarget(20, 0, TURN_EVIL_1);
+                if (target && doCast(target, GetSpell(TURN_EVIL_1)))
+                    return;
+            }
+            if (!target && IsSpellReady(HOLY_WRATH_1, diff, false) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(8, 0, TURN_EVIL_1); //here we check target as with turn evil cuz of same requirements
+                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
+                    return;
+            }
+            if (!target && IsSpellReady(HAMMER_OF_JUSTICE_1, diff, false))
+            {
+                target = FindCastingTarget(10, 0, HAMMER_OF_JUSTICE_1);
+                if (target && doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                {}
+            }
+        }
+
+        void TurnEvil(uint32 diff)
+        {
+            if (!IsSpellReady(TURN_EVIL_1, diff) || IsCasting() || Rand() > 50 ||
+                FindAffectedTarget(GetSpell(TURN_EVIL_1), me->GetGUID(), 50))
+                return;
+            Unit* target = FindUndeadCCTarget(20, TURN_EVIL_1);
+            if (target &&
+                (target != me->GetVictim() || GetHealthPCT(me) < 70 || target->GetVictim() == master) &&
+                doCast(target, GetSpell(TURN_EVIL_1)))
+                return;
+            else
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                !CCed(opponent) &&
+                opponent->GetVictim() && !IsTank(opponent->GetVictim()) && opponent->GetVictim() != me &&
+                GetHealthPCT(me) < 90 &&
+                doCast(opponent, GetSpell(TURN_EVIL_1)))
+                return;
+        }
+
+        void CheckDivineIntervention(uint32 diff)
+        {
+            if (!IsSpellReady(DIVINE_INTERVENTION_1, diff, !IsCasting()) || IAmFree() || IsTank() ||
+                GetManaPCT(me) > 10 || Rand() > 20)
+                return;
+
+            std::list<Unit*> players;
+
+            if (master->IsAlive() && !master->getAttackers().empty() && GetHealthPCT(master) < 15 &&
+                !master->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+                players.push_back(master);
+            if (Group const* gr = master->GetGroup())
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl || pl == master || !pl->IsInWorld() || me->GetMap() != pl->FindMap() ||
+                        !pl->IsAlive() || pl->getAttackers().empty() || GetHealthPCT(pl) > 15 ||
+                        pl->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+                        continue;
+
+                    players.push_back(pl);
+                }
+            }
+
+            if (players.empty())
+                return;
+
+            Unit* target = players.size() == 1 ? *players.begin() : Trinity::Containers::SelectRandomContainerElement(players);
+            if (doCast(target, GetSpell(DIVINE_INTERVENTION_1)))
+                return;
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            MoveBehind(opponent);
+
+            //Divine Shield
+            if (IsSpellReady(DIVINE_SHIELD_1, diff) && shieldDelayTimer <= diff && (IAmFree() || !IsTank()) &&
+                Rand() < 80 && !me->getAttackers().empty() && GetHealthPCT(me) < 25)
+            {
+                if (doCast(me, GetSpell(DIVINE_SHIELD_1)))
+                    return;
+            }
+
+            //Holy shield
+            if (IsSpellReady(HOLY_SHIELD_1, diff) && HasRole(BOT_ROLE_DPS) && CanBlock() && !me->getAttackers().empty() &&
+                !me->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+            {
+                if (doCast(me, GetSpell(HOLY_SHIELD_1)))
+                    return;
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_HOLY))
+                return;
+
+            float dist = me->GetDistance(opponent);
+
+            //HAMMER OF WRATH
+            if (IsSpellReady(HAMMER_OF_WRATH_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 80 &&
+                opponent->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT) && dist < 30)
+            {
+                if (doCast(opponent, GetSpell(HAMMER_OF_WRATH_1)))
+                    return;
+            }
+            //HAND OF RECKONING //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(HAND_OF_RECKONING_1, diff, false) && u && u != me && dist < 30 &&
+                opponent->GetTypeId() == TYPEID_UNIT && !opponent->IsControlledByPlayer() &&
+                !CCed(opponent) && HasRole(BOT_ROLE_DPS) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (IsTank() && GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                ((!IsTankingClass(u->getClass()) && GetHealthPCT(u) < 80) || IsTank()) &&
+                IsInBotParty(u) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(HAND_OF_RECKONING_1)))
+                    return;
+            }
+            //HAND OF RECKONING 2 (distant)
+            if (IsSpellReady(HAND_OF_RECKONING_1, diff, false) && u == me && IsTank() && HasRole(BOT_ROLE_DPS) && Rand() < 30)
+            {
+                Unit* tUnit = FindDistantTauntTarget();
+                if (tUnit)
+                {
+                    if (doCast(tUnit, GetSpell(HAND_OF_RECKONING_1)))
+                        return;
+                }
+            }
+            //RIGHTEOUS DEFENSE //No GCD
+            if (IsSpellReady(RIGHTEOUS_DEFENSE_1, diff, false) && u && u != me && IsTank() && me->GetDistance(u) < 40 &&
+                opponent->GetTypeId() == TYPEID_UNIT && !opponent->IsControlledByPlayer() &&
+                !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                IsInBotParty(u) && Rand() < 20 + 30 * u->getAttackers().size())
+            {
+                if (doCast(u, GetSpell(RIGHTEOUS_DEFENSE_1)))
+                    return;
+            }
+            //RIGHTEOUS DEFENSE 2 (distant)
+            if (IsSpellReady(RIGHTEOUS_DEFENSE_1, diff, false) && u == me && IsTank() && Rand() < 30)
+            {
+                Unit* tUnit = FindDistantTauntTarget(40, true);
+                if (tUnit)
+                {
+                    if (doCast(tUnit, GetSpell(RIGHTEOUS_DEFENSE_1)))
+                        return;
+                }
+            }
+            //Divine Plea tanks only (Guarded by the Light synergy)
+            if (IsSpellReady(DIVINE_PLEA_1, diff) && IsTank() && !HasRole(BOT_ROLE_HEAL) && Rand() < 30 &&
+                dist < 10 && GetManaPCT(me) < 90 &&
+                !me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1))
+            {
+                if (doCast(me, GetSpell(DIVINE_PLEA_1)))
+                    return;
+            }
+            //Avenging Wrath (tank - big threat, dps - big hp, heal - divine plea counter)
+            if (IsSpellReady(AVENGING_WRATH_1, diff, false) && avDelayTimer <= diff &&
+                HasRole(BOT_ROLE_HEAL|BOT_ROLE_DPS) && Rand() < 35 && dist < 30 &&
+                IsTank() ? (opponent->GetTypeId() == TYPEID_UNIT && (opponent->ToCreature()->IsDungeonBoss() || opponent->ToCreature()->isWorldBoss())) :
+                (!HasRole(BOT_ROLE_HEAL) || !HasRole(BOT_ROLE_RANGED)) ? (opponent->GetHealth() > me->GetMaxHealth()/4 * (1 + opponent->getAttackers().size())) :
+                me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1))
+            {
+                if (doCast(me, GetSpell(AVENGING_WRATH_1)))
+                {}
+            }
+            //Avenger's shield
+            if (IsSpellReady(AVENGERS_SHIELD_1, diff) && CanBlock() && (IsTank() || IAmFree()) &&
+                HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 60)
+            {
+                if (doCast(opponent, GetSpell(AVENGERS_SHIELD_1)))
+                    return;
+            }
+            //Divine Protection tanks only
+            if (IsSpellReady(DIVINE_PROTECTION_1, diff, false) && shieldDelayTimer <= diff && IsTank() && Rand() < 80 &&
+                !me->getAttackers().empty() && GetHealthPCT(me) < 67 - 20*me->HasAuraType(SPELL_AURA_PERIODIC_HEAL))
+            {
+                if (doCast(me, GetSpell(DIVINE_PROTECTION_1)))
+                    return;
+            }
+            //Exorcism (have cast window or instant)
+            if (IsSpellReady(EXORCISM_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 70 &&
+                ((IsTank() && dist > 12) || !HasRole(BOT_ROLE_HEAL) || me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_PALADIN, 0x0, 0x0, 0x2)))
+            {
+                if (doCast(opponent, GetSpell(EXORCISM_1)))
+                    return;
+            }
+            //Hammer of Justice
+            if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff) && !CCed(opponent) && dist < 10 && Rand() < 20 &&
+                opponent->GetDiminishing(DIMINISHING_STUN) <= DIMINISHING_LEVEL_2 &&
+                !opponent->IsImmunedToSpellEffect(sSpellMgr->GetSpellInfo(HAMMER_OF_JUSTICE_1), 0))
+            {
+                if (doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                    return;
+            }
+            //Judgement
+            if (GetSpellCooldown(JUDGEMENT_OF_LIGHT_1) <= diff && HasRole(BOT_ROLE_DPS) && Rand() < 120)
+            {
+                uint32 JUDGEMENT = 0;
+
+                if (GetSpell(JUDGEMENT_OF_JUSTICE_1) && opponent->HasAuraType(SPELL_AURA_MOD_INCREASE_SPEED) &&
+                    dist < CalcSpellMaxRange(JUDGEMENT_OF_JUSTICE_1))
+                {
+                    //has joj from someone else
+                    bool canCast = true;
+                    Unit::AuraEffectList const& notSpeedAuras = opponent->GetAuraEffectsByType(SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED);
+                    for (Unit::AuraEffectList::const_iterator itr = notSpeedAuras.begin(); itr != notSpeedAuras.end(); ++itr)
+                    {
+                        if ((*itr)->GetCasterGUID() != me->GetGUID() && (*itr)->GetBase()->GetDuration() > 2000)
+                        {
+                            canCast = false;
+                            break;
+                        }
+                    }
+                    if (canCast)
+                    {
+                        //has sprint or something
+                        Unit::AuraEffectList const& speedAuras = opponent->GetAuraEffectsByType(SPELL_AURA_MOD_INCREASE_SPEED);
+                        for (Unit::AuraEffectList::const_iterator itr = speedAuras.begin(); itr != speedAuras.end(); ++itr)
+                        {
+                            if (!(*itr)->GetBase()->IsPassive() &&
+                                (*itr)->GetBase()->GetDuration() > 2000 &&
+                                (*itr)->GetAmount() >= 30)
+                            {
+                                JUDGEMENT = JUDGEMENT_OF_JUSTICE_1;
+                                break;
+                            }
+                        }
+                    }
+                }
+                if (!JUDGEMENT && GetSpell(JUDGEMENT_OF_WISDOM_1) && dist < CalcSpellMaxRange(JUDGEMENT_OF_WISDOM_1))
+                {
+                    //from 35% to 50% mana
+                    //opponent->GetAuraEffect(JUDGEMENT_OF_WISDOM_AURA, 0, me->GetGUID()
+                    AuraEffect const* wisd = opponent->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 3014, 0);
+                    uint8 myManaPct = GetManaPCT(me);
+                    if ((!wisd && myManaPct < 35) || (wisd && wisd->GetCasterGUID() == me->GetGUID() && myManaPct < 50))
+                        JUDGEMENT = JUDGEMENT_OF_WISDOM_1;
+                }
+                if (!JUDGEMENT && GetSpell(JUDGEMENT_OF_LIGHT_1) && dist < CalcSpellMaxRange(JUDGEMENT_OF_LIGHT_1))
+                {
+                    JUDGEMENT = JUDGEMENT_OF_LIGHT_1;
+                }
+
+                if (JUDGEMENT && doCast(opponent, GetSpell(JUDGEMENT)))
+                    return;
+            }
+            //Consecration
+            if (IsSpellReady(CONSECRATION_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 5 &&
+                !opponent->isMoving() && Rand() < 50)
+            {
+                if (doCast(me, GetSpell(CONSECRATION_1)))
+                    return;
+            }
+            //Hammer of Righteous (1h only)
+            if (IsSpellReady(HAMMER_OF_THE_RIGHTEOUS_1, diff) && (IsTank() || IAmFree()) && HasRole(BOT_ROLE_DPS) &&
+                dist < 5 && Rand() < 80)
+            {
+                Item const* weapMH = GetEquips(BOT_SLOT_MAINHAND);
+                if (weapMH &&
+                    (weapMH->GetTemplate()->InventoryType == INVTYPE_WEAPON ||
+                    weapMH->GetTemplate()->InventoryType == INVTYPE_WEAPONMAINHAND) &&
+                    doCast(opponent, GetSpell(HAMMER_OF_THE_RIGHTEOUS_1)))
+                    return;
+            }
+            //Shield of Righteousness
+            if (IsSpellReady(SHIELD_OF_RIGHTEOUSNESS_1, diff) && HasRole(BOT_ROLE_DPS) && CanBlock() &&
+                (IsTank() || IAmFree()) && dist < 5 && Rand() < 90)
+            {
+                if (doCast(opponent, GetSpell(SHIELD_OF_RIGHTEOUSNESS_1)))
+                    return;
+            }
+            //Crusader Strike (2h only)
+            if (IsSpellReady(CRUSADER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 5 && Rand() < 90)
+            {
+                Item const* mh = GetEquips(BOT_SLOT_MAINHAND);
+                if (mh && mh->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                    if (doCast(opponent, GetSpell(CRUSADER_STRIKE_1)))
+                        return;
+            }
+            //Divine Storm (2h only)
+            if (IsSpellReady(DIVINE_STORM_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 7 && Rand() < 40)
+            {
+                Item const* mh = GetEquips(BOT_SLOT_MAINHAND);
+                if (mh && mh->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                    if (doCast(me, GetSpell(DIVINE_STORM_1)))
+                        return;
+            }
+            //Holy Wrath
+            if (IsSpellReady(HOLY_WRATH_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                    dist < 8.5f && doCast(me, GetSpell(HOLY_WRATH_1)))
+                    return;
+                else
+                {
+                    if (FindUndeadCCTarget(8.5f, HOLY_WRATH_1, false) &&
+                        doCast(me, GetSpell(HOLY_WRATH_1)))
+                        return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Sanctified Light: 6% additional critical chance for Holy Light and Holy Shock
+            if (lvl >= 30 && (baseId == HOLY_LIGHT_1 || baseId == HOLY_SHOCK_1))
+                crit_chance += 6.f;
+            //Holy Power: 5% additional critical chance for Holy spells
+            if (lvl >= 35 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                crit_chance += 5.f;
+            //Improved Flash of Light (id: 20251): 6% additional critical chance for Flash of Light
+            if (lvl >= 70 && baseId == FLASH_OF_LIGHT_1)
+                crit_chance += 6.f;
+            //Glyph of Flash of Light: 5% additional critical chance for Flash of Light
+            if (lvl >= 20 && baseId == FLASH_OF_LIGHT_1)
+                crit_chance += 5.f;
+            //Sanctified Wrath: 50% additional critical chance for Hammer of Wrath
+            if (lvl >= 45 && baseId == HAMMER_OF_WRATH_1)
+                crit_chance += 50.f;
+            //Fanaticism: 18% additional critical chance for all Judgements (not shure which check is right)
+            if (lvl >= 45 && spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+                crit_chance += 18.f;
+            //Infusion of Light
+            if (baseId == HOLY_LIGHT_1)
+            {
+                if (AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 0))
+                    if (infu->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 20.f;
+            }
+            if (baseId == HOLY_LIGHT_1 || baseId == FLASH_OF_LIGHT_1 || baseId == HOLY_SHOCK_1)
+            {
+                if (AuraEffect const* favo = me->GetAuraEffect(DIVINE_FAVOR_1, 0))
+                    if (favo->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 100.f;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+            //Sanctity of Battle: 15% bonus damage for Exorcism and Crusader Strike
+            if (lvl >= 25 && baseId == EXORCISM_1)
+                pctbonus += 0.15f;
+            //The Art of War (damage part): 10% bonus damage for Judgements, Crusader Strike and Divine Storm
+            if (lvl >= 40 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT || baseId == CRUSADER_STRIKE_1 || baseId == DIVINE_STORM_1))
+                pctbonus += 0.1f;
+            //Judgements of the Pure (damage part): 25% bonus damage for Judgements and Seals
+            if (lvl >= 50 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_SEAL ||
+                baseId == JUDGEMENT_OF_COMMAND_DAMAGE))
+                pctbonus += 0.25f;
+            //Glyph of Exorcism: 20% bonus damage for Exorcism
+            if (lvl >= 50 && baseId == EXORCISM_1)
+                pctbonus += 0.2f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+
+            //Judgements of the Pure (damage part): 25% bonus damage for Judgements and Seals
+            if (lvl >= 50 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_SEAL ||
+                spellId == JUDGEMENT_OF_COMMAND_DAMAGE))
+                pctbonus += 0.25f;
+            //Improved Consecration (id: 38422): 10% bonus damage for Consecration
+            if (lvl >= 20 && spellId == GetSpell(CONSECRATION_1))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType /*damagetype*/, uint32 /*stack*/) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Divine Plea: 50% reduced healing for all spells
+            if (/*lvl >= 71 && */me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1))
+                pctbonus -= 0.5f;
+
+            //Healing Light: 12% bonus healing for Holy Light, Flash of Light and Holy Shock
+            if (lvl >= 15 && (baseId == HOLY_LIGHT_1 || baseId == FLASH_OF_LIGHT_1 || baseId == HOLY_SHOCK_1))
+                pctbonus += 0.12f;
+            //Glyph of Seal of Light: 5% bonus healing for all spells
+            if (lvl >= 30 && me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_PALADIN, 0x0, 0x2000000, 0x0))
+                pctbonus += 0.05f;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Benediction: -10% mana cost for Instant spells
+            if (lvl >= 10 && !spellInfo->CalcCastTime())
+                pctbonus += 0.1f;
+            //Blessed Hands: -30% mana cost for Hand spells
+            if (lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x2110))
+                pctbonus += 0.3f;
+            //Holy Light Cost Reduction (id: 60148): -5% mana cost for Holy Light
+            if (lvl >= 30 && baseId == HOLY_LIGHT_1)
+                pctbonus += 0.05f;
+            //Consecration Discount (id: 37180): -15% mana cost for Consecration
+            if (lvl >= 30 && baseId == CONSECRATION_1)
+                pctbonus += 0.15f;
+            //Glyph of Seal of Wisdom: -5% mana cost for all healing spells (for bot it is all spells)
+            if (lvl >= 15 && me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_PALADIN, 0x0, 0x4000000, 0x0))
+                pctbonus += 0.05f;
+            //Glyph of Shield of Righteous: -80% mana cost for Shield of Righteous
+            if (lvl >= 75 && (spellInfo->SpellFamilyFlags[1] & 0x100000))
+                pctbonus += 0.8f;
+
+            //flat mods
+            //Cleanse Cost Reduced (id: 27847): -25 mana cost for Cleanse
+            if (lvl >= 40 && baseId == CLEANSE_1)
+                flatbonus += 25;
+            //Reduced Holy Light Cost (id: 37739): -34 mana cost for Holy Light
+            if (lvl >= 40 && baseId == HOLY_LIGHT_1)
+                flatbonus += 34;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Glyph of Turn Evil: -100% cast time for Turn Evil
+            if (lvl >= 24 && baseId == TURN_EVIL_1)
+                timebonus += casttime;
+            if (baseId == FLASH_OF_LIGHT_1 || baseId == EXORCISM_1)
+            {
+                //The Art of War
+                AuraEffect const* arto = me->GetAuraEffect(THE_ART_OF_WAR_BUFF, 0);
+                //Infusion of Light
+                AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 1);
+                if (arto && arto->IsAffectedOnSpell(spellInfo))
+                    timebonus += casttime;
+                else if (infu && infu->IsAffectedOnSpell(spellInfo))
+                    timebonus += casttime;
+            }
+
+            //flat mods
+            //Improved Holy Light (id: 24457): -0.1 sec cast time for Holy Light
+            if (lvl >= 40 && baseId == HOLY_LIGHT_1)
+                timebonus += 100;
+            //Recuced Holy Light Cast Time (id: 37189): -0.5 sec cast time for Holy Light (works only for healers)
+            //Light's Grace: -0.5 sec cast time for Holy Light
+            if (baseId == HOLY_LIGHT_1)
+            {
+                if (AuraEffect const* enli = me->GetAuraEffect(ENLIGHTENMENT_BUFF, 0))
+                    if (enli->IsAffectedOnSpell(spellInfo))
+                        timebonus += 500;
+                if (AuraEffect const* grac = me->GetAuraEffect(LIGHTS_GRACE_BUFF, 0))
+                    if (grac->IsAffectedOnSpell(spellInfo))
+                        timebonus += 500;
+            }
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+
+            //flat mods
+            //Improved Judgements: -2 sec cooldown for judgements
+            //Judgment Cooldown Reduction (60153): -1 sec cooldown for judgements
+            //Judgement Cooldown Reduction (61776): -1 sec cooldown for judgements
+            if (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+            {
+                if (lvl >= 70)
+                    timebonus += 4000;
+                else if (lvl >= 60)
+                    timebonus += 3000;
+                else if (lvl >= 15)
+                    timebonus += 2000;
+            }
+            //Sacred Duty: -60 sec cooldown for Divine Shield and Divine Protection
+            if (lvl >= 35 && (baseId == DIVINE_SHIELD_1 || baseId == DIVINE_PROTECTION_1))
+                timebonus += 60000;
+            //Reduced Righteous Defense Cooldown (37181): -2 sec cooldown for Righteous Defense
+            if (lvl >= 60 && baseId == RIGHTEOUS_DEFENSE_1)
+                timebonus += 2000;
+            //Paladin T9 Tank 2P Bonus part 1: -2 sec cooldown for Hand of Reckoning
+            if (lvl >= 60 && baseId == HAND_OF_RECKONING_1)
+                timebonus += 2000;
+            //Glyph of Turn Evil: +8 sec cooldown for Turn Evil
+            if (lvl >= 24 && baseId == TURN_EVIL_1)
+                timebonus -= 8000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Purifying Power part 2: -33% cooldown for Exorcism and Holy Wrath
+            if (lvl >= 35 && (baseId == EXORCISM_1 || baseId == HOLY_WRATH_1))
+                pctbonus += 0.333f;
+            //Glyph of Avenging Wrath: -50% cooldown for Hammer of Wrath if Avenging Wrath is active
+            if (lvl >= 70 && baseId == HAMMER_OF_WRATH_1 &&
+                me->GetAuraEffect(SPELL_AURA_MOD_HEALING_DONE_PERCENT, SPELLFAMILY_PALADIN, 0x0, 0x2000, 0x0))
+                pctbonus += 0.5f;
+
+            //flat mods
+            //Improved Judgements: -2 sec cooldown for judgements
+            //Judgment Cooldown Reduction (60153): -1 sec cooldown for judgements
+            //Judgement Cooldown Reduction (61776): -1 sec cooldown for judgements
+            if (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+            {
+                if (lvl >= 70)
+                    timebonus += 4000;
+                else if (lvl >= 60)
+                    timebonus += 3000;
+                else if (lvl >= 15)
+                    timebonus += 2000;
+            }
+            //Guardian's Favor part 1: -120 sec cooldown for Hand of Protection
+            if (lvl >= 15 && baseId == HAND_OF_PROTECTION_1)
+                timebonus += 120000;
+            //Improved Hammer of Justice: -20 sec cooldown for Hammer of Justice
+            if (lvl >= 25 && baseId == HAMMER_OF_JUSTICE_1)
+                timebonus += 20000;
+            //Judgements of the Just: -10 sec cooldown for Hammer of Justice (tanks only)
+            if (lvl >= 55 && baseId == HAMMER_OF_JUSTICE_1 && IsTank())
+                timebonus += 10000;
+            //Glyph of Holy Shock: -1 sec cooldown for Holy Shock
+            if (baseId == HOLY_SHOCK_1)
+                timebonus += 1000;
+            //Glyph of Consecration: +2 sec cooldown for Consecration
+            if (lvl >= 20 && baseId == CONSECRATION_1)
+                timebonus -= 2000;
+            //Glyph of Holy Wrath: -15 sec cooldown for Holy Wrath
+            if (lvl >= 50 && baseId == HOLY_WRATH_1)
+                timebonus += 15000;
+            //Improved Lay on Hands (part 2): -4 min cooldown for Lay on Hands
+            if (lvl >= 20 && baseId == LAY_ON_HANDS_1)
+                timebonus += 240000;
+            //Glyph of Lay on Hands: -5 min cooldown for Lay on Hands (only healers)
+            if (lvl >= 15 && HasRole(BOT_ROLE_HEAL) && baseId == LAY_ON_HANDS_1)
+                timebonus += 300000;
+            //Lay Hands (id: 28774): -4 min cooldown for Lay on Hands (only healers)
+            if (lvl >= 60 && HasRole(BOT_ROLE_HEAL) && baseId == LAY_ON_HANDS_1)
+                timebonus += 240000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            ////Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+            //    timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            ////Holy Reach
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Increased Aura Radii (23565)
+            if (lvl >= 40 && (spellInfo->SpellFamilyFlags[0] & 0x4020048))
+                flatbonus += 10.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Booming Voice
+            //if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+            //    pctbonus += 1.0f;
+
+            //flat mods
+            //Enlightened Judgements: +30 yd range for Judgement of Light and Judgement of Wisdom (healers)
+            if (lvl >= 55 && (spellInfo->SpellFamilyFlags[0] & 0x800000) &&
+                HasRole(BOT_ROLE_HEAL) && HasRole(BOT_ROLE_RANGED))
+                flatbonus += 30.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const
+        {
+            uint32 bonusTargets = 0;
+
+            //Glyph of Hammer of the Righteous: +1 target
+            if (spellInfo->SpellFamilyFlags[1] & 0x40000)
+                bonusTargets += 1;
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo)
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == HOLY_LIGHT_1 || baseId == FLASH_OF_LIGHT_1 || baseId == HOLY_SHOCK_1)
+            {
+                if (AuraEffect const* favo = me->GetAuraEffect(DIVINE_FAVOR_1, 0))
+                    if (favo->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(DIVINE_FAVOR_1);
+            }
+
+            if (baseId == HOLY_LIGHT_1)
+            {
+                if (AuraEffect const* enli = me->GetAuraEffect(ENLIGHTENMENT_BUFF, 0))
+                    if (enli->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(ENLIGHTENMENT_BUFF);
+                if (AuraEffect const* grac = me->GetAuraEffect(LIGHTS_GRACE_BUFF, 0))
+                    if (grac->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(LIGHTS_GRACE_BUFF);
+                if (AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 0))
+                    if (infu->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(INFUSION_OF_LIGHT_BUFF);
+            }
+
+            if (baseId == EXORCISM_1 || baseId == FLASH_OF_LIGHT_1)
+            {
+                //Infusion of Light takes priority since AoW affects Exorcism too
+                AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 1);
+                //The Art of War
+                AuraEffect const* arto = me->GetAuraEffect(THE_ART_OF_WAR_BUFF, 0);
+                if (arto && arto->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(THE_ART_OF_WAR_BUFF);
+                else if (infu && infu->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(INFUSION_OF_LIGHT_BUFF);
+            }
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Glyph of Beacon of Light: 30 sec increased duration
+            if (baseId == BEACON_OF_LIGHT_1)
+            {
+                Aura* beac = target->GetAura(spellId, me->GetGUID());
+                if (beac)
+                {
+                    uint32 dur = beac->GetDuration() + 30000;
+                    beac->SetDuration(dur);
+                    beac->SetMaxDuration(dur);
+                }
+            }
+            //Judgements of the Just melee attack speed reduction part 1
+            if (lvl >= 55 && IsTank() && spell->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+            {
+                me->CastSpell(target, JUDGEMENTS_OF_THE_JUST_AURA, true);
+            }
+            //Judgements of the Just melee attack speed reduction part 2
+            if (spellId == JUDGEMENTS_OF_THE_JUST_AURA)
+            {
+                AuraEffect* slow = target->GetAuraEffect(JUDGEMENTS_OF_THE_JUST_AURA, 1, me->GetGUID());
+                if (slow)
+                    slow->ChangeAmount(slow->GetAmount() - 20);
+            }
+
+            if (spellId == SEAL_OF_JUSTICE_STUN_AURA)
+            {
+                if (lvl >= 55)
+                {
+                    //Judgements of the Just: 1 sec increased duration
+                    Aura* stun = target->GetAura(spellId, me->GetGUID());
+                    if (stun)
+                    {
+                        uint32 dur = stun->GetDuration() + 1000;
+                        stun->SetDuration(dur);
+                        stun->SetMaxDuration(dur);
+                    }
+                }
+            }
+            if (baseId == CONSECRATION_1)
+            {
+                if (lvl >= 30)
+                {
+                    //Glyph of Consecration: 2 sec increased duration
+                    Aura* cons = target->GetAura(spellId, me->GetGUID());
+                    if (cons)
+                    {
+                        uint32 dur = cons->GetDuration() + 2000;
+                        cons->SetDuration(dur);
+                        cons->SetMaxDuration(dur);
+                    }
+                }
+            }
+            if (baseId == RETRIBUTION_AURA_1)
+            {
+                if (lvl >= 30)
+                {
+                    //Sanctified Retribution: 50% increased effect
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() * 3 / 2);
+                }
+            }
+            if (baseId == DEVOTION_AURA_1)
+            {
+                if (lvl >= 25)
+                {
+                    //Improved Devotion Aura: 50% increased effect
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() * 3 / 2);
+                }
+            }
+            if (baseId == CONCENTRATION_AURA_1)
+            {
+                if (lvl >= 25)
+                {
+                    //Improved Concentration Aura: 15% increased effect (flat)
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() + 15); //base = 35, bonus = 15
+                }
+            }
+            if (baseId == FLASH_OF_LIGHT_HEAL_PERIODIC)
+            {
+                if (lvl >= 68 && HasRole(BOT_ROLE_HEAL) && !HasRole(BOT_ROLE_TANK | BOT_ROLE_DPS))
+                {
+                    //Paldin T9 Holy 4P Bonus: 100% increased healing from Infusion of Light (pure healers only)
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() * 2);
+                }
+            }
+            if (baseId == BLESSING_OF_WISDOM_1)
+            {
+                if (lvl >= 25)
+                {
+                    //Improved Blessing of Wisdom: 20% increased effect
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() * 6 / 5);
+                }
+            }
+            if (baseId == BLESSING_OF_MIGHT_1)
+            {
+                if (lvl >= 15)
+                {
+                    //Improved Blessing of Might: 25% increased effect
+                    if (Aura* migh = target->GetAura(spellId, me->GetGUID()))
+                        for (uint8 i = 0; i != EFFECT_2; ++i) // 2 effects
+                            if (AuraEffect* eff = migh->GetEffect(i))
+                                eff->ChangeAmount((eff->GetAmount() * 125) / 100);
+                }
+            }
+            if (baseId == HAND_OF_FREEDOM_1)
+            {
+                //Guardian's Favor part 2 (handled separately)
+                if (Aura* hof = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = hof->GetDuration() + 4000;
+                    hof->SetDuration(dur);
+                    hof->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == HAND_OF_SALVATION_1 && !IsTank(target))
+            {
+                //Blessed Hands (part 2)
+                if (AuraEffect* hos = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    hos->ChangeAmount(hos->GetAmount() * 2);
+                }
+            }
+            if (baseId == HAND_OF_SACRIFICE_1)
+            {
+                //Blessed Hands (part 3)
+                if (AuraEffect* hos = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    hos->ChangeAmount(hos->GetAmount() + 10);
+                }
+            }
+            if (baseId == BLESSING_OF_KINGS_1 || baseId == BLESSING_OF_MIGHT_1 ||
+                baseId == BLESSING_OF_WISDOM_1 || baseId == BLESSING_OF_SANCTUARY_1)
+            {
+                //Blessings duration 1h
+                if (Aura* bless = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    bless->SetDuration(dur);
+                    bless->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == SACRED_SHIELD_AURA_TRIGGERED || baseId == SACRED_SHIELD_1)
+            {
+                //Divine Guardian (part 2): 20% increased absorb, +100% duration
+                Aura* shi = target->GetAura(spellId, me->GetGUID());
+                if (shi)
+                {
+                    uint32 dur = shi->GetDuration() * 2;
+                    shi->SetDuration(dur);
+                    shi->SetMaxDuration(dur);
+                    if (baseId == SACRED_SHIELD_AURA_TRIGGERED)
+                    {
+                        if (AuraEffect* eff = shi->GetEffect(EFFECT_0))
+                            eff->ChangeAmount(eff->GetAmount() * 6 / 5);
+                    }
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            //Glyph of Seal of Vengeance
+            if (baseId == SEAL_OF_VENGEANCE_1 || baseId == SEAL_OF_CORRUPTION_1)
+            {
+                AuraEffect* sea = me->GetAuraEffect(spell->Id, 1);
+                if (sea)
+                    sea->ChangeAmount(sea->GetAmount() + 10);
+            }
+
+            //Aura Helper
+            if (caster == me)
+            {
+                if (baseId == DEVOTION_AURA_1)
+                    _aura = DEVOTIONAURA;
+                if (baseId == CONCENTRATION_AURA_1)
+                    _aura = CONCENTRATIONAURA;
+                if (baseId == FIRE_RESISTANCE_AURA_1)
+                    _aura = FIRERESAURA;
+                if (baseId == FROST_RESISTANCE_AURA_1)
+                    _aura = FROSTRESAURA;
+                if (baseId == SHADOW_RESISTANCE_AURA_1)
+                    _aura = SHADOWRESAURA;
+                if (baseId == RETRIBUTION_AURA_1)
+                    _aura = RETRIBUTIONAURA;
+                if (baseId == CRUSADER_AURA_1)
+                    _aura = CRUSADERAURA;
+            }
+
+            //immunity markers
+            if (baseId == AVENGING_WRATH_MARKER_SPELL)
+                avDelayTimer = 30000;
+            if (baseId == IMMUNITY_SHIELD_MARKER_SPELL)
+                shieldDelayTimer = 30000;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void HealReceived(Unit* healer, uint32& heal)
+        {
+            //Spiritual Attunement (double the effect on bots)
+            if (heal && me->getLevel() >= 40 && healer != me && HasRole(BOT_ROLE_TANK) && GetLostHP(me))
+            {
+                if (int32 basepoints = int32(CalculatePct(std::min<int32>(heal, GetLostHP(me)), 20)))
+                    me->CastCustomSpell(me, SPIRITUAL_ATTUNEMENT_ENERGIZE, &basepoints, NULL, NULL, true);
+            }
+
+            //bot_ai::HealReceived(healer, heal);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            checkAuraTimer = 0;
+            checkSealTimer = 0;
+            checkShieldTimer = 0;
+            checkBeaconTimer = 0;
+            avDelayTimer = 0;
+            shieldDelayTimer = 0;
+            _aura = NOAURA;
+
+            CLEANSE = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (checkAuraTimer > diff)              checkAuraTimer -= diff;
+            if (checkSealTimer > diff)              checkSealTimer -= diff;
+            if (checkShieldTimer > diff)            checkShieldTimer -= diff;
+            if (checkBeaconTimer > diff)            checkBeaconTimer -= diff;
+            if (avDelayTimer > diff)                avDelayTimer -= diff;
+            if (shieldDelayTimer > diff)            shieldDelayTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(FLASH_OF_LIGHT_1);
+            InitSpellMap(HOLY_LIGHT_1);
+            InitSpellMap(LAY_ON_HANDS_1);
+            InitSpellMap(SACRED_SHIELD_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(HOLY_SHOCK_1) : RemoveSpell(HOLY_SHOCK_1);
+            InitSpellMap(REDEMPTION_1);
+            InitSpellMap(HAMMER_OF_JUSTICE_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(REPENTANCE_1) : RemoveSpell(REPENTANCE_1);
+            InitSpellMap(TURN_EVIL_1);
+            InitSpellMap(HOLY_WRATH_1);
+            InitSpellMap(EXORCISM_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(SEAL_OF_COMMAND_1) : RemoveSpell(SEAL_OF_COMMAND_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(CRUSADER_STRIKE_1) : RemoveSpell(CRUSADER_STRIKE_1);
+            InitSpellMap(JUDGEMENT_OF_LIGHT_1);
+            InitSpellMap(JUDGEMENT_OF_WISDOM_1);
+            InitSpellMap(JUDGEMENT_OF_JUSTICE_1);
+            InitSpellMap(CONSECRATION_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(DIVINE_STORM_1) : RemoveSpell(DIVINE_STORM_1);
+            InitSpellMap(HAMMER_OF_WRATH_1);
+            InitSpellMap(AVENGING_WRATH_1);
+            InitSpellMap(RIGHTEOUS_FURY_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(HOLY_SHIELD_1) : RemoveSpell(HOLY_SHIELD_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(AVENGERS_SHIELD_1) : RemoveSpell(AVENGERS_SHIELD_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(HAMMER_OF_THE_RIGHTEOUS_1) : RemoveSpell(HAMMER_OF_THE_RIGHTEOUS_1);
+            InitSpellMap(SHIELD_OF_RIGHTEOUSNESS_1);
+            InitSpellMap(BLESSING_OF_MIGHT_1);
+            InitSpellMap(BLESSING_OF_WISDOM_1);
+            InitSpellMap(BLESSING_OF_KINGS_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(BLESSING_OF_SANCTUARY_1) : RemoveSpell(BLESSING_OF_SANCTUARY_1);
+            InitSpellMap(DEVOTION_AURA_1);
+            InitSpellMap(CONCENTRATION_AURA_1);
+            InitSpellMap(FIRE_RESISTANCE_AURA_1);
+            InitSpellMap(FROST_RESISTANCE_AURA_1);
+            InitSpellMap(SHADOW_RESISTANCE_AURA_1);
+            InitSpellMap(RETRIBUTION_AURA_1);
+            InitSpellMap(CRUSADER_AURA_1);
+            InitSpellMap(DIVINE_PLEA_1);
+            InitSpellMap(HAND_OF_PROTECTION_1);
+            InitSpellMap(HAND_OF_FREEDOM_1);
+            InitSpellMap(HAND_OF_SALVATION_1);
+            InitSpellMap(HAND_OF_SACRIFICE_1);
+            InitSpellMap(HAND_OF_RECKONING_1);
+            InitSpellMap(RIGHTEOUS_DEFENSE_1);
+            //InitSpellMap(PURIFY_1);
+            //InitSpellMap(CLEANSE_1);
+            InitSpellMap(SEAL_OF_LIGHT_1);
+            InitSpellMap(SEAL_OF_RIGHTEOUSNESS_1);
+            InitSpellMap(SEAL_OF_WISDOM_1);
+            InitSpellMap(SEAL_OF_JUSTICE_1);
+            InitSpellMap((me->getRaceMask() & RACEMASK_ALLIANCE) ? SEAL_OF_VENGEANCE_1 : SEAL_OF_CORRUPTION_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(DIVINE_SACRIFICE_1) : RemoveSpell(DIVINE_SACRIFICE_1);
+            InitSpellMap(DIVINE_INTERVENTION_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(AURA_MASTERY_1) : RemoveSpell(AURA_MASTERY_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(DIVINE_FAVOR_1) : RemoveSpell(DIVINE_FAVOR_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(DIVINE_ILLUMINATION_1) : RemoveSpell(DIVINE_ILLUMINATION_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(BEACON_OF_LIGHT_1) : RemoveSpell(BEACON_OF_LIGHT_1);
+
+            InitSpellMap(DIVINE_PROTECTION_1);
+            InitSpellMap(DIVINE_SHIELD_1);
+
+            CLEANSE = InitSpell(me, CLEANSE_1) ? CLEANSE_1 : PURIFY_1;
+            RemoveSpell(CLEANSE_1);
+            RemoveSpell(PURIFY_1);
+            InitSpellMap(CLEANSE);
+
+ /*SPECIAL*/InitSpellMap(ARDENT_DEFENDER_HEAL, true);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(JUDGEMENTS_OF_THE_PURE, level >= 50 ? 1 : 0);
+            RefreshAura(JUDGEMENTS_OF_THE_WISE, level >= 40 ? 1 : 0);
+            RefreshAura(RECKONING5, level >= 50 ? 1 : 0);
+            RefreshAura(RECKONING4, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(RECKONING3, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(RECKONING2, level >= 35 && level < 40 ? 1 : 0);
+            RefreshAura(RECKONING1, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(VENGEANCE3, level >= 40 ? 1 : 0);
+            RefreshAura(VENGEANCE2, level >= 37 && level < 40 ? 1 : 0);
+            RefreshAura(VENGEANCE1, level >= 35 && level < 37 ? 1 : 0);
+            RefreshAura(RIGHTEOUS_VENGEANCE3, level >= 60 ? 1 : 0);
+            RefreshAura(RIGHTEOUS_VENGEANCE2, level >= 57 && level < 60 ? 1 : 0);
+            RefreshAura(RIGHTEOUS_VENGEANCE1, level >= 55 && level < 57 ? 1 : 0);
+            RefreshAura(SHEATH_OF_LIGHT3, level >= 60 ? 1 : 0);
+            RefreshAura(SHEATH_OF_LIGHT2, level >= 55 && level < 60 ? 1 : 0);
+            RefreshAura(SHEATH_OF_LIGHT1, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(SACRED_CLEANSING, level >= 45 ? 1 : 0);
+            RefreshAura(DIVINE_PURPOSE, level >= 35 ? 1 : 0);
+            RefreshAura(VINDICATION2, level >= 25 ? 1 : 0);
+            RefreshAura(VINDICATION1, level >= 20 && level < 25 ? 1 : 0);
+            RefreshAura(PURSUIT_OF_JUSTICE, level >= 20 ? 1 : 0);
+            RefreshAura(ART_OF_WAR, level >= 40 ? 1 : 0);
+            RefreshAura(IMPROVED_LAY_ON_HANDS, level >= 30 ? 1 : 0);
+            RefreshAura(FANATICISM, level >= 20 ? 2 : 0);
+            RefreshAura(ARDENT_DEFENDER, level >= 40 ? 1 : 0);
+            RefreshAura(ILLUMINATION, level >= 20 ? 1 : 0);
+            RefreshAura(INFUSION_OF_LIGHT, level >= 55 ? 1 : 0);
+            RefreshAura(REDOUBT3, level >= 55 ? 1 : 0);
+            RefreshAura(REDOUBT2, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(REDOUBT1, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(IMPROVED_RIGHTEOUS_FURY, level >= 20 ? 1 : 0);
+            RefreshAura(SHIELD_OF_THE_TEMPLAR, level >= 55 ? 1 : 0);
+            RefreshAura(IMPROVED_DEVOTION_AURA, level >= 25 ? 1 : 0);
+            RefreshAura(IMPROVED_CONCENTRATION_AURA, level >= 25 ? 1 : 0);
+            RefreshAura(SANCTIFIED_RETRIBUTION, level >= 30 ? 1 : 0);
+            RefreshAura(LIGHTS_GRACE, level >= 40 ? 1 : 0);
+            RefreshAura(DIVINE_GUARDIAN, level >= 25 ? 1 : 0);
+            //RefreshAura(COMBAT_EXPERTISE, level >= 45 ? 1 : 0);
+            RefreshAura(CRUSADE, level >= 25 ? 1 : 0);
+            RefreshAura(ONE_HANDED_WEAPON_SPECIALIZATION, level >= 35 ? 1 : 0);
+            RefreshAura(TWO_HANDED_WEAPON_SPECIALIZATION, level >= 30 ? 1 : 0);
+            //RefreshAura(JUDGEMENTS_OF_THE_JUST, level >= 55 ? 1 : 0);
+            RefreshAura(GUARDED_BY_THE_LIGHT, level >= 50 ? 1 : 0);
+            RefreshAura(TOUCHED_BY_THE_LIGHT, level >= 50 ? 1 : 0);
+            RefreshAura(HEART_OF_THE_CRUSADER, level >= 15 ? 1 : 0);
+            RefreshAura(SWIFT_RETRIBUTION, level >= 50 ? 1 : 0);
+            RefreshAura(GLYPH_HOLY_LIGHT, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_SALVATION, level >= 26 ? 1 : 0);
+
+            RefreshAura(JUDGEMENT_ANTI_PARRY_DODGE_PASSIVE);
+
+            RefreshAura(RECUCED_HOLY_LIGHT_CAST_TIME, level >= 65 ? 1 : 0);
+            //RefreshAura(CLEANSE_HEAL_PASSIVE, level >= 58 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case FLASH_OF_LIGHT_1:
+                case HOLY_LIGHT_1:
+                case LAY_ON_HANDS_1:
+                case HAND_OF_FREEDOM_1:
+                case SACRED_SHIELD_1:
+                case CLEANSE_1:
+                case HAND_OF_PROTECTION_1:
+                case HAND_OF_SALVATION_1:
+                case HAND_OF_SACRIFICE_1:
+                //case SEAL_OF_COMMAND_1:
+                //case SEAL_OF_LIGHT_1:
+                //case SEAL_OF_RIGHTEOUSNESS_1:
+                //case SEAL_OF_WISDOM_1:
+                //case SEAL_OF_JUSTICE_1:
+                case DIVINE_PLEA_1:
+                case AVENGING_WRATH_1:
+                case BLESSING_OF_MIGHT_1:
+                case BLESSING_OF_WISDOM_1:
+                case BLESSING_OF_KINGS_1:
+                case BLESSING_OF_SANCTUARY_1:
+                    return true;
+                case HOLY_SHOCK_1:
+                    return HasRole(BOT_ROLE_HEAL);
+                case DEVOTION_AURA_1:
+                    return _aura != DEVOTIONAURA;
+                case CONCENTRATION_AURA_1:
+                    return _aura != CONCENTRATIONAURA;
+                case FIRE_RESISTANCE_AURA_1:
+                    return _aura != FIRERESAURA;
+                case FROST_RESISTANCE_AURA_1:
+                    return _aura != FROSTRESAURA;
+                case SHADOW_RESISTANCE_AURA_1:
+                    return _aura != SHADOWRESAURA;
+                case RETRIBUTION_AURA_1:
+                    return _aura != RETRIBUTIONAURA;
+                case CRUSADER_AURA_1:
+                    return _aura != CRUSADERAURA;
+                case PURIFY_1:
+                    return !GetSpell(CLEANSE_1);
+                default:
+                    return false;
+            }
+        }
+
+        bool HasAbilitiesSpecifics() const { return true; }
+        void FillAbilitiesSpecifics(std::list<std::string> &specList)
+        {
+            std::ostringstream msg1;
+            msg1 << "Aura: ";
+            switch (_aura)
+            {
+                case DEVOTIONAURA:
+                    msg1 << "Devotion Aura";
+                    break;
+                case CONCENTRATIONAURA:
+                    msg1 << "Concentration Aura";
+                    break;
+                case FIRERESAURA:
+                    msg1 << "Fire Resistance Aura";
+                    break;
+                case FROSTRESAURA:
+                    msg1 << "Frost Resistance Aura";
+                    break;
+                case SHADOWRESAURA:
+                    msg1 << "Shadow Resistance Aura";
+                    break;
+                case RETRIBUTIONAURA:
+                    msg1 << "Retribution Aura";
+                    break;
+                case CRUSADERAURA:
+                    msg1 << "Crusader Aura";
+                    break;
+                case NOAURA:
+                default:
+                    msg1 << "No Aura";
+                    break;
+            }
+            specList.push_back(msg1.str());
+        }
+
+    private:
+        //Spells
+        uint32 CLEANSE;
+        //Timers
+/*misc*/uint32 checkAuraTimer, checkSealTimer, checkShieldTimer, checkBeaconTimer, avDelayTimer, shieldDelayTimer;
+        //Special
+/*misc*/uint8 _aura;
+
+        //uint32 _getBlessingsMask(Unit const*) const
+        //Scans target for auras which are related to paladin's blessings
+        //(even if aura is just incompatible with one)
+        //returns applied blessings mask
+        //used for finding out which blessings target lacks
+        uint32 _getBlessingsMask(Unit const* target) const
+        {
+            uint32 mask = 0;
+
+            bool blessing;
+            Unit::AuraApplicationMap const& aurapps = target->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                blessing = true;
+                switch (itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id)
+                {
+                    case BLESSING_OF_WISDOM_1:
+                    case GREATER_BLESSING_OF_WISDOM_1:
+                        mask |= SPECIFIC_BLESSING_WISDOM;
+                        break;
+                    case BLESSING_OF_KINGS_1:
+                    case GREATER_BLESSING_OF_KINGS_1:
+                        mask |= SPECIFIC_BLESSING_KINGS;
+                        break;
+                    case BLESSING_OF_SANCTUARY_1:
+                    case GREATER_BLESSING_OF_SANCTUARY_1:
+                        mask |= SPECIFIC_BLESSING_SANCTUARY;
+                        break;
+                    case BLESSING_OF_MIGHT_1:
+                    case GREATER_BLESSING_OF_MIGHT_1:
+                    case BATTLESHOUT_1:
+                        mask |= SPECIFIC_BLESSING_MIGHT;
+                        break;
+                    default:
+                        blessing = false; //next aura
+                        break;
+                }
+
+                if (blessing && itr->second->GetBase()->GetCasterGUID() == me->GetGUID())
+                    mask |= SPECIFIC_BLESSING_MY_BLESSING;
+            }
+
+            return mask;
+        }
+        //uint32 _getAurasMask(Unit const*) const
+        //Scans target for paladin's auras
+        //returns applied auras mask
+        //used for finding out which auras target lacks
+        uint32 _getAurasMask(std::map<uint32 /*type*/, uint32 /*curId*/>& idMap) const
+        {
+            uint32 mask = 0;
+
+            uint32 baseId;
+            bool isAura;
+            Unit::AuraApplicationMap const& aurapps = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                isAura = true;
+                baseId = itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id;
+                switch (baseId)
+                {
+                    case DEVOTION_AURA_1:
+                        mask |= SPECIFIC_AURA_DEVOTION;
+                        break;
+                    case CONCENTRATION_AURA_1:
+                        mask |= SPECIFIC_AURA_CONCENTRATION;
+                        break;
+                    case FIRE_RESISTANCE_AURA_1:
+                        mask |= SPECIFIC_AURA_FIRE_RES;
+                        break;
+                    case FROST_RESISTANCE_AURA_1:
+                        mask |= SPECIFIC_AURA_FROST_RES;
+                        break;
+                    case SHADOW_RESISTANCE_AURA_1:
+                        mask |= SPECIFIC_AURA_SHADOW_RES;
+                        break;
+                    case RETRIBUTION_AURA_1:
+                        mask |= SPECIFIC_AURA_RETRIBUTION;
+                        break;
+                    case CRUSADER_AURA_1:
+                        mask |= SPECIFIC_AURA_CRUSADER;
+                        break;
+                    default:
+                        isAura = false; //next aura
+                        break;
+                }
+
+                if (isAura)
+                {
+                    idMap[baseId] = itr->first;
+                    if (itr->second->GetBase()->GetCasterGUID() == me->GetGUID())
+                        mask |= SPECIFIC_AURA_MY_AURA;
+                }
+            }
+
+            return mask;
+        }
+
+        enum PaladinBaseSpells// all orignals
+        {
+            FLASH_OF_LIGHT_1                    = 19750,
+            HOLY_LIGHT_1                        = 635,
+            LAY_ON_HANDS_1                      = 633,
+            REDEMPTION_1                        = 7328,
+            HAND_OF_FREEDOM_1                   = 1044,
+            SACRED_SHIELD_1                     = 53601,
+            HOLY_SHOCK_1                        = 20473,
+            CLEANSE_1                           = 4987,
+            HAND_OF_PROTECTION_1                = 1022,
+            HAND_OF_SALVATION_1                 = 1038,
+            HAND_OF_SACRIFICE_1                 = 6940,
+            SEAL_OF_VENGEANCE_1                 = 31801,
+            SEAL_OF_CORRUPTION_1                = 53736,
+            SEAL_OF_COMMAND_1                   = 20375,
+            SEAL_OF_LIGHT_1                     = 20165,
+            SEAL_OF_RIGHTEOUSNESS_1             = 21084,
+            SEAL_OF_WISDOM_1                    = 20166,
+            SEAL_OF_JUSTICE_1                   = 20164,
+            DIVINE_SACRIFICE_1                  = 64205,
+            HAND_OF_RECKONING_1                 = 62124,
+            RIGHTEOUS_DEFENSE_1                 = 31789,
+            DIVINE_PLEA_1                       = 54428,
+            REPENTANCE_1                        = 20066,
+            TURN_EVIL_1                         = 10326,
+            CRUSADER_STRIKE_1                   = 35395,
+            JUDGEMENT_OF_LIGHT_1                = 20271,
+            JUDGEMENT_OF_WISDOM_1               = 53408,
+            JUDGEMENT_OF_JUSTICE_1              = 53407,
+            CONSECRATION_1                      = 26573,
+            HAMMER_OF_JUSTICE_1                 = 853,
+            DIVINE_STORM_1                      = 53385,
+            HAMMER_OF_WRATH_1                   = 24275,
+            EXORCISM_1                          = 879,
+            HOLY_WRATH_1                        = 2812,
+            AVENGING_WRATH_1                    = 31884,
+            RIGHTEOUS_FURY_1                    = 25780,
+            HOLY_SHIELD_1                       = 20925,
+            AVENGERS_SHIELD_1                   = 31935,
+            HAMMER_OF_THE_RIGHTEOUS_1           = 53595,
+            SHIELD_OF_RIGHTEOUSNESS_1           = 53600,
+            BLESSING_OF_MIGHT_1                 = 19740,
+            BLESSING_OF_WISDOM_1                = 19742,
+            BLESSING_OF_KINGS_1                 = 20217,
+            BLESSING_OF_SANCTUARY_1             = 20911,
+            DEVOTION_AURA_1                     = 465,
+            CONCENTRATION_AURA_1                = 19746,
+            FIRE_RESISTANCE_AURA_1              = 19891,
+            FROST_RESISTANCE_AURA_1             = 19888,
+            SHADOW_RESISTANCE_AURA_1            = 19876,
+            RETRIBUTION_AURA_1                  = 7294,
+            CRUSADER_AURA_1                     = 32223,
+
+            DIVINE_INTERVENTION_1               = 19752,
+            AURA_MASTERY_1                      = 31821,
+            DIVINE_FAVOR_1                      = 20216,
+            DIVINE_ILLUMINATION_1               = 31842,
+            BEACON_OF_LIGHT_1                   = 53563,
+
+            DIVINE_PROTECTION_1                 = 498,
+            DIVINE_SHIELD_1                     = 642,
+
+            PURIFY_1                            = 1152
+        };
+        enum PaladinPassives
+        {
+        //Talents
+            DIVINE_PURPOSE                      = 31872,
+            JUDGEMENTS_OF_THE_PURE              = 54155,
+            JUDGEMENTS_OF_THE_WISE              = 31878,
+            SACRED_CLEANSING                    = 53553,//rank 3
+            RECKONING1                          = 20177,
+            RECKONING2                          = 20179,
+            RECKONING3                          = 20181,
+            RECKONING4                          = 20180,
+            RECKONING5                          = 20182,
+            VINDICATION1                        = 9452,
+            VINDICATION2                        = 26016,
+            PURSUIT_OF_JUSTICE                  = 26023,//rank 2
+            ART_OF_WAR                          = 53488,//rank 2
+            IMPROVED_LAY_ON_HANDS               = 20235,//rank 2
+            FANATICISM                          = 31881,//rank 3
+            RIGHTEOUS_VENGEANCE1                = 53380,//rank 1
+            RIGHTEOUS_VENGEANCE2                = 53381,//rank 2
+            RIGHTEOUS_VENGEANCE3                = 53382,//rank 3
+            VENGEANCE1                          = 20049,//rank 1
+            VENGEANCE2                          = 20056,//rank 2
+            VENGEANCE3                          = 20057,//rank 3
+            SHEATH_OF_LIGHT1                    = 53501,//rank 1
+            SHEATH_OF_LIGHT2                    = 53502,//rank 2
+            SHEATH_OF_LIGHT3                    = 53503,//rank 3
+            ARDENT_DEFENDER                     = 31852,//rank 3
+            ILLUMINATION                        = 20215,//rank 5
+            INFUSION_OF_LIGHT                   = 53576,//rank 2
+            REDOUBT1                            = 20127,//rank 3
+            REDOUBT2                            = 20130,//rank 3
+            REDOUBT3                            = 20135,//rank 3
+            IMPROVED_RIGHTEOUS_FURY             = 20470,//rank 3
+            SHIELD_OF_THE_TEMPLAR               = 53711,//rank 3
+            IMPROVED_DEVOTION_AURA              = 20140,//rank 3
+            IMPROVED_CONCENTRATION_AURA         = 20256,//rank 3
+            SANCTIFIED_RETRIBUTION              = 31869,
+            SWIFT_RETRIBUTION                   = 53648,//rank 3
+            LIGHTS_GRACE                        = 31836,//rank 3
+            DIVINE_GUARDIAN                     = 53530,//rank 3
+            //COMBAT_EXPERTISE                    = 31860,//rank 3
+            CRUSADE                             = 31868,//rank 3
+            ONE_HANDED_WEAPON_SPECIALIZATION    = 20198,//rank 3
+            TWO_HANDED_WEAPON_SPECIALIZATION    = 20113,//rank 3
+            //JUDGEMENTS_OF_THE_JUST              = 53696,//rank 2
+            GUARDED_BY_THE_LIGHT                = 53585,//rank 2
+            TOUCHED_BY_THE_LIGHT                = 53592,//rank 3
+            HEART_OF_THE_CRUSADER               = 20337,//rank 3
+        //Glyphs
+            GLYPH_HOLY_LIGHT                    = 54937,
+            GLYPH_SALVATION                     = 63225,
+        //Innate
+            JUDGEMENT_ANTI_PARRY_DODGE_PASSIVE  = 60091,
+        //other
+            RECUCED_HOLY_LIGHT_CAST_TIME        = 37189,//not a typo
+            //CLEANSE_HEAL_PASSIVE                = 28787
+        };
+
+        enum PaladinSpecial
+        {
+            NOAURA                              = 0,
+            DEVOTIONAURA                        = 1,
+            CONCENTRATIONAURA                   = 2,
+            FIRERESAURA                         = 3,
+            FROSTRESAURA                        = 4,
+            SHADOWRESAURA                       = 5,
+            RETRIBUTIONAURA                     = 6,
+            CRUSADERAURA                        = 7,
+
+            SPECIFIC_BLESSING_WISDOM            = 0x01,
+            SPECIFIC_BLESSING_KINGS             = 0x02,
+            SPECIFIC_BLESSING_SANCTUARY         = 0x04,
+            SPECIFIC_BLESSING_MIGHT             = 0x08,
+            SPECIFIC_BLESSING_MY_BLESSING       = 0x10,
+
+            SPECIFIC_AURA_DEVOTION              = 0x01,
+            SPECIFIC_AURA_CONCENTRATION         = 0x02,
+            SPECIFIC_AURA_FIRE_RES              = 0x04,
+            SPECIFIC_AURA_FROST_RES             = 0x08,
+            SPECIFIC_AURA_SHADOW_RES            = 0x10,
+            SPECIFIC_AURA_RETRIBUTION           = 0x20,
+            SPECIFIC_AURA_CRUSADER              = 0x40,
+            SPECIFIC_AURA_MY_AURA               = 0x80,
+            SPECIFIC_AURA_ALL_AUTOUSE           = (SPECIFIC_AURA_DEVOTION | SPECIFIC_AURA_CONCENTRATION | SPECIFIC_AURA_RETRIBUTION | \
+                                                    SPECIFIC_AURA_FIRE_RES | SPECIFIC_AURA_FROST_RES | SPECIFIC_AURA_SHADOW_RES),
+
+            FLASH_OF_LIGHT_HEAL_PERIODIC        = 66922,
+
+            ENLIGHTENMENT_BUFF                  = 43837,
+            INFUSION_OF_LIGHT_BUFF              = 54149,//rank 2
+            THE_ART_OF_WAR_BUFF                 = 59578,//rank 2
+            //FORBEARANCE_AURA                    = 25771,
+
+            LIGHTS_GRACE_BUFF                   = 31834,
+
+            SEAL_OF_JUSTICE_STUN_AURA           = 20170,
+            JUDGEMENTS_OF_THE_JUST_AURA         = 68055, //melee attack speed reduce
+
+            //JUDGEMENT_OF_LIGHT_AURA             = 20185,
+            //JUDGEMENT_OF_WISDOM_AURA            = 20186,
+            //JUDGEMENT_OF_JUSTICE_AURA           = 20184,
+
+            GREATER_BLESSING_OF_MIGHT_1         = 25782,
+            GREATER_BLESSING_OF_WISDOM_1        = 25894,
+            GREATER_BLESSING_OF_KINGS_1         = 25898,
+            GREATER_BLESSING_OF_SANCTUARY_1     = 25899,
+            BATTLESHOUT_1                       = 6673,
+
+            ARDENT_DEFENDER_HEAL                = 66235,
+            JUDGEMENT_OF_COMMAND_DAMAGE         = 20467,
+            SPIRITUAL_ATTUNEMENT_ENERGIZE       = 31786,
+            SACRED_SHIELD_AURA_TRIGGERED        = 58597,
+
+            AVENGING_WRATH_MARKER_SPELL         = 61987,
+            IMMUNITY_SHIELD_MARKER_SPELL        = 61988
+        };
+    };
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_priest_ai.cpp b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
new file mode 100644
index 0000000..70452dd
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
@@ -0,0 +1,1455 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+//#include "WorldSession.h"
+/*
+Priest NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - Around 80%
+TODO:
+*/
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new priest_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct priest_botAI : public bot_minion_ai
+    {
+        priest_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_PRIEST;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_PRIEST) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        bool MassGroupHeal(Player* player, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (IAmFree() || !player->GetGroup()) return false;
+            if (IsCasting()) return false;
+            if (Rand() > 35 + 100 * (me->GetMap()->IsRaid())) return false;
+
+            if (IsSpellReady(DIVINE_HYMN_1, diff, false))
+            {
+                Group const* gr = player->GetGroup();
+                uint8 LHPcount = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player const* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                        continue;
+                    if (tPlayer->IsAlive() && me->GetDistance(tPlayer) < 40)
+                    {
+                        uint8 pct = 50 + tPlayer->getAttackers().size()*10;
+                        pct = pct < 80 ? pct : 80;
+                        if (GetHealthPCT(tPlayer) < pct && GetLostHP(tPlayer) > 4000)
+                            ++LHPcount;
+                    }
+                    if (LHPcount > 1)
+                        break;
+                    if (!tPlayer->HaveBot())
+                        continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature const* bot = it->second;
+                        if (bot && GetHealthPCT(bot) < 50 + 35*me->GetMap()->IsRaid() && me->GetDistance(bot) < 40)
+                            ++LHPcount;
+                        if (LHPcount > 1)
+                            break;
+                    }
+                }
+                if (LHPcount > 1 && doCast(me, GetSpell(DIVINE_HYMN_1)))
+                    return true;
+            }
+            if (IsSpellReady(CIRCLE_OF_HEALING_1, diff, false))
+            {
+                Group const* gr = player->GetGroup();
+                Unit* castTarget = NULL;
+                uint8 LHPcount = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                        continue;
+                    if (GetHealthPCT(tPlayer) < 85 && me->GetDistance(tPlayer) < 40)
+                    {
+                        ++LHPcount;
+                        if (GetHealthPCT(tPlayer) < lowestPCT)
+                        {
+                            lowestPCT = GetHealthPCT(tPlayer);
+                            castTarget = tPlayer;
+                        }
+                    }
+                    if (LHPcount > 2)
+                        break;
+                    if (!tPlayer->HaveBot())
+                        continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && bot->IsInWorld() && GetHealthPCT(bot) < 50 + 35*me->GetMap()->IsRaid() && me->GetDistance(bot) < 40)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(bot) < lowestPCT)
+                            {
+                                lowestPCT = GetHealthPCT(bot);
+                                castTarget = bot;
+                            }
+                        }
+                        if (LHPcount > 2)
+                            break;
+                    }
+                }
+
+                if (LHPcount > 2 && castTarget && doCast(castTarget, GetSpell(CIRCLE_OF_HEALING_1)))
+                    return true;
+            }
+            if (GetSpell(PRAYER_OF_HEALING_1))
+            {
+                Group const* gr = player->GetGroup();
+                Unit* castTarget = NULL;
+                uint8 LHPcount = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                        continue;
+                    if (GetHealthPCT(tPlayer) < 85 && me->GetDistance(tPlayer) < 40)
+                    {
+                        ++LHPcount;
+                        if (GetHealthPCT(tPlayer) < lowestPCT)
+                        {
+                            lowestPCT = GetHealthPCT(tPlayer);
+                            castTarget = tPlayer;
+                        }
+                    }
+                    if (LHPcount > 2)
+                        break;
+                    if (!tPlayer->HaveBot())
+                        continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && bot->IsInWorld() && GetHealthPCT(bot) < 50 + 35*me->GetMap()->IsRaid() && me->GetDistance(bot) < 40)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(bot) < lowestPCT)
+                            {
+                                lowestPCT = GetHealthPCT(bot);
+                                castTarget = bot;
+                            }
+                        }
+                        if (LHPcount > 2)
+                            break;
+                    }
+                }
+
+                if (LHPcount > 2 && castTarget && doCast(castTarget, GetSpell(PRAYER_OF_HEALING_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        bool ShieldGroup(uint32 diff)
+        {
+            if (GC_Timer > diff || IAmFree() || IsCasting()) return false;
+            if (!IsSpellReady(PW_SHIELD_1, diff)) return false;
+            if (Rand() > 65 + 100 * (me->GetMap()->IsRaid())) return false;
+
+            Group const* gr = master->GetGroup();
+            Unit* u = master;
+            if (!gr)
+            {
+                if (u->IsAlive() && !u->getAttackers().empty() && (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                    ShieldTarget(u, diff))
+                    return true;
+                BotMap const* map = master->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (u->IsAlive() && !u->getAttackers().empty() && !u->ToCreature()->IsTempBot() &&
+                        (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                        ShieldTarget(u, diff))
+                        return true;
+                }
+                for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsPet() || !u->IsInWorld() || me->GetMap() != u->FindMap() || u->IsTotem()) continue;
+                    if (u->IsAlive() && !u->getAttackers().empty() &&
+                        !(u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->IsTempBot()) &&
+                        (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                        ShieldTarget(u, diff))
+                        return true;
+                }
+                return false;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                    continue;
+                u = tPlayer;
+                if (u->IsAlive() && !u->getAttackers().empty() && (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                    ShieldTarget(u, diff))
+                    return true;
+                if (tPlayer->HaveBot())
+                {
+                    BotMap const* map = master->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        u = itr->second;
+                        if (u->IsAlive() && !u->getAttackers().empty() && !u->ToCreature()->IsTempBot() &&
+                            (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                            ShieldTarget(u, diff))
+                            return true;
+                    }
+                }
+                for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || u->IsTotem()) continue;
+                    if (u->IsAlive() && !u->getAttackers().empty() &&
+                        !(u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->IsTempBot()) &&
+                        (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                        ShieldTarget(u, diff))
+                        return true;
+                }
+            }
+            return false;
+        }
+
+        bool ShieldTarget(Unit* target, uint32 diff)
+        {
+            if (!IsSpellReady(PW_SHIELD_1, diff) || IsCasting())
+                return false;
+            //if (target->HasAura(WEAKENED_SOUL_DEBUFF) || HasAuraName(target, PW_SHIELD_1))
+            //    return false;
+            if (target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_PRIEST, 0x20000000) ||
+                target->HasAuraTypeWithFamilyFlags(SPELL_AURA_SCHOOL_ABSORB, SPELLFAMILY_PRIEST, 0x1))
+                return false;
+
+            if (doCast(target, GetSpell(PW_SHIELD_1)))
+                return true;
+
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force, u);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u) { bot_minion_ai::KilledUnit(u); }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+
+        bool removeShapeshiftForm()
+        {
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                    case FORM_SHADOW:
+                        me->RemoveAurasDueToSpell(SHADOWFORM_1);
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+            return true;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (Wait())
+                return;
+            GenerateRand();
+            Disperse(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+            DoDevCheck(diff);
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 33)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50 && (!HasRole(BOT_ROLE_HEAL) || me->HasAuraType(SPELL_AURA_MOD_SILENCE)))
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            doDefend(diff);
+
+            if (me->GetMap()->IsRaid())
+            {
+                CureGroup(GetSpell(DISPEL_MAGIC_1), diff);
+                CureGroup(GetSpell(CURE_DISEASE_1), diff);
+                MassGroupHeal(master, diff);
+                ShieldGroup(diff);
+                CheckMending(diff);
+                BuffAndHealGroup(diff);
+            }
+            else
+            {
+                MassGroupHeal(master, diff);
+                ShieldGroup(diff);
+                CheckMending(diff);
+                BuffAndHealGroup(diff);
+                CureGroup(GetSpell(DISPEL_MAGIC_1), diff);
+                CureGroup(GetSpell(CURE_DISEASE_1), diff);
+            }
+
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckDispel(diff);
+                CheckSilence(diff);
+            }
+
+            if (me->IsInCombat())
+                CheckShackles(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (!CheckAttackTarget(BOT_CLASS_PRIEST))
+                return;
+
+            StartAttack(opponent, IsMelee());
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_SHADOW))
+                return;
+
+            float dist = me->GetDistance(opponent);
+
+            Unit::AttackerSet m_attackers = master->getAttackers();
+            Unit::AttackerSet b_attackers = me->getAttackers();
+
+            if (GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && !IsCasting() && dist < 30 &&
+                (GetManaPCT(me) > 35 || !HasRole(BOT_ROLE_HEAL)) && GetHealthPCT(master) > 60 && GetHealthPCT(me) > 70 &&
+                (!HasRole(BOT_ROLE_HEAL) || m_attackers.size() < 4 || b_attackers.size() + m_attackers.size() < 3))
+            {
+                //spell reflections
+                if (IsSpellReady(SW_PAIN_1, diff) && CanRemoveReflectSpells(opponent, SW_PAIN_1) &&
+                    doCast(opponent, SW_PAIN_1)) //yes, using rank 1
+                    return;
+
+                if (IsSpellReady(SMITE_1, diff) && !GetSpell(MIND_FLAY_1) &&//MF is lvl 20, MB is lvl 10
+                    doCast(opponent, GetSpell(SMITE_1)))
+                    return;
+                if (IsSpellReady(SW_DEATH_1, diff) && Rand() < 60 &&
+                    (GetHealthPCT(opponent) < 15 || opponent->GetHealth() < me->GetMaxHealth()/6) &&
+                    doCast(opponent, GetSpell(SW_DEATH_1)))
+                    return;
+                if (IsSpellReady(SW_PAIN_1, diff) && Rand() < 80 &&
+                    opponent->GetHealth() > me->GetMaxHealth()/4 &&
+                    !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0x0, 0x0, me->GetGUID())
+                    /*!HasAuraName(opponent, SW_PAIN_1, me->GetGUID())*/ &&
+                    doCast(opponent, GetSpell(SW_PAIN_1)))
+                    return;
+                if (IsSpellReady(VAMPIRIC_TOUCH_1, diff) && Rand() < 70 &&
+                    opponent->GetHealth() > me->GetMaxHealth()/2 &&
+                    !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x0, 0x400, 0x0, me->GetGUID())
+                    /*!HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID())*/ &&
+                    doCast(opponent, GetSpell(VAMPIRIC_TOUCH_1)))
+                    return;
+                if (IsSpellReady(DEVOURING_PLAGUE_1, diff) && !Devcheck &&
+                    opponent->GetHealth() > me->GetMaxHealth()/2 &&
+                    !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_LEECH, SPELLFAMILY_PRIEST, 0x02000000, 0x0, 0x0, me->GetGUID())
+                    /*!HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID())*/ &&
+                    doCast(opponent, GetSpell(DEVOURING_PLAGUE_1)))
+                    return;
+                if (IsSpellReady(MIND_SEAR_1, diff) && Rand() < 35)
+                {
+                    if (Unit* u = FindSplashTarget(30.f, opponent, 9.f, 3)) //cluster of 4
+                        if (doCast(u, GetSpell(MIND_SEAR_1)))
+                            return;
+                }
+                if (IsSpellReady(MIND_BLAST_1, diff) && Rand() < 90 &&
+                    (!GetSpell(VAMPIRIC_TOUCH_1) || opponent->GetHealth() < me->GetMaxHealth()/2 ||
+                    opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x0, 0x400, 0x0, me->GetGUID())
+                    /*HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID())*/) &&
+                    doCast(opponent, GetSpell(MIND_BLAST_1)))
+                    return;
+                if (IsSpellReady(MIND_FLAY_1, diff) &&
+                    (opponent->isMoving() || !HasRole(BOT_ROLE_HEAL|BOT_ROLE_TANK) || opponent->GetHealth() < me->GetMaxHealth()/4) &&
+                    doCast(opponent, GetSpell(MIND_FLAY_1)))
+                    return;
+            }
+            //check horror after dots/damage
+            if (IsSpellReady(PSYCHIC_HORROR_1, diff, false) && dist < 30 &&
+                //opponent->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                opponent->GetHealth() > me->GetMaxHealth()/8 && !CCed(opponent) && Rand() < 25)
+            {
+                if (doCast(opponent, GetSpell(PSYCHIC_HORROR_1)))
+                    return;
+            }
+        }
+
+        bool HealTarget(Unit* target, uint32 diff)
+        {
+            if (!target || !target->IsAlive() || me->GetDistance(target) > 40)
+                return false;
+            uint8 hp = GetHealthPCT(target);
+            if (hp > 95 &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+            if (Rand() > 50 + 40*target->IsInCombat() + 100*master->GetMap()->IsRaid())
+                return false;
+
+            //GUARDIAN SPIRIT nod GCD
+            if (IsSpellReady(GUARDIAN_SPIRIT_1, diff, false) && !IAmFree() && target->IsInCombat() &&
+                !target->getAttackers().empty() && hp < (5 + std::min<uint32>(20, uint32(target->getAttackers().size())*5)) &&
+                IsInBotParty(target) &&
+                !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_HEALING_PCT, SPELLFAMILY_PRIEST, 0xC0000000)
+                /*!target->HasAura(GetSpell(GUARDIAN_SPIRIT_1))*/)
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(GUARDIAN_SPIRIT_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Guardian Spirit on you!", target->ToPlayer());
+                    if (target != master)
+                    {
+                        std::ostringstream msg;
+                        msg << "Guardian Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
+                        BotWhisper(msg.str().c_str());
+                    }
+                    //return true;
+                }
+            }
+
+            //PAIN SUPPRESSION
+            if (hp < 35 && IsSpellReady(PAIN_SUPPRESSION_1, diff) &&
+                target->IsInCombat() && !target->getAttackers().empty() &&
+                !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_DISPEL_RESIST, SPELLFAMILY_PRIEST, 0x80000000)
+                /*!target->HasAura(GetSpell(PAIN_SUPPRESSION_1))*/)
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(PAIN_SUPPRESSION_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Pain Suppression on you!", target->ToPlayer());
+                    if (target != master)
+                    {
+                        std::ostringstream msg;
+                        msg << "Pain Suppression on " << (target == me ? "myself" : target->GetName()) << '!';
+                        BotWhisper(msg.str().c_str());
+                    }
+                    return true;
+                }
+            }
+
+            if (IsCasting()) return false;
+
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->ToCreature() && u->ToCreature()->isWorldBoss();
+
+            //Penance
+            if (IsSpellReady(PENANCE_1, diff, false) && !target->IsCharmed() && !target->isPossessed() &&
+                (hp < 30 || (tanking && hp < 70) || GetLostHP(target) > 10000))
+            {
+                if (doCast(target, GetSpell(PENANCE_1)))
+                    return true;
+            }
+            //Big Heal
+            if (GC_Timer <= diff && (hp > 45 || !GetSpell(FLASH_HEAL_1)) &&
+                (tanking || hp < 70 || GetLostHP(target) > 12000))
+            {
+                if (doCast(target, HEAL))
+                    return true;
+            }
+            //Renew
+            if (IsSpellReady(RENEW_1, diff) && hp > 80 && (tanking || GetLostHP(target) > 3000) &&
+                !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_PRIEST, 0x40, 0x0, 0x0, me->GetGUID())
+                /*!target->HasAura(GetSpell(RENEW_1), me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(RENEW_1)))
+                    return true;
+            }
+            //Flash Heal
+            if (IsSpellReady(FLASH_HEAL_1, diff)/* && (hp < 35 || hp > 75 || GetLostHP(target) > 6000)*/)
+            {
+                if (doCast(target, GetSpell(FLASH_HEAL_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (IsSpellReady(FEAR_WARD_1, diff) && (!IAmFree() || target == me) &&
+                !target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, MECHANIC_FEAR) &&
+                doCast(target, GetSpell(FEAR_WARD_1)))
+                return true;
+
+            if (target == me)
+            {
+                uint32 INNER_FIRE = GetSpell(INNER_FIRE_1);
+                if (INNER_FIRE && !me->HasAura(INNER_FIRE) &&
+                    doCast(me, INNER_FIRE))
+                    return true;
+                uint32 VAMPIRIC_EMBRACE = GetSpell(VAMPIRIC_EMBRACE_1);
+                if (VAMPIRIC_EMBRACE && !me->HasAura(VAMPIRIC_EMBRACE) &&
+                    doCast(me, VAMPIRIC_EMBRACE))
+                    return true;
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (uint32 PW_FORTITUDE = GetSpell(PW_FORTITUDE_1))
+            {
+                if (!target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STAT, SPELLFAMILY_PRIEST, 0x8)
+                    /*!HasAuraName(target, PW_FORTITUDE)*/ &&
+                    doCast(target, PW_FORTITUDE))
+                    return true;
+            }
+            if (uint32 SHADOW_PROTECTION = GetSpell(SHADOW_PROTECTION_1))
+            {
+                if (!target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_EXCLUSIVE, SPELLFAMILY_PRIEST, 0x100)
+                    /*!HasAuraName(target, SHADOW_PROTECTION)*/ &&
+                    doCast(target, SHADOW_PROTECTION))
+                    return true;
+            }
+            if (uint32 DIVINE_SPIRIT = GetSpell(DIVINE_SPIRIT_1))
+            {
+                if ((target->GetMaxPower(POWER_MANA) > 1) &&
+                    !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STAT, SPELLFAMILY_PRIEST, 0x20)
+                    /*!HasAuraName(target, DIVINE_SPIRIT)*/ &&
+                    doCast(target, DIVINE_SPIRIT))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(RESURRECTION_1));
+
+            if (IsSpellReady(SHADOWFORM_1, diff) && HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_HEAL) && Rand() < 25)
+            {
+                if (doCast(me, SHADOWFORM_1))
+                    return;
+            }
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (CheckDispelTimer > diff || IsCasting() || Rand() > 35)
+                return;
+
+            CheckDispelTimer = urand(750, 1000);
+
+            uint32 DM = GetSpell(DISPEL_MAGIC_1);
+            uint32 MD = GetSpell(MASS_DISPEL_1);
+
+            if (!DM && !MD)
+                return;
+
+            if (Unit* target = FindHostileDispelTarget())
+            {
+                uint32 dm = DM && !target->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD) ? DM : MD;
+
+                if (dm && doCast(target, dm))
+                    return;
+            }
+        }
+
+        void CheckMending(uint32 diff)
+        {
+            if (Mend_Timer > diff || !HasRole(BOT_ROLE_HEAL) || !IsSpellReady(PRAYER_OF_MENDING_1, diff) ||
+                IAmFree() || !master->GetGroup() || IsCasting() || Rand() > 75)
+                return;
+
+            Mend_Timer = urand(1000, 2000);
+
+            if (FindAffectedTarget(PRAYER_OF_MENDING_AURA, me->GetGUID(), 60, 4))
+                return;
+
+            Group const* gr = master->GetGroup();
+            uint8 count = 0;
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL, ++count < 2; itr = itr->next());
+
+            if (count < 2)
+                return;
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->IsAlive() && me->GetMap() == player->FindMap() && !player->getAttackers().empty() &&
+                    IsTank(player) && me->GetDistance(player) < 40 &&
+                    !player->HasAura(PRAYER_OF_MENDING_AURA))
+                {
+                    if (doCast(player, GetSpell(PRAYER_OF_MENDING_1)))
+                    {
+                        return;
+                    }
+                }
+            }
+        }
+
+        void CheckShackles(uint32 diff)
+        {
+            if (Shackle_Timer > diff || !IsSpellReady(SHACKLE_UNDEAD_1, diff) || IsCasting() || Rand() > 50)
+                return;
+
+            Shackle_Timer = 500;
+
+            uint32 SHACKLE_UNDEAD = GetSpell(SHACKLE_UNDEAD_1);
+            if (FindAffectedTarget(SHACKLE_UNDEAD, me->GetGUID(), 60, 255))
+                return;
+            Unit* target = FindUndeadCCTarget(30, SHACKLE_UNDEAD);
+            if (target && doCast(target, SHACKLE_UNDEAD))
+            {}
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (IsCasting() || Rand() > 40)
+                return;
+
+            if (IsSpellReady(SILENCE_1, diff, false))
+            {
+                if (Unit* target = FindCastingTarget(30, 0, SILENCE_1))
+                    if (doCast(target, GetSpell(SILENCE_1)))
+                    {}
+            }
+            if (IsSpellReady(PSYCHIC_HORROR_1, diff))
+            {
+                if (Unit* target = FindCastingTarget(30, 0, PSYCHIC_HORROR_1))
+                    if (doCast(target, GetSpell(PSYCHIC_HORROR_1)))
+                    {}
+            }
+        }
+
+        void doDefend(uint32 diff)
+        {
+            if (Rand() > 50) return;
+
+            Unit::AttackerSet m_attackers = master->getAttackers();
+            Unit::AttackerSet b_attackers = me->getAttackers();
+
+            //fear master's attackers
+            if (IsSpellReady(PSYCHIC_SCREAM_1, diff))
+            {
+                if (!m_attackers.empty() && (!IsTank(master) || GetHealthPCT(master) < 75))
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                        return;
+                }
+
+                // Defend myself (psychic horror)
+                if (!b_attackers.empty())
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 0 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                        return;
+                }
+            }
+            // Heal myself
+            if (GetHealthPCT(me) < 95 && !b_attackers.empty())
+            {
+                if (ShieldTarget(me, diff)) return;
+
+                if (IsSpellReady(FADE_1, diff) && me->IsInCombat())
+                {
+                    if (b_attackers.empty()) return;
+                    uint8 Tattackers = 0;
+                    for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if (!(*iter)->IsAlive()) continue;
+                        if (!(*iter)->ToCreature()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if (me->GetDistance((*iter)) < 15)
+                            Tattackers++;
+                    }
+                    if (Tattackers > 0)
+                    {
+                        if (doCast(me, GetSpell(FADE_1)))
+                        {
+                            for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                                if ((*iter)->getThreatManager().getThreat(me) > 0.f)
+                                    (*iter)->getThreatManager().modifyThreatPercent(me, -50);
+                            return;
+                        }
+                    }
+                }
+            }
+        }
+
+        void DoDevCheck(uint32 diff)
+        {
+            if (DevcheckTimer <= diff)
+            {
+                Devcheck = FindAffectedTarget(GetSpell(DEVOURING_PLAGUE_1), me->GetGUID());
+                DevcheckTimer = 5000;
+            }
+        }
+
+        void Disperse(uint32 diff)
+        {
+            if (!IsSpellReady(DISPERSION_1, diff) || !me->IsInCombat() || IsCasting() || Rand() > 60)
+                return;
+            if ((me->getAttackers().size() > 3 && !IsSpellReady(FADE_1, diff, false) && GetHealthPCT(me) < 90) ||
+                (GetHealthPCT(me) < 20 && (me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) || !me->getAttackers().empty())) ||
+                (GetManaPCT(me) < 30) ||
+                (me->getAttackers().size() > 1 && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
+            {
+                if (doCast(me, GetSpell(DISPERSION_1)))
+                    return;
+            }
+
+            SetSpellCooldown(DISPERSION_1, 500); //fail
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+
+            //Improved Flash Heal (part 2): 10% additional critical chance on targets at or below 50% hp for Flash Heal
+            if (lvl >= 40 && spellId == GetSpell(FLASH_HEAL_1) && GetHealthPCT(victim) <= 50)
+                crit_chance += 10.f;
+            //Holy Specialization: 5% additional critical chance for Holy spells
+            if (lvl >= 10 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                crit_chance += 5.f;
+            //Increased Prayer of Healing Criticals (23550): 5% additional critical chance for Prayer of Healing
+            if (spellId == GetSpell(PRAYER_OF_HEALING_1))
+                crit_chance += 25.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Shadow Power: 50% additional crit damage bonus for Mind Blast, Mind Flay and SW:Death
+                if (lvl >= 40 &&
+                    (spellId == GetSpell(MIND_BLAST_1) || spellId == MIND_FLAY_DAMAGE || spellId == GetSpell(SW_DEATH_1)))
+                    pctbonus += 0.333f;
+                //Shadowform crit damage increase
+                if (me->GetShapeshiftForm() == FORM_SHADOW &&
+                    (spellId == GetSpell(SW_PAIN_1) || spellId == GetSpell(DEVOURING_PLAGUE_1) || spellId == GetSpell(VAMPIRIC_TOUCH_1)))
+                    pctbonus += 0.333f;
+            }
+            //Focused Power: 4% bonus damage for all spells
+            if (lvl >= 35)
+                pctbonus += 0.04f;
+            //Darkness: 10% bonus damage for shadow spells
+            if (lvl >= 10 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus += 0.1f;
+            //Shadowform: 15% bonus damage for shadow spells
+            if (lvl >= 40 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW) && me->HasAura(SHADOWFORM_1))
+                pctbonus += 0.15f;
+            //Twin Disciplines (damage part): 5% bonus damage for instant spells
+            if (lvl >= 13 && !spellInfo->CalcCastTime())
+                pctbonus += 0.05f;
+            //Twisted Faith (part 1): 10% bonus damage for Mind Blast and Mind Flay if target is affected BY SW: Pain
+            if (lvl >= 55 && (spellId == GetSpell(SW_PAIN_1) || spellId == MIND_FLAY_DAMAGE) &&
+                damageinfo.target && damageinfo.target->HasAura(GetSpell(SW_PAIN_1), me->GetGUID()))
+                pctbonus += 0.1f;
+            //Mind Melt (part 1): 30% bonus damage for Shadow Word: Death
+            if (lvl >= 41 && spellId == GetSpell(SW_DEATH_1))
+                pctbonus += 0.3f;
+
+            //Glyph of Mind Flay: 10% damage bonus for Mind Flay
+            if (lvl >= 25 && spellId == MIND_FLAY_DAMAGE)
+                pctbonus += 0.1f;
+
+            //other
+            if (spellId == SW_DEATH_BACKLASH)
+            {
+                ////T13 Shadow 2P Bonus (Shadow Word: Death), part 2
+                //if (lvl >= 60) //buffed
+                //    pctbonus -= 0.95f;
+                //Pain and Suffering (part 2): 40% reduced backlash damage
+                if (lvl >= 50)
+                    pctbonus -= 0.4f;
+
+                pctbonus = std::min<float>(pctbonus, 1.0f);
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //pct mods
+            //Focused Power: 4% bonus heal for all spells
+            if (lvl >= 35)
+                pctbonus += 0.04f;
+            //Improved Renew: 15% bonus healing for Renew
+            if (lvl >= 10 && spellId == GetSpell(RENEW_1))
+                pctbonus += 0.15f;
+            //Spiritual Healing: 10% bonus healing for all spells
+            if (lvl >= 35)
+                pctbonus += 0.15f;
+            //Blessend Resilience: 3% bonus healing for all spells
+            if (lvl >= 40)
+                pctbonus += 0.03f;
+            //Test of Faith: 12% bonus healing on targets at or below 50% health
+            if (lvl >= 50 && GetHealthPCT(victim) <= 50)
+                pctbonus += 0.12f;
+            //Divine Providence: 10% bonus healing for Circle of Healing, Binding Heal, Holy Nova, Prayer of Healing, Divine Hymn and Prayer of Mending
+            if (lvl >= 55 &&
+                (spellId == GetSpell(CIRCLE_OF_HEALING_1) || /*spellId == GetSpell(BINDING_HEAL_1) ||
+                spellId == GetSpell(HOLY_NOVA_1) || */spellId == GetSpell(PRAYER_OF_HEALING_1) ||
+                spellId == DIVINE_HYMN_HEAL || spellId == PRAYER_OF_MENDING_HEAL))
+                pctbonus += 0.12f;
+            //Empowered Healing: 40% bonus (from spellpower) for Greater Heal and 20% bonus (from spellpower) for Flash Heal
+            if (lvl >= 45)
+            {
+                if (spellId == HEAL)
+                    flat_mod += spellpower * 0.4f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+                else if (spellId == GetSpell(FLASH_HEAL_1))
+                    flat_mod += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            }
+            //Impowered Renew (heal bonus part): 15% bonus healing for Renew
+            if (lvl >= 50 && spellId == GetSpell(RENEW_1))
+                flat_mod += spellpower *  0.15f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * int32(stack) * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            //Priest T9 Healing 2P: 100 additional heal for Prayer of Mending
+            if (lvl >= 60 && spellId == PRAYER_OF_MENDING_HEAL)
+                pctbonus += 0.20f;
+
+            //flat mods
+            //Improved Prayer of Mending: 100 additional heal for Prayer of Mending
+            if (spellId == PRAYER_OF_MENDING_HEAL)
+                flat_mod += 100;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+        {
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Soul Warding:
+            if (lvl >= 30 && spellId == GetSpell(PW_SHIELD_1))
+                pctbonus += 0.15f;
+            //Improved Flash Heal:
+            if (lvl >= 40 && spellId == GetSpell(FLASH_HEAL_1))
+                pctbonus += 0.15f;
+            //Mental Agility:
+            if (lvl >= 25 && !spellInfo->CalcCastTime())
+                pctbonus += 0.1f;
+            //Reduced Prayer of Healing Cost (38410):
+            if (spellId == GetSpell(PRAYER_OF_HEALING_1))
+                pctbonus += 0.1f;
+            //Healing Prayers:
+            if (spellId == GetSpell(PRAYER_OF_HEALING_1) || spellId == GetSpell(PRAYER_OF_MENDING_1))
+                pctbonus += 0.2f;
+            //Improved Healing:
+            if (spellId == GetSpell(LESSER_HEAL_1) || spellId == GetSpell(NORMAL_HEAL_1) ||
+                spellId == GetSpell(GREATER_HEAL_1) || spellId == GetSpell(DIVINE_HYMN_1) || spellId == GetSpell(PENANCE_1))
+                pctbonus += 0.15f;
+            //Absolution:
+            if (lvl >= 25 &&
+                (spellId == GetSpell(DISPEL_MAGIC_1) || spellId == GetSpell(CURE_DISEASE_1) ||
+                spellId == GetSpell(MASS_DISPEL_1)))
+                pctbonus += 0.15f;
+            //Glyph of Mass Dispel
+            if (spellId == GetSpell(MASS_DISPEL_1))
+                pctbonus += 0.35f;
+            //Shadow Focus
+            if (lvl >= 15 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus += 0.06f;
+
+            //flat mods
+            //Cleanse Cost Reduced (id: 27847): -25 mana cost for Cleanse
+            //if (lvl >= 40 && spellId == GetSpell(CLEANSE_1))
+            //    flatbonus += 25;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+        {
+            //casttime is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Glyph of Turn Evil: -100% cast time for Turn Evil
+            if (spellId == GetSpell(FLASH_HEAL_1) && me->HasAura(SURGE_OF_LIGHT_BUFF))
+                pctbonus += 1.0f;
+
+            //pct mods
+            //Serendipity: -12% per stack cast time for Prayer of Mending or Greater Heal
+            if (spellId == GetSpell(GREATER_HEAL_1) || spellId == GetSpell(PRAYER_OF_HEALING_1))
+            {
+                if (Aura const* sere = me->GetAura(SERENDIPITY_BUFF))
+                    pctbonus += 0.12f * sere->GetStackAmount();
+            }
+
+            //flat mods
+            //Focused Power
+            if (lvl >= 35 && spellId == GetSpell(MASS_DISPEL_1))
+                timebonus += 1000;
+            //Difvine Fury
+            if (lvl >= 15 && (spellId == GetSpell(GREATER_HEAL_1) ||
+                spellId == GetSpell(LESSER_HEAL_1) || spellId == GetSpell(NORMAL_HEAL_1)))
+                timebonus += 500;
+
+            casttime = std::max<int32>((float(casttime) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Aspiration
+            if (lvl >= 45 && (spellId == GetSpell(PENANCE_1) || spellId == GetSpell(PAIN_SUPPRESSION_1)))
+                pctbonus += 0.2f;
+            //Divine Providence:
+            if (lvl >= 55 && spellId == GetSpell(PRAYER_OF_MENDING_1))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Penance:
+            if (spellId == GetSpell(PENANCE_1))
+                timebonus += 2000;
+            //Improved Psychic Scream:
+            if (lvl >= 20 && spellId == GetSpell(PSYCHIC_SCREAM_1))
+                timebonus += 4000;
+            //Veiled Shadow
+            if (lvl >= 25 && spellId == GetSpell(FADE_1))
+                timebonus += 6000;
+            //Improved Mind Blast
+            if (lvl >= 20 && spellId == GetSpell(MIND_BLAST_1))
+                timebonus += 2500;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Glyph of Holy Wrath: -15 sec cooldown for Holy Wrath
+            //if (lvl >= 50 && spellId == GetSpell(HOLY_WRATH_1))
+            //    timebonus += 15000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            ////Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+            //    timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Holy Reach
+            if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Mind Sear
+            if (lvl >= 75 && baseId == MIND_SEAR_DAMAGE_1)
+                flatbonus += 5.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* /*spellInfo*/)
+        {
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            if (spellId == GetSpell(PW_FORTITUDE_1))
+            {
+                if (AuraEffect* eff = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    float amount = float(eff->GetAmount());
+                    float bonus = 1.0f;
+                    //Improved PWF: +30% effect
+                    if (lvl >= 15)
+                        bonus += 0.3f;
+                    amount *= bonus;
+                    eff->ChangeAmount(int32(amount));
+                }
+            }
+            if (baseId == PW_SHIELD_1)
+            {
+                if (AuraEffect* eff = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    float amount = float(eff->GetAmount());
+                    float bonus = 1.0f;
+                    //Improved PWSH: +15% effect
+                    if (lvl >= 20)
+                        bonus += 0.15f;
+                    //Borrowed Time: +40% effect
+                    if (lvl >= 55)
+                        bonus += 0.4f;
+                    amount *= bonus;
+                    eff->ChangeAmount(int32(amount));
+                }
+            }
+
+            //Weakened Soul Reduction (id: 33333): -2 sec to Weakened Soul duration
+            if (lvl >= 51 && spellId == WEAKENED_SOUL_DEBUFF)
+                if (Aura* soul = target->GetAura(WEAKENED_SOUL_DEBUFF))
+                    soul->SetDuration(soul->GetDuration() - 2000);
+
+            //Pain and Suffering (part 1, 335 version): 100% to refresh Shadow Word: Pain on target hit by Mind Flay
+            if (lvl >= 51 && spellId == GetSpell(MIND_FLAY_1))
+                if (Aura* pain = target->GetAura(spellId, me->GetGUID()))
+                    pain->RefreshDuration();
+
+            if (spellId == GetSpell(FEAR_WARD_1))
+            {
+                //2 minutes bonus duration for Fear Ward
+                if (Aura* ward = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = ward->GetDuration() + 120000;
+                    ward->SetDuration(dur);
+                    ward->SetMaxDuration(dur);
+                }
+            }
+
+            if (baseId == INNER_FIRE_1 || baseId == VAMPIRIC_EMBRACE_1 || baseId == PW_FORTITUDE_1 ||
+                baseId == SHADOW_PROTECTION_1 || baseId == DIVINE_SPIRIT_1)
+            {
+                //1 hour duration for all buffs
+                if (Aura* buff = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    buff->SetDuration(dur);
+                    buff->SetMaxDuration(dur);
+                }
+            }
+
+            //convert to effect bonus somehow, this code gonna cause constant stack
+            //if (baseId == PRAYER_OF_MENDING_AURA)
+            //{
+            //    //Prayer of Mending Bounce (60154): +1 charge
+            //    if (Aura* mend = target->GetAura(spellId, me->GetGUID()))
+            //    {
+            //        mend->SetCharges(mend->GetCharges() + 1);
+            //    }
+            //}
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            //uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Glyph of Inner Fire + Improved Inner Fire:
+            if (lvl >= 15 && spellId == GetSpell(INNER_FIRE_1))
+            {
+                if (Aura* fire = me->GetAura(spellId))
+                {
+                    fire->SetCharges(fire->GetCharges() + 12);
+                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                        if (AuraEffect* eff = fire->GetEffect(i))
+                            eff->ChangeAmount(i == 0 ? 1.45f*1.5f : 1.45f);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Shackle_Timer = 0;
+
+            CheckDispelTimer = 0;
+            DevcheckTimer = 0;
+
+            Devcheck = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Shackle_Timer > diff)               Shackle_Timer -= diff;
+            if (Mend_Timer > diff)                  Mend_Timer -= diff;
+
+            if (CheckDispelTimer > diff)            CheckDispelTimer -= diff;
+            if (DevcheckTimer > diff)               DevcheckTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(DISPEL_MAGIC_1);
+            InitSpellMap(MASS_DISPEL_1);
+            InitSpellMap(CURE_DISEASE_1);
+            InitSpellMap(FEAR_WARD_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(PAIN_SUPPRESSION_1) : RemoveSpell(PAIN_SUPPRESSION_1);
+            InitSpellMap(PSYCHIC_SCREAM_1);
+            InitSpellMap(FADE_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(PSYCHIC_HORROR_1) : RemoveSpell(PSYCHIC_HORROR_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(SILENCE_1) : RemoveSpell(SILENCE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(PENANCE_1) : RemoveSpell(PENANCE_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(VAMPIRIC_EMBRACE_1) : RemoveSpell(VAMPIRIC_EMBRACE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(DISPERSION_1) : RemoveSpell(DISPERSION_1);
+            InitSpellMap(MIND_SEAR_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(GUARDIAN_SPIRIT_1) : RemoveSpell(GUARDIAN_SPIRIT_1);
+            InitSpellMap(SHACKLE_UNDEAD_1);
+            InitSpellMap(GREATER_HEAL_1);
+            InitSpellMap(NORMAL_HEAL_1);
+            InitSpellMap(LESSER_HEAL_1);
+            InitSpellMap(RENEW_1);
+            InitSpellMap(FLASH_HEAL_1);
+            InitSpellMap(PRAYER_OF_HEALING_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(CIRCLE_OF_HEALING_1) : RemoveSpell(CIRCLE_OF_HEALING_1);
+            InitSpellMap(DIVINE_HYMN_1);
+            InitSpellMap(PRAYER_OF_MENDING_1);
+            InitSpellMap(RESURRECTION_1);
+            InitSpellMap(PW_SHIELD_1);
+            InitSpellMap(INNER_FIRE_1);
+            InitSpellMap(PW_FORTITUDE_1);
+            InitSpellMap(SHADOW_PROTECTION_1);
+            InitSpellMap(DIVINE_SPIRIT_1);
+            InitSpellMap(SMITE_1);
+            InitSpellMap(SW_PAIN_1);
+            InitSpellMap(MIND_BLAST_1);
+            InitSpellMap(SW_DEATH_1);
+            InitSpellMap(DEVOURING_PLAGUE_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(MIND_FLAY_1) : RemoveSpell(MIND_FLAY_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(VAMPIRIC_TOUCH_1) : RemoveSpell(VAMPIRIC_TOUCH_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(SHADOWFORM_1) : RemoveSpell(SHADOWFORM_1);
+
+            //Always usable
+            HEAL = GetSpell(GREATER_HEAL_1) ? GetSpell(GREATER_HEAL_1) :
+                GetSpell(NORMAL_HEAL_1) ? GetSpell(NORMAL_HEAL_1) :
+                GetSpell(LESSER_HEAL_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(BORROWED_TIME, level >= 65 ? 1 : 0);
+            RefreshAura(DIVINE_AEGIS, level >= 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW3, level >= 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW2, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW1, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(BODY_AND_SOUL1, level >= 45 ? 1 : 0);
+            RefreshAura(RENEWED_HOPE, level >= 45 ? 1 : 0);
+            RefreshAura(PAINANDSUFFERING3, level >= 50 ? 1 : 0);
+            RefreshAura(PAINANDSUFFERING2, level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(PAINANDSUFFERING1, level >= 45 && level < 48 ? 1 : 0);
+            RefreshAura(MISERY3, level >= 50 ? 1 : 0);
+            RefreshAura(MISERY2, level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(MISERY1, level >= 45 && level < 48 ? 1 : 0);
+            RefreshAura(GRACE, level >= 25 ? 1 : 0);
+            RefreshAura(ENLIGHTENMENT, level >= 35 ? 1 : 0);
+            RefreshAura(RAPTURE, level >= 45 ? 1 : 0);
+            RefreshAura(SPIRIT_TAP, level >= 10 ? 1 : 0);
+            RefreshAura(IMPROVED_SPIRIT_TAP, level >= 10 ? 1 : 0);
+            RefreshAura(IMPROVED_DEVOURING_PLAGUE, level >= 25 ? 1 : 0);
+            RefreshAura(INSPIRATION3, level >= 25 ? 1 : 0);
+            RefreshAura(INSPIRATION2, level >= 23 && level < 25 ? 1 : 0);
+            RefreshAura(INSPIRATION1, level >= 20 && level < 23 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING3, level >= 30 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING2, level >= 28 && level < 30 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING1, level >= 25 && level < 28 ? 1 : 0);
+            RefreshAura(SURGE_OF_LIGHT, level >= 35 ? 1 : 0);
+            RefreshAura(MEDITATION, level >= 20 ? 1 : 0);
+            RefreshAura(HOLY_CONCENTRATION, level >= 40 ? 1 : 0);
+            RefreshAura(SERENDIPITY, level >= 45 ? 1 : 0);
+            //RefreshAura(GLYPH_SW_PAIN, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_PW_SHIELD, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_PRAYER_OF_HEALING, level >= 30 ? 1 : 0);
+            RefreshAura(PRIEST_T10_2P_BONUS, level >= 70 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case DISPEL_MAGIC_1:
+                case MASS_DISPEL_1:
+                case CURE_DISEASE_1:
+                case FEAR_WARD_1:
+                case PAIN_SUPPRESSION_1:
+                case FADE_1:
+                case PENANCE_1:
+                case VAMPIRIC_EMBRACE_1:
+                case DISPERSION_1:
+                case GUARDIAN_SPIRIT_1:
+                case LESSER_HEAL_1:
+                case NORMAL_HEAL_1:
+                case GREATER_HEAL_1:
+                case RENEW_1:
+                case FLASH_HEAL_1:
+                case PRAYER_OF_HEALING_1:
+                case CIRCLE_OF_HEALING_1:
+                case DIVINE_HYMN_1:
+                case PRAYER_OF_MENDING_1:
+                case PW_SHIELD_1:
+                case INNER_FIRE_1:
+                case PW_FORTITUDE_1:
+                case SHADOW_PROTECTION_1:
+                case DIVINE_SPIRIT_1:
+                case SHADOWFORM_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 HEAL;
+        uint32 Shackle_Timer, Mend_Timer;
+/*Misc*/uint16 CheckDispelTimer, DevcheckTimer;
+/*Misc*/bool Devcheck;
+
+        enum PriestBaseSpells
+        {
+            DISPEL_MAGIC_1                      = 527,
+            MASS_DISPEL_1                       = 32375,
+            CURE_DISEASE_1                      = 528,
+            FEAR_WARD_1                         = 6346,
+  /*Talent*/PAIN_SUPPRESSION_1                  = 33206,
+            PSYCHIC_SCREAM_1                    = 8122,
+            FADE_1                              = 586,
+  /*Talent*/PSYCHIC_HORROR_1                    = 64044,
+  /*Talent*/SILENCE_1                           = 15487,
+  /*Talent*/PENANCE_1                           = 47540,
+  /*Talent*/VAMPIRIC_EMBRACE_1                  = 15286,
+  /*Talent*/DISPERSION_1                        = 47585,
+            MIND_SEAR_1                         = 48045,
+  /*Talent*/GUARDIAN_SPIRIT_1                   = 47788,
+            SHACKLE_UNDEAD_1                    = 9484,
+            LESSER_HEAL_1                       = 2050,
+            NORMAL_HEAL_1                       = 2054,
+            GREATER_HEAL_1                      = 2060,
+            RENEW_1                             = 139,
+            FLASH_HEAL_1                        = 2061,
+            PRAYER_OF_HEALING_1                 = 596,
+            CIRCLE_OF_HEALING_1                 = 34861,
+            DIVINE_HYMN_1                       = 64843,
+            PRAYER_OF_MENDING_1                 = 33076,
+            RESURRECTION_1                      = 2006,
+            PW_SHIELD_1                         = 17,
+            INNER_FIRE_1                        = 588,
+            PW_FORTITUDE_1                      = 1243,
+            SHADOW_PROTECTION_1                 = 976,
+            DIVINE_SPIRIT_1                     = 14752,
+            SMITE_1                             = 585,
+            SW_PAIN_1                           = 589,
+            MIND_BLAST_1                        = 8092,
+            SW_DEATH_1                          = 32379,
+            DEVOURING_PLAGUE_1                  = 2944,
+  /*Talent*/MIND_FLAY_1                         = 15407,
+  /*Talent*/VAMPIRIC_TOUCH_1                    = 34914,
+            SHADOWFORM_1                        = 15473
+        };
+        enum PriestPassives
+        {
+        //Talents
+            SPIRIT_TAP                      = 15336,//rank 3
+            IMPROVED_SPIRIT_TAP             = 15338,//rank 2
+            IMPROVED_DEVOURING_PLAGUE       = 63627,//rank 3
+            MISERY1                         = 33191,
+            MISERY2                         = 33192,
+            MISERY3                         = 33193,
+            PAINANDSUFFERING1               = 47580,
+            PAINANDSUFFERING2               = 47581,
+            PAINANDSUFFERING3               = 47582,
+            SHADOW_WEAVING1                 = 15257,
+            SHADOW_WEAVING2                 = 15331,
+            SHADOW_WEAVING3                 = 15332,
+            DIVINE_AEGIS                    = 47515,//rank 3
+            BORROWED_TIME                   = 52800,//rank 5
+            GRACE                           = 47517,//rank 2
+            EMPOWERED_RENEW1                = 63534,
+            EMPOWERED_RENEW2                = 63542,
+            EMPOWERED_RENEW3                = 63543,
+            INSPIRATION1                    = 14892,
+            INSPIRATION2                    = 15362,
+            INSPIRATION3                    = 15363,
+            BODY_AND_SOUL1                  = 64127,
+            RENEWED_HOPE                    = 57472,//rank 3
+            ENLIGHTENMENT                   = 34910,//rank 3
+            RAPTURE                         = 47537,//rank 3
+            SURGE_OF_LIGHT                  = 33154,//rank 2
+            MEDITATION                      = 14777,//rank 3
+            HOLY_CONCENTRATION              = 34860,//rank 3
+            SERENDIPITY                     = 63737,//rank 3
+        //Glyphs
+            //GLYPH_SW_PAIN                   = 55681,
+            GLYPH_PW_SHIELD                 = 55672,
+            GLYPH_PRAYER_OF_HEALING         = 55680,
+        //other
+            PRIEST_T10_2P_BONUS             = 70770 //33% renew
+        };
+        enum PriestSpecial
+        {
+            //IMPROVED_DEVOURING_PLAGUE_DAMAGE= 63675,
+            MIND_FLAY_DAMAGE                = 58381,
+            MIND_SEAR_DAMAGE_1              = 49821,
+            SW_DEATH_BACKLASH               = 32409,
+            WEAKENED_SOUL_DEBUFF            = 6788,
+            SURGE_OF_LIGHT_BUFF             = 33151,
+            SERENDIPITY_BUFF                = 63734,
+            DIVINE_HYMN_HEAL                = 64844,
+            PRAYER_OF_MENDING_AURA          = 41635,
+            PRAYER_OF_MENDING_HEAL          = 33110
+        };
+    };
+};
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
new file mode 100644
index 0000000..74d353e
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
@@ -0,0 +1,1967 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "Spell.h"
+/*
+Rogue NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 90%
+TODO:
+*/
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new rogue_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct rogue_botAI : public bot_minion_ai
+    {
+        rogue_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_ROGUE;
+
+            //int8 id = 1;
+            //EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            //ASSERT(einfo && "rogue_botAI failed to init standard equips!");
+            //standardEquips[0] = einfo->ItemEntry[0];
+            //standardEquips[1] = einfo->ItemEntry[1];
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_ROGUE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force, u);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void AttackStart(Unit*) { targetPoisoned = false; }
+        void KilledUnit(Unit* u) { bot_minion_ai::KilledUnit(u); }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { comboPoints = 0; bot_minion_ai::JustDied(u); }
+
+        void getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+        }
+
+        int32 ecost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            getenergy();
+
+            CheckAuras();
+            if (Wait())
+                return;
+            GenerateRand();
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            CheckRacials(diff);
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            CheckSprint(diff);
+            CheckCloakOfShadows(diff);
+            CheckVanish(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_ROGUE))
+            {
+                if (!me->IsInCombat() && Rand() < 5 && me->HasAuraType(SPELL_AURA_MOD_STEALTH))
+                    me->RemoveAurasDueToSpell(STEALTH_1);
+                return;
+            }
+
+            CheckBlind(diff);
+            CheckPreparation(diff);
+            CheckTricksOfTheTrade(diff);
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            float dist = me->GetDistance(opponent);
+
+            //Stealth (for Cooldown handling see bot_ai::ReleaseSpellCooldown)
+            //we don't want rogue to swith into stealth for no purpose
+            if (IsSpellReady(STEALTH_1, diff, false) && !me->IsInCombat() && !IsTank() && Rand() < 50 && dist < 28 &&
+                (!me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) || (opponent->GetTypeId() == TYPEID_PLAYER && dist < 6)) &&
+                (me->getLevel() >= 35 || (energy >= 40 && me->getLevel() >= 30) || dist > 8))
+            {
+                if (doCast(me, GetSpell(STEALTH_1)))
+                {}
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+            {
+                //TC_LOG_ERROR("entities.player", "rogue_bot: cannot attack target...");
+                return;
+            }
+
+            bool stealthed = me->HasAuraType(SPELL_AURA_MOD_STEALTH);
+            bool shadowdance = me->HasAuraType(SPELL_AURA_MOD_IGNORE_SHAPESHIFT);
+
+            //Hunger for Blood
+            if (IsSpellReady(HUNGER_FOR_BLOOD_1, diff) && !shadowdance && HasRole(BOT_ROLE_DPS) && Rand() < 20 && dist < 30 &&
+                opponent->HasAuraState(AURA_STATE_BLEEDING) && energy >= ecost(HUNGER_FOR_BLOOD_1) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_ROGUE, 0x0, 0x1000000, 0x0))
+            {
+                if (doCast(opponent, GetSpell(HUNGER_FOR_BLOOD_1)))
+                    return;
+            }
+            //Premeditation
+            if (IsSpellReady(PREMEDITATION_1, diff, false) && (stealthed || shadowdance) &&
+                HasRole(BOT_ROLE_DPS) && comboPoints < 4 && Rand() < 90 && dist < 15 &&
+                (comboPoints == 0 || opponent->GetHealth() > me->GetMaxHealth() / 4))
+            {
+                if (doCast(opponent, GetSpell(PREMEDITATION_1)))
+                {}
+            }
+            //Kick
+            if (IsSpellReady(KICK_1, diff, false) && !stealthed && dist <= 5 && Rand() < 60 &&
+                energy >= ecost(KICK_1) && opponent->IsNonMeleeSpellCasted(false,false,true))
+            {
+                if (doCast(opponent, GetSpell(KICK_1)))
+                    getenergy();
+            }
+            //Killing Spree
+            if (IsSpellReady(KILLING_SPREE_1, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) &&
+                Rand() < (70 - energy) && dist < 10 && GetHealthPCT(me) > 25 && (!CCed(opponent) || dist > 5) &&
+                (opponent->getAttackers().size() < 4 || opponent->GetMaxHealth() > me->GetMaxHealth() * 2) &&
+                (opponent->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1))
+            {
+                if (doCast(opponent, GetSpell(KILLING_SPREE_1)))
+                    return;
+            }
+             //Gouge: if opponent is trying to attack/cast on us he will always try to face us
+            if (IsSpellReady(GOUGE_1, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) && dist <= 5 &&
+                Rand() < 30 && !CCed(opponent) && energy >= ecost(GOUGE_1) &&
+                ((energy < 55 && opponent->getAttackers().size() <= 1 && !opponent->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                opponent->IsNonMeleeSpellCasted(false,false,true)) && opponent->HasInArc(M_PI, me))
+            {
+                if (doCast(opponent, GetSpell(GOUGE_1)))
+                    return;
+            }
+            //Blind: in pvp only for restealth
+            if (IsSpellReady(BLIND_1, diff) && !stealthed && !shadowdance && dist <= 15 && Rand() < 30 &&
+                !CCed(opponent) && energy >= ecost(BLIND_1) &&
+                ((energy <= 30 && opponent->GetTarget() == me->GetGUID() &&
+                opponent->getAttackers().size() <= 1 &&
+                !opponent->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) &&
+                !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                (opponent->GetTypeId() == TYPEID_UNIT &&
+                !IsSpellReady(KICK_1, diff) && !IsSpellReady(GOUGE_1, diff) &&
+                opponent->IsNonMeleeSpellCasted(false,false,true))))
+            {
+                if (doCast(opponent, GetSpell(BLIND_1)))
+                    return;
+            }
+            //Blade Flurry
+            if (IsSpellReady(BLADE_FLURRY_1, diff) && HasRole(BOT_ROLE_DPS) && !stealthed && !shadowdance &&
+                dist <= 5 && Rand() < 30 && energy >= ecost(BLADE_FLURRY_1) && !CCed(opponent) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000000, 0x800, 0x0) &&
+                (opponent->GetTypeId() == TYPEID_PLAYER || opponent->GetHealth() > me->GetHealth() || FindSplashTarget(7, opponent)))
+            {
+                if (doCast(me, GetSpell(BLADE_FLURRY_1)))
+                    return;
+            }
+            //Slice and Dice: not in mutilate spec
+            if (IsSpellReady(SLICE_DICE_1, diff) && !shadowdance && !isdaggerMH && HasRole(BOT_ROLE_DPS) && comboPoints > 0 &&
+                Rand() < 30 && energy >= ecost(SLICE_DICE_1) && dist < 10 &&
+                (me->getAttackers().size() <= 1 || !IsSpellReady(BLADE_FLURRY_1, diff)) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000, 0x0, 0x0))
+            {
+                if (doCast(opponent, GetSpell(SLICE_DICE_1)))
+                    return;
+            }
+            //Dismantle
+            if (IsSpellReady(DISMANTLE_1, diff) && !stealthed && !shadowdance &&
+                opponent->GetHealth() >= me->GetHealth() / 2 && energy >= ecost(DISMANTLE_1) && dist <= 5 &&
+                !CCed(opponent) && Rand() < (30 + 90*opponent->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY)) &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (opponent->GetTypeId() == TYPEID_PLAYER ?
+                opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) && opponent->ToPlayer()->IsUseEquipedWeapon(true) :
+                opponent->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID) && opponent->CanUseAttackType(BASE_ATTACK)))
+            {
+                if (doCast(opponent, GetSpell(DISMANTLE_1)))
+                    return;
+            }
+            //Shadowstep
+            if (IsSpellReady(SHADOWSTEP_1, diff, false) && !IsTank() && HasRole(BOT_ROLE_DPS) &&
+                Rand() < 30 && dist < 25 && energy >= ecost(SHADOWSTEP_1) &&
+                (opponent->GetTypeId() != TYPEID_PLAYER || dist > 12 || CCed(me, true)) &&
+                (opponent->GetTypeId() == TYPEID_PLAYER || opponent->GetVictim() != me) &&
+                ((!stealthed && !shadowdance) || me->HasAuraWithMechanic(1<<MECHANIC_SNARE)))
+            {
+                if (doCast(opponent, GetSpell(SHADOWSTEP_1)))
+                    getenergy();
+            }
+            //Sprint (no GCD)
+            if (IsSpellReady(SPRINT_1, diff, false) && ((me->getLevel() >= 20 && CCed(me, true) && Rand() < 35) ||
+                (Rand() < (25 + 10*stealthed + 40*shadowdance) && dist > (20 - (5*stealthed + 10*shadowdance)))) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_INCREASE_SPEED, SPELLFAMILY_ROGUE, 0x40, 0x0, 0x0))
+            {
+                if (doCast(me, GetSpell(SPRINT_1)))
+                {}
+            }
+            //Evasion (no GCD)
+            if (IsSpellReady(EVASION_1, diff, false) && !stealthed && Rand() < 35 && !me->getAttackers().empty() &&
+                GetHealthPCT(me) < 65 + 10 * me->getAttackers().size() &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_DODGE_PERCENT, SPELLFAMILY_ROGUE, 0x20, 0x0, 0x0))
+            {
+                if (doCast(me, GetSpell(EVASION_1)))
+                    return; //custom: do not skip animation
+            }
+            //Deadly Throw
+            if (IsSpellReady(DEADLY_THROW_1, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) &&
+                comboPoints > 0 && Rand() < 40 && dist < 30 && dist > 5 && energy >= ecost(DEADLY_THROW_1) &&
+                opponent->IsNonMeleeSpellCasted(false,false,true))
+            {
+                Item const* thrown = GetEquips(BOT_SLOT_RANGED);
+                if (thrown && thrown->GetTemplate()->Class == ITEM_CLASS_WEAPON &&
+                    thrown->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_THROWN &&
+                    doCast(opponent, GetSpell(DEADLY_THROW_1)))
+                    return;
+            }
+
+            //if target is affected by gouge or blind just try to regen some energy
+            bool hasnormalstun = false;
+            int32 duration = 0;
+            //sizes of theese are typically 1, sometimes maybe 2
+            Unit::AuraEffectList const& stunAuras = opponent->GetAuraEffectsByType(SPELL_AURA_MOD_STUN);
+            for (Unit::AuraEffectList::const_iterator itr = stunAuras.begin(); itr != stunAuras.end(); ++itr)
+            {
+                if (!((*itr)->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE) &&
+                    (*itr)->GetBase()->GetDuration() > 2000)
+                {
+                    hasnormalstun = true;
+                    break;
+                }
+                if ((*itr)->GetBase()->GetDuration() > duration)
+                    duration = (*itr)->GetBase()->GetDuration();
+            }
+            if (!hasnormalstun)
+            {
+                Unit::AuraEffectList const& confuseAuras = opponent->GetAuraEffectsByType(SPELL_AURA_MOD_CONFUSE);
+                for (Unit::AuraEffectList::const_iterator itr = confuseAuras.begin(); itr != confuseAuras.end(); ++itr)
+                {
+                    if (!((*itr)->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE) &&
+                        (*itr)->GetBase()->GetDuration() > 2000)
+                    {
+                        hasnormalstun = true;
+                        break;
+                    }
+                    if ((*itr)->GetBase()->GetDuration() > duration)
+                        duration = (*itr)->GetBase()->GetDuration();
+                }
+            }
+
+            //Vanish (no GCD)
+            if (IsSpellReady(VANISH_1, diff, false) && !stealthed && !shadowdance && !IsTank() && Rand() < 25 && !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+            {
+                bool cast = false;
+                //case 1: restealth for opener
+                if (!hasnormalstun && duration < 500 && me->IsInCombat() && dist <= 5)
+                    cast = true;
+                //case 2: evade casted spell
+                if (!cast)
+                {
+                    if (Spell const* spell = opponent->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                    {
+                        if (spell->m_targets.GetUnitTarget() == me && spell->GetTimer() < 500 &&
+                            spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE))
+                            cast = true;
+                    }
+                }
+                //case 3: reset threat / evade in CheckVanish (regardless of opponent availability)
+                if (cast && doCast(me, GetSpell(VANISH_1)))
+                    return; //custom: do not skip animation
+            }
+
+            if (dist > 5)
+            {
+                //if (opponent->IsPolymorphed())
+                //    TC_LOG_ERROR("entities.player", "rogue_bot: cannot attack target (dist)...");
+                return;
+            }
+
+            MoveBehind(opponent);
+
+            if (IsSpellReady(THISTLE_TEA, diff, false) && !hasnormalstun && duration < 1000 &&
+                energy <= std::max<int32>(me->GetMaxPower(POWER_ENERGY) - 110, 10))
+            {
+                if (doCast(me, THISTLE_TEA))
+                    getenergy();
+            }
+
+            //No IsSpellReady checks for spells with no cd below
+            if (GC_Timer > diff)
+                return;
+
+            //Feint
+            if (opponent->CanHaveThreatList())
+            {
+                if (IsSpellReady(FEINT_1, diff) && !stealthed && !IsTank() && opponent->GetVictim() == me && Rand() < 15 &&
+                    energy >= ecost(FEINT_1) && int32(opponent->getThreatManager().getThreatList().size()) > 1 &&
+                    int32(opponent->getAttackers().size()) > 1)
+                {
+                    if (doCast(opponent, GetSpell(FEINT_1)))
+                        return;
+                }
+            }
+
+            //Adrenaline Rush
+            if (GetSpell(ADRENALINE_RUSH_1) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) && (hasnormalstun || duration < 1300) && Rand() < 40 &&
+                energy < 50 && GetHealthPCT(me) > 35 &&
+                (opponent->getAttackers().size() < 3 || opponent->GetMaxHealth() > me->GetMaxHealth() * 2) &&
+                (opponent->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1))
+            {
+                if (doCast(me, GetSpell(ADRENALINE_RUSH_1)))
+                    return;
+            }
+
+            DiminishingLevels const stunDivider = opponent->GetDiminishing(DIMINISHING_OPENING_STUN);
+
+            //Rupture: little troll with applying rupture on target without breaking gouge (creatures only, pvp - restealth)
+            if (GetSpell(RUPTURE_1) && !stealthed && !shadowdance && comboPoints > 1 && HasRole(BOT_ROLE_DPS) &&
+                (hasnormalstun || (opponent->CanHaveThreatList() && duration < 2000)) &&
+                (comboPoints < 4 || !GetSpell(KIDNEY_SHOT_1) || stunDivider > DIMINISHING_LEVEL_2) &&
+                energy >= ecost(RUPTURE_1) && opponent->GetHealth() > me->GetMaxHealth() / 2 &&
+                Rand() < (40 + 40 * (opponent->GetTypeId() == TYPEID_PLAYER && IsMeleeClass(opponent->getClass()))) &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x100000, 0x0, 0x0, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(RUPTURE_1)))
+                    return;
+            }
+
+            if (!hasnormalstun && duration > 300 && uint32(energy) < me->GetMaxPower(POWER_ENERGY))
+            {
+                //TC_LOG_ERROR("entities.player", "bot_rogue: delaying attacks on gouged or blinded target...");
+                return;
+            }
+
+            //Finishers
+            if (comboPoints > 0)
+            {
+                //Kidney Shot
+                if (GetSpell(KIDNEY_SHOT_1) && !stealthed && stunDivider < DIMINISHING_LEVEL_4 &&
+                    Rand() < 80 && !CCed(opponent) &&
+                    ((comboPoints >= 4 && stunDivider < DIMINISHING_LEVEL_3 &&
+                    (opponent->GetHealth() > me->GetMaxHealth() / 2 || opponent->GetTypeId() == TYPEID_PLAYER)) ||
+                    opponent->IsNonMeleeSpellCasted(false,false,true)) &&
+                    energy >= ecost(KIDNEY_SHOT_1))
+                {
+                    if (doCast(opponent, GetSpell(KIDNEY_SHOT_1)))
+                        return;
+                }
+                //Eviscerate
+                if (IsSpellReady(EVISCERATE_1, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) &&
+                    (comboPoints >= 4 || opponent->GetHealth() < me->GetMaxHealth() / 4) &&
+                    energy >= ecost(EVISCERATE_1) && Rand() < (50 + comboPoints * 20))
+                {
+                    //Cold Blood (no GCD)
+                    if (IsSpellReady(COLD_BLOOD_1, diff, false) && comboPoints == 5)
+                        if (doCast(me, GetSpell(COLD_BLOOD_1)))
+                        {}
+                    if (doCast(opponent, GetSpell(EVISCERATE_1)))
+                        return;
+                }
+            }
+
+            //Shadow Dance: if have energy or under effect of Adrenaline Rush
+            if (IsSpellReady(SHADOW_DANCE_1, diff, false) && !stealthed && HasRole(BOT_ROLE_DPS) &&
+                (energy >= 60 || (energy >= 40 && me->GetAuraEffect(SPELL_AURA_MOD_POWER_REGEN_PERCENT, SPELLFAMILY_ROGUE, 0x0, 0x80, 0x0))) &&
+                Rand() < 30 && GetHealthPCT(me) > 50 && (stunDivider == DIMINISHING_LEVEL_1 || CCed(opponent)) &&
+                (opponent->GetTypeId() == TYPEID_PLAYER || opponent->GetHealth() > (me->GetMaxHealth() / 4) * opponent->getAttackers().size()))
+            {
+                if (doCast(me, GetSpell(SHADOW_DANCE_1)))
+                {}
+            }
+
+            //Openers
+            if (stealthed || shadowdance)
+            {
+                uint32 opener =
+                    GetSpell(CHEAP_SHOT_1) &&
+                    !opponent->HasAuraType(SPELL_AURA_MOD_STUN) && stunDivider < DIMINISHING_LEVEL_3 &&
+                    (opponent->GetTypeId() == TYPEID_PLAYER || (!IAmFree() && master->GetNpcBotsCount() > 1)) ? CHEAP_SHOT_1 :
+                    GetSpell(GARROTE_1) && HasRole(BOT_ROLE_DPS) && opponent->GetHealth() > me->GetMaxHealth() / 4 &&
+                    !opponent->IsImmunedToSpellEffect(sSpellMgr->GetSpellInfo(GARROTE_1), 0) &&
+                    (!isdaggerMH || (opponent->GetTypeId() == TYPEID_PLAYER &&
+                    (opponent->getClass() == CLASS_MAGE || opponent->getClass() == CLASS_PRIEST || opponent->getClass() == CLASS_WARLOCK))) &&
+                    !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x100, 0x0, 0x0, me->GetGUID()) ? GARROTE_1 :
+                    GetSpell(AMBUSH_1) && HasRole(BOT_ROLE_DPS) && isdaggerMH ? AMBUSH_1 :
+                    GetSpell(BACKSTAB_1) && HasRole(BOT_ROLE_DPS) && isdaggerMH ? BACKSTAB_1 : 0;
+
+                //all opener spells disabled/unusable
+                if (!opener)
+                {
+                    if (stealthed && HasRole(BOT_ROLE_DPS))
+                        me->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+                    //if (shadowdance)
+                    //    me->RemoveAurasByType(SPELL_AURA_MOD_IGNORE_SHAPESHIFT);
+
+                    return;
+                }
+                //openers from behind (backstab too)
+                if (opener != CHEAP_SHOT_1 && opponent->HasInArc(M_PI, me))
+                    return;
+
+                //We do not check combo points amount
+                if (energy >= ecost(opener))
+                {
+                    if (doCast(opponent, GetSpell(opener)))
+                        return;
+                }
+
+                return;
+            }
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            //Fan of Knives
+            if (GetSpell(FAN_OF_KNIVES_1) && energy >= ecost(FAN_OF_KNIVES_1) &&
+                Rand() < 35
+                + 40*(me->GetAuraEffect(SPELL_AURA_MOD_POWER_REGEN_PERCENT, SPELLFAMILY_ROGUE, 0x0, 0x80, 0x0) != NULL)
+                + 50*(me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000000, 0x800, 0x0) != NULL)
+                /*Adrenaline Rush and Blade Flurry*/)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 7.f);
+                if (targets.size() > 2 && doCast(me, GetSpell(FAN_OF_KNIVES_1)))
+                    return;
+            }
+
+            //Combo points generating
+            //Hemorrhage: does not stack from different casters
+            if (GetSpell(HEMORRHAGE_1) && !isdaggerMH && comboPoints < 5 && Rand() < 55 && energy >= ecost(HEMORRHAGE_1) &&
+                !opponent->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_TAKEN, SPELLFAMILY_ROGUE, 0x2800000, 0x0, 0x0))
+            {
+                if (doCast(opponent, GetSpell(HEMORRHAGE_1)))
+                    return;
+            }
+            //Riposte: only after parry
+            if (IsSpellReady(RIPOSTE_1, diff) && comboPoints < 5 && me->HasReactive(REACTIVE_DEFENSE) && Rand() < 45 &&
+                energy >= ecost(RIPOSTE_1))
+            {
+                if (doCast(opponent, GetSpell(RIPOSTE_1)))
+                    return;
+            }
+            //Ghostly Strike: tank mode only
+            if (IsSpellReady(GHOSTLY_STRIKE_1, diff) && comboPoints < 5 && IsTank() && !me->getAttackers().empty() &&
+                GetHealthPCT(me) < 90 && Rand() < 75 && energy >= ecost(GHOSTLY_STRIKE_1))
+            {
+                if (doCast(opponent, GetSpell(GHOSTLY_STRIKE_1)))
+                    return;
+            }
+            //Sinister Strike: tank mode or no hemo
+            if (GetSpell(SINISTER_STRIKE_1) && comboPoints < 5 && Rand() < (25 + energy/4) &&
+                (IsTank() || opponent->GetVictim() == me || (!isdaggerMH && !GetSpell(HEMORRHAGE_1)) || !GetSpell(BACKSTAB_1)) &&
+                energy >= ecost(SINISTER_STRIKE_1))
+            {
+                if (doCast(opponent, GetSpell(SINISTER_STRIKE_1)))
+                    return;
+            }
+            //Backstab/Mutilate
+            uint32 mutistab =
+                isdaggerMH && isdaggerOH && targetPoisoned && GetSpell(MUTILATE_1) ? MUTILATE_1 : isdaggerMH && GetSpell(BACKSTAB_1) ? BACKSTAB_1 : 0;
+            if (mutistab && comboPoints < 4 && Rand() < (35 + energy/4) && energy >= ecost(mutistab) && (mutistab == MUTILATE_1 || !opponent->HasInArc(M_PI, me)))
+            {
+                if (doCast(opponent, GetSpell(mutistab)))
+                    return;
+            }
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (me->IsInCombat() && Rand() < 25)
+            {
+                bool canVanish = IsSpellReady(VANISH_1, diff, false);
+                bool canSprint = me->getLevel() >= 25 && IsSpellReady(SPRINT_1, diff, false);
+                if ((canVanish || canSprint) && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+                {
+                    uint32 Spanish = canSprint ? SPRINT_1 : VANISH_1;
+                    if (doCast(me, GetSpell(Spanish)))
+                        return;
+                }
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting() || Rand() > 25)
+                return;
+
+            if (mhEnchantExpireTimer > 0 && mhEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* mh = GetEquips(BOT_SLOT_MAINHAND))
+                    if (mh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            mh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+            if (ohEnchantExpireTimer > 0 && ohEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* oh = GetEquips(BOT_SLOT_OFFHAND))
+                    if (oh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            oh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+
+            // Weapon Enchants
+            uint8 lvl = me->getLevel();
+            if (lvl < 20)
+                return;
+
+            Item* mhWeapon = GetEquips(BOT_SLOT_MAINHAND);
+            Item* ohWeapon = GetEquips(BOT_SLOT_OFFHAND);
+            //item must be non-standard, otherwise combat spells won't be rolled anyway
+            bool mhReady = mhWeapon && !mhWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && mhWeapon->GetEntry() != standardEquips[0]*/;
+            bool ohReady = ohWeapon && !ohWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && ohWeapon->GetEntry() != standardEquips[1]*/;
+            if (!mhReady && !ohReady)
+                return; //no ecnhantable weapons
+
+            //OK choose the poisons
+            //MH 20+ Instant, 32+ Wound
+            //OH 20+ Crippling, 40+ Instant (deadly brew inc), 68+ Anesthetic
+            if (needChooseMHEnchant && mhReady)
+                mhEnchant = me->getLevel() >= 32 ? WOUND_POISON_1 :
+                    me->getLevel() >= 20 ? INSTANT_POISON_1 : 0;
+
+            if (needChooseOHEnchant && ohReady)
+                ohEnchant = me->getLevel() >= 68 ? ANESTHETIC_POISON_1 :
+                    me->getLevel() >= 40 ? INSTANT_POISON_1 :
+                    me->getLevel() >= 20 ? CRIPPLING_POISON_1 : 0;
+
+            uint32 MhPoison = !mhReady ? 0 : GetSpell(mhEnchant);
+            uint32 OhPoison = !ohReady ? 0 : GetSpell(ohEnchant);
+
+            SpellInfo const* MhPoisonInfo = mhReady && MhPoison ? sSpellMgr->GetSpellInfo(MhPoison) : NULL;
+            SpellInfo const* OhPoisonInfo = ohReady && OhPoison ? sSpellMgr->GetSpellInfo(OhPoison) : NULL;
+
+            Item* targetWeapon = NULL;
+            SpellInfo const* targetInfo = NULL;
+
+            if (mhReady && MhPoison && mhWeapon->IsFitToSpellRequirements(MhPoisonInfo))
+            {
+                targetWeapon = mhWeapon;
+                targetInfo = MhPoisonInfo;
+            }
+            if (!targetWeapon && ohReady && OhPoison && ohWeapon->IsFitToSpellRequirements(OhPoisonInfo))
+            {
+                targetWeapon = ohWeapon;
+                targetInfo = OhPoisonInfo;
+            }
+            if (targetWeapon)
+            {
+                Spell* spell = new Spell(me, targetInfo, TRIGGERED_NONE);
+                SpellCastTargets targets;
+                targets.SetItemTarget(targetWeapon);
+                spell->prepare(&targets);
+                return;
+            }
+        }
+
+        void CheckVanish(uint32 diff)
+        {
+            if (!IsSpellReady(VANISH_1, diff, false) || !me->IsInCombat() || me->IsMounted() || IsTank() || Rand() > 50 ||
+                me->getAttackers().empty() || me->HasAuraType(SPELL_AURA_MOD_STEALTH) ||
+                me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY) || me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return;
+
+            if (GetHealthPCT(me) < 30 + 20*me->getAttackers().size() ||
+                (!IAmFree() && GetHealthPCT(me) < 70 && master->GetNpcBotsCount() > 1))
+            {
+                Unit* victim = me->GetVictim();
+                if (doCast(me, GetSpell(VANISH_1)))
+                    return;
+            }
+        }
+
+        void CheckCloakOfShadows(uint32 diff)
+        {
+            if (!IsSpellReady(CLOAK_OF_SHADOWS_1, diff) || me->IsMounted() || Rand() > 30/* ||
+                me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY)*/)
+                return;
+
+            uint32 count = 0;
+            uint32 const dispelMask = DISPEL_ALL_MASK;
+            Unit::AuraApplicationMap const& Auras = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator iter = Auras.begin(); iter != Auras.end(); ++iter)
+            {
+                // remove all harmful spells on you...
+                SpellInfo const* spellInfo = iter->second->GetBase()->GetSpellInfo();
+                if ((spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC || (spellInfo->GetDispelMask() & dispelMask)) &&
+                    !iter->second->IsPositive() && !iter->second->GetBase()->IsPassive())
+                {
+                    if (spellInfo->HasAura(SPELL_AURA_PERIODIC_DAMAGE) ||
+                        spellInfo->HasAura(SPELL_AURA_MOD_SPEED_SLOW_ALL) ||
+                        spellInfo->HasAura(SPELL_AURA_HASTE_SPELLS))
+                        if (++count > 1)
+                            break;
+                }
+            }
+
+            if (!(count > 1))
+                return;
+
+            if (doCast(me, GetSpell(CLOAK_OF_SHADOWS_1)))
+                return;
+        }
+
+        void CheckBlind(uint32 diff)
+        {
+            if (!IsSpellReady(BLIND_1, diff) || !me->IsInCombat() || me->IsMounted() || IsTank() || Rand() > 40 ||
+                me->HasAuraType(SPELL_AURA_MOD_STEALTH) || me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY) ||
+                IsSpellReady(BLADE_FLURRY_1, diff, false) || IsSpellReady(EVASION_1, diff, false) ||
+                me->GetAuraEffect(SPELL_AURA_MOD_DODGE_PERCENT, SPELLFAMILY_ROGUE, 0x20, 0x0, 0x0) ||//evasion
+                me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000000, 0x800, 0x0))
+                return;
+
+            Unit* u = FindStunTarget(15); //improved always (base 34, improved 15)
+            if (!u)
+                u = FindCastingTarget(15, 0, BLIND_1);
+
+            if (u && doCast(u, GetSpell(BLIND_1)))
+                return;
+        }
+
+        void CheckPreparation(uint32 diff)
+        {
+            if (!IsSpellReady(PREPARATION_1, diff) || !me->IsInCombat() || me->IsMounted() || Rand() > 10)
+                return;
+
+            //TODO: recheck priorities
+            uint32 needFactor = 0;
+            uint32 cooldown;
+            cooldown = GetSpellCooldown(EVASION_1);
+            needFactor += !cooldown ? 0 : 3 * cooldown / 1200; //1-100 x3
+            cooldown = GetSpellCooldown(SPRINT_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 1200; //1-100
+            cooldown = GetSpellCooldown(VANISH_1);
+            needFactor += !cooldown ? 0 : 3 * cooldown / 1200; //1-100 x3
+            cooldown = GetSpellCooldown(COLD_BLOOD_1);
+            needFactor += !cooldown ? 0 : 2 * cooldown / 1800; //1-100 x2
+            cooldown = GetSpellCooldown(SHADOWSTEP_1);
+            needFactor += !cooldown ? 0 : 2 * cooldown / 200;  //1-100 x2
+            cooldown = GetSpellCooldown(BLADE_FLURRY_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 1200; //1-100
+            cooldown = GetSpellCooldown(DISMANTLE_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 600;  //1-100
+            //0-1300
+            //ignore Kick
+
+            if (needFactor >= 800 && doCast(me, GetSpell(PREPARATION_1)))
+                return;
+        }
+
+        void CheckTricksOfTheTrade(uint32 diff)
+        {
+            if (!IsSpellReady(TRICKS_OF_THE_TRADE_1, diff) || !me->IsInCombat() || me->IsMounted() || IAmFree() ||
+                IsTank() || Rand() > 30 || !me->GetMap()->IsDungeon() ||
+                me->HasAuraType(SPELL_AURA_MOD_STEALTH) || me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY))
+                return;
+
+            Group const* group = master->GetGroup();
+            if (!group)
+                return;
+            Unit* victim = me->GetVictim();
+            if (!victim)
+                return;
+
+            Unit* target = NULL;
+            for (GroupReference const* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || !player->IsAlive() || me->GetMap() != player->FindMap() ||
+                    me->GetDistance(player) > 20)
+                    continue;
+
+                if (IsTank(player) || player->GetVictim() == victim)
+                {
+                    if (!victim->CanHaveThreatList() ||
+                        victim->getThreatManager().getThreat(player) < victim->getThreatManager().getThreat(me) * 0.75)
+                    {
+                        target = player;
+                        break;
+                    }
+                }
+            }
+
+            if (target)
+                if (doCast(target, GetSpell(TRICKS_OF_THE_TRADE_1)))
+                    return;
+        }
+
+        void CheckSprint(uint32 diff)
+        {
+            if (!IsSpellReady(SPRINT_1, diff, false) || GetBotCommandState() != COMMAND_FOLLOW ||
+                me->GetVictim() || me->IsMounted() || IAmFree() || Rand() > 15)
+                return;
+
+            if (me->GetExactDist2d(master) > std::max<uint8>(master->GetBotFollowDist(), 40))
+            {
+                if (doCast(me, GetSpell(SPRINT_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const
+        {
+            if (spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE)
+                return;
+
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Cold Blood
+            if (AuraEffect const* bloo = me->GetAuraEffect(COLD_BLOOD_1, 0, me->GetGUID()))
+                if (bloo->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 100.f;
+
+            //Puncturing Wounds:
+            if (lvl >= 15)
+            {
+                //30% additional critical chance for Backstab
+                if (baseId == BACKSTAB_1)
+                    crit_chance += 30.f;
+                //Puncturing Wounds: 15% additional critical chance for Mutilate
+                else if (baseId == MUTILATE_1 ||
+                    baseId == MUTILATE_DAMAGE_MAINHAND_1 || baseId == MUTILATE_DAMAGE_OFFHAND_1)
+                    crit_chance += 15.f;
+            }
+            //Glyph of Eviscerate: 10% additional critical chance for Eviscerate
+            if (lvl >= 15 && baseId == EVISCERATE_1)
+                crit_chance += 10.f;
+            //Improved Ambush: 50% additional critical chance for Ambush
+            if (baseId == AMBUSH_1)
+                crit_chance += 50.f;
+            //Turn the Tables:
+            if (lvl >= 50 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x2600070E) || (spellInfo->SpellFamilyFlags[1] & 0x7900106)) &&
+                me->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_ROGUE, 0x0, 0x200000, 0x0))
+                crit_chance += 6.f;
+            //Remorseless Attacks:
+            if (AuraEffect const* remo = me->GetAuraEffect(REMORSELESS_ATTACKS_BUFF, 0, me->GetGUID()))
+                if (remo->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 40.f;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Lethality: 30% crit damage bonus for non-stealth combo-generating abilities (on 25 lvl)
+                if (lvl >= 25 &&
+                    (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 || baseId == MUTILATE_1 || baseId == RIPOSTE_1 ||
+                    baseId == GOUGE_1 || baseId == HEMORRHAGE_1 || baseId == GHOSTLY_STRIKE_1
+                    /*|| baseId == SHIV_1*/ || baseId == MUTILATE_DAMAGE_MAINHAND_1 || baseId == MUTILATE_DAMAGE_OFFHAND_1))
+                    pctbonus += 0.15f;
+            }
+
+            //DeathDealer set bonus: 15% damage bonus for Eviscerate
+            if (lvl >= 60 && baseId == EVISCERATE_1)
+                pctbonus += 0.15f;
+            //Find Weakness: 6% bonus damage to all abilities
+            if (lvl >= 45)
+                pctbonus += 0.06f;
+            //Improved Eviscerate: 20% damage bonus for Eviscerate
+            if (lvl >= 10 && baseId == EVISCERATE_1)
+                pctbonus += 0.2f;
+            //Opportunity: 20% damage bonus for Backstab, Mutilate, Garrote and Ambush
+            if (lvl >= 10 &&
+                (baseId == BACKSTAB_1 || baseId == MUTILATE_1 || baseId == MUTILATE_DAMAGE_MAINHAND_1 ||
+                baseId == MUTILATE_DAMAGE_OFFHAND_1 || baseId == GARROTE_1 || baseId == AMBUSH_1))
+                pctbonus += 0.2f;
+            //Aggression: 15% damage bonus for Sinister Strike, Backstab and Eviscerate
+            if (lvl >= 25 && (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 || baseId == EVISCERATE_1))
+                pctbonus += 0.15f;
+            //Blood Spatter: 30% bonus damage for Rupture and Garrote
+            if (lvl >= 15 && (baseId == RUPTURE_1 || baseId == GARROTE_1))
+                pctbonus += 0.3f;
+            //Vile Poisons: 20% damage bonus for Poisons and Envenom
+            if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x10012000) || (spellInfo->SpellFamilyFlags[1] & 0x18)))
+                pctbonus += 0.2f;
+            //Serrated Blades part 2: 30% bonus damage for Rupture
+            if (lvl >= 20 && baseId == RUPTURE_1)
+                pctbonus += 0.3f;
+            //Surprise Attacks: 10% bonus damage for Sinister Strike, Backstab, Shiv, Hemmorhage and Gouge
+            if (lvl >= 50 && (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 ||
+                /*baseId == SHIV_1 || */baseId == HEMORRHAGE_1 || baseId == GOUGE_1))
+                pctbonus += 0.1f;
+            //Blade Twisting: 10% bonus damage for Sinister Strike and Backstab
+            if (lvl >= 35 && (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1))
+                pctbonus += 0.1f;
+            //Sinister Calling: 10% bonus percentage damage for Backstab and Hemorrhage
+            //We add bonus damage pct because SpellMods are not handled
+            if (lvl >= 45 && (baseId == BACKSTAB_1 || baseId == HEMORRHAGE_1))
+                pctbonus += 0.1f;
+            //Glyph of Fan of Knives: 20% bonus damage for Fan of Knives
+            if (lvl >= 80 && baseId == FAN_OF_KNIVES_1)
+                pctbonus += 0.2f;
+
+            //Glyph of Sinister Strike: 50% chance to add 1 cp on crit
+            if (baseId == SINISTER_STRIKE_1)
+                static_cast<bool>(glyphSSProc) = crit && lvl >= 15 && urand(1,100) <= 50;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Glyph of Blade Flurry: -100% cost for Blade Flurry
+            if (lvl >= 30 && baseId == BLADE_FLURRY_1)
+                pctbonus += 1.0f;
+
+            //percent mods
+            //Dirty Tricks: -50% cost for Blind and Sap
+            if (lvl >= 15 && (baseId == BLIND_1 || baseId == SAP_1))
+                pctbonus += 0.5f;
+
+            //flat mods
+            //Improved Expose Armor: -10 energy cost for Expose Armor
+            if (lvl >= 20 && baseId == EXPOSE_ARMOR_1)
+                flatbonus += 10;
+            //Improved Sinister Strike: -5 energy cost for Sinister Strike
+            if (lvl >= 10 && baseId == SINISTER_STRIKE_1)
+                flatbonus += 5;
+            //Dirty Deeds part 1: -20 energy cost for Cheap Shot and Garrote
+            if (lvl >= 30 && (baseId == CHEAP_SHOT_1 || baseId == GARROTE_1))
+                flatbonus += 20;
+            //Filthy Tricks part 2: -10 energy cost for Tricks of the Trade, Distract and Shadowstep
+            if (lvl >= 50 && (baseId == TRICKS_OF_THE_TRADE_1 || baseId == DISTRACT_1 || baseId == SHADOWSTEP_1))
+                flatbonus += 10;
+            //Slaugher from the Shadows part 1: -20 energy cost for Backstab and Ambush
+            if (lvl >= 55 && (baseId == BACKSTAB_1 || baseId == AMBUSH_1))
+                flatbonus += 20;
+            //Slaugher from the Shadows part 2: -5 energy cost for Hemorrhage
+            if (lvl >= 55 && baseId == HEMORRHAGE_1)
+                flatbonus += 5;
+            //Glyph of Feint: -20 energy cost for Feint
+            if (lvl >= 16 && baseId == FEINT_1)
+                flatbonus += 20;
+            //Glyph of Gouge: -15 energy cost for Gouge
+            if (lvl >= 15 && baseId == GOUGE_1)
+                flatbonus += 15;
+            //Glyph of Mutilate: -5 energy cost for Mutilate
+            if (lvl >= 50 && baseId == MUTILATE_1)
+                flatbonus += 5;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Improved Slam: -100% cast time for Slam
+            //if (lvl >= 40 && spellId == GetSpell(SLAM_1) && me->HasAura(BLOODSURGE_BUFF))
+            //    timebonus += casttime;
+
+            //flat mods
+            //Glyph of Pick Lock: 100% cast time for Pick Lock (reduced for bots)
+            if (lvl >= 16 && baseId == PICK_LOCK_1)
+                timebonus += 4000;
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Intensify Rage: -33% cooldown for Bloodrage, Berserker Rage, Recklessness and Death Wish
+            //if (lvl >= 40 &&
+            //    (spellId == GetSpell(BLOODRAGE_1) || spellId == GetSpell(BERSERKERRAGE_1) ||
+            //    spellId == GetSpell(RECKLESSNESS_1) || spellId == GetSpell(DEATHWISH_1)))
+            //    pctbonus += 0.33f;
+
+            //flat mods
+            //Camouflage part 2: -60 sec cooldown for Blind
+            if (lvl >= 20 && baseId == BLIND_1)
+                timebonus += 60000;
+            //Camouflage part 3: -30 sec cooldown for Cloak of Shadows
+            if (lvl >= 20 && baseId == CLOAK_OF_SHADOWS_1)
+                timebonus += 30000;
+            //Filthy Tricks part 1: -10 sec cooldown for Tricks of the Trade, Distract and Shadowstep
+            if (lvl >= 50 && (baseId == TRICKS_OF_THE_TRADE_1 || baseId == DISTRACT_1 || baseId == SHADOWSTEP_1))
+                timebonus += 10000;
+            //Filthy Tricks part 3: -3 min cooldown for Preparation
+            if (lvl >= 50 && baseId == PREPARATION_1)
+                timebonus += 180000;
+            //Glyph of Killing Spree: -45 sec cooldown for Killing Spree
+            if (lvl >= 60 && baseId == KILLING_SPREE_1)
+                timebonus += 45000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Endurance: -1 min cooldown for Sprint and Evasion
+            if (lvl >= 20 && (baseId == SPRINT_1 || baseId == EVASION_1))
+                timebonus += 60000;
+            //Camouflage part 1: -60 sec cooldown for Vanish
+            if (lvl >= 20 && baseId == VANISH_1)
+                timebonus += 60000;
+            //Elusiveness part 1: -6 sec cooldown for Stealth
+            if (lvl >= 15 && baseId == STEALTH_1)
+                timebonus += 6000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+            //    timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Booming Voice
+            //if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+            //    pctbonus += 1.0f;
+
+            //flat mods
+            //Glyph of Thunder Clap
+            //if (spellInfo->SpellFamilyFlags[0] & 0x80)
+            //    flatbonus += 4.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Booming Voice
+            //if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+            //    pctbonus += 1.0f;
+
+            //flat mods
+            //Throwing Specialization: + 4 yd range for Deadly Throw
+            if (lvl >= 45 && baseId == DEADLY_THROW_1)
+                flatbonus += 4.f;
+            //Dirty Tricks: + 5 yd range for Blind and Sap
+            if (lvl >= 15 && (baseId == BLIND_1 || baseId == SAP_1))
+                flatbonus += 5.f;
+            //Glyph of Ambush: + 5 yd range for Ambush
+            if (/*lvl >= 18 && */baseId == AMBUSH_1)
+                flatbonus += 5.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const
+        {
+            uint32 bonusTargets = 0;
+
+            //Improved Revenge: +1 target (actually 2 in dbc)
+            //if (spellInfo->SpellFamilyFlags[0] & 0x400)
+            //    bonusTargets += 1;
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo)
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Thistle Tea: cooldown
+            if (baseId == THISTLE_TEA)
+                SetSpellCooldown(THISTLE_TEA, 300000); //5 min (item cd)
+
+            //Remorseless Attacks: proc consume buff
+            if (AuraEffect const* remo = me->GetAuraEffect(REMORSELESS_ATTACKS_BUFF, 0, me->GetGUID()))
+                if (remo->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(REMORSELESS_ATTACKS_BUFF);
+
+            //Relentless Strikes
+            if (spellInfo->NeedsComboPoints() && comboPoints)
+            {
+                if (lvl >= 10)
+                {
+                    if (irand(1,100) <= 20 * comboPoints)
+                    {
+                        me->CastSpell(me, RELENTLESS_STRIKES_EFFECT, true);
+                        //TC_LOG_ERROR("entities.player", "rogue_bot CP SPEND1: RS proc!");
+                    }
+                }
+            }
+
+            //Item enchant
+            //We don't know which item is targeted
+            //Actually it is mh, then oh
+            if (baseId == CRIPPLING_POISON_1 || baseId == INSTANT_POISON_1 || baseId == DEADLY_POISON_1 ||
+                baseId == WOUND_POISON_1 || baseId == ANESTHETIC_POISON_1 || baseId == MIND_NUMBING_POISON_1)
+            {
+                //We set duration to 2 seconds to prevent exploiting unequip mechanic
+                //to get enchanted weapons for player (for non-shaman bots it won't work)
+                uint32 slot = TEMP_ENCHANTMENT_SLOT;
+                uint32 duration = 2 * IN_MILLISECONDS;
+                uint32 charges = 0;
+                uint32 enchant_id = spellInfo->Effects[0].MiscValue;
+                SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+                Item* mh = GetEquips(BOT_SLOT_MAINHAND);
+                Item* oh = GetEquips(BOT_SLOT_OFFHAND);
+                Item* item = NULL;
+                uint8 itemSlot = 0;
+
+                if (mh && !mh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && mh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = mh;
+                    itemSlot = BOT_SLOT_MAINHAND;
+                }
+                else if (oh && !oh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && oh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = oh;
+                    itemSlot = BOT_SLOT_OFFHAND;
+                }
+                else
+                    ASSERT(false && "rogue bot attempted to enchant his weapons but cannot find a weapon to apply it!");
+
+                if (!IAmFree())
+                    master->GetSession()->SendEnchantmentLog(me->GetGUID(), me->GetGUID(), item->GetEntry(), enchant_id);
+
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_ID_OFFSET, enchant_id);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_DURATION_OFFSET, duration);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_CHARGES_OFFSET, charges);
+                ApplyItemBonuses(itemSlot); //RemoveItemBonuses inside
+                if (itemSlot == BOT_SLOT_MAINHAND)
+                    mhEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                else if (itemSlot == BOT_SLOT_OFFHAND)
+                    ohEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                //GC_Timer = 1500; //needed
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            //Vanish: handle stealth add
+            if (baseId == VANISH_TRIGGERED_1 || baseId == VANISH_TRIGGERED_2 || baseId == VANISH_TRIGGERED_3)
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_SHAPESHIFT, SPELLFAMILY_ROGUE, 0x400000, 0x0, 0x0))
+                {
+                    //SetSpellCooldown(STEALTH_1, 0);
+                    me->CastSpell(me, STEALTH_1, true);
+                }
+            }
+            //Cheat Death: assume resilience bonus
+            if (baseId == CHEATING_DEATH_BUFF)
+            {
+                if (AuraEffect* chea = me->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_GENERIC, 2109, 0))
+                {
+                    chea->ChangeAmount(-100);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Cold Blood: handle proc
+            if (AuraEffect const* bloo = me->GetAuraEffect(COLD_BLOOD_1, 0, me->GetGUID()))
+                if (bloo->IsAffectedOnSpell(spell))
+                    me->RemoveAurasDueToSpell(COLD_BLOOD_1);
+
+            //Combo point generating from effects
+            if (baseId == SEAL_FATE_EFFECT || baseId == RUTHLESSNESS_EFFECT ||
+                baseId == SETUP_EFFECT || baseId == INITIATIVE_EFFECT || baseId == HONOR_AMONG_THIEVES_EFFECT)
+            {
+                ++comboPoints;
+                //TC_LOG_ERROR("entities.player", "rogue_bot CP GEN2: %s adds 1, now %u", spell->SpellName[0], uint32(comboPoints));
+                if (comboPoints > 5)
+                {
+                    comboPoints = 5;
+                    //TC_LOG_ERROR("entities.player", "rogue_bot CP NOR2: now %u", uint32(comboPoints));
+                }
+            }
+            //Combo point generating from spells
+            if (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 || baseId == MUTILATE_1 ||
+                baseId == GOUGE_1 || baseId == HEMORRHAGE_1 || baseId == GHOSTLY_STRIKE_1 ||
+                baseId == RIPOSTE_1 || baseId == PREMEDITATION_1 ||
+                baseId == AMBUSH_1 || baseId == GARROTE_1 || baseId == CHEAP_SHOT_1/* || baseId == SHIV_1*/)
+            {
+                (baseId == MUTILATE_1 || baseId == PREMEDITATION_1 || baseId == CHEAP_SHOT_1) ?
+                    comboPoints += 2 : ++comboPoints;
+
+                //TC_LOG_ERROR("entities.player", "rogue_bot CP GEN1: %s adds %u, now %u",
+                //    spell->SpellName[0], (baseId == MUTILATE_1 || baseId == PREMEDITATION_1 || baseId == CHEAP_SHOT_1) ?
+                //    2 : 1, uint32(comboPoints));
+
+                //Glyph of Sinister Strike: handle proc
+                if (baseId == SINISTER_STRIKE_1 && glyphSSProc)
+                {
+                    ++comboPoints;
+                    //TC_LOG_ERROR("entities.player", "rogue_bot CP GEN1: glyphSS proc, now %u", uint32(comboPoints));
+                }
+
+                if (comboPoints > 5)
+                {
+                    comboPoints = 5;
+                    //TC_LOG_ERROR("entities.player", "rogue_bot CP NOR1: now %u", uint32(comboPoints));
+                }
+            }
+            //if (spellId == EVISCERATE || spellId == KIDNEY_SHOT || spellId == SLICE_DICE || spellId == RUPTURE || spellId == EXPOSE_ARMOR || spellId == ENVENOM)
+            //some abilities like relentless strikes require combo points thus tries to proc itself
+            else if (spell->NeedsComboPoints() && comboPoints)
+            {
+                uint32 tempCP = comboPoints;
+                comboPoints = 0;
+
+                //TC_LOG_ERROR("entities.player", "rogue_bot CP SPEND1: %u to 0", tempCP);
+
+                //Relentless Strikes: moved to OnClassSpellGo (triggered even without hitting the target)
+
+                //Ruthlessness
+                if (lvl >= 15)
+                {
+                    if (urand(1,100) <= 60)
+                    {
+                        me->CastSpell(target, RUTHLESSNESS_EFFECT, true);
+                        //TC_LOG_ERROR("entities.player", "rogue_bot CP SPEND1: RU proc!");
+                    }
+                }
+            }
+
+            //Preparation: handle effect
+            if (baseId == PREPARATION_1)
+            {
+                //TC_LOG_ERROR("entities.player", "rogue_bot Preparation hit!");
+                if (GetSpell(EVASION_1))
+                    SetSpellCooldown(EVASION_1, 0);
+                if (GetSpell(SPRINT_1))
+                    SetSpellCooldown(SPRINT_1, 0);
+                if (GetSpell(VANISH_1))
+                    SetSpellCooldown(VANISH_1, 0);
+                if (GetSpell(COLD_BLOOD_1))
+                    SetSpellCooldown(COLD_BLOOD_1, 0);
+                if (GetSpell(SHADOWSTEP_1))
+                    SetSpellCooldown(SHADOWSTEP_1, 0);
+
+                //Glyph of Preparation
+                //if (lvl >= 30) // same level as spell itself
+                {
+                    if (GetSpell(BLADE_FLURRY_1))
+                        SetSpellCooldown(BLADE_FLURRY_1, 0);
+                    if (GetSpell(DISMANTLE_1))
+                        SetSpellCooldown(DISMANTLE_1, 0);
+                    if (GetSpell(KICK_1))
+                        SetSpellCooldown(KICK_1, 0);
+                }
+            }
+
+            //Glyph of Garrote
+            if (lvl >= 15 && baseId == GARROTE_1)
+            {
+                if (Aura* garr = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = garr->GetMaxDuration() - 3000;
+                    garr->SetDuration(dur);
+                    garr->SetMaxDuration(dur);
+                    if (AuraEffect* garrEff = garr->GetEffect(0))
+                    {
+                        garrEff->ChangeAmount(int32(garrEff->GetAmount() * 1.44f)); //not a mistake
+                    }
+                }
+            }
+            //Glyph of Deadly Throw
+            if (lvl >= 64 && baseId == DEADLY_THROW_1)
+            {
+                if (AuraEffect* thro = target->GetAuraEffect(spellId, 1, me->GetGUID()))
+                {
+                    thro->ChangeAmount(thro->GetAmount() - 20);
+                }
+            }
+            //Glyph of Hunger for Blood
+            if (lvl >= 60 && baseId == HUNGER_FOR_BLOOD_BUFF)
+            {
+                if (AuraEffect* hung = me->GetAuraEffect(spellId, 0))
+                {
+                    hung->ChangeAmount(hung->GetAmount() + 3);
+                }
+            }
+            //Glyph of Cloak of Shadows
+            if (lvl >= 66 && baseId == CLOAK_OF_SHADOWS_1)
+            {
+                if (AuraEffect* cloa = me->GetAuraEffect(spellId, 2))
+                {
+                    cloa->ChangeAmount(cloa->GetAmount() - 40);
+                }
+            }
+            //Glyph of Sprint
+            if (lvl >= 15 && baseId == SPRINT_1)
+            {
+                if (AuraEffect* spri = me->GetAuraEffect(spellId, 0))
+                {
+                    spri->ChangeAmount(spri->GetAmount() + 30);
+                }
+            }
+            //Glyph of Vanish
+            if (lvl >= 22 && baseId == VANISH_1)
+            {
+                if (AuraEffect* vani = me->GetAuraEffect(spellId, 2))
+                {
+                    vani->ChangeAmount(vani->GetAmount() + 30);
+                }
+            }
+            //Glyph of Adrenaline Rush
+            if (lvl >= 40 && baseId == ADRENALINE_RUSH_1)
+            {
+                if (Aura* rush = me->GetAura(spellId))
+                {
+                    uint32 dur = rush->GetMaxDuration() + 5000;
+                    rush->SetDuration(dur);
+                    rush->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Evasion
+            if (lvl >= 15 && baseId == EVASION_1)
+            {
+                if (Aura* evas = me->GetAura(spellId))
+                {
+                    uint32 dur = evas->GetMaxDuration() + 5000;
+                    evas->SetDuration(dur);
+                    evas->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Slice and Dice
+            //Improved Slice and Dice
+            if (lvl >= 15 && baseId == SLICE_DICE_1)
+            {
+                if (Aura* dice = me->GetAura(spellId))
+                {
+                    uint32 dur = dice->GetMaxDuration() + 3000;
+                    dur = dur + dur / 2;
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Shadow Dance: 4 sec for bots
+            if (lvl >= 60 && baseId == SHADOW_DANCE_1)
+            {
+                if (Aura* danc = me->GetAura(spellId))
+                {
+                    uint32 dur = danc->GetMaxDuration() + 4000;
+                    danc->SetDuration(dur);
+                    danc->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Rupture
+            if (lvl >= 20 && baseId == RUPTURE_1)
+            {
+                if (Aura* rupt = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = rupt->GetMaxDuration() + 4000;
+                    rupt->SetDuration(dur);
+                    rupt->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Expose Armor
+            if (lvl >= 15 && baseId == EXPOSE_ARMOR_1)
+            {
+                if (Aura* expo = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = expo->GetMaxDuration() + 12000;
+                    expo->SetDuration(dur);
+                    expo->SetMaxDuration(dur);
+                }
+            }
+            //Improved Gouge: Increased duration by 1.5 sec
+            if (lvl >= 10 && baseId == GOUGE_1)
+            {
+                if (Aura* goug = target->GetAura(spellId, me->GetGUID()))
+                {
+                    int32 duration = goug->GetMaxDuration() + 1500;
+                    goug->SetDuration(duration);
+                    goug->SetMaxDuration(duration);
+                }
+            }
+            //Glyph of Tricks of Trade
+            if (lvl >= 75 && baseId == TRICKS_OF_THE_TRADE_BUFF)
+            {
+                if (Aura* tric = target->GetAura(spellId, me->GetGUID()))
+                {
+                    int32 duration = tric->GetMaxDuration() + 4000;
+                    tric->SetDuration(duration);
+                    tric->SetMaxDuration(duration);
+                }
+            }
+            //Cut to the Chase: Eviscerate and Envenom will refresh Slice and Dice duration as for 5 points
+            if (lvl >= 55 && (baseId == EVISCERATE_1/* || baseId == ENVENOM_1*/) && GetSpell(SLICE_DICE_1))
+            {
+                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
+                {
+                    int32 duration = 21000 + 3000 + 12000; //base + glyph + improved
+                    dice->SetDuration(duration);
+                    dice->SetMaxDuration(duration);
+                }
+            }
+            //Waylay
+            if (lvl >= 45 && (baseId == BACKSTAB_1 || baseId == AMBUSH_1))
+                me->CastSpell(target, WAYLAY_DEBUFF, true);
+
+            //Stun: move behind
+            if (baseId == CHEAP_SHOT_1 || baseId == KIDNEY_SHOT_1 || baseId == GOUGE_1)
+                if (target == opponent)
+                    MoveBehind(target);
+
+            //Poison marker
+            if (baseId == CRIPPLING_POISON_1 || baseId == DEADLY_POISON_PROC_1 ||
+                baseId == WOUND_POISON_PROC_1 || baseId == MIND_NUMBING_POISON_PROC_1)
+                targetPoisoned = true;
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void CheckAttackState()
+        {
+            if (!me->GetVictim())
+                Evade();
+            else if (HasRole(BOT_ROLE_DPS) && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+                (me->isAttackReady() || me->isAttackReady(OFF_ATTACK)) &&
+                (!me->GetVictim()->GetAuraEffect(SPELL_AURA_MOD_STUN, SPELLFAMILY_ROGUE, 0x8, 0x0, 0x0) &&
+                !me->GetVictim()->GetAuraEffect(SPELL_AURA_MOD_CONFUSE, SPELLFAMILY_ROGUE, 0x01000000, 0x0, 0x0)))
+                DoMeleeAttackIfReady();
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_COMBO_POINTS:
+                    return comboPoints;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    return mhEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    return ohEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    return mhEnchant;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    return ohEnchant;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_1:
+                    return GetSpell(CRIPPLING_POISON_1) ? CRIPPLING_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_2:
+                    return GetSpell(INSTANT_POISON_1) ? INSTANT_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_3:
+                    return GetSpell(MIND_NUMBING_POISON_1) ? MIND_NUMBING_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_4:
+                    return GetSpell(DEADLY_POISON_1) ? DEADLY_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_5:
+                    return GetSpell(WOUND_POISON_1) ? WOUND_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_6:
+                    return GetSpell(ANESTHETIC_POISON_1) ? ANESTHETIC_POISON_1 : 0;
+                default:
+                    return 0;
+            }
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 value)
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_DAGGER_MAINHAND:
+                    isdaggerMH = bool(value);
+                    break;
+                case BOTAI_MISC_DAGGER_OFFHAND:
+                    isdaggerOH = bool(value);
+                    break;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    if (value)
+                        mhEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    if (value)
+                        ohEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    mhEnchant = value;
+                    needChooseMHEnchant = value ? false : true;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    ohEnchant = value;
+                    needChooseOHEnchant = value ? false : true;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset()
+        {
+            energy = 0;
+            comboPoints = 0;
+            glyphSSProc = false;
+            targetPoisoned = false;
+
+            energyFraction = 0.f;
+            energyGainMult = sWorld->getRate(RATE_POWER_ENERGY);
+
+            mhEnchantExpireTimer = 1;
+            ohEnchantExpireTimer = 1;
+
+            DefaultInit();
+
+            mhEnchant = 0;
+            ohEnchant = 0;
+            needChooseMHEnchant = true;
+            needChooseOHEnchant = true;
+
+            //Hack for power
+            me->setPowerType(POWER_ENERGY);
+            RefreshAura(VIGOR_GLADIATOR, 10);
+            me->SetPower(POWER_ENERGY, me->GetMaxPower(POWER_ENERGY));
+
+            //after InitEquips
+            Item const* mh = GetEquips(BOT_SLOT_MAINHAND);
+            Item const* oh = GetEquips(BOT_SLOT_OFFHAND);
+            isdaggerMH = mh && mh->GetTemplate()->Class == ITEM_CLASS_WEAPON && mh->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER;
+            isdaggerOH = oh && oh->GetTemplate()->Class == ITEM_CLASS_WEAPON && oh->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER;
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (mhEnchantExpireTimer > diff)            mhEnchantExpireTimer -= diff;
+            if (ohEnchantExpireTimer > diff)            ohEnchantExpireTimer -= diff;
+        }
+
+        void InitPowers()
+        {
+            RefreshAura(VIGOR_GLADIATOR, 10);
+
+            if (energy)
+                me->SetPower(POWER_ENERGY, energy);
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+
+            InitSpellMap(KICK_1);
+            //InitSpellMap(EXPOSE_ARMOR_1);
+            InitSpellMap(DISMANTLE_1);
+            InitSpellMap(FEINT_1);
+
+            InitSpellMap(BACKSTAB_1);
+            InitSpellMap(SINISTER_STRIKE_1);
+            InitSpellMap(EVISCERATE_1);
+            InitSpellMap(RUPTURE_1);
+            lvl >= 50 ? InitSpellMap(MUTILATE_1) : RemoveSpell(MUTILATE_1);
+            lvl >= 30 ? InitSpellMap(HEMORRHAGE_1) : RemoveSpell(HEMORRHAGE_1);
+            lvl >= 20 ? InitSpellMap(GHOSTLY_STRIKE_1) : RemoveSpell(GHOSTLY_STRIKE_1);
+            lvl >= 20 ? InitSpellMap(RIPOSTE_1) : RemoveSpell(RIPOSTE_1);
+            InitSpellMap(DEADLY_THROW_1);
+            InitSpellMap(FAN_OF_KNIVES_1);
+
+            InitSpellMap(SPRINT_1);
+            InitSpellMap(EVASION_1);
+            InitSpellMap(BLIND_1);
+            InitSpellMap(VANISH_1);
+            lvl >= 30 ? InitSpellMap(COLD_BLOOD_1) : RemoveSpell(COLD_BLOOD_1);
+            lvl >= 60 ? InitSpellMap(HUNGER_FOR_BLOOD_1) : RemoveSpell(HUNGER_FOR_BLOOD_1);
+            lvl >= 40 ? InitSpellMap(ADRENALINE_RUSH_1) : RemoveSpell(ADRENALINE_RUSH_1);
+            lvl >= 60 ? InitSpellMap(KILLING_SPREE_1) : RemoveSpell(KILLING_SPREE_1);
+            lvl >= 30 ? InitSpellMap(PREPARATION_1) : RemoveSpell(PREPARATION_1);
+            lvl >= 40 ? InitSpellMap(PREMEDITATION_1) : RemoveSpell(PREMEDITATION_1);
+
+            InitSpellMap(GOUGE_1);
+
+            InitSpellMap(KIDNEY_SHOT_1);
+            InitSpellMap(SLICE_DICE_1);
+            lvl >= 30 ? InitSpellMap(BLADE_FLURRY_1) : RemoveSpell(BLADE_FLURRY_1);
+            lvl >= 50 ? InitSpellMap(SHADOWSTEP_1) : RemoveSpell(SHADOWSTEP_1);
+            InitSpellMap(CLOAK_OF_SHADOWS_1);
+            InitSpellMap(TRICKS_OF_THE_TRADE_1);
+            lvl >= 60 ? InitSpellMap(SHADOW_DANCE_1) : RemoveSpell(SHADOW_DANCE_1);
+
+            InitSpellMap(STEALTH_1);
+            //InitSpellMap(SAP_1);
+            InitSpellMap(GARROTE_1);
+            InitSpellMap(CHEAP_SHOT_1);
+            InitSpellMap(AMBUSH_1);
+
+            //InitSpellMap(DISTRACT_1);
+
+            InitSpellMap(CRIPPLING_POISON_1);
+            InitSpellMap(INSTANT_POISON_1);
+            InitSpellMap(DEADLY_POISON_1);
+            InitSpellMap(WOUND_POISON_1);
+            InitSpellMap(MIND_NUMBING_POISON_1);
+            InitSpellMap(ANESTHETIC_POISON_1);
+
+            lvl >= 10 ? InitSpellMap(THISTLE_TEA) : RemoveSpell(THISTLE_TEA);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(COMBAT_POTENCY5, level >= 55 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY4, level >= 52 && level < 55 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY3, level >= 49 && level < 52 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY2, level >= 47 && level < 49 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY1, level >= 45 && level < 47 ? 1 : 0);
+            RefreshAura(SEAL_FATE5, level >= 45 ? 1 : 0);
+            RefreshAura(SEAL_FATE4, level >= 42 && level < 45 ? 1 : 0);
+            RefreshAura(SEAL_FATE3, level >= 39 && level < 42 ? 1 : 0);
+            RefreshAura(SEAL_FATE2, level >= 37 && level < 39 ? 1 : 0);
+            RefreshAura(SEAL_FATE1, level >= 35 && level < 37 ? 1 : 0);
+            RefreshAura(DEADLY_BREW, level >= 40 ? 1 : 0);
+            //RefreshAura(BLADE_TWISTING1, level >= 35 ? 1 : 0);
+            RefreshAura(QUICK_RECOVERY2, level >= 35 ? 1 : 0);
+            RefreshAura(QUICK_RECOVERY1, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(IMPROVED_KIDNEY_SHOT, level >= 30 ? 1 : 0);
+            RefreshAura(VIGOR, level >= 70 ? 2 : level >= 20 ? 1 : 0); //glyphed
+            RefreshAura(REMORSELESS_ATTACKS, level >= 10 ? 1 : 0);
+            RefreshAura(FLEET_FOOTED, level >= 30 ? 1 : 0);
+            RefreshAura(MURDER, level >= 35 ? 1 : 0);
+            RefreshAura(OVERKILL, level >= 40 ? 1 : 0);
+            RefreshAura(FOCUSED_ATTACKS, level >= 45 ? 1 : 0);
+            RefreshAura(MASTER_POISONER, level >= 45 ? 1 : 0);
+            RefreshAura(DUAL_WIELD_SPECIALIZATION, level >= 10 ? 1 : 0);
+            RefreshAura(IMPROVED_KICK, level >= 25 ? 1 : 0);
+            RefreshAura(IMPROVED_SPRINT, level >= 25 ? 1 : 0);
+            RefreshAura(HACK_AND_SLASH, level >= 30 ? 1 : 0);
+            RefreshAura(VITALITY, level >= 40 ? 1 : 0);
+            RefreshAura(NERVES_OF_STEEL, level >= 40 ? 1 : 0);
+            RefreshAura(THROWING_SPECIALIZATION, level >= 45 ? 1 : 0);
+            //RefreshAura(SAVAGE_COMBAT, level >= 50 ? 1 : 0);
+            RefreshAura(UNFAIR_ADVANTAGE, level >= 50 ? 1 : 0);
+            RefreshAura(SURPRISE_ATTACKS, level >= 50 ? 1 : 0);
+            RefreshAura(PREY_ON_THE_WEAK, level >= 60 ? 1 : 0);
+            RefreshAura(MASTER_OF_DECEPTION, level >= 70 ? 2 : level >= 10 ? 1 : 0);
+            RefreshAura(SETUP, level >= 25 ? 1 : 0);
+            RefreshAura(INITIATIVE, level >= 25 ? 1 : 0);
+            RefreshAura(DIRTY_DEEDS, level >= 30 ? 1 : 0);
+            RefreshAura(MASTER_OF_SUBTLETY, level >= 35 ? 1 : 0);
+            RefreshAura(CHEAT_DEATH, level >= 40 ? 1 : 0);
+            RefreshAura(ENVELOPING_SHADOWS, level >= 40 ? 1 : 0);
+            //RefreshAura(SINISTER_CALLING, level >= 45 ? 1 : 0);
+            RefreshAura(TURN_THE_TABLES, level >= 55 ? 1 : 0);
+            RefreshAura(HONOR_AMONG_THIEVES, level >= 55 ? 1 : 0);
+
+            RefreshAura(GLYPH_BACKSTAB, level >= 15 ? 1 : 0);
+
+            RefreshAura(ROGUE_PASSIVE_DND);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case STEALTH_1:
+                case SPRINT_1:
+                case VANISH_1:
+                case BLADE_FLURRY_1:
+                case FAN_OF_KNIVES_1:
+                case TRICKS_OF_THE_TRADE_1:
+                case PREPARATION_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        float GetBotArmorPenetrationCoef() const
+        {
+            float bonus = 0.0f;
+
+            //Serrated Blades part 1
+            if (me->getLevel() >= 20)
+                bonus += 9.f;
+
+            //Mace Specialization: 15% armor penetration
+            if (me->getLevel() >= 30)
+                if (Item const* weap = GetEquips(BOT_SLOT_MAINHAND))
+                    if (weap->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_MACE)
+                        bonus += 15.f;
+
+            return bonus + bot_ai::GetBotArmorPenetrationCoef();
+        }
+
+        void RegenerateEnergy()
+        {
+            uint32 curValue = me->GetPower(POWER_ENERGY);
+            uint32 maxValue = me->GetMaxPower(POWER_ENERGY);
+
+            if (curValue < maxValue)
+            {
+                float addvalue = 0.01f * lastdiff * energyGainMult;
+                Unit::AuraEffectList const& ModPowerRegenPCTAuras = me->GetAuraEffectsByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
+                for (Unit::AuraEffectList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
+                    if (Powers((*i)->GetMiscValue()) == POWER_ENERGY)
+                        AddPct(addvalue, (*i)->GetAmount());
+
+                //not present in db
+                //addvalue += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_ENERGY) * lastdiff / 5000;
+                //me->ModifyPower(POWER_ENERGY, int32(addvalue));
+
+                addvalue += energyFraction;
+
+                if (addvalue == 0x0) //only if world rate for enegy is 0
+                    return;
+
+                uint32 integerValue = uint32(fabs(addvalue));
+
+                curValue += integerValue;
+
+                if (curValue > maxValue)
+                {
+                    curValue = maxValue;
+                    energyFraction = 0.f;
+                }
+                else
+                    energyFraction = addvalue - float(integerValue);
+
+                //if (regenTimer >= REGEN_CD || curValue == maxValue)
+                    me->SetPower(POWER_ENERGY, curValue);
+                //else
+                //    me->UpdateUInt32Value(UNIT_FIELD_POWER1 + POWER_ENERGY, curValue);
+            }
+        }
+
+        bool HasAbilitiesSpecifics() const { return true; }
+        void FillAbilitiesSpecifics(std::list<std::string> &specList)
+        {
+            std::ostringstream msg1;
+            msg1 << "Main hand: ";
+            switch (mhEnchant)
+            {
+                case CRIPPLING_POISON_1:    msg1 << "Crippling";     break;
+                case INSTANT_POISON_1:      msg1 << "Instant";       break;
+                case DEADLY_POISON_1:       msg1 << "Deadly";        break;
+                case WOUND_POISON_1:        msg1 << "Wound";         break;
+                case MIND_NUMBING_POISON_1: msg1 << "Mind-Numbing";  break;
+                case ANESTHETIC_POISON_1:   msg1 << "Anesthetic";    break;
+                default:                    msg1 << "Nothing";       break;
+            }
+            specList.push_back(msg1.str());
+
+            std::ostringstream msg2;
+            msg2 << "Offhand: ";
+            switch (ohEnchant)
+            {
+                case CRIPPLING_POISON_1:    msg2 << "Crippling";     break;
+                case INSTANT_POISON_1:      msg2 << "Instant";       break;
+                case DEADLY_POISON_1:       msg2 << "Deadly";        break;
+                case WOUND_POISON_1:        msg2 << "Wound";         break;
+                case MIND_NUMBING_POISON_1: msg2 << "Mind-Numbing";  break;
+                case ANESTHETIC_POISON_1:   msg2 << "Anesthetic";    break;
+                default:                    msg2 << "Nothing";       break;
+            }
+            specList.push_back(msg2.str());
+        }
+
+    private:
+        bool glyphSSProc;
+        bool targetPoisoned;
+        int32 energy;
+        uint8 comboPoints;
+        //uint32 standardEquips[2];
+        float energyFraction, energyGainMult;
+        bool isdaggerMH, isdaggerOH;
+        uint32 mhEnchantExpireTimer, ohEnchantExpireTimer;
+        uint32 mhEnchant, ohEnchant;
+        bool needChooseMHEnchant, needChooseOHEnchant;
+
+        enum RogueBaseSpells
+        {
+            KICK_1                              = 1766,
+            EXPOSE_ARMOR_1                      = 8647, //NYI
+            FEINT_1                             = 1966,
+            DISMANTLE_1                         = 51722,
+
+            BACKSTAB_1                          = 53,
+            SINISTER_STRIKE_1                   = 1752,
+            EVISCERATE_1                        = 2098,
+            RUPTURE_1                           = 1943,
+  /*Talent*/MUTILATE_1                          = 1329,
+  /*Talent*/HEMORRHAGE_1                        = 16511,
+  /*Talent*/GHOSTLY_STRIKE_1                    = 14278,
+  /*Talent*/RIPOSTE_1                           = 14251,
+            DEADLY_THROW_1                      = 26679,
+            FAN_OF_KNIVES_1                     = 51723,
+
+            SPRINT_1                            = 2983,
+            EVASION_1                           = 5277,
+            BLIND_1                             = 2094,
+            VANISH_1                            = 1856,
+  /*Talent*/COLD_BLOOD_1                        = 14177,
+  /*Talent*/HUNGER_FOR_BLOOD_1                  = 51662,
+  /*Talent*/ADRENALINE_RUSH_1                   = 13750,
+  /*Talent*/KILLING_SPREE_1                     = 51690,
+  /*Talent*/PREPARATION_1                       = 14185,
+  /*Talent*/PREMEDITATION_1                     = 14183,
+
+            GOUGE_1                             = 1776,
+
+            KIDNEY_SHOT_1                       = 408,
+            SLICE_DICE_1                        = 5171,
+  /*Talent*/BLADE_FLURRY_1                      = 13877,
+  /*Talent*/SHADOWSTEP_1                        = 36554,
+            CLOAK_OF_SHADOWS_1                  = 31224,
+            TRICKS_OF_THE_TRADE_1               = 57934,
+  /*Talent*/SHADOW_DANCE_1                      = 51713,
+
+            STEALTH_1                           = 1784,
+            SAP_1                               = 6770, //NYI
+            GARROTE_1                           = 703,
+            CHEAP_SHOT_1                        = 1833,
+            AMBUSH_1                            = 8676,
+
+            DISTRACT_1                          = 1725, //NYI
+
+            //Poisons
+            CRIPPLING_POISON_1                  = 3408,
+            INSTANT_POISON_1                    = 8679,
+            DEADLY_POISON_1                     = 2823, //manual use only
+            WOUND_POISON_1                      = 13219,
+            MIND_NUMBING_POISON_1               = 5761, //manual use only
+            ANESTHETIC_POISON_1                 = 26785,
+
+            PICK_LOCK_1                         = 1804
+        };
+
+        enum RoguePassives
+        {
+            //Talents
+            SEAL_FATE1                          = 14189,
+            SEAL_FATE2                          = 14190,
+            SEAL_FATE3                          = 14193,
+            SEAL_FATE4                          = 14194,
+            SEAL_FATE5                          = 14195,
+            COMBAT_POTENCY1                     = 35541,
+            COMBAT_POTENCY2                     = 35550,
+            COMBAT_POTENCY3                     = 35551,
+            COMBAT_POTENCY4                     = 35552,
+            COMBAT_POTENCY5                     = 35553,
+            QUICK_RECOVERY1                     = 31244,
+            QUICK_RECOVERY2                     = 31245,
+            //BLADE_TWISTING1                     = 31124,
+            //BLADE_TWISTING2                     = 31126,
+            DEADLY_BREW                         = 51626,//rank 2
+            IMPROVED_KIDNEY_SHOT                = 14176,//rank 3
+            VIGOR                               = 14983,
+            REMORSELESS_ATTACKS                 = 14148,//rank 2
+            FLEET_FOOTED                        = 31209,//rank 2
+            MURDER                              = 14159,//rank 2
+            OVERKILL                            = 58426,
+            FOCUSED_ATTACKS                     = 51636,//rank 3
+            MASTER_POISONER                     = 58410,//rank 3
+            DUAL_WIELD_SPECIALIZATION           = 13852,//rank 5
+            IMPROVED_KICK                       = 13867,//rank 2
+            IMPROVED_SPRINT                     = 13875,//rank 2
+            HACK_AND_SLASH                      = 13964,//rank 5
+            VITALITY                            = 61329,//rank 3
+            NERVES_OF_STEEL                     = 31131,//rank 2
+            THROWING_SPECIALIZATION             = 51679,//rank 2
+            //SAVAGE_COMBAT                       = 58413,//rank 2
+            UNFAIR_ADVANTAGE                    = 51674,//rank 2
+            SURPRISE_ATTACKS                    = 32601,
+            PREY_ON_THE_WEAK                    = 51689,//rank 5
+            MASTER_OF_DECEPTION                 = 13971,//rank 3
+            SETUP                               = 14071,//rank 3
+            INITIATIVE                          = 13980,//rank 3
+            DIRTY_DEEDS                         = 14083,//rank 2
+            MASTER_OF_SUBTLETY                  = 31223,//rank 3
+            CHEAT_DEATH                         = 31230,//rank 3
+            ENVELOPING_SHADOWS                  = 31213,//rank 3
+            //SINISTER_CALLING                    = 31220,//rank 5
+            TURN_THE_TABLES                     = 51629,//rank 3
+            HONOR_AMONG_THIEVES                 = 51701,//rank 3
+
+            //Other
+            VIGOR_GLADIATOR                     = 21975,
+            GLYPH_BACKSTAB                      = 56800,
+
+            ROGUE_PASSIVE_DND                   = 21184 //from playercreateinfo_spell
+        };
+
+        enum RogueSpecial
+        {
+            MUTILATE_DAMAGE_MAINHAND_1          = 5374,
+            MUTILATE_DAMAGE_OFFHAND_1           = 27576,
+
+            //TURN_THE_TABLES_BUFF                = 52910,//'rank 3'
+            HUNGER_FOR_BLOOD_BUFF               = 63848,
+            WAYLAY_DEBUFF                       = 51693,
+            REMORSELESS_ATTACKS_BUFF            = 14149,
+            CHEATING_DEATH_BUFF                 = 45182, //hidden
+            TRICKS_OF_THE_TRADE_BUFF            = 57933,
+
+            RELENTLESS_STRIKES_EFFECT           = 14181,
+            RUTHLESSNESS_EFFECT                 = 14157,
+            SEAL_FATE_EFFECT                    = 14189,
+            SETUP_EFFECT                        = 15250,
+            INITIATIVE_EFFECT                   = 13977,
+            HONOR_AMONG_THIEVES_EFFECT          = 51699,
+
+            VANISH_TRIGGERED_1                  = 11327,
+            VANISH_TRIGGERED_2                  = 11329,
+            VANISH_TRIGGERED_3                  = 26888,
+
+            //Poisons
+            CRIPPLING_POISON_PROC_1             = 3409,
+            //INSTANT_POISON_PROC_1               = 8680,
+            DEADLY_POISON_PROC_1                = 2818,
+            WOUND_POISON_PROC_1                 = 13218,
+            MIND_NUMBING_POISON_PROC_1          = 5760,
+            //ANESTHETIC_POISON_PROC_1            = 26688,
+
+            THISTLE_TEA                         = 9512 //'Restore Energy' 1 min cd
+        };
+    };
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
new file mode 100644
index 0000000..5a3285b
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
@@ -0,0 +1,2495 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+//#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+#include "Spell.h"
+#include "Totem.h"
+/*
+Shaman NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - around 90%
+TODO: Elemental mastery (exclusive cd with NatSw), Lava Lash
+Problems: Unsummon elemental totems if Elementals are killed
+*/
+#define MAX_TOTEMS 4
+
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new shaman_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct shaman_botAI : public bot_minion_ai
+    {
+        shaman_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_SHAMAN;
+
+            //int8 id = 1;
+            //EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            //ASSERT(einfo && "shaman_botAI failed to init standard equips!");
+            //standardEquips[0] = einfo->ItemEntry[0];
+            //standardEquips[1] = einfo->ItemEntry[1];
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_SHAMAN) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, TriggerCastFlags flags)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_SHAMAN) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, flags);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force, u);
+        }
+
+        void EnterCombat(Unit* u) { TotemsCheckTimer = 0; bot_minion_ai::EnterCombat(u); }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u) { bot_minion_ai::KilledUnit(u); }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { UnsummonAll(); bot_minion_ai::JustDied(u); }
+
+        void CheckBloodlust(uint32 diff)
+        {
+            if (BloodlustCheckTimer > diff || (!me->IsInCombat() && !master->IsInCombat()) ||
+                me->GetDistance(master) > 18 || Rand() > 35)
+                return;
+
+            BloodlustCheckTimer = 3000;
+
+            uint32 BLOODLUST = (me->getRaceMask() & RACEMASK_ALLIANCE) ? HEROISM_1 : BLOODLUST_1;
+            if (!IsSpellReady(BLOODLUST, diff))
+                return;
+
+            //already rockin'
+            //if (HasAuraName(master, BLOODLUST_1) || HasAuraName(me, BLOODLUST_1))
+            if (me->GetAuraEffect(SPELL_AURA_MOD_MELEE_RANGED_HASTE, SPELLFAMILY_SHAMAN, 0x0, 0x40, 0x0) ||
+                master->GetAuraEffect(SPELL_AURA_MOD_MELEE_RANGED_HASTE, SPELLFAMILY_SHAMAN, 0x0, 0x40, 0x0))
+                return;
+
+            //environment conditions
+            Unit const* u = me->GetVictim();
+            Creature const* cre = u ? u->ToCreature() : NULL;
+            if (!(u && (u->GetHealth() > me->GetMaxHealth() * 5 || u->GetTypeId() == TYPEID_PLAYER ||
+                (cre && (cre->IsDungeonBoss() || cre->isWorldBoss())) ||
+                me->getAttackers().size() + master->getAttackers().size() > 4)))
+                return;
+
+            //BLOODLUST = GetSpell(BLOODLUST); //not ranked
+
+            uint32 sateSpell = (me->getRaceMask() & RACEMASK_ALLIANCE) ? EXHAUSTION_AURA : SATED_AURA;
+            Unit::AuraEffectList const& dummies = me->GetAuraEffectsByType(SPELL_AURA_DUMMY);
+            for (Unit::AuraEffectList::const_iterator itr = dummies.begin(); itr != dummies.end(); ++itr)
+            {
+                if ((*itr)->GetEffIndex() != 0) continue;
+                SpellInfo const* spellInfo = (*itr)->GetSpellInfo();
+                if (spellInfo->SpellFamilyName != SPELLFAMILY_GENERIC || spellInfo->SpellIconID != 44) continue;
+                if (spellInfo->Id == sateSpell)
+                    return; //can't cast my type of bloodlust
+            }
+
+            me->InterruptNonMeleeSpells(true);
+            if (doCast(me, BLOODLUST))
+                return;
+        }
+
+        void CheckTotems(uint32 diff)
+        {
+            if (TotemsCheckTimer > diff)
+                return;
+
+            TotemsCheckTimer = urand(1500, 2000) + (!IAmFree() ? 100 * master->GetNpcBotsCount() / 2 : 0);
+
+            //Unsummon
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0 &&
+                    (!master->IsAlive() || master->GetDistance(_totems[i].second._pos) > _totems[i].second._effradius) &&
+                    me->GetDistance(_totems[i].second._pos) > _totems[i].second._effradius)
+                {
+                    //Check if we can use totemic recall and regain some mana
+                    if (!me->GetVictim()/* && GetManaPCT(me) < 90*/ && IsSpellReady(TOTEMIC_RECALL_1, diff))
+                    {
+                        uint8 count = 0;
+                        for (uint8 j = 0; j != MAX_TOTEMS; ++j)
+                        {
+                            if (j == i || _totems[j].first == 0) continue;
+                            if (me->GetDistance(_totems[j].second._pos) > 20.f)
+                                ++count;
+                        }
+                        if (count > 1)
+                        {
+                            if (doCast(me, GetSpell(TOTEMIC_RECALL_1)))
+                                return;
+                        }
+                    }
+                    Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
+                    if (!to)
+                    {
+                        TC_LOG_ERROR("entities.player", "%s has unexpectingly lost totem in slot %u!", me->GetName().c_str(), i);
+                        _totems[i].first = 0;
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                    //reset summon check timer;
+                    TotemTimer[i] = 0;
+                }
+            }
+            //global cooldown is not performed below, intead there is a special condition for Calls
+            if (GC_Timer > diff || me->IsMounted() || Feasting() || IsCasting() ||
+                (master->IsAlive() && me->GetDistance(master) > 15))
+                return;
+
+            bool CotE = me->getLevel() >= 30; //Call of the Elements is at level 30;
+
+            std::map<uint32, uint32> idMap;
+            uint32 mask = _getTotemsMask(idMap);
+
+            //EARTH
+            //EARTHsituative1 : tremor
+            if (TotemTimer[T_EARTH] <= diff && me->IsInCombat() && !IAmFree() &&
+                IsSpellReady(TREMOR_TOTEM_1, diff, false) && _totems[T_EARTH].second._type != BOT_TOTEM_TREMOR)
+            {
+                //Tremor no cd, party members only
+                Group const* gr = master->GetGroup();
+                if (gr && gr->IsMember(me->GetGUID()))
+                {
+                    uint8 subgr = gr->GetMemberGroup(me->GetGUID());
+                    uint8 count = 0;
+                    for (GroupReference const* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+                    {
+                        if (ref->getSubGroup() != subgr) continue;
+                        Player* pl = ref->GetSource();
+                        if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                        if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                        if (me->GetDistance(pl) < 20 &&
+                            pl->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+                            ++count;
+
+                        if (!pl->HaveBot()) continue;
+                        BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            if (!gr->IsMember(it->first) || gr->GetMemberGroup(it->first) != subgr) continue;
+                            Creature* bot = it->second;
+                            if (!bot || !bot->IsInWorld() || me->GetMap() != bot->FindMap() ||
+                                !bot->InSamePhase(me) || me->GetDistance(bot) > 20) continue;
+                            if (bot->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+                                ++count;
+                        }
+                    }
+
+                    if (count >= (1 + 1*((mask & BOT_TOTEM_MASK_MY_TOTEM_EARTH) != 0)))
+                    {
+                        if (doCast(me, GetSpell(TREMOR_TOTEM_1), TRIGGERED_CAST_DIRECTLY))
+                            if (!CotE)
+                                return;
+                    }
+                }
+                //check if casted
+                if (_totems[T_EARTH].second._type != BOT_TOTEM_TREMOR)
+                    SetSpellCooldown(TREMOR_TOTEM_1, 3000); //fail
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_EARTH) && TotemTimer[T_EARTH] <= diff && me->IsInCombat())
+            {
+                //EARTHsituative2 : earthbind
+                if (GetSpell(EARTHBIND_TOTEM_1)/* && _totems[T_EARTH].second.type != BOT_TOTEM_EARTHBIND*/)
+                {
+                    //15 sec cd, nearby enemies, instant effect
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 15.f);
+                    for (std::list<Unit*>::iterator itr = targets.begin(); itr != targets.end();)
+                    {
+                        Unit* u = *itr;
+                        bool erase = false;
+                        if (u->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || u->HasAuraType(SPELL_AURA_MOD_SPEED_SLOW_ALL))
+                            erase = true;
+                        else if (u->isMoving())
+                        {
+                            if (me->GetDistance(u) > 10.f && !u->HasInArc(M_PI/2, me))
+                                erase = true;
+                        }
+                        else if (me->GetDistance(u) > 9.f)
+                            erase = true;
+
+                        if (erase)
+                        {
+                            targets.erase(itr++);
+                            continue;
+                        }
+                        ++itr;
+                    }
+
+                    if (uint8(targets.size()) >= (1 + 2*((mask & BOT_TOTEM_MASK_MY_TOTEM_EARTH) != 0)))
+                    {
+                        if (doCast(me, GetSpell(EARTHBIND_TOTEM_1), TRIGGERED_CAST_DIRECTLY))
+                            if (!CotE)
+                                return;
+                    }
+                }
+
+                //EARTHmain : strength of earth
+                uint32 SoE = GetSpell(STRENGTH_OF_EARTH_TOTEM_1); //tripple check
+                if (SoE &&
+                    (!(mask & BOT_TOTEM_MASK_STRENGTH_OF_EARTH) || idMap[STRENGTH_OF_EARTH_TOTEM_1] < SoE))
+                {
+                    //no cd
+                    if (doCast(me, SoE, TRIGGERED_CAST_DIRECTLY))
+                        if (!CotE)
+                            return;
+                }
+
+                //EARTHlast : earth elemental (for mass taunt)
+                //uint32 earthElem = GetSpell(EARTH_ELEMENTAL_TOTEM_1);
+                //if (earthElem && IsSpellReady(EARTH_ELEMENTAL_TOTEM_1, diff) && !me->GetMap()->IsDungeon() &&
+                //    me->getAttackers().size() > 1)
+                //{
+                //    //no cd
+                //    if (doCast(me, earthElem, TRIGGERED_CAST_DIRECTLY))
+                //        if (!CotE)
+                //            return;
+                //}
+            }
+
+            //FIRE
+            //FIREsituative1 : magma
+            if (TotemTimer[T_FIRE] <= diff && me->IsInCombat() && !IAmFree() &&
+                GetSpell(MAGMA_TOTEM_1)/* && _totems[T_FIRE].second.type != BOT_TOTEM_MAGMA*/)
+            {
+                //magma no cd 8 yd, 2 sec delay before first tick
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 13.f);
+                for (std::list<Unit*>::iterator itr = targets.begin(); itr != targets.end();)
+                {
+                    Unit* u = *itr;
+                    bool erase = false;
+                    if (u->isMoving())
+                    {
+                        if (me->GetDistance(u) > 10.f && !u->HasInArc(M_PI/2, me))
+                            erase = true;
+                    }
+                    else if (me->GetDistance(u) > 7.f)
+                        erase = true;
+
+                    if (erase)
+                    {
+                        targets.erase(itr++);
+                        continue;
+                    }
+                    ++itr;
+                }
+
+                if (uint8(targets.size()) >= (3 + 3*((mask & BOT_TOTEM_MASK_MY_TOTEM_FIRE) != 0)))
+                {
+                    if (doCast(me, GetSpell(MAGMA_TOTEM_1), TRIGGERED_CAST_DIRECTLY))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_FIRE) && me->IsInCombat() && TotemTimer[T_FIRE] <= diff)
+            {
+                //FIREMain : wrath or flametongue no cd
+                //aura is exclusive so check mask
+                uint32 base = TOTEM_OF_WRATH_1;
+                uint32 wrathTotem = GetSpell(TOTEM_OF_WRATH_1);
+                uint32 fMask = BOT_TOTEM_MASK_WRATH;
+                if (!wrathTotem)
+                {
+                    base = FLAMETONGUE_TOTEM_1;
+                    wrathTotem = GetSpell(FLAMETONGUE_TOTEM_1);
+                    fMask = BOT_TOTEM_MASK_FLAMETONGUE;
+                }
+                if (wrathTotem &&
+                    ((mask & BOT_TOTEM_MASK_PRIMARY_FIRE) < fMask ||
+                    ((mask & BOT_TOTEM_MASK_PRIMARY_FIRE) == fMask && idMap[base] < wrathTotem)))
+                {
+                    if (doCast(me, wrathTotem, TRIGGERED_CAST_DIRECTLY))
+                        if (!CotE)
+                            return;
+                }
+
+                //FIREaddin : fire elemental
+                //uint32 fireElem = GetSpell(FIRE_ELEMENTAL_TOTEM_1);
+                //if (fireElem && IsSpellReady(FIRE_ELEMENTAL_TOTEM_1, diff) && !me->GetMap()->IsDungeon())
+                //{
+                //    if (doCast(me, fireElem, TRIGGERED_CAST_DIRECTLY))
+                //        if (!CotE)
+                //            return;
+                //}
+
+                //FIRElastresort : frostres (3 shamans of same level req)
+                uint32 frostRes = GetSpell(FROST_RESISTANCE_TOTEM_1);
+                if (frostRes && !IAmFree() &&
+                    (!(mask & BOT_TOTEM_MASK_RESISTANCE_FROST) || idMap[FROST_RESISTANCE_TOTEM_1] < frostRes))
+                {
+                    if (doCast(me, frostRes, TRIGGERED_CAST_DIRECTLY))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            //WATER
+            //WATERsituative1 : manatide
+            if (TotemTimer[T_WATER] <= diff && me->IsInCombat() && !IAmFree() &&
+                IsSpellReady(MANA_TIDE_TOTEM_1, diff, false))
+            {
+                //5 min cd, party members only, instant effect +4 ticks in 12 secs
+                bool cast = false;
+                Group const* gr = master->GetGroup();
+                if (gr && gr->IsMember(me->GetGUID()))
+                {
+                    uint8 count = 0;
+                    uint8 subgr = gr->GetMemberGroup(me->GetGUID());
+                    for (GroupReference const* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+                    {
+                        if (ref->getSubGroup() != subgr) continue;
+                        Player* pl = ref->GetSource();
+                        if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                        if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                        if (pl->IsInCombat() && pl->getPowerType() == POWER_MANA &&
+                            GetManaPCT(pl) < 35 && me->GetDistance(pl) < 25)
+                            ++count;
+
+                        if (!pl->HaveBot()) continue;
+                        BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            if (!gr->IsMember(it->first) || gr->GetMemberGroup(it->first) != subgr) continue;
+                            Creature* bot = it->second;
+                            if (!bot || !bot->IsInWorld() || me->GetMap() != bot->FindMap() || !bot->InSamePhase(me)) continue;
+                            if (bot->IsInCombat() && bot->getPowerType() == POWER_MANA &&
+                                GetManaPCT(bot) < 35 && me->GetDistance(bot) < 20)
+                                ++count;
+                        }
+                    }
+                    cast = (count >= (3 + 1*((mask & BOT_TOTEM_MASK_MY_TOTEM_WATER) != 0)));
+                }
+                if (!cast)
+                {
+                    if (master->IsInCombat() && master->getPowerType() == POWER_MANA &&
+                        GetManaPCT(master) < 35 && me->GetDistance(master) < 18)
+                        cast = true;
+                    else if (me->IsInCombat() && GetManaPCT(me) < 35)
+                        cast = true;
+                }
+
+                if (cast)
+                {
+                    if (doCast(me, GetSpell(MANA_TIDE_TOTEM_1), TRIGGERED_CAST_DIRECTLY))
+                        if (!CotE)
+                            return;
+                }
+                //check if casted
+                if (_totems[T_WATER].second._type != BOT_TOTEM_MANA_TIDE)
+                    SetSpellCooldown(MANA_TIDE_TOTEM_1, 3000); //fail
+            }
+
+            //WATERsituative2 : cleansing
+            //REMOVED CHECKS ARE TOO HEAVY
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_WATER))
+            {
+                //WATERmain : manaspring
+                uint32 MSpring = GetSpell(MANA_SPRING_TOTEM_1); //tripple check
+                if (MSpring && TotemTimer[T_WATER] <= diff && (me->IsInCombat() || !master->isMoving()) &&
+                    (!(mask & BOT_TOTEM_MASK_MANA_SPRING) || idMap[MANA_SPRING_TOTEM_1] < MSpring))
+                {
+                    //no cd
+                    bool cast = false;
+                    if (!IAmFree())
+                    {
+                        Group const* gr = master->GetGroup();
+                        if (gr)
+                        {
+                            for (GroupReference const* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+                            {
+                                Player* pl = ref->GetSource();
+                                if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                                if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                                if (pl->isMoving()) continue;
+                                if (pl->getPowerType() == POWER_MANA && GetManaPCT(pl) < 85 && me->GetDistance(pl) < 25)
+                                {
+                                    cast = true;
+                                    break;
+                                }
+
+                                if (!pl->HaveBot()) continue;
+                                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                                {
+                                    Creature* bot = it->second;
+                                    if (!bot || !bot->IsInWorld() || me->GetMap() != bot->FindMap() || !bot->InSamePhase(me)) continue;
+                                    if (bot->getPowerType() == POWER_MANA && GetManaPCT(bot) < 35 && me->GetDistance(bot) < 25)
+                                    {
+                                        cast = true;
+                                        break;
+                                    }
+                                }
+                                if (cast)
+                                    break;
+                            }
+                        }
+                        else if (!master->isMoving() && master->getPowerType() == POWER_MANA && GetManaPCT(master) < 85)
+                            cast = true;
+                    }
+                    if (!me->isMoving() && GetManaPCT(me) < 95)
+                        cast = true;
+
+                    if (cast)
+                    {
+                        if (doCast(me, MSpring, TRIGGERED_CAST_DIRECTLY))
+                            if (!CotE)
+                                return;
+                    }
+                }
+
+                //WATERlastresort : fireres (2-3 shamans of same level req)
+                uint32 fireRes = GetSpell(FIRE_RESISTANCE_TOTEM_1);
+                if (fireRes && TotemTimer[T_WATER] <= diff && me->IsInCombat() && !IAmFree() &&
+                    (!(mask & BOT_TOTEM_MASK_RESISTANCE_FIRE) || idMap[FIRE_RESISTANCE_TOTEM_1] < fireRes))
+                {
+                    if (doCast(me, fireRes, TRIGGERED_CAST_DIRECTLY))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            //AIR
+            //AIRsituative1 : grounding
+            if (TotemTimer[T_AIR] <= diff && me->IsInCombat() &&/* !IAmFree() &&*/
+                IsSpellReady(GROUNDING_TOTEM_1, diff, false))
+            {
+                //grounding 15 sec cd, party members only (and bot and master of course)
+                bool cast = false;
+                Unit* u = FindCastingTarget(27); //totem must be within cast distance
+                if (u && !IsChanneling(u)) //do not waste grounding on periodic ticks
+                {
+                    Group const* gr = !IAmFree() ? master->GetGroup() : NULL;
+                    for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                    {
+                        if (Spell const* spell = u->GetCurrentSpell(i))
+                        {
+                            uint64 tGuid = spell->m_targets.GetUnitTargetGUID();
+                            if (tGuid == me->GetGUID() || tGuid == master->GetGUID() ||
+                                (gr && gr->IsMember(tGuid) && gr->IsMember(me->GetGUID()) && gr->SameSubGroup(tGuid, me->GetGUID())))
+                            {
+                                Unit* t = sObjectAccessor->FindUnit(tGuid);
+                                if (t && t->GetDistance(me) < 27 && !t->HasAuraType(SPELL_AURA_SPELL_MAGNET))
+                                    cast = true;
+                            }
+                            break;
+                        }
+                    }
+                }
+                if (cast)
+                {
+                    if (doCast(me, GetSpell(GROUNDING_TOTEM_1), TRIGGERED_CAST_DIRECTLY))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR) && TotemTimer[T_AIR] <= diff && me->IsInCombat())
+            {
+                //AIRmain1 : wrathofair - if windfury is disabled or me and master both casters
+                if (!(mask & BOT_TOTEM_MASK_WRATH_OF_AIR) && GetSpell(WRATH_OF_AIR_TOTEM_1))
+                {
+                    bool cast = false;
+
+                    if (!IsMelee() && HasRole(BOT_ROLE_DPS|BOT_ROLE_HEAL) && !IsMeleeClass(master->getClass()))
+                        cast = true;
+                    else if (!GetSpell(WINDFURY_TOTEM_1)) //disabled
+                        cast = true;
+                    else if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR))
+                        if (mask & BOT_TOTEM_MASK_WINDFURY) //already have windfury from someone else
+                            cast = true;
+
+                    //no cd
+                    if (cast)
+                    {
+                        if (doCast(me, GetSpell(WRATH_OF_AIR_TOTEM_1), TRIGGERED_CAST_DIRECTLY))
+                            if (!CotE)
+                                return;
+                    }
+                }
+
+                //AIRmain2 : windfury
+                if (!(mask & BOT_TOTEM_MASK_WINDFURY) && GetSpell(WINDFURY_TOTEM_1))
+                {
+                    bool cast = false;
+
+                    if (IsMelee() && HasRole(BOT_ROLE_DPS) || IsMeleeClass(master->getClass()))
+                        cast = true;
+                    else if (!GetSpell(WRATH_OF_AIR_TOTEM_1)) //disabled or not available yet
+                        cast = true;
+                    else if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR))
+                        if (mask & BOT_TOTEM_MASK_WRATH_OF_AIR) //already have wrath of air from someone else
+                            cast = true;
+
+                    //no cd
+                    if (cast)
+                    {
+                        if (doCast(me, GetSpell(WINDFURY_TOTEM_1), TRIGGERED_CAST_DIRECTLY))
+                            if (!CotE)
+                                return;
+                    }
+                }
+
+                //AIRlastresort : natureres (3-4 shamans of same level req)
+                uint32 natureRes = GetSpell(NATURE_RESISTANCE_TOTEM_1);
+                if (natureRes && !IAmFree() &&
+                    (!(mask & BOT_TOTEM_MASK_RESISTANCE_NATURE) || idMap[NATURE_RESISTANCE_TOTEM_1] < natureRes))
+                {
+                    if (doCast(me, natureRes, TRIGGERED_CAST_DIRECTLY))
+                        if (!CotE)
+                            return;
+                }
+            }
+        }
+
+        void CheckShamanisticRage(uint32 diff)
+        {
+            if (!IsSpellReady(SHAMANISTIC_RAGE_1, diff) || !me->IsInCombat() || IsCasting() || Rand() > 35)
+                return;
+
+            bool cast = false;
+            //case 1: hp pressure
+            if (GetHealthPCT(me) < (50 + 20 * me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) + 5 * uint32(me->getAttackers().size())))
+                cast = true;
+            //case 2: low mana (melee)
+            else if (me->GetVictim() && !CCed(me, true) && HasRole(BOT_ROLE_DPS) && IsMelee() && GetManaPCT(me) < 40)
+                cast = true;
+
+            if (cast && doCast(me, GetSpell(SHAMANISTIC_RAGE_1)))
+                return;
+        }
+
+        void CheckThunderStorm(uint32 diff)
+        {
+            if (!IsSpellReady(THUNDERSTORM_1, diff) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 25)
+                return;
+
+            //case 1: low mana
+            if (GetManaPCT(me) < 25)
+            {
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                    return;
+            }
+
+            //case 2: AoE damage
+            //AttackerSet m_attackers = master->getAttackers();
+            Unit::AttackerSet b_attackers = me->getAttackers();
+            if (b_attackers.empty())
+                return;
+
+            uint8 tCount = 0;
+            for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if (me->GetDistance((*iter)) > 9) continue;
+                if (me->IsValidAttackTarget(*iter))
+                {
+                    ++tCount;
+                    break;
+                }
+            }
+
+            if (tCount > 1)
+            {
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                    return;
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (!IsSpellReady(WIND_SHEAR_1, diff, false) || Rand() > 40)
+                return;
+
+            if (Unit* target = FindCastingTarget(25, 0, WIND_SHEAR_1))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(WIND_SHEAR_1)))
+                    return;
+            }
+        }
+
+        void CheckShield(uint32 diff)
+        {
+            if (GC_Timer > diff || ShieldCheckTimer > diff || IsCasting() || Rand() > 15)
+                return;
+
+            ShieldCheckTimer = 2000;
+
+            Aura const* shield = NULL;
+            uint32 SHIELD =
+                HasRole(BOT_ROLE_TANK)   ? GetSpell(EARTH_SHIELD_1) :
+                HasRole(BOT_ROLE_HEAL)   ? GetSpell(WATER_SHIELD_1) :
+                HasRole(BOT_ROLE_DPS)    ? GetSpell(LIGHTNING_SHIELD_1) :
+                0;
+            SHIELD =
+                SHIELD ? SHIELD :
+                GetSpell(WATER_SHIELD_1) ? GetSpell(WATER_SHIELD_1) :
+                GetSpell(EARTH_SHIELD_1) ? GetSpell(EARTH_SHIELD_1) :
+                0;
+
+            if (!SHIELD)
+                return;
+
+            AuraApplication const* sh = me->GetAuraApplicationOfRankedSpell(SHIELD);
+            if (!sh || sh->GetBase()->GetCharges() < 5 || sh->GetBase()->GetDuration() < 30000 ||
+                sh->GetBase()->GetSpellInfo()->GetRank() < sSpellMgr->GetSpellInfo(SHIELD)->GetRank())
+            {
+                if (doCast(me, SHIELD))
+                    return;
+            }
+        }
+
+        void UpdateDeadAI(uint32 diff)
+        {
+            if (IsSpellReady(REINCARNATION_1, diff, false) && (IAmFree() || master->IsInCombat()) && Rand() < 20)
+                if (doCast(me, GetSpell(REINCARNATION_1)))
+                    return;
+
+            bot_minion_ai::UpdateDeadAI(diff);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (Wait())
+                return;
+            GenerateRand();
+            CheckShamanisticRage(diff);
+            CheckThunderStorm(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            CheckHexy(diff);
+            CheckEarthy(diff);
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 33)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50 && (!HasRole(BOT_ROLE_HEAL) || me->HasAuraType(SPELL_AURA_MOD_SILENCE)))
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            CheckBloodlust(diff);
+            BuffAndHealGroup(diff);
+            CureGroup(CURE_TOXINS, diff);
+            CheckTotems(diff);
+            CheckShield(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckDispel(diff);
+                CheckFireNova(diff);
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_SHAMAN))
+                return;
+
+            CheckHex(diff);
+            Counter(diff);
+
+            if (IsCasting())
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_FIRE|SPELL_SCHOOL_MASK_NATURE))
+                return;
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetDistance(opponent);
+
+            //spell reflections
+            if (IsSpellReady(EARTH_SHOCK_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 && CanRemoveReflectSpells(opponent, EARTH_SHOCK_1) &&
+                doCast(opponent, EARTH_SHOCK_1))
+                return;
+
+            MoveBehind(opponent);
+
+            //STORMSTRIKE
+            if (IsSpellReady(STORMSTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && IsMelee() && dist <= 5 && Rand() < 120)
+            {
+                if (doCast(opponent, GetSpell(STORMSTRIKE_1)))
+                    return;
+            }
+            //SHOCKS
+            if ((GetSpell(FLAME_SHOCK_1) || GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1)) &&
+                HasRole(BOT_ROLE_DPS) && dist < 25 && Rand() < 70)
+            {
+                if (GetSpell(FLAME_SHOCK_1))
+                {
+                    AuraEffect const* fsh = opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_SHAMAN, 0x10000000, 0x0, 0x0, me->GetGUID());
+                    if (!fsh || fsh->GetBase()->GetDuration() < 3000)
+                    {
+                        if (doCast(opponent, GetSpell(FLAME_SHOCK_1)))
+                            return;
+                    }
+                }
+
+                uint32 SHOCK = GetSpell(FROST_SHOCK_1);
+                if (!SHOCK)
+                    SHOCK = GetSpell(EARTH_SHOCK_1);
+
+                if (SHOCK)
+                {
+                    if (doCast(opponent, SHOCK))
+                        return;
+                }
+            }
+            //LAVA BURST
+            if (IsSpellReady(LAVA_BURST_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 60 &&
+                (me->getAttackers().empty() || dist > 10))
+            {
+                if (doCast(opponent, GetSpell(LAVA_BURST_1)))
+                    return;
+            }
+
+            if (((MaelstromCount < 5 || MaelstromTimer == 0) && IsMelee()) ||
+                (HasRole(BOT_ROLE_HEAL) && GetManaPCT(me) < 25))
+                return;
+
+            //CHAIN LIGHTNING
+            if (IsSpellReady(CHAIN_LIGHTNING_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 80)
+            {
+                Unit* u = FindSplashTarget(35.f, opponent, 5.f);
+                if (u && doCast(opponent, GetSpell(CHAIN_LIGHTNING_1)))
+                    return;
+            }
+            //LIGHTNING BOLT
+            if (IsSpellReady(LIGHTNING_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30)
+            {
+                uint32 LIGHTNING_BOLT = GetSpell(LIGHTNING_BOLT_1);
+                if (doCast(opponent, LIGHTNING_BOLT))
+                    return;
+            }
+        }
+
+        void CheckHexy(uint32 diff)
+        {
+            if (HexyCheckTimer > diff)
+                return;
+
+            HexyCheckTimer = 2000;
+            Hexy = FindAffectedTarget(GetSpell(HEX_1), me->GetGUID());
+        }
+
+        void CheckHex(uint32 diff)
+        {
+            //if (Hexy || !IsSpellReady(HEX_1, diff))
+            //    return;
+
+            //if (Unit* target = FindPolyTarget(20))
+            //{
+            //    if (doCast(target, GetSpell(HEX_1)))
+            //        return;
+            //}
+        }
+
+        void CheckEarthy(uint32 diff)
+        {
+            if (EarthyCheckTimer > diff)
+                return;
+
+            EarthyCheckTimer = 1000;
+            Unit const* u = FindAffectedTarget(GetSpell(EARTH_SHIELD_1), me->GetGUID(), 90.f, 3);
+            Earthy = (u && (IsTank(u) || u == master));
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting() || Rand() > 25)
+                return;
+
+            RezGroup(GetSpell(ANCESTRAL_SPIRIT_1));
+
+            if (mhEnchantExpireTimer > 0 && mhEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* mh = GetEquips(BOT_SLOT_MAINHAND))
+                    if (mh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            mh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+            if (ohEnchantExpireTimer > 0 && ohEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* oh = GetEquips(BOT_SLOT_OFFHAND))
+                    if (oh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            oh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+
+            // Weapon Enchants
+            Item* mhWeapon = GetEquips(BOT_SLOT_MAINHAND);
+            Item* ohWeapon = GetEquips(BOT_SLOT_OFFHAND);
+            //item must be non-standard, otherwise combat spells won't be rolled anyway
+            bool mhReady = mhWeapon && !mhWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && mhWeapon->GetEntry() != standardEquips[0]*/;
+            bool ohReady = ohWeapon && !ohWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && ohWeapon->GetEntry() != standardEquips[1]*/;
+
+            if (!mhReady && !ohReady)
+                return; //no ecnhantable weapons
+
+            //OK choose the enchants
+            //MH 1+ Rockbiter, 10+ Flametongue, 30+ Windfury/Earthliving
+            //OH 1+ Rockbiter, 10+ Flametongue, 20+ Frostbrand, 30+ Windfury/Earthliving
+            if (needChooseMHEnchant && mhReady)
+                mhEnchant = HasRole(BOT_ROLE_HEAL) ? (me->getLevel() >= 30 ? EARTHLIVING_WEAPON_1 :
+                    me->getLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    HasRole(BOT_ROLE_RANGED) ? (me->getLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    (me->getLevel() >= 30 ? WINDFURY_WEAPON_1 :
+                    //me->getLevel() >= 20 ? FROSTBRAND_WEAPON_1 :
+                    me->getLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/);
+
+            if (needChooseOHEnchant && ohReady) //basically only lvl 40+
+                ohEnchant = HasRole(BOT_ROLE_HEAL) ? (me->getLevel() >= 30 ? EARTHLIVING_WEAPON_1 :
+                    me->getLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    HasRole(BOT_ROLE_RANGED) ? (me->getLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    (me->getLevel() >= 30 ? WINDFURY_WEAPON_1 :
+                    me->getLevel() >= 20 ? FROSTBRAND_WEAPON_1 :
+                    me->getLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/);
+
+            uint32 MhEnchant = !mhReady ? 0 : GetSpell(mhEnchant);
+            uint32 OhEnchant = !ohReady ? 0 : GetSpell(ohEnchant);
+
+            SpellInfo const* MhEnchantInfo = mhReady && MhEnchant ? sSpellMgr->GetSpellInfo(MhEnchant) : NULL;
+            SpellInfo const* OhEnchantInfo = ohReady && OhEnchant ? sSpellMgr->GetSpellInfo(OhEnchant) : NULL;
+
+            Item* targetWeapon = NULL;
+            SpellInfo const* targetInfo = NULL;
+
+            if (mhReady && MhEnchant && mhWeapon->IsFitToSpellRequirements(MhEnchantInfo))
+            {
+                targetWeapon = mhWeapon;
+                targetInfo = MhEnchantInfo;
+            }
+            if (!targetWeapon && ohReady && OhEnchant && ohWeapon->IsFitToSpellRequirements(OhEnchantInfo))
+            {
+                targetWeapon = ohWeapon;
+                targetInfo = OhEnchantInfo;
+            }
+            if (targetWeapon)
+            {
+                Spell* spell = new Spell(me, targetInfo, TRIGGERED_NONE);
+                SpellCastTargets targets;
+                targets.SetItemTarget(targetWeapon);
+                spell->prepare(&targets);
+                return;
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GetSpell(EARTH_SHIELD_1) && Earthy == false && IsTank(target) && (target == me || !IsTank()) &&
+                (target->IsInCombat() || !target->isMoving()) && Rand() < 35)
+            {
+                AuraEffect const* eShield = target->GetAuraEffect(SPELL_AURA_REDUCE_PUSHBACK, SPELLFAMILY_SHAMAN, 0x0, 0x400, 0x0);
+                bool cast = (!eShield || eShield->GetBase()->GetCharges() < 5 || eShield->GetBase()->GetDuration() < 30000);
+
+                if (cast && doCast(target, GetSpell(EARTH_SHIELD_1)))
+                    return true;
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (target->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+            {
+                //water walking breaks on any damage
+                if (GetSpell(WATER_WALKING_1) && target->getAttackers().empty() &&
+                    !target->HasAuraType(SPELL_AURA_WATER_WALK) &&
+                    doCast(target, GetSpell(WATER_WALKING_1)))
+                {
+                    //GC_Timer = 1000;
+                    return true;
+                }
+                //bots don't need water breathing
+                if (GetSpell(WATER_BREATHING_1) && target->GetTypeId() == TYPEID_PLAYER &&
+                    !target->HasAuraType(SPELL_AURA_WATER_BREATHING) &&
+                    doCast(target, GetSpell(WATER_BREATHING_1)))
+                {
+                    //GC_Timer = 1000;
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (!IsSpellReady(PURGE_1, diff/*, false*/) || IsCasting()/* || Rand() > 35*/)
+                return;
+
+            Unit* target = FindHostileDispelTarget();
+            if (target && doCast(target, GetSpell(PURGE_1)))
+                return;
+
+            SetSpellCooldown(PURGE_1, 1500); //fail
+        }
+
+        void CheckFireNova(uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_DPS) || _totems[T_FIRE].second._type == BOT_TOTEM_NONE ||
+                !IsSpellReady(FIRE_NOVA_1, diff) || IsCasting() || Rand() > 25)
+                return;
+
+            std::list<Unit*> targets;
+            GetNearbyTargetsList(targets, 9.f, false, ObjectAccessor::GetObjectInWorld(_totems[T_FIRE].first, (Creature*)NULL));
+            if (targets.size() > 1 || (!targets.empty() && *(targets.begin()) == me->GetVictim()))
+            {
+                if (doCast(me, GetSpell(FIRE_NOVA_1)))
+                    return;
+            }
+        }
+
+        bool HealTarget(Unit* target, uint32 diff)
+        {
+            if (!target || !target->IsAlive() || me->GetDistance(target) > 40)
+                return false;
+            uint8 hp = GetHealthPCT(target);
+            if (hp > 95 &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+            if (Rand() > 50 + 40*target->IsInCombat() + 100*master->GetMap()->IsRaid())
+                return false;
+
+            if (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) &&
+                (hp < 20 || (hp < 35 && target->getAttackers().size() > 2)) &&
+                (target->GetTypeId() == TYPEID_PLAYER || IsTank(target) || target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(me, GetSpell(NATURES_SWIFTNESS_1)))
+                {
+                    if (doCast(target, GetSpell(HEALING_WAVE_1)))
+                        return true;
+                }
+            }
+
+            if (IsCasting()) return false;
+
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->ToCreature() && u->ToCreature()->isWorldBoss();
+
+            if (IsSpellReady(HEALING_WAVE_1, diff) &&
+                (hp > 45 || !GetSpell(LESSER_HEALING_WAVE_1)) && (tanking || hp < 75 || GetLostHP(target) > 12000))
+            {
+                if (doCast(target, GetSpell(HEALING_WAVE_1)))
+                    return true;
+            }
+            //Riptide stacks from different casters
+            if (IsSpellReady(RIPTIDE_1, diff) && hp < 90 && (tanking || hp < 35 || GetLostHP(target) > 3500) &&
+                !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0x0, 0x0, 0x10, me->GetGUID())
+                /*!target->HasAura(GetSpell(RIPTIDE_1), me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(RIPTIDE_1)))
+                    return true;
+            }
+            if (IsSpellReady(CHAIN_HEAL_1, diff) && hp > 50 && (hp < 90 || GetLostHP(target) > 4500) &&
+                (!tanking || target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0x0, 0x0, 0x10, me->GetGUID())))
+            {
+                if (doCast(target, GetSpell(CHAIN_HEAL_1)))
+                    return true;
+            }
+
+            if (IsSpellReady(LESSER_HEALING_WAVE_1, diff)/* && (hp < 35 || GetLostHP(target) > 7000)*/)
+            {
+                if (doCast(target, GetSpell(LESSER_HEALING_WAVE_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            //if (spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MAGIC)
+            //    return;
+
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+
+            //Call of Thunder: 5% additional critical chance for Lightning Bolt, Chain Lightning and Thunderstorm
+            if (lvl >= 30 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(THUNDERSTORM_1)))
+                crit_chance += 5.f;
+            //Tidal Mastery: 5% additional critical chance for lightning spells
+            if (lvl >= 25 && (SPELL_SCHOOL_MASK_NATURE & schoolMask))
+                crit_chance += 5.f;
+            //Blessing of the Eternals: 4% additional critical chance for all spells
+            if (lvl >= 45)
+                crit_chance += 4.f;
+            //Tidal Waves (Lesser Healing Wave crit)
+            if (spellInfo->SpellFamilyFlags[0] & 0x80)
+                if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 1, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 25.f;
+            //Tidal Force
+            if (spellInfo->SpellFamilyFlags[0] & 0x1C0)
+                if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_FORCE_BUFF, 0, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 20.f * eff->GetBase()->GetStackAmount();
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                if (lvl >= 21)
+                    pctbonus += 0.25f;
+            }
+
+            //SHAMAN_T8_ENCHANCEMENT_2P_BONUS: 20% bonus damage for Lava Lash and Stormstrike
+            if (lvl >= 60 &&
+                (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND/* || spellId == LAVA_LASH*/))
+                pctbonus += 0.2f;
+
+            //custom bonus to make stormstrike useful
+            if (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND)
+                pctbonus += 1.0f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            float flat_mod = 0.f;
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost spells
+                if (lvl >= 21 &&
+                    (spellInfo->GetSchoolMask() & (SPELL_SCHOOL_MASK_NATURE|SPELL_SCHOOL_MASK_FIRE|SPELL_SCHOOL_MASK_FROST)))
+                    pctbonus += 0.333f;
+                //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+                if (lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+                    pctbonus += 0.16f;
+            }
+            //Concussion: 5% bonus damage for Lightning Bolt, Chain Lightning, Thunderstorm, Lava Burst and Shocks
+            if (lvl >= 10 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(THUNDERSTORM_1) ||
+                spellId == GetSpell(LAVA_BURST_1) ||
+                spellId == GetSpell(EARTH_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1) ||
+                spellId == GetSpell(FLAME_SHOCK_1)))
+                pctbonus += 0.05f;
+            //Call of Flame (part 2): 6% bonus damage for Lava burst
+            if (lvl >= 15 && spellId == GetSpell(LAVA_BURST_1))
+                pctbonus += 0.06f;
+            //Storm, Earth and fire (part 3): 60% bonus damage for Flame Shock (periodic damage in fact but who cares?)
+            if (lvl >= 40 && spellId == GetSpell(FLAME_SHOCK_1))
+                pctbonus += 0.6f;
+            //Booming Echoes (part 2): 20% bonus damage for Flame Shock and Frost Shock (direct damage)
+            if (lvl >= 45 &&
+                (spellId == GetSpell(FLAME_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1)))
+                pctbonus += 0.2f;
+            //Improved Shields (part 1): 15% bonus damage for Lightning Shield orbs
+            if (lvl >= 15 && spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(LIGHTNING_SHIELD_DAMAGE_1)))
+                pctbonus += 0.15f;
+            //Shamanism: +20/25% bonus from spp
+            if (lvl >= 45)
+            {
+                if (spellId == GetSpell(CHAIN_LIGHTNING_1) || spellId == GetSpell(LIGHTNING_BOLT_1))
+                    flat_mod += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * 1.88f * me->CalculateLevelPenalty(spellInfo);
+                else if (spellId == GetSpell(LAVA_BURST_1))
+                    flat_mod += spellpower * 0.25f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * 1.88f * me->CalculateLevelPenalty(spellInfo);
+            }
+            //Elemental Oath (part 1): 10% bonus damage
+            if (lvl >= 45 && me->GetAuraEffect(ELEMENTAL_FOCUS_BUFF, 0, me->GetGUID()))
+                pctbonus += 0.1f;
+            //Elemental Weapons (part 1): 40% bonus damage
+            if (lvl >= 20 && (spellId == WINDFURY_ATTACK_MAINHAND || spellId == WINDFURY_ATTACK_OFFHAND))
+                pctbonus += 0.4f;
+
+            //Totemic Recall: bots have reduced base mana so increase mana gain here
+            //if (lvl >= 30 && spellId == GetSpell(TOTEMIC_RECALL_1))
+            //    pctbonus += 0.5f;
+
+            damage = int32(fdamage * (1.0f + pctbonus) + flat_mod);
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Healing Way: 25% bonus healing for Healing Wave
+            if (lvl >= 30 && spellId == GetSpell(HEALING_WAVE_1))
+                pctbonus += 0.25f;
+            //Purification: 10% bonus healing for all spells
+            if (lvl >= 35)
+                pctbonus += 0.1f;
+            //Nature's Blessing: 15% of Intellect to healing
+            if (lvl >= 45)
+                flat_mod += me->GetTotalStatValue(STAT_INTELLECT) * 1.0f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            //Improved Chain Heal: 20% bonus healing for Chain Heal
+            if (lvl >= 45 && spellId == GetSpell(CHAIN_HEAL_1))
+                pctbonus += 0.2f;
+            //Improved Earth Shield: 10% bonus healing for Earth Shield
+            //Glyph of Earth Shield: 20% bonus healing for Earth Shield
+            if (lvl >= 50 && spellId == EARTH_SHIELD_HEAL)
+                pctbonus += 0.3f;
+            //Improved Shields (part 3): 15% bonus healing for Earth Shield
+            if (lvl >= 15 && spellId == EARTH_SHIELD_HEAL)
+                pctbonus += 0.15f;
+            //Tidal Waves (part 2): 20% bonus (from spellpower) for Healing Wave and 10% bonus (from spellpower) for Lesser Healing Wave
+            if (lvl >= 55)
+            {
+                if (spellId == GetSpell(HEALING_WAVE_1))
+                    flat_mod += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+                else if (spellId == GetSpell(LESSER_HEALING_WAVE_1))
+                    flat_mod += spellpower * 0.1f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            }
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Clearcasting: -40% mana cost
+            if (AuraEffect const* eff = me->GetAuraEffect(ELEMENTAL_FOCUS_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 0.4f;
+            //Convection
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x90100003) || (spellInfo->SpellFamilyFlags[1] & 0x8001000)))
+                pctbonus += 0.1f;
+            //Shamanistic Focus
+            if (lvl >= 20 && (spellInfo->SpellFamilyFlags[0] & 0x90100000))
+                pctbonus += 0.45f;
+            //Mental Quickness:
+            if (lvl >= 50 && !spellInfo->CalcCastTime())
+                pctbonus += 0.06f;
+            //Totemic Focus:
+            if (lvl >= 10 && (spellInfo->AttributesEx7 & SPELL_ATTR7_SUMMON_PLAYER_TOTEM))
+                pctbonus += 0.25f;
+            //Tidal Focus:
+            if (lvl >= 15 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x1C0) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x400) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x10)))
+                pctbonus += 0.05f;
+
+            //flat mods
+            //!1 rage = 10 pts!
+            ////Improved Heroic Strike: -3 rage cost for Heroic Strike
+            //if (lvl >= 10 && spellId == GetSpell(HEROIC_STRIKE_1))
+            //    flatbonus += 30;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+        {
+            //casttime is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Nature's Swiftness: -100% cast time
+            if (AuraEffect const* eff = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+
+            //pct mods
+            if (spellId == GetSpell(LIGHTNING_BOLT_1) || spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(HEALING_WAVE_1) || spellId == GetSpell(LESSER_HEALING_WAVE_1) ||
+                spellId == GetSpell(CHAIN_HEAL_1) || spellId == GetSpell(HEX_1))
+            {
+                Aura* maelstrom = me->GetAura(MAELSTROM_WEAPON_BUFF);
+                if (maelstrom)
+                {
+                    pctbonus += 0.2f * maelstrom->GetStackAmount();
+                    static_cast<bool>(maelUseUp) = true;
+                }
+            }
+            //Tidal Waves (Healing Wave cast time)
+            if (spellInfo->SpellFamilyFlags[0] & 0x40)
+                if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 0, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.3f;
+
+            //flat mods
+            //Improved Healing Wave: -0.5 sec
+            if (lvl >= 10 && spellId == GetSpell(HEALING_WAVE_1))
+                timebonus += 500;
+            //Lightning Mastery: -0.5 sec
+            if (lvl >= 35 && ((spellInfo->SpellFamilyFlags[0] & 0x3) || (spellInfo->SpellFamilyFlags[1] & 0x1000)))
+                timebonus += 500;
+            //Stormcaller Chain Heal Bonus (26122): -0.4 sec
+            if (lvl >= 60 && spellId == GetSpell(CHAIN_HEAL_1))
+                timebonus += 400;
+
+            casttime = std::max<int32>((float(casttime) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            //if (lvl >= 40 && spellId == GetSpell(CHARGE_1))
+            //    pctbonus += 0.07f;
+
+            //flat mods
+            //Reverberation
+            if (lvl >= 20 && ((spellInfo->SpellFamilyFlags[0] & 0x90100000) || (spellInfo->SpellFamilyFlags[1] & 0x8000000)))
+                timebonus += 1000;
+            //Booming Echoes (part 1)
+            if (lvl >= 45 && (spellInfo->SpellFamilyFlags[0] & 0x90000000))
+                timebonus += 2000;
+            //Storm, Earth and Fire (part 1)
+            if (lvl >= 40 && (spellInfo->SpellFamilyFlags[0] & 0x2))
+                timebonus += 2500;
+            //Improved Fire Nova (part 2)
+            if (lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x8000000))
+                timebonus += 4000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Improved Reincarnation + Reduced Reincarnation Cooldown: -20 min cooldown for Reincarnation
+            if (spellId == GetSpell(REINCARNATION_1))
+                timebonus += 1200000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->getLevel();
+            //float timebonus = 0.0f;
+            //float pctbonus = 0.0f;
+
+            //Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+            //    timebonus += 500.f;
+
+            //cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const
+        {
+            uint32 bonusTargets = 0;
+
+            //Glyph of Chain Heal
+            if (spellInfo->SpellFamilyFlags[0] & 0x100)
+                bonusTargets += 1;
+            //Glyph of Chain Lightning
+            if (spellInfo->SpellFamilyFlags[0] & 0x2)
+                bonusTargets += 1;
+            //Chain Healing Wave (23573)
+            if (me->getLevel() >= 60 && spellInfo->SpellFamilyFlags[0] & 0x100)
+                bonusTargets += 2;
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo)
+        {
+            uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //reincarnation: notify master
+            if (baseId == REINCARNATION_1)
+            {
+                BotWhisper("Reincarnation used!");
+
+                //no spellHit trigger - do it here
+                SpellHit(me, spellInfo);
+                me->CastSpell(me, RESURRECTION_VISUAL_SPELL, true);
+            }
+            //manatide: notify
+            if (baseId == MANA_TIDE_TOTEM_1)
+            {
+                BotWhisper("Mana Tide used!");
+            }
+            //Nature's Swiftness: notify master
+            if (baseId == NATURES_SWIFTNESS_1)
+            {
+                BotWhisper("Nature's Swiftness used!");
+            }
+
+            //Handle Clearcasting
+            if (AuraEffect* eff = me->GetAuraEffect(ELEMENTAL_FOCUS_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    eff->GetBase()->DropCharge();
+            //Handle Tidal Focus
+            //Healing Wave (cast time): if full Maelstrom than don't use up charge
+            if (MaelstromCount < 5 && (spellInfo->SpellFamilyFlags[0] & 0x40))
+                if (AuraEffect* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 0, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        eff->GetBase()->DropCharge();
+            //Lesser Healing Wave (crit)
+            if (spellInfo->SpellFamilyFlags[0] & 0x80)
+                if (AuraEffect* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 1, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        eff->GetBase()->DropCharge();
+
+            //Nature's Swiftness
+            if (AuraEffect const* eff = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0, me->GetGUID()))
+            {
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(NATURES_SWIFTNESS_1, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+
+            //Tidal Force: Handled in Unit::HandleDummyAuraProc(): case 55166:
+            //if (spellInfo->SpellFamilyFlags[0] & 0x1C0)
+            //    if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_FORCE_BUFF, 0, me->GetGUID()))
+            //        if (eff->IsAffectedOnSpell(spellInfo))
+            //            me->RemoveAuraFromStack(TIDAL_FORCE_BUFF);
+
+            //Shield cd
+            if (baseId == LIGHTNING_SHIELD_DAMAGE_1)
+                SetSpellCooldown(LIGHTNING_SHIELD_DAMAGE_1, 3000); //is that right? from spell_proc_event
+
+            //autouse totems
+            if (baseId == EARTHBIND_TOTEM_1 || baseId == STRENGTH_OF_EARTH_TOTEM_1)
+                TotemTimer[T_EARTH] = 5000;
+            if (baseId == TREMOR_TOTEM_1)
+                TotemTimer[T_EARTH] = 12000;
+            if (baseId == MAGMA_TOTEM_1)
+                TotemTimer[T_FIRE] = 12000;
+            if (baseId == TOTEM_OF_WRATH_1 || baseId == FLAMETONGUE_TOTEM_1)
+                TotemTimer[T_FIRE] = 5000;
+            if (baseId == FROST_RESISTANCE_TOTEM_1)
+                TotemTimer[T_FIRE] = 120000;
+            if (baseId == MANA_TIDE_TOTEM_1)
+                TotemTimer[T_WATER] = 12000;
+            if (baseId == MANA_SPRING_TOTEM_1)
+                TotemTimer[T_WATER] = 5000;
+            if (baseId == FIRE_RESISTANCE_TOTEM_1)
+                TotemTimer[T_WATER] = 120000;
+            if (baseId == GROUNDING_TOTEM_1)
+                TotemTimer[T_AIR] = me->getLevel() >= 15 ? 13000 : 15000;
+            if (baseId == WRATH_OF_AIR_TOTEM_1 || baseId == WINDFURY_TOTEM_1)
+                TotemTimer[T_AIR] = 5000;
+            if (baseId == NATURE_RESISTANCE_TOTEM_1)
+                TotemTimer[T_AIR] = 120000;
+            //other (manual use)
+            if (baseId == STONECLAW_TOTEM_1)
+                TotemTimer[T_EARTH] = 15000;
+            if (baseId == STONESKIN_TOTEM_1)
+                TotemTimer[T_EARTH] = 300000;
+            if (baseId == EARTH_ELEMENTAL_TOTEM_1)
+                TotemTimer[T_EARTH] = 120000;
+            if (baseId == SEARING_TOTEM_1)
+                TotemTimer[T_FIRE] = 60000;
+            if (baseId == FIRE_ELEMENTAL_TOTEM_1)
+                TotemTimer[T_FIRE] = 120000;
+            if (baseId == CLEANSING_TOTEM_1)
+                TotemTimer[T_WATER] = 300000;
+            if (baseId == HEALING_STREAM_TOTEM_1)
+                TotemTimer[T_WATER] = 300000;
+
+            //Totemic Recall totems resummon helper
+            if (baseId == TOTEMIC_RECALL_1)
+            {
+                TotemsCheckTimer = GC_Timer;
+                for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                    TotemTimer[i] = 0;
+            }
+
+            if (maelUseUp)
+            {
+                if (baseId == LIGHTNING_BOLT_1 || baseId == CHAIN_LIGHTNING_1 || baseId == HEALING_WAVE_1 ||
+                    baseId == LESSER_HEALING_WAVE_1 || baseId == CHAIN_HEAL_1 || baseId == HEX_1)
+                {
+                    MaelstromCount = 0;
+                    me->RemoveAurasDueToSpell(MAELSTROM_WEAPON_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+                }
+            }
+
+            //Item enchant
+            //We don't know which item is targeted
+            //Actually it is mh, then oh
+            if (/*baseId == ROCKBITER_WEAPON_1 || */baseId == FLAMETONGUE_WEAPON_1 || baseId == FROSTBRAND_WEAPON_1 ||
+                baseId == WINDFURY_WEAPON_1 || baseId == EARTHLIVING_WEAPON_1)
+            {
+                //We set duration to 2 seconds to prevent exploiting unequip mechanic
+                //to get enchanted weapons for player (for non-shaman bots it won't work)
+                uint32 slot = TEMP_ENCHANTMENT_SLOT;
+                uint32 duration = 2 * IN_MILLISECONDS;
+                uint32 charges = 0;
+                uint32 enchant_id = spellInfo->Effects[0].MiscValue;
+                SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+                Item* mh = GetEquips(BOT_SLOT_MAINHAND);
+                Item* oh = GetEquips(BOT_SLOT_OFFHAND);
+                Item* item = NULL;
+                uint8 itemSlot = 0;
+
+                if (mh && !mh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && mh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = mh;
+                    itemSlot = BOT_SLOT_MAINHAND;
+                }
+                else if (oh && !oh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && oh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = oh;
+                    itemSlot = BOT_SLOT_OFFHAND;
+                }
+                else
+                    ASSERT(false && "shaman bot attempted to enchant his weapons but cannot find a weapon to apply it!");
+
+                if (!IAmFree())
+                    master->GetSession()->SendEnchantmentLog(me->GetGUID(), me->GetGUID(), item->GetEntry(), enchant_id);
+
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_ID_OFFSET, enchant_id);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_DURATION_OFFSET, duration);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_CHARGES_OFFSET, charges);
+                ApplyItemBonuses(itemSlot); //RemoveItemBonuses inside
+                if (itemSlot == BOT_SLOT_MAINHAND)
+                    mhEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                else if (itemSlot == BOT_SLOT_OFFHAND)
+                    ohEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                GC_Timer = 1500; //needed
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Maelstrom Weapon helper
+            if (spellId == MAELSTROM_WEAPON_BUFF)
+            {
+                if (Aura const* mwb = me->GetAura(MAELSTROM_WEAPON_BUFF))
+                    MaelstromCount = mwb->GetStackAmount();
+
+                MaelstromTimer = 30000; //30 sec duration then reset
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            if (baseId == EARTH_SHIELD_1)
+                Earthy = true;
+
+            if (baseId == HEX_1)
+            {
+                Hexy = true;
+                HexyCheckTimer += 2000;
+            }
+
+            //Didn't comment this right away and now I don't remember talent name...
+            if (me->getLevel() >= 50 && baseId == EARTH_SHOCK_1)
+            {
+                if (AuraEffect* eff = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                    eff->ChangeAmount(eff->GetAmount() * 2);
+            }
+
+            //Lightning Overload
+            if (me->getLevel() >= 40 && (baseId == LIGHTNING_BOLT_1 || baseId == CHAIN_LIGHTNING_1) &&
+                urand(1,100) <= 33)
+            {
+                uint32 procId = 0;
+                switch (spellId)
+                {
+                    // Lightning Bolt
+                    case   403: procId = 45284; break; // Rank  1
+                    case   529: procId = 45286; break; // Rank  2
+                    case   548: procId = 45287; break; // Rank  3
+                    case   915: procId = 45288; break; // Rank  4
+                    case   943: procId = 45289; break; // Rank  5
+                    case  6041: procId = 45290; break; // Rank  6
+                    case 10391: procId = 45291; break; // Rank  7
+                    case 10392: procId = 45292; break; // Rank  8
+                    case 15207: procId = 45293; break; // Rank  9
+                    case 15208: procId = 45294; break; // Rank 10
+                    case 25448: procId = 45295; break; // Rank 11
+                    case 25449: procId = 45296; break; // Rank 12
+                    case 49237: procId = 49239; break; // Rank 13
+                    case 49238: procId = 49240; break; // Rank 14
+                    // Chain Lightning
+                    case   421: procId = 45297; break; // Rank  1
+                    case   930: procId = 45298; break; // Rank  2
+                    case  2860: procId = 45299; break; // Rank  3
+                    case 10605: procId = 45300; break; // Rank  4
+                    case 25439: procId = 45301; break; // Rank  5
+                    case 25442: procId = 45302; break; // Rank  6
+                    case 49270: procId = 49268; break; // Rank  7
+                    case 49271: procId = 49269; break; // Rank  8
+                    default:                    break;
+                }
+
+                if (procId)
+                {
+                    if (baseId == LIGHTNING_BOLT_1)
+                        me->CastSpell(target, procId, true);
+                    if (baseId == CHAIN_LIGHTNING_1)
+                    {
+                        //Normalize chance
+                        if (urand(1,100) <= (100.f / spell->Effects[0].ChainTarget))
+                            me->CastSpell(target, procId, true);
+                    }
+                }
+            }
+
+            //Shields improvement, replaces Static Shock (part 2) and Improved Earth Shield (part 1)
+            if (baseId == LIGHTNING_SHIELD_1 || baseId == EARTH_SHIELD_1 || baseId == WATER_SHIELD_1)
+            {
+                if (Aura* shield = target->GetAura(spellId, me->GetGUID()))
+                {
+                    shield->SetCharges(shield->GetCharges() + 7);
+                }
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void UnsummonAll()
+        {
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0)
+                {
+                    Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
+                    if (!to)
+                    {
+                        //TC_LOG_ERROR("entities.player", "%s has no totem in slot %u during remove!", me->GetName().c_str(), i);
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                }
+            }
+        }
+
+        //void SummonedCreatureDies(Creature* summon, Unit* /*killer*/)
+        //{
+        //    TC_LOG_ERROR("entities.player", "shaman_bot::SummonedCreatureDies(): %s", summon->GetName().c_str());
+        //}
+
+        //void JustSummoned(Creature* summon)
+        //{
+        //    TC_LOG_ERROR("entities.player", "shaman_bot::JustSummoned(): %s", summon->GetName().c_str());
+        //}
+
+        void OnBotDespawn(Creature* summon)
+        {
+            if (!summon)
+            {
+                UnsummonAll();
+                return;
+            }
+
+            TempSummon const* totem = summon->ToTempSummon();
+            if (!totem || !totem->IsTotem())
+            {
+                //TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned summon %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    slot = T_FIRE;  break;
+                case SUMMON_TYPE_TOTEM_EARTH:   slot = T_EARTH; break;
+                case SUMMON_TYPE_TOTEM_WATER:   slot = T_WATER; break;
+                case SUMMON_TYPE_TOTEM_AIR:     slot = T_AIR;   break;
+                default:
+                    TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned totem %s in unknown slot %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
+                    return;
+            }
+
+            if (_totems[slot].first == 0)
+                TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned totem %s while not having it registered!", me->GetName().c_str(), summon->GetName().c_str());
+            else if (_totems[slot].second._type == BOT_TOTEM_NONE || _totems[slot].second._type >= BOT_TOTEM_END)
+                TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned totem %s with no type assigned!", me->GetName().c_str(), summon->GetName().c_str());
+
+            //here we reset totem category cd (not totem spell cd) if totem is destroyed
+            //TC_LOG_ERROR("entities.player", "OnBotDespawn(): %s despawned (%s : %u)", summon->GetName().c_str(), summon->IsAlive() ? "alive" : summon->isDying() ? "justdied" : "unk", (uint32)summon->getDeathState());
+            if (!summon->IsAlive()) // alive here means totem is being replaced or unsummoned through other means
+                TotemTimer[slot] = 0;
+
+            _totems[slot].first = 0;
+            _totems[slot].second._type = BOT_TOTEM_NONE;
+            me->m_SummonSlot[slot+1] = 0;
+        }
+
+        void OnBotSummon(Creature* summon)
+        {
+            TempSummon const* totem = summon->ToTempSummon();
+            if (!totem || !totem->IsTotem())
+            {
+                //TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned creature %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    slot = T_FIRE;  break;
+                case SUMMON_TYPE_TOTEM_EARTH:   slot = T_EARTH; break;
+                case SUMMON_TYPE_TOTEM_WATER:   slot = T_WATER; break;
+                case SUMMON_TYPE_TOTEM_AIR:     slot = T_AIR;   break;
+                default:
+                    TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
+                    return;
+            }
+
+            //Unsummon current totem
+            uint64 curTotemGUID = _totems[slot].first;
+            if (curTotemGUID)
+            {
+                Unit* curTotem = sObjectAccessor->FindUnit(curTotemGUID);
+                if (curTotem)
+                    curTotem->ToTotem()->UnSummon();
+            }
+
+            float radius = 30.f;
+            if (SpellInfo const* info = sSpellMgr->GetSpellInfo(summon->m_spells[0]))
+                if (SpellRadiusEntry const* entry = info->Effects[0].RadiusEntry)
+                    radius = std::max<float>(entry->RadiusMax, radius);
+
+            uint32 createSpell = summon->GetUInt32Value(UNIT_CREATED_BY_SPELL);
+            if (createSpell)
+                createSpell = sSpellMgr->GetSpellInfo(createSpell)->GetFirstRankSpell()->Id;
+            //DEBUG
+            //if (!IAmFree())
+            //{
+            //    std::ostringstream msg;
+            //    msg << "Summoned " << summon->GetName() << " by basespell: " << createSpell;
+            //    BotWhisper(msg.str().c_str());
+            //}
+            uint32 btype;
+            switch (createSpell)
+            {
+                case SEARING_TOTEM_1:           btype = BOT_TOTEM_SEARING;              break;
+                case STONECLAW_TOTEM_1:         btype = BOT_TOTEM_STONECLAW;            break;
+                case SENTRY_TOTEM_1:            btype = BOT_TOTEM_SENTRY;               break;
+                case STONESKIN_TOTEM_1:         btype = BOT_TOTEM_STONESKIN;            break;
+                case HEALING_STREAM_TOTEM_1:    btype = BOT_TOTEM_HEALING_STREAM;       break;
+                case EARTHBIND_TOTEM_1:         btype = BOT_TOTEM_EARTHBIND;            break;
+                case EARTH_ELEMENTAL_TOTEM_1:   btype = BOT_TOTEM_ELEMENTAL_EARTH;      break;
+                case FIRE_ELEMENTAL_TOTEM_1:    btype = BOT_TOTEM_ELEMENTAL_FIRE;       break;
+                case MAGMA_TOTEM_1:             btype = BOT_TOTEM_MAGMA;                break;
+                case FLAMETONGUE_TOTEM_1:       btype = BOT_TOTEM_FLAMETONGUE;          break;
+                case FROST_RESISTANCE_TOTEM_1:  btype = BOT_TOTEM_RESISTANCE_FROST;     break;
+                case FIRE_RESISTANCE_TOTEM_1:   btype = BOT_TOTEM_RESISTANCE_FIRE;      break;
+                case NATURE_RESISTANCE_TOTEM_1: btype = BOT_TOTEM_RESISTANCE_NATURE;    break;
+                case GROUNDING_TOTEM_1:         btype = BOT_TOTEM_GROUNDING;            break;
+                case STRENGTH_OF_EARTH_TOTEM_1: btype = BOT_TOTEM_STRENGTH_OF_EARTH;    break;
+                case WINDFURY_TOTEM_1:          btype = BOT_TOTEM_WINDFURY;             break;
+                case WRATH_OF_AIR_TOTEM_1:      btype = BOT_TOTEM_WRATH_OF_AIR;         break;
+                case CLEANSING_TOTEM_1:         btype = BOT_TOTEM_CLEANSING;            break;
+                case MANA_SPRING_TOTEM_1:       btype = BOT_TOTEM_MANA_SPRING;          break;
+                case MANA_TIDE_TOTEM_1:         btype = BOT_TOTEM_MANA_TIDE;            break;
+                case TREMOR_TOTEM_1:            btype = BOT_TOTEM_TREMOR;               break;
+                case TOTEM_OF_WRATH_1:          btype = BOT_TOTEM_WRATH;                break;
+                default:
+                {
+                    btype = BOT_TOTEM_NONE;
+                    if (!IAmFree())
+                    {
+                        std::ostringstream msg;
+                        msg << "Unknown totem create spell: " << createSpell << "!";
+                        BotWhisper(msg.str().c_str());
+                    }
+                    break;
+                }
+            }
+            _totems[slot].first = summon->GetGUID();
+            _totems[slot].second._pos.Relocate(*summon);
+            _totems[slot].second._effradius = !((1<<btype) & BOT_TOTEM_MASK_SUMMONS) ? radius : SIZE_OF_GRIDS;
+            _totems[slot].second._type = btype;
+            me->m_SummonSlot[slot+1] = _totems[slot].first; //needed for scripts handlers
+
+            //TC_LOG_ERROR("entities.player", "shaman bot: summoned %s (type %u) at x=%.2f, y=%.2f, z=%.2f",
+            //    summon->GetName().c_str(), slot + 1, _totems[slot].second.pos.GetPositionX(), _totems[slot].second.pos.GetPositionY(), _totems[slot].second.pos.GetPositionZ());
+
+            //TODO: gets overriden in Spell::EffectSummonType (end)
+            //Without setting creator correctly it will be impossible to use summon X elemental totems
+            summon->SetCreatorGUID(me->GetGUID());
+            summon->SetDisplayId(me->GetModelForTotem(PlayerTotemType(totem->m_Properties->Id)));
+            // totem will claim master's summon slot
+            // free it to avoid conflicts with other shaman bots and master
+            // if master is a shaman his totem will despawn
+            // fixed in summoning sequence
+            //master->m_SummonSlot[++slot] = 0;
+
+            //After summon effects which are not handled for bot totems
+            //check by btype
+
+            // Storm, Earth and Fire: Earthbind totem AoE root
+            if (btype == BOT_TOTEM_EARTHBIND && me->getLevel() >= 40)
+            {
+                //master's talent will be found so do not cast earthgrab twice, instead let spell script roll the chance
+                //see spell_shaman.cpp
+                if (!master->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 3063, EFFECT_1))
+                    summon->CastSpell(summon, STORMEARTHANDFIRE_EARTHGRAB, false);
+            }
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    return mhEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    return ohEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    return mhEnchant;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    return ohEnchant;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_1:
+                    return /*GetSpell(ROCKBITER_WEAPON_1) ? ROCKBITER_WEAPON_1 : */0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_2:
+                    return GetSpell(FLAMETONGUE_WEAPON_1) ? FLAMETONGUE_WEAPON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_3:
+                    return GetSpell(FROSTBRAND_WEAPON_1) ? FROSTBRAND_WEAPON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_4:
+                    return GetSpell(WINDFURY_WEAPON_1) ? WINDFURY_WEAPON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_5:
+                    return GetSpell(EARTHLIVING_WEAPON_1) ? EARTHLIVING_WEAPON_1 : 0;
+                default:
+                    return 0;
+            }
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 value)
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    if (value)
+                        mhEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    if (value)
+                        ohEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    mhEnchant = value;
+                    needChooseMHEnchant = value ? false : true;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    ohEnchant = value;
+                    needChooseOHEnchant = value ? false : true;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset()
+        {
+            UnsummonAll();
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                TotemTimer[i] = 0;
+
+            TotemsCheckTimer = 1500;
+
+            HexyCheckTimer = 3000;
+            EarthyCheckTimer = 2000;
+            ShieldCheckTimer = 2000;
+            BloodlustCheckTimer = 5000;
+            MaelstromTimer = 0;
+
+            MaelstromCount = 0;
+
+            Hexy = false;
+            Earthy = false;
+            maelUseUp = false;
+
+            mhEnchantExpireTimer = 1;
+            ohEnchantExpireTimer = 1;
+
+            DefaultInit();
+
+            mhEnchant = 0;
+            ohEnchant = 0;
+            needChooseMHEnchant = true;
+            needChooseOHEnchant = true;
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                if (TotemTimer[i] > diff)
+                    TotemTimer[i] -= diff;
+
+            if (TotemsCheckTimer > diff)        TotemsCheckTimer -= diff;
+
+            if (HexyCheckTimer > diff)          HexyCheckTimer -= diff;
+            if (EarthyCheckTimer > diff)        EarthyCheckTimer -= diff;
+            if (ShieldCheckTimer > diff)        ShieldCheckTimer -= diff;
+            if (BloodlustCheckTimer > diff)     BloodlustCheckTimer -= diff;
+
+            if (MaelstromTimer > diff)          MaelstromTimer -= diff;
+            else if (MaelstromCount) { MaelstromCount = 0; maelUseUp = false; }
+
+            if (mhEnchantExpireTimer > diff)    mhEnchantExpireTimer -= diff;
+            if (ohEnchantExpireTimer > diff)    ohEnchantExpireTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(HEALING_WAVE_1);
+            InitSpellMap(CHAIN_HEAL_1);
+            InitSpellMap(LESSER_HEALING_WAVE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(RIPTIDE_1) : RemoveSpell(RIPTIDE_1);
+            InitSpellMap(ANCESTRAL_SPIRIT_1);
+            InitSpellMap(CURE_TOXINS_1);
+            InitSpellMap(FLAME_SHOCK_1);
+            InitSpellMap(EARTH_SHOCK_1);
+            InitSpellMap(FROST_SHOCK_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(STORMSTRIKE_1) : RemoveSpell(STORMSTRIKE_1);
+            InitSpellMap(LIGHTNING_BOLT_1);
+            InitSpellMap(CHAIN_LIGHTNING_1);
+            InitSpellMap(LAVA_BURST_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(THUNDERSTORM_1) : RemoveSpell(THUNDERSTORM_1);
+            InitSpellMap(LIGHTNING_SHIELD_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(EARTH_SHIELD_1) : RemoveSpell(EARTH_SHIELD_1);
+            InitSpellMap(WATER_SHIELD_1);
+            InitSpellMap(WATER_BREATHING_1);
+            InitSpellMap(WATER_WALKING_1);
+            InitSpellMap(PURGE_1);
+            InitSpellMap(WIND_SHEAR_1);
+            InitSpellMap(HEX_1);
+            InitSpellMap((me->getRaceMask() & RACEMASK_ALLIANCE) ? HEROISM_1 : BLOODLUST_1); //at least race is constant
+  /*Talent*/lvl >= 50 ? InitSpellMap(SHAMANISTIC_RAGE_1) : RemoveSpell(SHAMANISTIC_RAGE_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(NATURES_SWIFTNESS_1) : RemoveSpell(NATURES_SWIFTNESS_1);
+  /*Talent*///lvl >= 40 ? InitSpellMap(ELEMENTAL_MASTERY_1) : RemoveSpell(ELEMENTAL_MASTERY_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(TIDAL_FORCE_1) : RemoveSpell(TIDAL_FORCE_1);
+
+            InitSpellMap(FIRE_NOVA_1);
+            //totems
+            InitSpellMap(EARTHBIND_TOTEM_1);
+            InitSpellMap(MAGMA_TOTEM_1);
+            //InitSpellMap(SEARING_TOTEM_1);
+            //InitSpellMap(STONECLAW_TOTEM_1);
+            InitSpellMap(FIRE_ELEMENTAL_TOTEM_1);
+            InitSpellMap(EARTH_ELEMENTAL_TOTEM_1);
+            InitSpellMap(FIRE_RESISTANCE_TOTEM_1);
+            InitSpellMap(FROST_RESISTANCE_TOTEM_1);
+            InitSpellMap(NATURE_RESISTANCE_TOTEM_1);
+            InitSpellMap(FLAMETONGUE_TOTEM_1);
+            InitSpellMap(GROUNDING_TOTEM_1);
+            //InitSpellMap(SENTRY_TOTEM_1);
+            //InitSpellMap(STONESKIN_TOTEM_1);
+            InitSpellMap(STRENGTH_OF_EARTH_TOTEM_1);
+            InitSpellMap(WINDFURY_TOTEM_1);
+            InitSpellMap(WRATH_OF_AIR_TOTEM_1);
+            InitSpellMap(CLEANSING_TOTEM_1);
+            //InitSpellMap(HEALING_STREAM_TOTEM_1);
+            InitSpellMap(MANA_SPRING_TOTEM_1);
+  /*Talent*/InitSpellMap(TOTEM_OF_WRATH_1); //safe
+  /*Talent*/InitSpellMap(MANA_TIDE_TOTEM_1); //safe
+            InitSpellMap(TREMOR_TOTEM_1);
+
+            InitSpellMap(TOTEMIC_RECALL_1);
+
+            //rev
+            InitSpellMap(REINCARNATION_1); //base lvl 30, 30 min cd
+
+            CURE_TOXINS = InitSpell(me, CLEANSE_SPIRIT_1) ? CLEANSE_SPIRIT_1 : CURE_TOXINS_1;
+            RemoveSpell(CLEANSE_SPIRIT_1);
+            RemoveSpell(CURE_TOXINS_1);
+            InitSpellMap(CURE_TOXINS);
+
+            //InitSpellMap(ROCKBITER_WEAPON_1); //lvl 1
+            InitSpellMap(FLAMETONGUE_WEAPON_1); //lvl 10
+            InitSpellMap(FROSTBRAND_WEAPON_1); //lvl 20
+            InitSpellMap(WINDFURY_WEAPON_1); //lvl 30
+            InitSpellMap(EARTHLIVING_WEAPON_1); //lvl 30
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(SHAMAN_FLAME_SHOCK_PASSIVE);
+
+            RefreshAura(ELEMENTAL_FOCUS, level >= 20 ? 1 : 0);
+            RefreshAura(ELEMENTAL_WARDING, level >= 58 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION3, level >= 18 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION2, level >= 15 && level < 18 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION1, level >= 12 && level < 15 ? 1 : 0);
+            RefreshAura(ANCESTRAL_KNOWLEDGE, level >= 30 ? 3 : level >= 20 ? 2 : level >= 10 ? 1 : 0);
+            RefreshAura(TOUGHNESS, level >= 25 ? 1 : 0);
+            RefreshAura(FLURRY5, level >= 29 ? 1 : 0);
+            RefreshAura(FLURRY4, level >= 28 && level < 29 ? 1 : 0);
+            RefreshAura(FLURRY3, level >= 27 && level < 28 ? 1 : 0);
+            RefreshAura(FLURRY2, level >= 26 && level < 27 ? 1 : 0);
+            RefreshAura(FLURRY1, level >= 25 && level < 26 ? 1 : 0);
+            RefreshAura(WEAPON_MASTERY, level >= 30 ? 1 : 0);
+            RefreshAura(STATIC_SHOCK, level >= 45 ? 2 : level >= 41 ? 1 : 0);
+            RefreshAura(ANCESTRAL_HEALING, level >= 20 ? 1 : 0);
+            RefreshAura(ANCESTRAL_AWAKENING, level >= 50 ? 1 : 0);
+            RefreshAura(IMPROVED_WATER_SHIELD, level >= 20 ? 1 : 0);
+            RefreshAura(TIDAL_WAVES, level >= 55 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON5, level >= 70 ? 2 : level >= 60 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON4, level >= 55 && level < 60 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON3, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON2, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON1, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(EARTHEN_POWER, level >= 50 ? 1 : 0);
+            RefreshAura(UNLEASHED_RAGE, level >= 40 ? 1 : 0);
+            RefreshAura(IMPROVED_STORMSTRIKE, level >= 40 ? 1 : 0);
+            RefreshAura(ELEMENTAL_OATH, level >= 40 ? 1 : 0);
+            //RefreshAura(STORM_EARTH_AND_FIRE, level >= 45 ? 1 : 0);
+            RefreshAura(SHAMAN_T10_RESTO_4P, level >= 70 ? 1 : 0);
+            //RefreshAura(EARTHLIVING_WEAPON_PASSIVE_6, level >= 70 ? 3 : 0);
+            //RefreshAura(EARTHLIVING_WEAPON_PASSIVE_5, level >= 50 && level < 70 ? 3 : 0);
+            //RefreshAura(EARTHLIVING_WEAPON_PASSIVE_4, level >= 30 && level < 50 ? 3 : 0);
+
+            RefreshAura(GLYPH_THUNDERSTORM, GetSpell(THUNDERSTORM_1) ? 1 : 0);
+            RefreshAura(GLYPH_TOTEM_OF_WRATH, GetSpell(TOTEM_OF_WRATH_1) ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case HEALING_WAVE_1:
+                case CHAIN_HEAL_1:
+                case LESSER_HEALING_WAVE_1:
+                case RIPTIDE_1:
+                case CLEANSE_SPIRIT_1:
+                case WATER_WALKING_1:
+                case WATER_BREATHING_1:
+                case BLOODLUST_1:
+                case HEROISM_1:
+                case SHAMANISTIC_RAGE_1:
+                //case ELEMENTAL_MASTERY_1:
+                case TIDAL_FORCE_1:
+                //Totems
+                //case EARTHBIND_TOTEM_1:
+                //case MAGMA_TOTEM_1:
+                //case SEARING_TOTEM_1:
+                //case STONECLAW_TOTEM_1:
+                case FIRE_ELEMENTAL_TOTEM_1:
+                case EARTH_ELEMENTAL_TOTEM_1:
+                //case FIRE_RESISTANCE_TOTEM_1:
+                //case FROST_RESISTANCE_TOTEM_1:
+                //case NATURE_RESISTANCE_TOTEM_1:
+                //case FLAMETONGUE_TOTEM_1:
+                //case GROUNDING_TOTEM_1:
+                //case SENTRY_TOTEM_1:
+                //case STONESKIN_TOTEM_1:
+                //case STRENGTH_OF_EARTH_TOTEM_1:
+                //case WINDFURY_TOTEM_1:
+                //case WRATH_OF_AIR_TOTEM_1:
+                case CLEANSING_TOTEM_1:
+                //case HEALING_STREAM_TOTEM_1:
+                //case MANA_SPRING_TOTEM_1:
+                //case TOTEM_OF_WRATH_1:
+                case MANA_TIDE_TOTEM_1:
+                //case TREMOR_TOTEM_1:
+                case TOTEMIC_RECALL_1:
+                    return true;
+                case CURE_TOXINS_1:
+                    return !GetSpell(CLEANSE_SPIRIT_1);
+                case FIRE_NOVA_1:
+                    return _totems[T_FIRE].second._type != BOT_TOTEM_NONE;
+                default:
+                    return false;
+            }
+        }
+
+        bool HasAbilitiesSpecifics() const { return true; }
+        void FillAbilitiesSpecifics(std::list<std::string> &specList)
+        {
+            std::ostringstream msg1;
+            msg1 << "Main hand: ";
+            switch (mhEnchant)
+            {
+                //case ROCKBITER_WEAPON_1:   msg1 << "Rockbiter";  break;
+                case FLAMETONGUE_WEAPON_1: msg1 << "Flametongue";break;
+                case FROSTBRAND_WEAPON_1:  msg1 << "Frostbrand"; break;
+                case WINDFURY_WEAPON_1:    msg1 << "Windfury";   break;
+                case EARTHLIVING_WEAPON_1: msg1 << "Earthliving";break;
+                default:                   msg1 << "Nothing";    break;
+            }
+            specList.push_back(msg1.str());
+
+            std::ostringstream msg2;
+            msg2 << "Offhand: ";
+            switch (ohEnchant)
+            {
+                //case ROCKBITER_WEAPON_1:   msg2 << "Rockbiter";  break;
+                case FLAMETONGUE_WEAPON_1: msg2 << "Flametongue";break;
+                case FROSTBRAND_WEAPON_1:  msg2 << "Frostbrand"; break;
+                case WINDFURY_WEAPON_1:    msg2 << "Windfury";   break;
+                case EARTHLIVING_WEAPON_1: msg2 << "Earthliving";break;
+                default:                   msg2 << "Nothing";    break;
+            }
+            specList.push_back(msg2.str());
+        }
+
+    private:
+        //Totem system
+        struct BotTotemParam
+        {
+            BotTotemParam() : _effradius(0.f) {}
+            uint32 _type;
+            Position _pos;
+            float _effradius;
+        };
+        typedef std::pair<uint64 /*guid*/, BotTotemParam /*param*/> BotTotem;
+        BotTotem _totems[MAX_TOTEMS];
+        uint32 TotemTimer[MAX_TOTEMS];
+        //Spells
+        uint32 CURE_TOXINS;
+        //Timers
+        uint32 TotemsCheckTimer;
+        uint32 HexyCheckTimer, EarthyCheckTimer, ShieldCheckTimer, BloodlustCheckTimer, MaelstromTimer;
+        uint8 MaelstromCount;
+        bool Hexy, Earthy;
+        bool maelUseUp;
+        //uint32 standardEquips[2];
+        uint32 mhEnchantExpireTimer, ohEnchantExpireTimer;
+        uint32 mhEnchant, ohEnchant;
+        bool needChooseMHEnchant, needChooseOHEnchant;
+
+        uint32 _getTotemsMask(std::map<uint32 /*type*/, uint32 /*curId*/>& idMap) const
+        {
+            uint32 mask = 0;
+
+            Unit* cre;
+            uint32 sumonSpell;
+            uint32 baseId;
+            bool isTotem;
+            int8 mytype;
+            Unit::AuraApplicationMap const& aurapps = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                //from totem aura extract base spell it could be summoned by
+                if (itr->second->GetBase()->GetType() != UNIT_AURA_TYPE) continue;
+                cre = itr->second->GetBase()->GetUnitOwner();
+                //DEBUG
+                //uint32 base = cre->GetUInt32Value(UNIT_CREATED_BY_SPELL);
+                //if (base)
+                //    baseId = sSpellMgr->GetSpellInfo(base)->GetFirstRankSpell()->Id;
+                //if (target->GetEntry() == 70025 && cre->GetGUID() != me->GetGUID())
+                //{
+                //    TC_LOG_ERROR("spells","totemMask: unit %s, %s (%u), owner %s (crSp %u, base %u), istotem %u", target->GetName().c_str(),
+                //        itr->second->GetBase()->GetSpellInfo()->SpellName[0], itr->second->GetBase()->GetId(),
+                //        cre ? cre->GetName().c_str() : "unk", base, baseId, uint32(cre->IsTotem()));
+                //}
+                sumonSpell = cre ? cre->GetUInt32Value(UNIT_CREATED_BY_SPELL) : 0;
+                if (!sumonSpell || !cre->IsTotem())
+                    continue;
+
+                isTotem = true;
+                baseId = sSpellMgr->GetSpellInfo(sumonSpell)->GetFirstRankSpell()->Id;
+                switch (baseId)
+                {
+                    case FIRE_RESISTANCE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_RESISTANCE_FIRE;     mytype = T_WATER;   break;
+                    case FROST_RESISTANCE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_RESISTANCE_FROST;    mytype = T_FIRE;    break;
+                    case NATURE_RESISTANCE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_RESISTANCE_NATURE;   mytype = T_AIR;     break;
+                    case FLAMETONGUE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_FLAMETONGUE;         mytype = T_FIRE;    break;
+                    case GROUNDING_TOTEM_1: //no ranking
+                        mask |= BOT_TOTEM_MASK_GROUNDING;           mytype = T_AIR;     break;
+                    //case STONESKIN_TOTEM_1:
+                    //    mask |= BOT_TOTEM_MASK_STONESKIN;           mytype = T_EARTH;   break;
+                    case STRENGTH_OF_EARTH_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_STRENGTH_OF_EARTH;   mytype = T_EARTH;   break;
+                    case WINDFURY_TOTEM_1: //no ranking
+                        mask |= BOT_TOTEM_MASK_WINDFURY;            mytype = T_AIR;     break;
+                    case WRATH_OF_AIR_TOTEM_1: //no ranking
+                        mask |= BOT_TOTEM_MASK_WRATH_OF_AIR;        mytype = T_AIR;     break;
+                    case MANA_SPRING_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_MANA_SPRING;         mytype = T_WATER;   break;
+                    case TOTEM_OF_WRATH_1:
+                        mask |= BOT_TOTEM_MASK_WRATH;               mytype = T_FIRE;    break;
+                    default:
+                        isTotem = false; //next aura
+                        break;
+                }
+
+                if (isTotem)
+                {
+                    idMap[baseId] = sumonSpell;
+                    for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                    {
+                        if (itr->second->GetBase()->GetCasterGUID() == me->m_SummonSlot[i+1])
+                        {
+                            //mask |= BOT_TOTEM_MASK_MY_TOTEM;
+                            switch (mytype)
+                            {
+                                case T_FIRE:    mask |= BOT_TOTEM_MASK_MY_TOTEM_FIRE;   break;
+                                case T_EARTH:   mask |= BOT_TOTEM_MASK_MY_TOTEM_EARTH;  break;
+                                case T_WATER:   mask |= BOT_TOTEM_MASK_MY_TOTEM_WATER;  break;
+                                case T_AIR:     mask |= BOT_TOTEM_MASK_MY_TOTEM_AIR;    break;
+                                default:                                                break;
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+
+            return mask;
+        }
+
+        enum ShamanBaseSpells
+        {
+            HEALING_WAVE_1                      = 331,
+            CHAIN_HEAL_1                        = 1064,
+            LESSER_HEALING_WAVE_1               = 8004,
+            RIPTIDE_1                           = 61295,
+            ANCESTRAL_SPIRIT_1                  = 2008,
+            CURE_TOXINS_1                       = 526,
+            CLEANSE_SPIRIT_1                    = 51886,
+            FLAME_SHOCK_1                       = 8050,
+            EARTH_SHOCK_1                       = 8042,
+            FROST_SHOCK_1                       = 8056,
+            STORMSTRIKE_1                       = 17364,
+            LIGHTNING_BOLT_1                    = 403,
+            CHAIN_LIGHTNING_1                   = 421,
+            LAVA_BURST_1                        = 51505,
+            THUNDERSTORM_1                      = 51490,
+            LIGHTNING_SHIELD_1                  = 324,
+            EARTH_SHIELD_1                      = 974,
+            WATER_SHIELD_1                      = 52127,
+            WATER_BREATHING_1                   = 131,
+            WATER_WALKING_1                     = 546,
+            PURGE_1                             = 370,
+            WIND_SHEAR_1                        = 57994,
+            HEX_1                               = 51514,
+            BLOODLUST_1                         = 2825,
+            HEROISM_1                           = 32182,
+            SHAMANISTIC_RAGE_1                  = 30823,
+            NATURES_SWIFTNESS_1                 = 16188,//castegory = 1202
+            //ELEMENTAL_MASTERY_1                 = 16166,//castegory = 1202 NYI
+            TIDAL_FORCE_1                       = 55198,
+
+            FIRE_NOVA_1                         = 1535,//shaman spell
+            EARTHBIND_TOTEM_1                   = 2484,
+            MAGMA_TOTEM_1                       = 8190,
+            SEARING_TOTEM_1                     = 3599,
+            STONECLAW_TOTEM_1                   = 5730,
+            FIRE_ELEMENTAL_TOTEM_1              = 2894,
+            EARTH_ELEMENTAL_TOTEM_1             = 2062,
+            FIRE_RESISTANCE_TOTEM_1             = 8184,
+            FROST_RESISTANCE_TOTEM_1            = 8181,
+            NATURE_RESISTANCE_TOTEM_1           = 10595,
+            FLAMETONGUE_TOTEM_1                 = 8227,
+            GROUNDING_TOTEM_1                   = 8177,
+            SENTRY_TOTEM_1                      = 6495,
+            STONESKIN_TOTEM_1                   = 8071,
+            STRENGTH_OF_EARTH_TOTEM_1           = 8075,
+            WINDFURY_TOTEM_1                    = 8512,
+            WRATH_OF_AIR_TOTEM_1                = 3738,
+            CLEANSING_TOTEM_1                   = 8170,
+            HEALING_STREAM_TOTEM_1              = 5394,
+            MANA_SPRING_TOTEM_1                 = 5675,
+            TOTEM_OF_WRATH_1                    = 30706,
+            MANA_TIDE_TOTEM_1                   = 16190,
+            TREMOR_TOTEM_1                      = 8143,
+
+            TOTEMIC_RECALL_1                    = 36936,
+
+            REINCARNATION_1                     = 21169,
+
+            //ROCKBITER_WEAPON_1                  = 8017, //disabled due to bonus handling method
+            FLAMETONGUE_WEAPON_1                = 8024,
+            FROSTBRAND_WEAPON_1                 = 8033,
+            WINDFURY_WEAPON_1                   = 8232,
+            EARTHLIVING_WEAPON_1                = 51730
+        };
+
+        enum ShamanPassives
+        {
+            //Elemental
+            ELEMENTAL_FOCUS                     = 16164,//clearcast
+            ELEMENTAL_DEVASTATION1              = 30160,
+            ELEMENTAL_DEVASTATION2              = 29179,
+            ELEMENTAL_DEVASTATION3              = 29180,
+            ELEMENTAL_WARDING                   = 28998,//rank 3
+            ELEMENTAL_OATH                      = 51470,//rank 2
+            //STORM_EARTH_AND_FIRE                = 51486,//rank 3
+            //Enchancement
+            ANCESTRAL_KNOWLEDGE                 = 17489,//rank 5
+            TOUGHNESS                           = 16309,//rank 5
+            FLURRY1                             = 16256,
+            FLURRY2                             = 16281,
+            FLURRY3                             = 16282,
+            FLURRY4                             = 16283,
+            FLURRY5                             = 16284,
+            WEAPON_MASTERY                      = 29086,//rank 3
+            UNLEASHED_RAGE                      = 30809,//rank 3
+            STATIC_SHOCK                        = 51527,//rank 3
+            IMPROVED_STORMSTRIKE                = 51522,//rank 2
+            MAELSTROM_WEAPON1                   = 51528,
+            MAELSTROM_WEAPON2                   = 51529,
+            MAELSTROM_WEAPON3                   = 51530,
+            MAELSTROM_WEAPON4                   = 51531,
+            MAELSTROM_WEAPON5                   = 51532,
+            EARTHEN_POWER                       = 51524,//rank 2
+            //Restoration
+            ANCESTRAL_HEALING                   = 16240,//rank 3
+            ANCESTRAL_AWAKENING                 = 51558,//rank 3
+            IMPROVED_WATER_SHIELD               = 16198,//rank 3
+            TIDAL_WAVES                         = 51566,//rank 5
+            //Special
+            GLYPH_THUNDERSTORM                  = 62132,
+            GLYPH_TOTEM_OF_WRATH                = 63280,
+            SHAMAN_T10_RESTO_4P                 = 70808 //Chain Heal HoT
+        };
+
+        enum ShamanSpecial
+        {
+            SHAMAN_FLAME_SHOCK_PASSIVE          = 75461,//flame shock damage can be critical in 3.3.5, innate
+
+            ELEMENTAL_FOCUS_BUFF                = 16246,
+            TIDAL_FORCE_BUFF                    = 55166,//Unit::HandleAuraDummy(): case 55198:
+
+            //20% chance to put HoT on healed target over 12 sec
+            //EARTHLIVING_WEAPON_PASSIVE_4        = 52005,//348 base hp
+            //EARTHLIVING_WEAPON_PASSIVE_5        = 52007,//456 base hp
+            //EARTHLIVING_WEAPON_PASSIVE_6        = 52008,//652 base hp
+
+            MAELSTROM_WEAPON_BUFF               = 53817,
+            TIDAL_WAVES_BUFF                    = 53390,
+            STORMSTRIKE_DAMAGE                  = 32175,
+            STORMSTRIKE_DAMAGE_OFFHAND          = 32176,
+
+            LIGHTNING_SHIELD_DAMAGE_1           = 26364,
+            EARTH_SHIELD_HEAL                   = 379,
+
+            RESURRECTION_VISUAL_SPELL           = 21074, //Test NPC Resurrection
+
+            EXHAUSTION_AURA                     = 57723,
+            SATED_AURA                          = 57724,
+
+            WINDFURY_ATTACK_MAINHAND            = 25504,
+            WINDFURY_ATTACK_OFFHAND             = 33750,
+
+            STORMEARTHANDFIRE_EARTHGRAB         = 64695,
+
+            //TOTEM_AURA_WRATH_AURA1              = 57658,//100
+            //TOTEM_AURA_WRATH_AURA2              = 57660,//120
+            //TOTEM_AURA_WRATH_AURA3              = 57662,//140
+            //TOTEM_AURA_WRATH_AURA4              = 57663,//280
+            //TOTEM_AURA_RESISTANCE_FIRE_1        = 8185,
+            //TOTEM_AURA_RESISTANCE_FROST_1       = 8182,
+            //TOTEM_AURA_RESISTANCE_NATURE_1      = 10596,
+            //TOTEM_AURA_FLAMETONGUE_1            = 52109,
+            //TOTEM_AURA_GROUNDING                = 8178,
+            //TOTEM_AURA_STONESKIN_1              = 8072,
+            //TOTEM_AURA_STRENGTH_OF_EARTH_1      = 8076,
+            //TOTEM_AURA_WINDFURY                 = 8515,
+            //TOTEM_AURA_WRATH_OF_AIR             = 2895,
+            //TOTEM_AURA_MANA_SPRING_1            = 5677
+        };
+
+        enum TotemSlot
+        {
+            T_FIRE  = 0,//m_SummonSlot[1]
+            T_EARTH = 1,//m_SummonSlot[2]
+            T_WATER = 2,//m_SummonSlot[3]
+            T_AIR   = 3,//m_SummonSlot[4]
+        };
+        enum BotTotemType : uint32
+        {
+            BOT_TOTEM_NONE                  = 0,
+            BOT_TOTEM_STRENGTH_OF_EARTH     = 1, //main earth totem
+            BOT_TOTEM_FLAMETONGUE           = 2, //main fire totem
+            BOT_TOTEM_WRATH                 = 3, //main fire totem
+            BOT_TOTEM_MANA_SPRING           = 4, //main water totem
+            BOT_TOTEM_WINDFURY              = 5, //main air totem
+            BOT_TOTEM_WRATH_OF_AIR          = 6, //main air totem
+            BOT_TOTEM_STONESKIN             = 7, //secondary earth totem UNUSED
+            BOT_TOTEM_HEALING_STREAM        = 8, //secondary water totem UNUSED
+            BOT_TOTEM_TREMOR                = 9, //situative earth 1
+            BOT_TOTEM_EARTHBIND             = 10, //situative earth 2
+            BOT_TOTEM_MAGMA                 = 11, //situative fire 1
+            BOT_TOTEM_MANA_TIDE             = 12, //situative water 1
+            BOT_TOTEM_CLEANSING             = 13, //situative water 2 non-raid
+            BOT_TOTEM_GROUNDING             = 14, //situative air 1
+            BOT_TOTEM_RESISTANCE_FROST      = 15, //manual fire 1
+            BOT_TOTEM_RESISTANCE_FIRE       = 16, //manual water 1
+            BOT_TOTEM_RESISTANCE_NATURE     = 17, //manual air 1
+            BOT_TOTEM_ELEMENTAL_EARTH       = 18, //manual earth 1
+            BOT_TOTEM_ELEMENTAL_FIRE        = 19, //manual fire 2
+            BOT_TOTEM_SENTRY                = 20, //UNUSED
+            BOT_TOTEM_STONECLAW             = 21, //UNUSED
+            BOT_TOTEM_SEARING               = 22, //UNUSED, annoying as hell too
+            BOT_TOTEM_END,
+
+            BOT_TOTEM_FLAG_MY_TOTEM_FIRE,
+            BOT_TOTEM_FLAG_MY_TOTEM_EARTH,
+            BOT_TOTEM_FLAG_MY_TOTEM_WATER,
+            BOT_TOTEM_FLAG_MY_TOTEM_AIR,
+
+            BOT_TOTEM_MASK_SUMMONS          = ((1<<BOT_TOTEM_ELEMENTAL_EARTH)|(1<<BOT_TOTEM_ELEMENTAL_FIRE)),
+
+            //BOT_TOTEM_MASK_MY_TOTEM         = (1<<BOT_TOTEM_NONE),
+
+            BOT_TOTEM_MASK_STRENGTH_OF_EARTH= (1<<BOT_TOTEM_STRENGTH_OF_EARTH),
+            BOT_TOTEM_MASK_FLAMETONGUE      = (1<<BOT_TOTEM_FLAMETONGUE),
+            BOT_TOTEM_MASK_WRATH            = (1<<BOT_TOTEM_WRATH),
+            BOT_TOTEM_MASK_MANA_SPRING      = (1<<BOT_TOTEM_MANA_SPRING),
+            BOT_TOTEM_MASK_WINDFURY         = (1<<BOT_TOTEM_WINDFURY),
+            BOT_TOTEM_MASK_WRATH_OF_AIR     = (1<<BOT_TOTEM_WRATH_OF_AIR),
+            //BOT_TOTEM_MASK_STONESKIN        = (1<<BOT_TOTEM_STONESKIN),
+            BOT_TOTEM_MASK_MANA_TIDE        = (1<<BOT_TOTEM_MANA_TIDE),
+            BOT_TOTEM_MASK_GROUNDING        = (1<<BOT_TOTEM_GROUNDING),
+            BOT_TOTEM_MASK_RESISTANCE_FROST = (1<<BOT_TOTEM_RESISTANCE_FROST),
+            BOT_TOTEM_MASK_RESISTANCE_FIRE  = (1<<BOT_TOTEM_RESISTANCE_FIRE),
+            BOT_TOTEM_MASK_RESISTANCE_NATURE= (1<<BOT_TOTEM_RESISTANCE_NATURE),
+
+            BOT_TOTEM_MASK_PRIMARY_FIRE     = (BOT_TOTEM_MASK_FLAMETONGUE | BOT_TOTEM_MASK_WRATH),
+
+            BOT_TOTEM_MASK_MY_TOTEM_FIRE    = (1<<BOT_TOTEM_FLAG_MY_TOTEM_FIRE),
+            BOT_TOTEM_MASK_MY_TOTEM_EARTH   = (1<<BOT_TOTEM_FLAG_MY_TOTEM_EARTH),
+            BOT_TOTEM_MASK_MY_TOTEM_WATER   = (1<<BOT_TOTEM_FLAG_MY_TOTEM_WATER),
+            BOT_TOTEM_MASK_MY_TOTEM_AIR     = (1<<BOT_TOTEM_FLAG_MY_TOTEM_AIR),
+
+            BOT_TOTEM_MASK_PRIMARY_USE      = (BOT_TOTEM_MASK_STRENGTH_OF_EARTH | BOT_TOTEM_MASK_FLAMETONGUE | \
+                                            BOT_TOTEM_MASK_WRATH | BOT_TOTEM_MASK_MANA_SPRING | \
+                                            BOT_TOTEM_WINDFURY | BOT_TOTEM_MASK_WRATH_OF_AIR),
+
+            BOT_TOTEM_MASK_MY_TOTEM_ALL     = (BOT_TOTEM_MASK_MY_TOTEM_FIRE | BOT_TOTEM_MASK_MY_TOTEM_EARTH | \
+                                            BOT_TOTEM_MASK_MY_TOTEM_WATER | BOT_TOTEM_MASK_MY_TOTEM_AIR)
+        };
+    };
+};
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
new file mode 100644
index 0000000..43f5a69
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
@@ -0,0 +1,1506 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+/*
+Warlock NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Voidwalker pet AI included
+Complete - 40%
+TODO: pet(s), firestone/spellstone, atrocity?, curses, seed of curruption, drains, do something with banish, etc...
+*/
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warlock_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct warlock_botAI : public bot_minion_ai
+    {
+        static uint32 const _healthStoneSpells[8/*createHealthstoneRank*/];
+
+        warlock_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_WARLOCK;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_WARLOCK) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void EnterCombat(Unit* u) { CanShadowWard = false; bot_minion_ai::EnterCombat(u); }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u) { bot_minion_ai::KilledUnit(u); }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { me->SetBotsPetDied(); bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting() || Feasting() || Rand() > 20)
+                return;
+
+            if (GetSpell(FEL_ARMOR_1))
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT, SPELLFAMILY_WARLOCK, 0x0, 0x20000000, 0x0)
+                    /*!HasAuraName(me, FEL_ARMOR_1)*/ &&
+                    doCast(me, GetSpell(FEL_ARMOR_1)))
+                    return;
+            }
+            else if (GetSpell(DEMON_ARMOR_1))
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_WARLOCK, 0x0, 0x20, 0x0)
+                    /*!HasAuraName(me, DEMON_ARMOR_1)*/ &&
+                    doCast(me, GetSpell(DEMON_ARMOR_1)))
+                    return;
+            }
+            else if (GetSpell(DEMON_SKIN_1))
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_WARLOCK, 0x0, 0x0, 0x10)
+                    /*!HasAuraName(me, DEMON_SKIN_1)*/ &&
+                    doCast(me, GetSpell(DEMON_SKIN_1)))
+                    return;
+            }
+
+            if (!hasHealthstone && GetSpell(CREATE_HEALTHSTONE_1))
+            {
+                if (doCast(me, GetSpell(CREATE_HEALTHSTONE_1)))
+                    return;
+            }
+
+            if (!hasSoulstone && GetSpell(CREATE_SOULSTONE_1))
+            {
+                if (doCast(me, GetSpell(CREATE_SOULSTONE_1)))
+                    return;
+            }
+
+            if (GetSpell(DETECT_INVISIBILITY_1))
+            {
+                if (master->IsAlive() && !master->HasAuraType(SPELL_AURA_MOD_INVISIBILITY_DETECT) &&
+                    doCast(master, GetSpell(DETECT_INVISIBILITY_1)))
+                    return;
+            }
+
+            //TODO: soulstone on self/bots
+            if (!IAmFree() && hasSoulstone && soulstoneTimer <= diff && GetSpell(CREATE_SOULSTONE_1))
+            {
+                Group const* gr = master->GetGroup();
+                Unit* u = master;
+                if (!gr)
+                {
+                    if (!u->IsAlive() || u->isPossessed() || u->IsCharmed() ||
+                        me->GetDistance(u) > 30 || u->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                        u = NULL;
+                }
+                else
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        u = itr->GetSource();
+                        if (!u || !u->IsAlive() || me->GetMap() != u->FindMap() || u->isPossessed() || u->IsCharmed() ||
+                            me->GetDistance(u) > 30 || u->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                        {
+                            u = NULL;
+                            continue;
+                        }
+                        if (u->getClass() == CLASS_PRIEST || u->getClass() == CLASS_PALADIN ||
+                            u->getClass() == CLASS_DRUID || u->getClass() == CLASS_SHAMAN)
+                            break;
+                    }
+                    if (!u)
+                    {
+                        for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            u = itr->GetSource();
+                            if (!u || !u->IsAlive() || me->GetMap() != u->FindMap() || u->isPossessed() || u->IsCharmed() ||
+                                me->GetDistance(u) > 30 || u->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                            {
+                                u = NULL;
+                                continue;
+                            }
+                            break;
+                        }
+                    }
+                }
+
+                if (u)
+                {
+                    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(GetSpell(CREATE_SOULSTONE_1));
+                    ASSERT(spellInfo);
+                    uint32 rank = spellInfo->GetRank();
+                    ASSERT(rank >= 1 && rank <= 7);
+                    uint32 spellId;
+                    switch (spellInfo->Id)
+                    {
+                        case   693: spellId = SOULSTONE_RESURRECTION_1; break; //rank 1
+                        case 20752: spellId = SOULSTONE_RESURRECTION_2; break; //rank 2
+                        case 20755: spellId = SOULSTONE_RESURRECTION_3; break; //rank 3
+                        case 20756: spellId = SOULSTONE_RESURRECTION_4; break; //rank 4
+                        case 20757: spellId = SOULSTONE_RESURRECTION_5; break; //rank 5
+                        case 27238: spellId = SOULSTONE_RESURRECTION_6; break; //rank 6
+                        case 47884: spellId = SOULSTONE_RESURRECTION_7; break; //rank 7
+                        default:
+                            TC_LOG_ERROR("entities.player", "bot_warlockAI: unknown soulstone Id %u", spellInfo->Id);
+                            spellId = 20707;
+                            break;
+                    }
+                    me->CastSpell(u, spellId, false);
+                }
+            }
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force, u);
+            fearTimer = std::max<uint32>(fearTimer, 1000);
+        }
+
+        //uint8 Afflicted(Unit* target) const
+        //{
+        //    if (!target || target->isDead()) return 0;
+        //    bool aff = HasAuraName(target, UNSTABLE_AFFLICTION_1, me->GetGUID());
+        //    bool imm = HasAuraName(target, IMMOLATE_1, me->GetGUID());
+        //    if (imm) return 1;
+        //    if (aff) return 2;
+        //    return 0;
+        //}
+
+        void CheckFear(uint32 diff)
+        {
+            if (fearTimer > diff || GC_Timer > diff || !me->IsInCombat() || IsCasting())
+                return;
+
+            fearTimer = 1000;
+
+            uint32 FEAR = GetSpell(FEAR_1);
+            if (!FEAR)
+                return;
+
+            if (FindAffectedTarget(FEAR, me->GetGUID()))
+                return;
+
+            Unit* feartarget = FindFearTarget();
+            if (feartarget && doCast(feartarget, FEAR))
+                return;
+        }
+
+        void CheckWard(uint32 diff)
+        {
+            if (!CanShadowWard || (!me->IsInCombat() && !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                !IsSpellReady(SHADOW_WARD_1, diff) || IsCasting())
+                return;
+
+            if (doCast(me, GetSpell(SHADOW_WARD_1)))
+                return;
+        }
+
+        void CheckSoulShatter(uint32 diff)
+        {
+            if (!IsSpellReady(SOULSHATTER_1, diff) || me->getAttackers().empty() || Rand() < 80)
+                return;
+
+            Unit* u = *(me->getAttackers().begin());
+            if (u->getThreatManager().getThreatList().size() < 3 || u->getThreatManager().getThreat(me) < 100.f)
+                return;
+
+            if (doCast(me, GetSpell(SOULSHATTER_1)))
+                return;
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (GC_Timer > diff || IsChanneling() || Rand() > 40)
+                return;
+
+            bool busyCasting = me->IsNonMeleeSpellCasted(true,true,true);
+
+            //Fear
+            if (!busyCasting && IsSpellReady(FEAR_1, diff))
+            {
+                Unit* u = FindCastingTarget(20, 0, FEAR_1);
+                if (u && doCast(u, GetSpell(FEAR_1)))
+                    return;
+            }
+            //Howl of Terror (only instant cast)
+            if (!busyCasting && me->getLevel() >= 45 && IsSpellReady(HOWL_OF_TERROR_1, diff))
+            {
+                Unit* u = FindCastingTarget(9, 0, FEAR_1); //same immunity
+                if (u && doCast(u, GetSpell(HOWL_OF_TERROR_1)))
+                    return;
+            }
+            //Shadowfury
+            if (HasRole(BOT_ROLE_DPS) && IsSpellReady(SHADOWFURY_1, diff))
+            {
+                if (Unit* u = FindCastingTarget(30, 0, SHADOWFURY_1))
+                {
+                    if (busyCasting)
+                        me->InterruptNonMeleeSpells(true, 0, false);
+                    if (doCast(u, GetSpell(SHADOWFURY_1)))
+                        return;
+                }
+            }
+             //Death Coil
+            if (HasRole(BOT_ROLE_DPS) && IsSpellReady(DEATH_COIL_1, diff))
+            {
+                if (Unit* u = FindCastingTarget(30, 0, DEATH_COIL_1))
+                {
+                    if (busyCasting)
+                        me->InterruptNonMeleeSpells(true, 0, false);
+                    if (doCast(u, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+            }
+        }
+
+        void DoDefend(uint32 diff)
+        {
+            if (GC_Timer > diff || !me->IsInCombat() || Rand() > 120)
+                return;
+
+            Unit::AttackerSet m_attackers = master->getAttackers();
+            Unit::AttackerSet b_attackers = me->getAttackers();
+            bool needFearM = !IAmFree() && !m_attackers.empty() && (!IsTank(master) || GetHealthPCT(master) < 75);
+
+            //HOWL
+            //fear master's attackers
+            if (IsSpellReady(HOWL_OF_TERROR_1, diff))
+            {
+                if (needFearM)
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if (CCed(*iter, true)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetDistance(*iter) > 9) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(HOWL_OF_TERROR_1)))
+                        return;
+                }
+                // Defend myself
+                if (!b_attackers.empty())
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if (CCed(*iter, true)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetDistance(*iter) > 9) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(HOWL_OF_TERROR_1)))
+                        return;
+                }
+            }
+            //COIL
+            if (HasRole(BOT_ROLE_DPS) && IsSpellReady(DEATH_COIL_1, diff))
+            {
+                Unit* u = needFearM ? *(m_attackers.begin()) : NULL;
+                if (u && u->GetMaxHealth() > master->GetMaxHealth() * 2 &&
+                    u->GetDistance(me) < 30 && u->GetDistance(master) < 8)
+                {
+                    if (doCast(u, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+                u = !b_attackers.empty() ? *(b_attackers.begin()) : NULL;
+                if (u && u->GetMaxHealth() > me->GetMaxHealth() * 2 && u->GetDistance(me) < 8)
+                {
+                    if (doCast(u, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (target->GetTypeId() != TYPEID_PLAYER) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (GetSpell(UNENDING_BREATH_1) && target->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) &&
+                !target->HasAuraType(SPELL_AURA_WATER_BREATHING))
+            {
+                if (doCast(target, GetSpell(UNENDING_BREATH_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (Wait())
+                return;
+            GenerateRand();
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            //if pet is dead or unreachable
+            //Creature* m_botsPet = me->GetBotsPet();
+            //if (!m_botsPet || m_botsPet->FindMap() != master->GetMap() || (me->GetDistance2d(m_botsPet) > sWorld->GetMaxVisibleDistanceOnContinents() - 20.f))
+            //    if (master->getLevel() >= 10 && !me->IsInCombat() && !IsCasting() && !me->IsMounted())
+            //        SummonBotsPet(PET_VOIDWALKER);
+
+            //Hellfire interrupt
+            Spell const* spell = me->GetCurrentSpell(CURRENT_CHANNELED_SPELL);
+            if (spell && spell->GetSpellInfo()->Id == GetSpell(HELLFIRE_1) && GetHealthPCT(me) < 20)
+                me->InterruptSpell(CURRENT_CHANNELED_SPELL);
+            else
+            {
+                spell = me->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+                if (spell)
+                {
+                    //Fear interrupt
+                    if (spell->GetSpellInfo()->Id == GetSpell(FEAR_1) && spell->m_targets.GetUnitTarget() &&
+                        spell->m_targets.GetUnitTarget()->HasAuraType(SPELL_AURA_MOD_FEAR))
+                        me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                    //Soulstone resurrection interrupt
+                    else if (spell->GetSpellInfo()->SpellVisual[0] == 99 && spell->m_targets.GetUnitTarget() &&
+                        spell->m_targets.GetUnitTarget()->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                        me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                }
+            }
+
+            if (hasHealthstone && healthstoneTimer <= diff &&
+                GetSpell(CREATE_HEALTHSTONE_1) && !IsCasting() && GetHealthPCT(me) < 65)
+            {
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(GetSpell(CREATE_HEALTHSTONE_1));
+                ASSERT(spellInfo);
+                uint32 rank = spellInfo->GetRank();
+                ASSERT(rank >= 1 && rank <= 8);
+                spellInfo = sSpellMgr->GetSpellInfo(_healthStoneSpells[rank - 1]);
+                ASSERT(spellInfo);
+                int32 healing = spellInfo->Effects[0].BasePoints;
+                //Glyph of Healthstone
+                if (me->getLevel() >= 15)
+                    healing = int32(float(healing) * 1.3f);
+                me->CastCustomSpell(me, _healthStoneSpells[rank - 1], &healing, NULL, NULL, true);
+                healthstoneTimer = 120000; //2 min
+                hasHealthstone = false;
+                return;
+            }
+            else if (IsPotionReady() && GetHealthPCT(me) < 50)
+            {
+                DrinkPotion(false);
+            }
+
+            if (IsSpellReady(LIFE_TAP_1, diff) && !IsCasting() && GetHealthPCT(me) > (me->IsInCombat() ? 30 : 15) &&
+                GetManaPCT(me) < 25 && Rand() < 50)
+            {
+                //it is possible that CheckCast will return SPELL_FAILED_NO_POWER if not enough hp
+                if (doCast(me, GetSpell(LIFE_TAP_1)))
+                    return;
+            }
+            else if (IsPotionReady() && GetManaPCT(me) < 15)
+            {
+                DrinkPotion(true);
+            }
+
+            CheckRacials(diff);
+
+            DoDefend(diff);
+
+            CheckSoulShatter(diff);
+            CheckFear(diff);
+            CheckWard(diff);
+
+            BuffAndHealGroup(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (!CheckAttackTarget(BOT_CLASS_WARLOCK))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            if (GC_Timer > diff)
+                return;
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_SHADOW|SPELL_SCHOOL_MASK_FIRE))
+                return;
+
+            float dist = me->GetDistance(opponent);
+
+            //spell reflections
+            //TODO: low-level curse of weakness (shadow), searing pain (fire)
+            if (IsSpellReady(CURSE_OF_THE_ELEMENTS_1, diff) && dist < 30 && CanRemoveReflectSpells(opponent, CURSE_OF_THE_ELEMENTS_1) &&
+                doCast(opponent, CURSE_OF_THE_ELEMENTS_1))
+                return;
+
+            //Offensive heal (Death Coil)
+            if (IsSpellReady(DEATH_COIL_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && GetHealthPCT(me) < 25)
+            {
+                //if (me->IsNonMeleeSpellCasted(true))
+                //    me->InterruptNonMeleeSpells(true);
+                if (doCast(opponent, GetSpell(DEATH_COIL_1)))
+                    return;
+            }
+
+            //Shadowfury
+            if (IsSpellReady(SHADOWFURY_1, diff) && HasRole(BOT_ROLE_DPS) && !CCed(opponent, true) && Rand() < 35)
+            {
+                if (FindSplashTarget(30) && doCast(opponent, GetSpell(SHADOWFURY_1)))
+                    return;
+            }
+            //Hellfire
+            if (IsSpellReady(HELLFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && GetHealthPCT(me) > 90 && Rand() < 25)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 15.f);
+                for (std::list<Unit*>::iterator itr = targets.begin(); itr != targets.end();)
+                {
+                    Unit* u = *itr;
+                    bool erase = false;
+                    if (u->isMoving())
+                    {
+                        if (me->GetDistance(u) > 10.f && !u->HasInArc(M_PI/2, me))
+                            erase = true;
+                    }
+                    else if (me->GetDistance(u) > 9.5f)
+                        erase = true;
+
+                    if (erase)
+                    {
+                        targets.erase(itr++);
+                        continue;
+                    }
+                    ++itr;
+                }
+                if (targets.size() > 4 && doCast(me, GetSpell(HELLFIRE_1)))
+                    return;
+            }
+            //Rain of Fire
+            if (IsSpellReady(RAIN_OF_FIRE_1, diff) && HasRole(BOT_ROLE_DPS) && !JumpingOrFalling() && Rand() < 45)
+            {
+                if (Unit* raintarget = FindAOETarget(30, true))
+                {
+                    if (doCast(raintarget, GetSpell(RAIN_OF_FIRE_1)))
+                        return;
+                }
+            }
+            //Shadowflame
+            if (longCasted && IsSpellReady(SHADOWFLAME_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 65)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 8); //radius 10 yd
+                if (targets.size() > 0 && doCast(me, GetSpell(SHADOWFLAME_1)))
+                    return;
+            }
+
+            if (dist > 30)
+                return;
+
+            //Curse
+            if (IsSpellReady(CURSE_OF_THE_ELEMENTS_1, diff) && Rand() < 15 &&
+                !opponent->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_WARLOCK, 0x0, 0x200, 0x0)
+                /*!HasAuraName(opponent, CURSE_OF_THE_ELEMENTS_1)*/)
+            {
+                if (doCast(opponent, GetSpell(CURSE_OF_THE_ELEMENTS_1)))
+                    return;
+            }
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            //Chaos Bolt
+            if (IsSpellReady(CHAOS_BOLT_1, diff))
+            {
+                if (doCast(opponent, GetSpell(CHAOS_BOLT_1)))
+                    return;
+            }
+            //Soul Fire 1
+            if (IsSpellReady(SOUL_FIRE_1, diff)/* && opponent->GetHealth() > me->GetMaxHealth()/2*/ && Rand() < 80 &&
+                (opponent->IsPolymorphed() || me->HasAura(DECIMATION_BUFF) || me->HasAura(CHAOTIC_MIND_BUFF)))
+            {
+                if (doCast(opponent, GetSpell(SOUL_FIRE_1)))
+                    return;
+            }
+            //Conflagrate
+            if (IsSpellReady(CONFLAGRATE_1, diff) && Rand() < 75)
+            {
+                Aura const* immo = opponent->GetAura(GetSpell(IMMOLATE_1), me->GetGUID());
+                if (immo && immo->GetDuration() <= immo->GetMaxDuration() - 6000)
+                {
+                    if (doCast(opponent, GetSpell(CONFLAGRATE_1)))
+                        return;
+                }
+            }
+            //Haunt
+            if (IsSpellReady(HAUNT_1, diff) && opponent->GetHealth() > me->GetMaxHealth()/2 && Rand() < 55 &&
+                !opponent->HasAura(GetSpell(HAUNT_1), me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(HAUNT_1)))
+                    return;
+            }
+            //Corruption
+            if (longCasted && IsSpellReady(CORRUPTION_1, diff) && opponent->GetHealth() > me->GetMaxHealth()/2 &&
+                Rand() < 45 && !opponent->HasAura(GetSpell(CORRUPTION_1), me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(CORRUPTION_1)))
+                    return;
+            }
+            //Shadowburn
+            if (longCasted && IsSpellReady(SHADOWBURN_1, diff) && opponent->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+            {
+                if (doCast(opponent, GetSpell(SHADOWBURN_1)))
+                    return;
+            }
+            //Immolate
+            if (IsSpellReady(IMMOLATE_1, diff) && opponent->GetHealth() > me->GetMaxHealth()/4 && Rand() < 55 &&
+                !opponent->HasAura(GetSpell(IMMOLATE_1), me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(IMMOLATE_1)))
+                    return;
+            }
+            //Soul Fire (conditional)
+            if (IsSpellReady(SOUL_FIRE_1, diff) && opponent->GetHealth() > me->GetMaxHealth()/4 &&
+                me->HasAura(BACKDRAFT_BUFF))
+            {
+                if (doCast(opponent, GetSpell(SOUL_FIRE_1)))
+                    return;
+            }
+            //Shadow Bolt or Incinerate: main
+            if (Rand() < 120)
+            {
+                uint32 boltinerate = (me->getLevel() >= 64 && opponent->HasAura(GetSpell(IMMOLATE_1), me->GetGUID()) &&
+                    opponent->HasAura(SHADOW_MASTERY_DEBUFF)) && !me->HasAura(SHADOW_TRANCE_BUFF) ?
+                    GetSpell(INCINERATE_1) : GetSpell(SHADOW_BOLT_1);
+
+                if (doCast(opponent, boltinerate))
+                    return;
+            }
+        }
+
+        //void SummonedCreatureDies(Creature* summon, Unit* /*killer*/)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPetDied();
+        //}
+
+        //void SummonedCreatureDespawn(Creature* summon)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPet(NULL);
+        //}
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            //victim can be NULL
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+
+            //Devastation: 5% additional critical chance for Destruction spells
+            if (lvl >= 30 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x3E5) || (spellInfo->SpellFamilyFlags[1] & 0x8310C0)))
+                crit_chance += 5.f;
+            //Fire and Brimstone part 2: 25% additional critical chance for Conflagrate
+            if (lvl >= 55 && spellId == GetSpell(CONFLAGRATE_1))
+                crit_chance += 25.f;
+            //Molten Core part 2.2: 25% additional critical chance for Soul Fire
+            if (lvl >= 35 && spellId == GetSpell(SOUL_FIRE_1))
+            {
+                static_cast<bool>(moltencore) = me->HasAura(MOLTEN_CORE_BUFF);
+                if (moltencore)
+                    crit_chance += 15.f;
+            }
+            //Malediction: 25% additional critical chance for Corruption and Unstable Affliction
+            if (lvl >= 45 && (spellId == GetSpell(CORRUPTION_1) || spellId == GetSpell(CONFLAGRATE_1)))
+                crit_chance += 9.f;
+            //Glyph of Shadowburn: 20% additional critical chance for Shadowburn on targets 35% hp and below
+            if (lvl >= 20 && spellId == GetSpell(SHADOWBURN_1) && victim && victim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+                crit_chance += 20.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            float flatbonus = 0.f;
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Ruin: 50% additional crit damage bonus for Destruction spells
+                if (lvl >= 20 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                    ((spellInfo->SpellFamilyFlags[0] & 0x13E5) || (spellInfo->SpellFamilyFlags[1] & 0xC310C0)))
+                    pctbonus += 0.333f;
+                //Pandemic: crit damage for periodics and haunt
+                if (lvl >= 50 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                    ((spellInfo->SpellFamilyFlags[0] & 0x2) || (spellInfo->SpellFamilyFlags[1] & 0x40100)))
+                    pctbonus += 0.333f;
+            }
+            //Improved Shadow Bolt and Incinerate (38393): 6% bonus damage for Shadow bolt and Incinerate
+            if (spellId == GetSpell(SHADOW_BOLT_1) || spellId == GetSpell(INCINERATE_1))
+                pctbonus += 0.06f;
+            //Glyph of Incinerate: 5% bonus damage for Incinerate
+            if (spellId == GetSpell(INCINERATE_1))
+                pctbonus += 0.05f;
+            //Improved Immolate: 30% bonus damage for Immolate
+            if (lvl >= 30 && spellId == GetSpell(IMMOLATE_1))
+                pctbonus += 0.3f;
+            //EmberStorm part 1: 15% bonus damage for Fire spells
+            if (lvl >= 20 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x364) || (spellInfo->SpellFamilyFlags[1] & 0x8200C0)))
+                pctbonus += 0.15f;
+            //Fire and Brimstone part 1: 10% bonus damage for Incinerate and Chaos Bolt
+            if (lvl >= 55 && (spellId == GetSpell(INCINERATE_1) || spellId == GetSpell(CHAOS_BOLT_1)) &&
+                damageinfo.target->HasAura(GetSpell(IMMOLATE_1), me->GetGUID()))
+                pctbonus += 0.1f;
+            //Molten Core part 1: 18% bonus damage for Incinerate and Soul Fire
+            if (lvl >= 35 && (spellId == GetSpell(INCINERATE_1) || spellId == GetSpell(SOUL_FIRE_1)))
+                pctbonus += 0.18f;
+            //Improved Corruption part 1: 10% bonus damage for Corruption
+            if (lvl >= 10 && spellId == GetSpell(CORRUPTION_1))
+                pctbonus += 0.1f;
+            //Corruption (28829): 12% bonus damage for Corruption
+            if (spellId == GetSpell(CORRUPTION_1))
+                pctbonus += 0.12f;
+            //Malediction part 1: 3% bonus damage for All spells
+            if (lvl >= 45)
+                pctbonus += 0.03f;
+            //Death's Embrace part 2: 12% bonus damage for Shadow spells on targets below 35 pct health
+            if (lvl >= 50 && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT) &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x8248B) || (spellInfo->SpellFamilyFlags[1] & 0x59913)))
+                pctbonus += 0.12f;
+
+            //Demoniv Pact part 1: 10% bonus damage for all spells
+            if (lvl >= 55)
+                fdamage *= 1.1f;
+
+            //Shadow and Flame: 20% spellpower bonus for Shadow Bolt, Shadowburn, Chaos Bolt and Incineration
+            if (lvl >= 20 &&
+                (spellId == GetSpell(SHADOW_BOLT_1) || spellId == GetSpell(CHAOS_BOLT_1)/* ||
+                spellId == GetSpell(SHADOWBURN_1)*/ || spellId == GetSpell(INCINERATE_1)))
+                flatbonus += 0.2f * spellpower;
+            //Empowered Corruption: 10% bonus damage for Corruption
+            if (lvl >= 25 && spellId == GetSpell(CORRUPTION_1))
+                flatbonus += 0.36f * spellpower;
+            //Everlasting Affliction part 1: 5% bonus damage for Corruption and Unstable Affliction
+            if (lvl >= 55 && (spellId == GetSpell(CORRUPTION_1) || spellId == GetSpell(UNSTABLE_AFFLICTION_1)))
+                flatbonus += 0.05f * spellpower;
+
+            damage = int32(fdamage * (1.0f + pctbonus) + flatbonus);
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType /*damagetype*/, uint32 /*stack*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Glyph of Siphon Life: 25% bonus healing for Siphon Life effect (50% for bots)
+            if (spellId == SIPHON_LIFE_HEAL)
+                pctbonus += 0.5f;
+            //Improved Death Coil (30052): 30% bonus healing for Death Coil
+            if (spellId == GetSpell(DEATH_COIL_1))
+                pctbonus += 0.3f;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+        {
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float fcost = float(cost);
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Doomcaller Reduced Shadow Bolt Cost (26117): -15% mana cost for Shadow Bolt
+            if (spellId == GetSpell(SHADOW_BOLT_1))
+                pctbonus += 0.15f;
+            //Glyph of Shadow Bolt: -10% mana cost for Shadow Bolt
+            if (lvl >= 15 && spellId == GetSpell(SHADOW_BOLT_1))
+                pctbonus += 0.1f;
+            //Cataclysm: -10% mana cost for Destruction spells
+            if (lvl >= 15 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x3E5) || (spellInfo->SpellFamilyFlags[1] & 0x8310C0)))
+                pctbonus += 0.1f;
+            //Suppression: -6% mana cost for Affliction spells
+            if (lvl >= 10 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x814CC41A) || (spellInfo->SpellFamilyFlags[1] & 0x248F1B)))
+                pctbonus += 0.06f;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus));
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+        {
+            //casttime is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Backlash: -100% cast time for Shadow Bolt or Incinerate
+            if (lvl >= 15 && (spellId == GetSpell(SHADOW_BOLT_1) || spellId == GetSpell(INCINERATE_1)))
+            {
+                static_cast<bool>(backlash) = me->HasAura(BACKLASH_BUFF);
+                static_cast<bool>(shadowtrance) = me->HasAura(SHADOW_TRANCE_BUFF);
+                if (backlash || shadowtrance)
+                    timebonus += casttime;
+            }
+            //Improved Howl of Terror: -1.5sec (-100%) cast time for Howl of Terror
+            if (lvl >= 45 && spellId == GetSpell(HOWL_OF_TERROR_1))
+                timebonus += casttime;
+            //Chaotic Mind (custom)
+            if (spellId == GetSpell(SOUL_FIRE_1))
+            {
+                static_cast<bool>(chaoticmind) = me->HasAura(CHAOTIC_MIND_BUFF);
+                if (chaoticmind)
+                    timebonus += casttime;
+            }
+
+            //pct mods
+            //BackDraft part 1: -30% cast time for Destruction spells
+            if (lvl >= 50 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x165) || (spellInfo->SpellFamilyFlags[1] & 0x310C0)))
+            {
+                //skip soul fire insta cast
+                static_cast<bool>(backdraft) = me->HasAura(BACKDRAFT_BUFF) && !(chaoticmind && spellId == GetSpell(SOUL_FIRE_1));
+                if (backdraft)
+                    pctbonus += 0.3f;
+            }
+            //Molten Core part 2.1: -30% cast time for Incinerate
+            if (lvl >= 35 && spellId == GetSpell(INCINERATE_1))
+            {
+                static_cast<bool>(moltencore) = me->HasAura(MOLTEN_CORE_BUFF);
+                if (moltencore)
+                    pctbonus += 0.3f;
+            }
+            //Decimation: -40% cast time for Soul Fire
+            if (spellId == GetSpell(SOUL_FIRE_1) && me->HasAura(DECIMATION_BUFF))
+                pctbonus += 0.4f;
+
+            //flat mods
+            //Bane: -0.5 sec cast time for Shadow Bolt, Incinerate and Chaos Bolt, -2 sec cast for Soul Fire
+            if (lvl >= 10)
+            {
+                if (spellId == GetSpell(SHADOW_BOLT_1) || spellId == GetSpell(INCINERATE_1) ||
+                    spellId == GetSpell(CHAOS_BOLT_1))
+                    timebonus += 500;
+                else if (spellId == GetSpell(SOUL_FIRE_1))
+                    timebonus += 2000;
+            }
+            //EmberStorm part 2: -0.25 sec cast time for Incinerate
+            if (lvl >= 20 && spellId == GetSpell(INCINERATE_1))
+                timebonus += 250;
+            //Fear Cast Time Reduction (23047): -0.2 sec cast time for Fear
+            if (spellId == GetSpell(FEAR_1))
+                timebonus += 200;
+
+            casttime = std::max<int32>((float(casttime) * (1.0f - pctbonus)) - timebonus, 0);
+
+            static_cast<bool>(instaCast) = (casttime <= 500); //triggered GCD is too long
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            //if (lvl >= 40 && spellId == GetSpell(CHARGE_1))
+            //    pctbonus += 0.07f;
+
+            //flat mods
+            //Glyph of Chaos Bolt: -2 sec cooldown for Chaos Bolt
+            if (lvl >= 60 && spellId == GetSpell(CHAOS_BOLT_1))
+                timebonus += 2000;
+            //Improved Death Coil (24487): -15% sec cooldown for Death Coil (30 sec for bots)
+            if (spellId == GetSpell(DEATH_COIL_1))
+                timebonus += 30000;
+            //Glyph of Howl of Terror: -8 sec cooldown for Howl of Terror
+            if (lvl >= 45 && spellId == GetSpell(HOWL_OF_TERROR_1))
+                timebonus += 8000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        //void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        //{
+        //    //cooldown is in milliseconds
+        //    uint32 spellId = spellInfo->Id;
+        //    //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+        //    uint8 lvl = me->getLevel();
+        //    int32 timebonus = 0;
+        //    float pctbonus = 0.0f;
+
+        //    //Unrelenting Assault (part 1): -4 sec cooldown for Overpower and Revenge (not for tanks)
+        //    //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+        //    //    timebonus += 4000;
+
+        //    cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        //}
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //BackDraft: -30% global cooldown for Destruction spells
+            if (lvl >= 50 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x165) || (spellInfo->SpellFamilyFlags[1] & 0x310C0)) &&
+                me->HasAura(BACKDRAFT_BUFF))
+                pctbonus += 0.3f;
+
+            //flat mods
+            //Amplify Curse: -0.5 sec global cooldown for Curses
+            if (lvl >= 25 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x408400) || (spellInfo->SpellFamilyFlags[1] & 0x200202) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x800)))
+                timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            ////Holy Reach
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Improved Rain of Fire / Hellfire
+            if (lvl >= 40 && (spellInfo->SpellFamilyFlags[0] & 0x60))
+                flatbonus += 2.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo)
+        {
+            uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //Instacast buffs handling
+            if (spellId == GetSpell(SHADOW_BOLT_1))
+            {
+                if (backlash)
+                    me->RemoveAurasDueToSpell(BACKLASH_BUFF);
+                else if (shadowtrance)
+                    me->RemoveAurasDueToSpell(SHADOW_TRANCE_BUFF);
+            }
+            if (spellId == GetSpell(INCINERATE_1))
+            {
+                if (backlash)
+                    me->RemoveAurasDueToSpell(BACKLASH_BUFF);
+            }
+            if (chaoticmind && spellId == GetSpell(SOUL_FIRE_1))
+                me->RemoveAurasDueToSpell(CHAOTIC_MIND_BUFF);
+
+            //Backdraft
+            if (backdraft && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x165) || (spellInfo->SpellFamilyFlags[1] & 0x310C0)))
+            {
+                if (Aura* bd = me->GetAura(BACKDRAFT_BUFF))
+                    bd->DropCharge();
+            }
+            //Molten Core
+            if (moltencore && (spellId == GetSpell(INCINERATE_1) || spellId == GetSpell(SOUL_FIRE_1)))
+            {
+                if (Aura* mc = me->GetAura(MOLTEN_CORE_BUFF))
+                    mc->DropCharge();
+            }
+            //Decimation: NOT DROPPED ON CAST
+            //if (spellId == GetSpell(SOUL_FIRE_1))
+            //{
+            //    if (Aura* mc = me->GetAura(DECIMATION_BUFF))
+            //        mc->DropCharge();
+            //}
+            longCasted = !instaCast &&
+                (baseId == SHADOW_BOLT_1 || baseId == INCINERATE_1 || baseId == CHAOS_BOLT_1 ||
+                baseId == SOUL_FIRE_1 || baseId == HAUNT_1/* || baseId == FEAR_1*/); //damaging spells
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Shadow Ward helper
+            if (!CanShadowWard && !spell->IsPositive() && (spell->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+            {
+                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                {
+                    if (spell->Effects[i].IsEffect(SPELL_EFFECT_SCHOOL_DAMAGE) ||
+                        spell->Effects[i].IsAura(SPELL_AURA_PERIODIC_DAMAGE))
+                    {
+                        CanShadowWard = true;
+                        break;
+                    }
+                }
+            }
+
+            //Create Healthstone trigger
+            if (spellId == GetSpell(CREATE_HEALTHSTONE_1))
+            {
+                hasHealthstone = true;
+            }
+            //Create Soulstone trigger
+            if (spellId == GetSpell(CREATE_SOULSTONE_1))
+            {
+                hasSoulstone = true;
+            }
+
+            //Life Tap energize
+            if (spellId == GetSpell(LIFE_TAP_1))
+            {
+                //level * 3 based on in-game tooltip and spellwork (BasePoints = 2000 + Level * 4,00)
+                int32 damage = spell->Effects[0].CalcValue(me);
+                int32 manaGain = damage;
+                damage += int32(me->getLevel() * 3);
+                manaGain += spellpower / 2;
+
+                //Life Tap (id: 28830)
+                //damage = int32(float(damage) * 0.88f);
+                //Improved Life Tap
+                if (me->getLevel() >= 15)
+                    manaGain = int32(float(manaGain) * 1.2f);
+
+                me->ModifyHealth(-damage);
+                me->CastCustomSpell(me, LIFE_TAP_ENERGIZE, &manaGain, NULL, NULL, true);
+                //TODO: mana feed?
+            }
+
+            //Armors duration
+            if (spellId == GetSpell(DEMON_ARMOR_1) || spellId == GetSpell(FEL_ARMOR_1))
+            {
+                if (Aura* ar = me->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = 1 * HOUR * IN_MILLISECONDS;
+                    ar->SetDuration(dur);
+                    ar->SetMaxDuration(dur);
+                }
+            }
+            //Chaotic Mind (custom)
+            if (spellId == CHAOTIC_MIND)
+            {
+                if (Aura* mind = me->GetAura(spellId))
+                {
+                    uint32 dur = 30000; //30 sec
+                    mind->SetDuration(dur);
+                    mind->SetMaxDuration(dur);
+                }
+            }
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Soulstone resurrection trigger (not ranked)
+            if (spellId == SOULSTONE_RESURRECTION_1 || spellId == SOULSTONE_RESURRECTION_2 ||
+                spellId == SOULSTONE_RESURRECTION_3 || spellId == SOULSTONE_RESURRECTION_4 ||
+                spellId == SOULSTONE_RESURRECTION_5 || spellId == SOULSTONE_RESURRECTION_6 ||
+                spellId == SOULSTONE_RESURRECTION_7)
+            {
+                hasSoulstone = false;
+                //reduced for bot
+                //soulstoneTimer = 15 * MINUTE * IN_MILLISECONDS;
+                soulstoneTimer = 10 * MINUTE * IN_MILLISECONDS;
+            }
+
+            //Chaotic Mind (custom)
+            if (me->getLevel() >= 60 && spell->SpellFamilyName == SPELLFAMILY_WARLOCK && !spell->IsPositive())
+            {
+                if (urand(1,100) <= 5)
+                    me->CastSpell(me, CHAOTIC_MIND, true);
+            }
+            //Molten Core: + 9 sec duration for Immolate
+            if (spellId == GetSpell(IMMOLATE_1))
+            {
+                if (Aura* immolate = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = immolate->GetDuration() + 9000;
+                    immolate->SetDuration(dur);
+                    immolate->SetMaxDuration(dur);
+                }
+            }
+            //Improved Corruption and Immolate (37380): + 3 sec duration for Immolate and Corruption
+            if (spellId == GetSpell(IMMOLATE_1) || spellId == GetSpell(CORRUPTION_1))
+            {
+                if (Aura* per = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = per->GetDuration() + 3000;
+                    per->SetDuration(dur);
+                    per->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Death Coil: + 0.5 sec duration for Death Coil (2 sec on creatures)
+            if (spellId == GetSpell(DEATH_COIL_1))
+            {
+                if (Aura* dc = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = dc->GetDuration() + (target->GetTypeId() == TYPEID_PLAYER ? 500 : 2000);
+                    dc->SetDuration(dur);
+                    dc->SetMaxDuration(dur);
+                }
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const
+        {
+            switch (data)
+            {
+                case CREATE_HEALTHSTONE_1:
+                    return uint32(hasHealthstone);
+                default:
+                    return 0;
+            }
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 value)
+        {
+            switch (data)
+            {
+                case CREATE_HEALTHSTONE_1:
+                    hasHealthstone = bool(value);
+                default:
+                    break;
+            }
+        }
+
+        void Reset()
+        {
+            fearTimer = 0;
+            healthstoneTimer = 0;
+
+            hasHealthstone = false;
+            hasSoulstone = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (fearTimer > diff)                   fearTimer -= diff;
+            if (healthstoneTimer > diff)            healthstoneTimer -= diff;
+            if (soulstoneTimer > diff)              soulstoneTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(CURSE_OF_THE_ELEMENTS_1);
+            InitSpellMap(SHADOW_BOLT_1);
+            InitSpellMap(IMMOLATE_1);
+            InitSpellMap(INCINERATE_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(SHADOWBURN_1) : RemoveSpell(SHADOWBURN_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(CONFLAGRATE_1) : RemoveSpell(CONFLAGRATE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(CHAOS_BOLT_1) : RemoveSpell(CHAOS_BOLT_1);
+            InitSpellMap(SOUL_FIRE_1);
+            InitSpellMap(RAIN_OF_FIRE_1);
+            InitSpellMap(HELLFIRE_1);
+            InitSpellMap(SHADOWFLAME_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(SHADOWFURY_1) : RemoveSpell(SHADOWFURY_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(HAUNT_1) : RemoveSpell(HAUNT_1);
+            InitSpellMap(CORRUPTION_1);
+///*Talent*/lvl >= 50 ? InitSpellMap(UNSTABLE_AFFLICTION_1) : RemoveSpell(UNSTABLE_AFFLICTION_1);
+            InitSpellMap(FEAR_1);
+            InitSpellMap(DEATH_COIL_1);
+            InitSpellMap(HOWL_OF_TERROR_1);
+            InitSpellMap(SOULSHATTER_1);
+
+            InitSpellMap(DEMON_SKIN_1);
+            InitSpellMap(DEMON_ARMOR_1);
+            InitSpellMap(FEL_ARMOR_1);
+            InitSpellMap(DETECT_INVISIBILITY_1);
+            InitSpellMap(UNENDING_BREATH_1);
+            InitSpellMap(SHADOW_WARD_1);
+            InitSpellMap(LIFE_TAP_1);
+            InitSpellMap(CREATE_HEALTHSTONE_1);
+            InitSpellMap(CREATE_SOULSTONE_1);
+
+            InitSpellMap(RITUAL_OF_SUMMONING_1);
+        }
+
+        //TODO
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(CHAOS_BOLT_PASSIVE);
+
+            RefreshAura(IMP_SHADOW_BOLT, level >= 10 ? 1 : 0);
+            RefreshAura(BACKLASH, level >= 30 ? 1 : 0);
+            RefreshAura(NETHER_PROTECTION, level >= 35 ? 1 : 0);
+            RefreshAura(BACKDRAFT, level >= 50 ? 1 : 0);
+            RefreshAura(AFTERMATH, level >= 15 ? 1 : 0);
+            RefreshAura(MOLTEN_CORE, level >= 35 ? 1 : 0);
+            RefreshAura(DECIMATION, level >= 45 ? 1 : 0);
+            RefreshAura(IMP_FEAR, level >= 20 ? 1 : 0);
+            RefreshAura(NIGHTFALL, level >= 75 ? 3 : level >= 50 ? 2 : level >= 25 ? 1 : 0);
+            RefreshAura(SIPHON_LIFE, level >= 30 ? 1 : 0);
+            RefreshAura(SHADOW_EMBRACE, level >= 30 ? 1 : 0);
+            RefreshAura(ERADICATION, level >= 80 ? 5 : level >= 70 ? 4 : level >= 60 ? 3 : level >= 50 ? 2 : level >= 40 ? 1 : 0);
+            RefreshAura(UNSTABLE_AFFLICTION, level >= 55 ? 1 : 0);
+
+            RefreshAura(GLYPH_CONFLAGRATE, level >= 40 ? 1 : 0);
+            RefreshAura(GLYPH_CORRUPTION, level >= 80 ? 4 : level >= 65 ? 3 : level >= 40 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_SHADOWFLAME, level >= 75 ? 1 : 0);
+            RefreshAura(GLYPH_UNENDING_BREATH, level >= 15 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case HELLFIRE_1:
+                case RAIN_OF_FIRE_1:
+                case HOWL_OF_TERROR_1:
+                case DETECT_INVISIBILITY_1:
+                case UNENDING_BREATH_1:
+                case RITUAL_OF_SUMMONING_1:
+                case SHADOW_WARD_1:
+                case FEL_ARMOR_1:
+                    return true;
+                case DEMON_ARMOR_1:
+                    return !GetSpell(FEL_ARMOR_1);
+                case DEMON_SKIN_1:
+                    return !GetSpell(FEL_ARMOR_1) && !GetSpell(DEMON_ARMOR_1);
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Timers
+        uint32 fearTimer, healthstoneTimer, soulstoneTimer;
+        //Special
+        bool backlash, shadowtrance, backdraft, moltencore, chaoticmind;
+        bool CanShadowWard;
+        bool longCasted, instaCast; //some sort of rotation thing
+        bool hasHealthstone, hasSoulstone;
+
+        enum WarlockBaseSpells
+        {
+            CURSE_OF_THE_ELEMENTS_1             = 1490,
+            SHADOW_BOLT_1                       = 686,
+            IMMOLATE_1                          = 348,
+            INCINERATE_1                        = 29722,
+            SHADOWBURN_1                        = 17877,
+            CONFLAGRATE_1                       = 17962,
+            CHAOS_BOLT_1                        = 50796,
+            SOUL_FIRE_1                         = 6353,
+            RAIN_OF_FIRE_1                      = 5740,
+            HELLFIRE_1                          = 1949,
+            SHADOWFLAME_1                       = 47897,
+            SHADOWFURY_1                        = 30283,
+            HAUNT_1                             = 48181,
+            CORRUPTION_1                        = 172,
+            UNSTABLE_AFFLICTION_1               = 30108,//NI
+            FEAR_1                              = 5782,
+            DEATH_COIL_1                        = 6789,
+            HOWL_OF_TERROR_1                    = 5484,
+            SOULSHATTER_1                       = 29858,
+
+            DEMON_SKIN_1                        = 687,
+            DEMON_ARMOR_1                       = 706,
+            FEL_ARMOR_1                         = 28176,
+            DETECT_INVISIBILITY_1               = 132,
+            UNENDING_BREATH_1                   = 5697,
+            SHADOW_WARD_1                       = 6229,
+            LIFE_TAP_1                          = 1454, //scripted for players only
+
+            CREATE_HEALTHSTONE_1                = 6201,
+            CREATE_SOULSTONE_1                  = 693,
+
+            CHAOTIC_MIND                        = 61188, //8 sec duration, no cd
+
+            RITUAL_OF_SUMMONING_1               = 698
+        };
+        enum WarlockPassives
+        {
+            IMP_SHADOW_BOLT                     = 17803,//rank 5
+            BACKLASH                            = 34939,//rank 3
+            NETHER_PROTECTION                   = 30302,//rank 3
+            BACKDRAFT                           = 47260,//rank 3
+            AFTERMATH                           = 18120,//rank 2
+            MOLTEN_CORE                         = 47247,//rank 3
+            DECIMATION                          = 63158,//rank 2
+            IMP_FEAR                            = 53759,//rank 2
+            NIGHTFALL                           = 18095,//rank 2
+            SHADOW_EMBRACE                      = 32394,//rank 5
+            ERADICATION                         = 47197,//rank 3
+            UNSTABLE_AFFLICTION                 = 47205,//rank 5
+            SIPHON_LIFE                         = 63108,
+
+            //Special
+            GLYPH_CONFLAGRATE                   = 56235,
+            GLYPH_CORRUPTION                    = 56218,
+            GLYPH_SHADOWFLAME                   = 63310,
+            GLYPH_UNENDING_BREATH               = 58079
+        };
+        enum WarlockSpecial
+        {
+            CHAOS_BOLT_PASSIVE                  = 58284,
+
+            BACKLASH_BUFF                       = 34936,
+            BACKDRAFT_BUFF                      = 54277,//rank 3
+            SHADOW_TRANCE_BUFF                  = 17941,
+            MOLTEN_CORE_BUFF                    = 71165,//rank 3
+            DECIMATION_BUFF                     = 63167,//rank 2
+            CHAOTIC_MIND_BUFF                   = 61189,// "Soul Fire!" 6 sec duration Soul Fire instant cast
+
+            SHADOW_MASTERY_DEBUFF               = 17800,// Improved Shadow Bolt talent debuff
+
+            SIPHON_LIFE_HEAL                    = 63106,
+            LIFE_TAP_ENERGIZE                   = 31818,
+
+            SOULSTONE_RESURRECTION_1            = 20707,
+            SOULSTONE_RESURRECTION_2            = 20762,
+            SOULSTONE_RESURRECTION_3            = 20763,
+            SOULSTONE_RESURRECTION_4            = 20764,
+            SOULSTONE_RESURRECTION_5            = 20765,
+            SOULSTONE_RESURRECTION_6            = 27239,
+            SOULSTONE_RESURRECTION_7            = 47883
+        };
+    };
+};
+
+//HealthstoneSpellIds (Improved Healthstone rank 2)
+uint32 const warlock_bot::warlock_botAI::_healthStoneSpells[8/*createHealthstoneRank*/] =
+{
+    23469,// Minor
+    23471,// Lesser
+    23473,//
+    23475,// Greater
+    23477,// Major
+    27237,// Master
+    47872,// Demonic
+    47877 // Fel
+};
+
+class voidwalker_bot : public CreatureScript
+{
+public:
+    voidwalker_bot() : CreatureScript("voidwalker_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new voidwalker_botAI(creature);
+    }
+
+    struct voidwalker_botAI : public bot_pet_ai
+    {
+        voidwalker_botAI(Creature* creature) : bot_pet_ai(creature)
+        {
+            _botclass = BOT_CLASS_MAGE;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_NONE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void EnterCombat(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { m_creatureOwner->SetBotsPetDied(); }
+        void DoNonCombatActions() { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            //OnStartAttack(u);
+            GetInPosition(force, u);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (Wait())
+                return;
+            if (CCed(me)) return;
+
+            //TODO: add checks to help owner
+
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(PET_TYPE_VOIDWALKER))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            //float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //TORMENT
+            if (IsSpellReady(TORMENT_1, diff) && meleedist < 5 && !IsTank(opponent->GetVictim()))
+            {
+                if (doCast(opponent, GetSpell(TORMENT_1)))
+                    return;
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (m_creatureOwner->IsAIEnabled)
+                if (bot_minion_ai* ai = m_creatureOwner->GetBotMinionAI())
+                    ai->OnOwnerDamagedBy(u);
+        }
+
+        //debug
+        //void ListSpells(ChatHandler* ch) const
+        //{
+        //    ch->PSendSysMessage("Spells list:");
+        //    ch->PSendSysMessage("Torment: %u", TORMENT);
+        //    ch->PSendSysMessage("End of spells list.");
+        //}
+
+        void Reset()
+        {
+            if (master && m_creatureOwner)
+            {
+                DefaultInit();
+                SetBaseArmor(162 * master->getLevel());
+            }
+        }
+
+        void ReduceCD(uint32 /*diff*/)
+        {
+        }
+
+        void InitSpells()
+        {
+            InitSpellMap(TORMENT_1);
+        }
+
+        void ApplyClassPassives() { }
+
+    private:
+        //Timers
+
+        enum VoidwalkerBaseSpells
+        {
+            TORMENT_1                           = 3716
+        };
+        enum VoidwalkerPassives
+        {
+        };
+    };
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+    new voidwalker_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
new file mode 100644
index 0000000..ac0d9b3
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
@@ -0,0 +1,1980 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+//#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+//#include "WorldSession.h"
+/*
+Warrior NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 95-97%
+*/
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warrior_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct warrior_botAI : public bot_minion_ai
+    {
+        warrior_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_WARRIOR;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        uint8 GetBotStance() const
+        {
+            if (battleStance)
+                return WARRIOR_BATTLE_STANCE;
+            else if (defensiveStance)
+                return WARRIOR_DEFENSIVE_STANCE;
+            else if (berserkerStance)
+                return WARRIOR_BERSERKER_STANCE;
+
+            return BOT_STANCE_NONE;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            if (ragetimer2 <= diff)
+            {
+                if (me->IsInCombat() && me->getLevel() >= 20)
+                {
+                    if (me->GetPower(POWER_RAGE) < 990)
+                        me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) + uint32(10.f * rageIncomeMult)); //1 rage per 2 sec
+                    else
+                        me->SetPower(POWER_RAGE, 1000); //max
+                }
+                ragetimer2 = 2000;
+            }
+            if (ragetimer <= diff)
+            {
+                if (!me->IsInCombat() &&
+                    !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_WARRIOR, 0x100)
+                    /*!HasAuraName(me, BLOODRAGE_1)*/)
+                {
+                    if (me->GetPower(POWER_RAGE) > uint32(10.f * rageLossMult))
+                        me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) - uint32(10.f * rageLossMult)); //-1 rage per 1.5 sec
+                    else
+                        me->SetPower(POWER_RAGE, 0); //min
+                }
+                ragetimer = 1500;
+            }
+            getrage();
+
+            CheckAuras();
+            if (Wait())
+                return;
+            GenerateRand();
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            CheckShouts(diff);
+            CheckVigilance(diff);
+            CheckIntervene(diff);
+            CheckSpellReflect(diff);
+
+            if (me->IsInCombat())
+                CheckShatteringThrow(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (!CheckAttackTarget(BOT_CLASS_WARRIOR))
+            {
+                if (!IsTank() && !me->IsInCombat() && battleStance != true && master->getAttackers().empty() &&
+                    stancetimer <= diff && Rand() < 25)
+                    stanceChange(diff, 1);
+                return;
+            }
+
+            if (IsSpellReady(BLOODRAGE_1, diff, false) && me->IsInCombat() && rage < 600 &&
+                Rand() < 20 &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0)
+                /*!me->HasAura(ENRAGED_REGENERATION_1)*/)
+            {
+                if (doCast(me, GetSpell(BLOODRAGE_1)))
+                    getrage();
+            }
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force, u);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u)
+        {
+            //Victorious State spell
+            //only on targets which give xp or honor
+            if (me->getLevel() >= 5 && u->getLevel() + 9 >= me->getLevel())
+                me->CastSpell(me, VICTORIOUS_SPELL, true);
+
+            bot_minion_ai::KilledUnit(u);
+        }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void modrage(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && rage < abs(mod))
+            {
+                //debug set rage to 0
+                mod = 0;
+                set = true;
+                return;
+            }
+
+            if (set)
+                rage = mod ? mod*10 : 0;
+            else
+                rage += mod*10;
+
+            me->SetPower(POWER_RAGE, rage);
+        }
+
+        void getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            if (me->FindCurrentSpellBySpellId(GetSpell(CLEAVE_1)))
+                rage = std::max<int32>(rage - 200, 0);
+            else if (me->FindCurrentSpellBySpellId(GetSpell(HEROIC_STRIKE_1)))
+                rage = std::max<int32>(rage - 150, 0);
+        }
+
+        int32 rcost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (Rand() < 45 && me->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_DISORIENTED)))
+            {
+                if (IsSpellReady(BERSERKERRAGE_1, diff) &&
+                    !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0)
+                    /*!me->HasAura(ENRAGED_REGENERATION_1)*/ &&
+                    doCast(me, GetSpell(BERSERKERRAGE_1)))
+                    return;
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            //Keep defensive stance if tank
+            if (IsTank() && defensiveStance != true && stancetimer <= diff)
+                stanceChange(diff, 2);
+            //SelfHeal
+            if (IsSpellReady(ENRAGED_REGENERATION_1, diff) && rage > rcost(ENRAGED_REGENERATION_1) &&
+                GetHealthPCT(me) < 40 && Rand() < 40 && me->HasAuraWithMechanic(uint32(1<<MECHANIC_ENRAGED)))
+            {
+                if (doCast(me, GetSpell(ENRAGED_REGENERATION_1)))
+                    return;
+            }
+
+            Unit::AttackerSet m_attackers = master->getAttackers();
+            Unit::AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetDistance(opponent);
+            //charge + warbringer
+            if (IsSpellReady(CHARGE_1, diff, false) && HasRole(BOT_ROLE_TANK|BOT_ROLE_DPS) && !CCed(opponent) &&
+                dist > 10 && dist < 25 &&/* me->HasInArc(M_PI, opponent) &&*/
+                (me->getLevel() >= 50 ||
+                (!me->IsInCombat() && (battleStance || (stancetimer <= diff && stanceChange(diff, 1))))))
+            {
+                if (me->getLevel() >= 29)
+                    me->RemoveMovementImpairingAuras();
+                if (doCast(opponent, GetSpell(CHARGE_1), me->IsInCombat()))
+                    return;
+            }
+            //intercept
+            if (IsSpellReady(INTERCEPT_1, diff, false) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                !CCed(opponent) && rage > rcost(INTERCEPT_1) && dist > 10 && dist < 25 &&/* me->HasInArc(M_PI, opponent) &&*/
+                (berserkerStance || (stancetimer <= diff && stanceChange(diff, 3))))
+            {
+                if (doCast(opponent, GetSpell(INTERCEPT_1)))
+                    return;
+            }
+            //SelfHeal 2 - LAST STAND
+            if (IsSpellReady(LAST_STAND_1, diff, false) && IsTank() && Rand() < 67 &&
+                GetHealthPCT(me) < (30 + 20 * (b_attackers.size() > 1) + 10 * me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)))
+            {
+                if (doCast(me, GetSpell(LAST_STAND_1)))
+                    return;
+            }
+            //FEAR
+            if (IsSpellReady(INTIMIDATING_SHOUT_1, diff) && Rand() < 70 && rage > rcost(INTIMIDATING_SHOUT_1))
+            {
+                if (opponent->IsNonMeleeSpellCasted(false, false, true) && dist <= 8 &&
+                    !(opponent->ToCreature() && opponent->ToCreature()->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                {
+                    if (doCast(opponent, GetSpell(INTIMIDATING_SHOUT_1)))
+                        return;
+                }
+                Unit* fearTarget = NULL;
+                bool triggered = false;
+                uint8 tCount = 0;
+                //fear master's attackers
+                if (!m_attackers.empty() &&
+                    ((master->getClass() != BOT_CLASS_DEATH_KNIGHT &&
+                    master->getClass() != BOT_CLASS_WARRIOR &&
+                    master->getClass() != BOT_CLASS_PALADIN) ||
+                    GetHealthPCT(master) < 70))
+                {
+                    for (Unit::AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 1) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
+                        return;
+                }
+                //Defend myself
+                if (b_attackers.size() > 1)
+                {
+                    tCount = 0;
+                    fearTarget = NULL;
+                    triggered = false;
+                    for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 1) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
+                        return;
+                }
+            }//end FEAR
+            //TAUNT //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(TAUNT_1, diff, false) && u && u != me && dist < 30 &&
+                opponent->GetTypeId() == TYPEID_UNIT && !opponent->IsControlledByPlayer() &&
+                !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (IsTank() && GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                ((!IsTankingClass(u->getClass()) && (GetHealthPCT(u) < 80 || defensiveStance)) || IsTank()) &&
+                IsInBotParty(u) && Rand() < 40 &&
+                (defensiveStance || (stancetimer <= diff && stanceChange(diff, 2))))
+            {
+                if (doCast(opponent, GetSpell(TAUNT_1)))
+                    return;
+            }
+            //TAUNT 2 (distant)
+            if (IsSpellReady(TAUNT_1, diff, false) && u == me && IsTank() &&
+                (defensiveStance || stancetimer <= diff) && Rand() < 25)
+            {
+                Unit* tUnit = FindDistantTauntTarget();
+                if (tUnit && (defensiveStance || (stancetimer <= diff && stanceChange(diff, 2))))
+                {
+                    if (doCast(tUnit, GetSpell(TAUNT_1)))
+                        return;
+                }
+            }
+            //CHALLENGING SHOUT
+            if (IsSpellReady(CHALLENGING_SHOUT_1, diff) && rage > rcost(CHALLENGING_SHOUT_1))
+            {
+                u = opponent->GetVictim();
+                if (u && u != me && !IsTank(u) && !CCed(opponent) && dist <= 10 &&
+                    Rand() < 30 && (!IsTankingClass(u->getClass()) || IsTank()) && IsInBotParty(u))
+                {
+                    if (doCast(me, GetSpell(CHALLENGING_SHOUT_1)))
+                        return;
+                }
+                if (IsTank() && Rand() < 20)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets);
+                    uint8 count = 0;
+                    for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                    {
+                        if (!((*itr)->GetVictim() && IsTank((*itr)->GetVictim())))
+                            if (++count > 1)
+                                break;
+                    }
+                    if (count > 1 && doCast(me, GetSpell(CHALLENGING_SHOUT_1)))
+                        return;
+                }
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+                return;
+
+            u = opponent->GetVictim();
+            //MOCKING BLOW
+            if (IsSpellReady(MOCKING_BLOW_1, diff) && HasRole(BOT_ROLE_DPS) && u && u != me && !IsTank(u) &&
+                dist <= 5 && rage > rcost(MOCKING_BLOW_1) &&
+                !CCed(opponent) && Rand() < 70 && (!IsTankingClass(u->getClass()) || IsTank()) && IsInBotParty(u) &&
+                (battleStance || defensiveStance || (stancetimer <= diff && stanceChange(diff, 4))))
+            {
+                if (doCast(opponent, GetSpell(MOCKING_BLOW_1)))
+                    return;
+            }
+            //SHIELD SLAM
+            if (IsSpellReady(SHIELD_SLAM_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                (battleStance || defensiveStance || stancetimer <= diff) &&
+                dist <= 5 && rage > rcost(SHIELD_SLAM_1) && CanBlock() &&
+                Rand() < (55 + 200*(me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_WARRIOR, 2780, 0) != NULL)
+                /*me->HasAura(SWORD_AND_BOARD_BUFF)*/))
+            {
+                //check Shield Block
+                if (IsSpellReady(SHIELD_BLOCK_1, diff, false) && (defensiveStance || stanceChange(diff, 2)))
+                {
+                    if (!doCast(me, GetSpell(SHIELD_BLOCK_1)))
+                        return;
+                }
+                if (battleStance || defensiveStance || stanceChange(diff, 4))
+                {
+                    if (doCast(opponent, GetSpell(SHIELD_SLAM_1)))
+                        return;
+                }
+            }
+            //SHIELD BLOCK
+            if (IsSpellReady(SHIELD_BLOCK_1, diff, false) && CanBlock() &&
+                ((u == me && dist <= 8) || (!b_attackers.empty() && me->GetDistance2d(*(b_attackers.begin())) <= 8)) &&
+                GetHealthPCT(me) < (65 + 8 * uint8(b_attackers.size())) && Rand() < 50 &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                if ((defensiveStance || stanceChange(diff, 2)) &&
+                    doCast(me, GetSpell(SHIELD_BLOCK_1)))
+                    return;
+            }
+            //HEROIC THROW
+            if (IsSpellReady(HEROIC_THROW_1, diff) && HasRole(BOT_ROLE_DPS) && dist <= 30 &&
+                (opponent->GetTypeId() == TYPEID_UNIT || dist > 8) &&
+                Rand() < (20 - 15 * CanBlock() + 70 * opponent->IsNonMeleeSpellCasted(false,false,true)))
+            {
+                if (doCast(opponent, GetSpell(HEROIC_THROW_1)))
+                    return;
+            }
+            //SHOCKWAVE - frontal cone
+            if (IsSpellReady(SHOCKWAVE_1, diff) && HasRole(BOT_ROLE_DPS) && CanBlock() && dist <= 9.5f && !CCed(opponent) &&
+                rage > rcost(SHOCKWAVE_1) && Rand() < (30 + 50 * opponent->IsNonMeleeSpellCasted(true)) &&
+                me->HasInArc(M_PI / 2.f, opponent) && opponent->IsWithinLOSInMap(me))
+            {
+                if (doCast(me, GetSpell(SHOCKWAVE_1)))
+                    return;
+            }
+            //OVERPOWER
+            if (IsSpellReady(OVERPOWER_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                dist <= 5 && rage > rcost(OVERPOWER_1) && (battleStance || stancetimer <= diff) &&
+                (me->HasReactive(REACTIVE_OVERPOWER) ||
+                me->GetAuraEffect(SPELL_AURA_ABILITY_IGNORE_AURASTATE, SPELLFAMILY_WARRIOR, 2961, 0)
+                /*me->HasAura(TASTE_FOR_BLOOD_BUFF)*/))
+            {
+                if (battleStance || stanceChange(diff, 1))
+                {
+                    //custom
+                    me->CastSpell(opponent, GetSpell(OVERPOWER_1));
+                    return;
+                }
+            }
+            //THUNDER CLAP
+            if (IsSpellReady(THUNDER_CLAP_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                dist <= 7.5f && rage > rcost(THUNDER_CLAP_1) && Rand() < 40 &&
+                (battleStance || defensiveStance || stancetimer <= diff) &&
+                ((IsTank() && me->getAttackers().size() > 1) ||
+                !opponent->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_WARRIOR, 0x80)
+                /*!HasAuraName(opponent, THUNDER_CLAP_1)*/))
+            {
+                if (battleStance || defensiveStance || stanceChange(diff, 4))
+                {
+                    if (doCast(me, GetSpell(THUNDER_CLAP_1)))
+                        return;
+                }
+            }
+            //REVENGE
+            if (IsSpellReady(REVENGE_1, diff) && me->HasAuraState(AURA_STATE_DEFENSE) && HasRole(BOT_ROLE_DPS) && IsTank() &&
+                dist <= 5 && rage > rcost(REVENGE_1) && Rand() < 70 &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                if (defensiveStance || stanceChange(diff, 2))
+                {
+                    if (doCast(opponent, GetSpell(REVENGE_1)))
+                    {
+                        ////Improved Revenge (part 2): find second target
+                        //if (me->getLevel() >= 25)
+                        //    if (Unit* u = FindSplashTarget(5, opponent))
+                        //        me->CastSpell(u, GetSpell(REVENGE_1), true);
+                        return;
+                    }
+                }
+            }
+            //DEVASTATE - only with shield
+            if (IsSpellReady(DEVASTATE_1, diff) && HasRole(BOT_ROLE_DPS) && CanBlock() &&
+                dist <= 5 && rage > rcost(DEVASTATE_1) && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(DEVASTATE_1)))
+                    return;
+            }
+
+            MoveBehind(opponent);
+
+            //CONCUSSION_BLOW
+            if (IsSpellReady(CONCUSSION_BLOW_1, diff) && HasRole(BOT_ROLE_DPS) && IsTank() && !CCed(opponent) &&
+                dist <= 5 && rage > rcost(CONCUSSION_BLOW_1) &&
+                opponent->GetDiminishing(DIMINISHING_STUN) <= DIMINISHING_LEVEL_2 &&
+                Rand() < (30 + 60 * opponent->IsNonMeleeSpellCasted(false,false,true)))
+            {
+                if (doCast(opponent, GetSpell(CONCUSSION_BLOW_1)))
+                    return;
+            }
+            //HAMSTRING
+            if (IsSpellReady(HAMSTRING_1, diff) && (!GetSpell(PIERCING_HOWL_1) || opponent->GetTypeId() == TYPEID_PLAYER) &&
+                (opponent->isMoving() || opponent->GetTypeId() == TYPEID_PLAYER) && dist <= 5 && rage > rcost(HAMSTRING_1) &&
+                Rand() < 50 && (battleStance || berserkerStance || stancetimer <= diff) &&
+                !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (battleStance || berserkerStance || stanceChange(diff, 5))
+                    if (doCast(opponent, GetSpell(HAMSTRING_1)))
+                        return;
+            }
+            //PIERCING HOWL
+            if (IsSpellReady(PIERCING_HOWL_1, diff) && opponent->isMoving() && dist <= 9 && rage > rcost(PIERCING_HOWL_1) &&
+                Rand() < 70 && !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (doCast(me, GetSpell(PIERCING_HOWL_1)))
+                    return;
+            }
+            //DISARM
+            if (IsSpellReady(DISARM_1, diff) && dist <= 5 && rage > rcost(DISARM_1) &&
+                opponent->GetHealth() > me->GetMaxHealth() / 4 &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) && Rand() < (15 + 55*opponent->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY)) &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                //check weapons
+                bool hasWeapon = true;
+                if (opponent->GetTypeId() == TYPEID_UNIT && !opponent->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID))
+                    hasWeapon = false;
+                else if (Player const* pla = opponent->ToPlayer())
+                    if (!pla->GetWeaponForAttack(BASE_ATTACK) || !pla->IsUseEquipedWeapon(true))
+                        hasWeapon = false;
+
+                if (hasWeapon && (defensiveStance || stanceChange(diff, 2)) &&
+                    doCast(opponent, GetSpell(DISARM_1)))
+                    return;
+            }
+            //Victory Rush
+            if (IsSpellReady(VICTORY_RUSH_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && dist <= 5 &&
+                me->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_WARRIOR, 0x0, 0x40000, 0x0) &&
+                (battleStance || berserkerStance || stancetimer <= diff))
+            {
+                if (battleStance || berserkerStance || stanceChange(diff, 5))
+                    if (doCast(opponent, GetSpell(VICTORY_RUSH_1)))
+                        return;
+            }
+            //UBERS
+            //Shield Wall
+            if (IsSpellReady(SHIELD_WALL_1, diff, false) && CanBlock() &&
+                GetHealthPCT(me) < (30 + 4 * b_attackers.size() + 10 * (opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss())) &&
+                Rand() < 70 &&
+                (defensiveStance || stanceChange(diff, 2)))
+            {
+                if (doCast(me, GetSpell(SHIELD_WALL_1)))
+                    return;
+            }
+            //Retaliation
+            if (IsSpellReady(RETALIATION_1, diff) && HasRole(BOT_ROLE_DPS) && b_attackers.size() > 4 && Rand() < 30 &&
+                (battleStance || stanceChange(diff, 1)))
+            {
+                if (doCast(me, GetSpell(RETALIATION_1)))
+                    return;
+            }
+            //Recklessness
+            if (IsSpellReady(RECKLESSNESS_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                b_attackers.size() < 2 && opponent->GetHealth() > (me->GetMaxHealth() * 3) && Rand() < 20 &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0)
+                /*!me->HasAura(ENRAGED_REGENERATION_1)*/ &&
+                (berserkerStance || stanceChange(diff, 3)))
+            {
+                if (doCast(me, GetSpell(RECKLESSNESS_1)))
+                    return;
+            }
+            //DEATHWISH
+            if (IsSpellReady(DEATHWISH_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && dist <= 20 && rage > rcost(DEATHWISH_1) &&
+                opponent->GetHealth() > me->GetHealth()/2 && Rand() < 20 &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0)
+                /*!me->HasAura(ENRAGED_REGENERATION_1)*/)
+            {
+                if (doCast(me, GetSpell(DEATHWISH_1)))
+                    return;
+            }
+            //EXECUTE
+            if (IsSpellReady(EXECUTE_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                dist <= 5 && rage > rcost(EXECUTE_1) &&
+                opponent->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT) && Rand() < 70 &&
+                (battleStance || berserkerStance || (stancetimer <= diff && stanceChange(diff, 5))))
+            {
+                if (doCast(opponent, GetSpell(EXECUTE_1)))
+                    return;
+            }
+            //Mortal Strike
+            if (IsSpellReady(MORTALSTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && !CanBlock() &&
+                dist <= 5 && rage > rcost(MORTALSTRIKE_1) && Rand() < 130)
+            {
+                if (doCast(opponent, GetSpell(MORTALSTRIKE_1)))
+                    return;
+            }
+            //SUNDER ARMOR
+            if (IsSpellReady(SUNDER_1, diff) && (!GetSpell(DEVASTATE_1) || !HasRole(BOT_ROLE_DPS)) && IsTank() &&
+                dist <= 5 && rage > rcost(SUNDER_1) &&
+                opponent->GetHealth() > me->GetMaxHealth() && Rand() < 45)
+            {
+                AuraApplication const* sunder = opponent->GetAuraApplicationOfRankedSpell(SUNDER_1);
+                if ((!sunder || sunder->GetBase()->GetStackAmount() < 5 || sunder->GetBase()->GetDuration() < 15000) &&
+                    doCast(opponent, GetSpell(SUNDER_1)))
+                    return;
+            }
+            //SS //no GCD
+            if (IsSpellReady(SWEEPING_STRIKES_1, diff, false) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                dist <= 15 && rage > rcost(SWEEPING_STRIKES_1) &&
+                (battleStance || berserkerStance || stancetimer <= diff) && Rand() < 35 &&
+                (b_attackers.size() > 1 || FindSplashTarget(7, opponent)))
+            {
+                if ((battleStance || berserkerStance || stanceChange(diff, 5)) &&
+                    doCast(me, GetSpell(SWEEPING_STRIKES_1)))
+                    return;
+            }
+            //WHIRLWIND
+            if (IsSpellReady(WHIRLWIND_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && !CanBlock() &&
+                (berserkerStance || stancetimer <= diff) &&
+                dist <= 10 && rage > rcost(WHIRLWIND_1) && Rand() < 50 &&
+               ((rage > 800 && dist <= 7) || FindSplashTarget(7, opponent)))
+            {
+                if ((berserkerStance || stanceChange(diff, 3)) &&
+                    doCast(me, GetSpell(WHIRLWIND_1)))
+                    return;
+            }
+            //BLADESTORM
+            if (IsSpellReady(BLADESTORM_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && !CanBlock() &&
+               dist <= 10 && rage > rcost(BLADESTORM_1) &&
+               (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()/2) &&
+               (Rand() < 20 || me->HasAuraTypeWithFamilyFlags(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_WARRIOR, 0x10)
+               /*me->HasAura(RECKLESSNESS_1)*/))
+            {
+                if (doCast(me, GetSpell(BLADESTORM_1)))
+                    return;
+            }
+            //Slam
+            if (IsSpellReady(SLAM_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && !opponent->isMoving() &&
+                dist <= 5 && rage > rcost(SLAM_1) &&
+                Rand() < (40 + 60 * (me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_WARRIOR, 0x0, 0x1000000, 0x0) != NULL)
+                /*me->HasAura(BLOODSURGE_BUFF)*/))
+            {
+                if (doCast(opponent, GetSpell(SLAM_1)))
+                    return;
+            }
+            //SHIELD BASH - shared cd with pummel
+            if (IsSpellReady(SHIELD_BASH_1, diff, false) && CanBlock() &&
+                dist <= 5 && rage > rcost(SHIELD_BASH_1) && Rand() < 80 &&
+                opponent->IsNonMeleeSpellCasted(false,false,true) &&
+                (battleStance || defensiveStance || stancetimer <= diff))
+            {
+                if ((battleStance || defensiveStance || stanceChange(diff, 4)) &&
+                    doCast(opponent, GetSpell(SHIELD_BASH_1)))
+                    return;
+            }
+            //PUMMEL - shared cd with shield bash
+            if (IsSpellReady(PUMMEL_1, diff, false) && !IsTank() &&
+                dist <= 5 && rage > rcost(PUMMEL_1) && Rand() < 80 &&
+                opponent->IsNonMeleeSpellCasted(false,false,true) &&
+                (berserkerStance || stancetimer <= diff))
+            {
+                if ((berserkerStance || stanceChange(diff, 3)) &&
+                    doCast(opponent, GetSpell(PUMMEL_1)))
+                    return;
+            }
+            //REND
+            if (IsSpellReady(REND_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                opponent->GetHealth() > me->GetMaxHealth()/2 && dist <= 5 && rage > rcost(REND_1) &&
+                !(opponent->GetTypeId() == TYPEID_UNIT &&
+                (opponent->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1 << MECHANIC_BLEED))) &&
+                Rand() < 80 &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARRIOR, 0x20, 0x0, 0x0, me->GetGUID())
+                /*!opponent->HasAura(GetSpell(REND_1), me->GetGUID())*/ &&
+                (battleStance || defensiveStance || (stancetimer <= diff && stanceChange(diff, 4))))
+            {
+                if (doCast(opponent, GetSpell(REND_1)))
+                    return;
+            }
+
+            //skip if already have cleave of heroic strike casted
+            if (me->GetCurrentSpell(CURRENT_MELEE_SPELL))
+                return;
+
+            //CLEAVE //no GCD
+            if (IsSpellReady(CLEAVE_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                dist <= 5 && (!IsTank() || rage > 500) && rage > rcost(CLEAVE_1) && Rand() < 25)
+            {
+                u = FindSplashTarget(5);
+                if (u && doCast(opponent, GetSpell(CLEAVE_1)))
+                    return;
+            }
+            //HEROIC STRIKE
+            if (IsSpellReady(HEROIC_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && (IsTank() || rage > 600) &&
+                dist <= 5 && rage > rcost(HEROIC_STRIKE_1) && Rand() < (15 + rage / 10))
+            {
+                if (doCast(opponent, GetSpell(HEROIC_STRIKE_1)))
+                    return;
+            }
+        }//end Attack
+
+        void CheckShouts(uint32 diff)
+        {
+            if (shoutCheckTimer > diff || GC_Timer > diff || me->IsMounted() || IsCasting() ||
+                /*rage < rcost(BATTLESHOUT_1) || */Rand() > 35)
+                return;
+
+            shoutCheckTimer = 3000;
+
+            //if (!GetSpell(BATTLESHOUT_1))
+            //    return;
+
+            if (IAmFree())
+            {
+                if (GetSpell(BATTLESHOUT_1) &&
+                    !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_ATTACK_POWER, SPELLFAMILY_WARRIOR, 0x10000)
+                    /*!HasAuraName(me, BATTLESHOUT_1, me->GetGUID())*/)
+                {
+                    if (rage < rcost(BATTLESHOUT_1))
+                    {
+                        if (IsSpellReady(BLOODRAGE_1, diff, false))
+                        {
+                            if (doCast(me, GetSpell(BLOODRAGE_1)))
+                            {}
+                            else
+                                return;
+                        }
+                        else
+                            return;
+                    }
+                    if (doCast(me, GetSpell(BATTLESHOUT_1)))
+                        return;
+                }
+
+                return;
+            }
+
+            if (me->GetDistance(master) > 30)
+                return;
+
+            AuraApplication const* bs = me->GetAuraApplicationOfRankedSpell(BATTLESHOUT_1);
+            AuraApplication const* cs = me->GetAuraApplicationOfRankedSpell(COMMANDING_SHOUT_1);
+
+            bool hasBS = bs && bs->GetBase()->GetDuration() >= 30000 && bs->GetBase()->GetId() >= GetSpell(BATTLESHOUT_1);
+            bool hasCS = cs && cs->GetBase()->GetDuration() >= 30000 && cs->GetBase()->GetId() >= GetSpell(COMMANDING_SHOUT_1);
+
+            if (hasCS && hasBS)
+                return;
+
+            bool battleshout = !hasBS && (!cs || cs->GetBase()->GetCasterGUID() != me->GetGUID()) &&
+                (!IsTank(me) || !GetSpell(COMMANDING_SHOUT_1)) && GetSpell(BATTLESHOUT_1);
+            bool commandingshout = !hasCS && (!bs || bs->GetBase()->GetCasterGUID() != me->GetGUID()) &&
+                GetSpell(COMMANDING_SHOUT_1);
+
+            if (battleshout && !HasRole(BOT_ROLE_DPS) && GetSpell(COMMANDING_SHOUT_1))
+            {
+                battleshout = false;
+                commandingshout = true;
+            }
+
+            if (battleshout || commandingshout)
+            {
+                if (rage < rcost(BATTLESHOUT_1))
+                {
+                    if (IsSpellReady(BLOODRAGE_1, diff, false))
+                    {
+                        if (doCast(me, GetSpell(BLOODRAGE_1)))
+                        {}
+                        else
+                            return;
+                    }
+                    else
+                        return;
+                }
+                if ((battleshout && doCast(me, GetSpell(BATTLESHOUT_1))) ||
+                    (commandingshout && doCast(me, GetSpell(COMMANDING_SHOUT_1))))
+                    return;
+            }
+        }
+
+        void CheckVigilance(uint32 diff)
+        {
+            if (vigiCheckTimer > diff || !IsSpellReady(VIGILANCE_1, diff) || me->IsInCombat() ||
+                me->IsMounted() || IsCasting() || Rand() > 50)
+                return;
+
+            vigiCheckTimer = 750;
+            uint32 VIGILANCE = GetSpell(VIGILANCE_1);
+
+            Unit* u = vigilanceTargetGuid ? sObjectAccessor->FindUnit(vigilanceTargetGuid) : NULL;
+
+            if (u)
+            {
+                bool myVig = u->HasAura(VIGILANCE, me->GetGUID());
+                if (!IsTank() || !myVig)
+                {
+                    if (myVig)
+                        u->RemoveAura(VIGILANCE, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                    vigilanceTargetGuid = 0;
+                }
+                return;
+            }
+            else
+                vigilanceTargetGuid = 0;
+
+            if (IAmFree() || !IsTank())
+                return;
+
+            Group const* pGroup = master->GetGroup();
+            if (pGroup)
+            {
+                //tanks
+                for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pPlayer = itr->GetSource();
+                    if (!pPlayer || !pPlayer->IsInWorld()) continue;
+                    if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                    if (pPlayer->IsAlive() && IsTankingClass(pPlayer->getClass()) && me->GetDistance(pPlayer) < 30 &&
+                        !pPlayer->HasAura(VIGILANCE) && !pPlayer->HasAura(DAMAGE_REDUCTION))
+                    {
+                        u = pPlayer;
+                        break;
+                    }
+                }
+                if (!u)
+                {
+                    for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player const* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* cre = it->second;
+                            if (!cre || cre == me || !cre->IsInWorld() || !cre->IsAlive()) continue;
+                            if (cre->GetBotAI()->HasRole(BOT_ROLE_TANK) &&
+                                me->GetDistance(cre) < 30 && !cre->HasAura(VIGILANCE) && !cre->HasAura(DAMAGE_REDUCTION))
+                            {
+                                u = cre;
+                                break;
+                            }
+                        }
+                    }
+                }
+                //any players
+                if (!u)
+                {
+                    for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || pPlayer == master) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (pPlayer->IsAlive() && me->GetDistance(pPlayer) < 30 &&
+                            !pPlayer->HasAura(VIGILANCE))
+                        {
+                            u = pPlayer;
+                            break;
+                        }
+                    }
+                }
+                //damage-dealing bots
+                if (!u)
+                {
+                    for (GroupReference const* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player const* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* cre = it->second;
+                            if (!cre || cre == me || !cre->IsInWorld() || !cre->IsAlive() || cre->IsTempBot()) continue;
+                            if (cre->GetBotAI()->HasRole(BOT_ROLE_DPS) && me->GetDistance(cre) < 30 &&
+                                !cre->HasAura(VIGILANCE))
+                            {
+                                u = cre;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+            if (!u && master->IsAlive() && me->IsWithinDistInMap(master, 30) && !master->HasAura(VIGILANCE))
+                u = master;
+
+            if (u && doCast(u, VIGILANCE))
+                return;
+        }
+
+        void CheckIntervene(uint32 diff)
+        {
+            if (IsSpellReady(INTERVENE_1, diff, false) && GetBotCommandState() != COMMAND_STAY &&
+                !me->IsMounted() && rage > rcost(INTERVENE_1) &&
+                !IAmFree() && !IsCasting() && Rand() < (IsTank() ? 80 : 30) &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                if (!me->GetVictim() && master->getAttackers().empty() && master->isMoving())
+                {
+                    float mydist = me->GetDistance(master);
+                    if (mydist < 24 && mydist > 18 && (defensiveStance || stanceChange(diff, 2)))
+                    {
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                        {
+                            //Follow(true);
+                            return;
+                        }
+                    }
+                }
+                Group const* gr = master->GetGroup();
+                if (!gr)
+                {
+                    if (GetHealthPCT(master) < 95 && !master->getAttackers().empty() &&
+                        me->getAttackers().size() <= master->getAttackers().size())
+                    {
+                        float dist = me->GetExactDist(master);
+                        if (dist > 24 || dist < 10) return;
+                        if (!(defensiveStance || stanceChange(diff, 2))) return;
+
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                            return;
+                    }
+                }
+                else
+                {
+                    bool Bots = false;
+                    float dist;
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        if (tPlayer->HaveBot())
+                            Bots = true;
+                        if (!tPlayer->IsAlive() || GetHealthPCT(tPlayer) > 90 || IsTank(tPlayer)) continue;
+                        if (tPlayer->getAttackers().size() < me->getAttackers().size()) continue;
+                        dist = me->GetExactDist(tPlayer);
+                        if (dist > 24 || dist < 10) continue;
+                        if (defensiveStance || stanceChange(diff, 2))
+                        {
+                            if (doCast(tPlayer, GetSpell(INTERVENE_1)))
+                                return;
+                        }
+                    }
+                    if (!Bots) return;
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer || !tPlayer->HaveBot()) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (!bot || bot == me  || !bot->IsInWorld()|| !bot->IsAlive() || !bot->IsTempBot()) continue;
+                            if (GetHealthPCT(bot) > 90 || IsTank(bot)) continue;
+                            dist = me->GetExactDist(bot);
+                            if (dist > 24 || dist < 10) continue;
+                            if (bot->getAttackers().size() <= me->getAttackers().size()) continue;
+                            if (defensiveStance || stanceChange(diff, 2))
+                            {
+                                if (doCast(bot, GetSpell(INTERVENE_1)))
+                                    return;
+                            }
+                        }
+                    }
+                }
+
+                SetSpellCooldown(INTERVENE_1, 2000); //fail
+            }
+        }
+
+        void CheckSpellReflect(uint32 diff)
+        {
+            if (!IsSpellReady(SPELL_REFLECTION_1, diff, false) || me->IsMounted() || IsCasting() ||
+                !CanBlock() || !(battleStance || defensiveStance || stancetimer <= diff) ||
+                rage < rcost(SPELL_REFLECTION_1) || Rand() > 85)
+                return;
+
+            //use simpliest finder - first match (covers most cases)
+            if (Unit const* target = FindCastingTarget(70))
+            {
+                for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                {
+                    if (Spell const* spell = target->GetCurrentSpell(CurrentSpellTypes(i)))
+                    {
+                        if (!spell->GetSpellInfo()->IsChanneled() &&
+                            spell->GetSpellInfo()->DmgClass == SPELL_DAMAGE_CLASS_MAGIC &&
+                            !(spell->GetSpellInfo()->Attributes & SPELL_ATTR0_ABILITY) &&
+                            !(spell->GetSpellInfo()->AttributesEx & SPELL_ATTR1_CANT_BE_REFLECTED) &&
+                            !(spell->GetSpellInfo()->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY) &&
+                            !spell->GetSpellInfo()->IsPassive() && !spell->GetSpellInfo()->IsPositive() &&
+                            spell->GetTimer() < 500/*(4500 - 4000 * (target->GetTypeId() == TYPEID_PLAYER))*/)
+                        {
+                            if (Unit const* u = spell->m_targets.GetUnitTarget())
+                            {
+                                if (me->GetDistance(u) < 20 && IsInBotParty(u) &&
+                                    u->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS) < 100)
+                                {
+                                    if ((battleStance || defensiveStance || (stancetimer <= diff && stanceChange(diff, 4))) &&
+                                        doCast(me, GetSpell(SPELL_REFLECTION_1)))
+                                        return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            SetSpellCooldown(SPELL_REFLECTION_1, 500); //fail
+        }
+
+        void CheckShatteringThrow(uint32 diff)
+        {
+            if (!IsSpellReady(SHATTERING_THROW_1, diff) || shatterCheckTimer > diff ||
+                !(battleStance || stancetimer <= diff) || rage < rcost(SHATTERING_THROW_1) ||
+                me->getAttackers().size() > 2 || Rand() > 50)
+                return;
+
+            shatterCheckTimer = urand(500, 1000);
+
+            Unit* unit = FindImmunityShieldDispelTarget();
+            if (unit && (battleStance || (stancetimer <= diff && stanceChange(diff, 1))))
+                if (doCast(unit, GetSpell(SHATTERING_THROW_1)))
+                    return;
+        }
+
+        bool stanceChange(uint32 diff, uint8 stance)
+        {
+            if (stancetimer > diff || !stance)
+                return false;
+
+            if (stance == 5)
+                stance = (me->getLevel() >= 30 && !IsTank() && urand(1,100) <= 70) ? 3 : 1;
+            else if (stance == 4)
+                stance = me->getLevel() >= 10 && IsTank() ? 2 : 1;
+
+            if (stance == 2 && me->getLevel() < 10)
+                return false;
+            if (stance == 3 && me->getLevel() < 30)
+                return false;
+
+            switch (stance)
+            {
+                case 1:
+                    return doCast(me, BATTLESTANCE_1);
+                case 2:
+                    return doCast(me, DEFENSIVESTANCE_1);
+                case 3:
+                    return doCast(me, BERSERKERSTANCE_1);
+                default:
+                    return false;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+        {
+            float pctbonus = 0.0f;
+
+            if (damageinfo.hitOutCome == MELEE_HIT_CRIT)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Poleaxe Specialization: 5% additional critical damage for all attacks
+                if (me->getLevel() >= 30)
+                    if (Item const* weap = GetEquips(damageinfo.attackType))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                pctbonus += 0.025f;
+            }
+
+            damage = damage * (1.0f + pctbonus);
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType attackType) const
+        {
+            if (spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE)
+                return;
+
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Poleaxe Specialization: 5% additional critical chance for all attacks
+            if (lvl >= 30)
+                if (Item const* weap = GetEquips(attackType))
+                    if (ItemTemplate const* proto = weap->GetTemplate())
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                            proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                            crit_chance += 5.f;
+            //Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+            if (lvl >= 15 && (baseId == CLEAVE_1 || baseId == HEROIC_STRIKE_1 || baseId == THUNDER_CLAP_1))
+                crit_chance += 15.f;
+            //Improved Overpower: 50% additional critical chance for Overpower
+            if (lvl >= 20 && baseId == OVERPOWER_1)
+                crit_chance += 50.f;
+            //Critical Block: 15% additional critical chance for Shield Slam
+            if (lvl >= 50 && baseId == SHIELD_SLAM_1)
+                crit_chance += 15.f;
+            //Sword and Board: 15% additional critical chance for Devastate
+            if (lvl >= 55 && baseId == DEVASTATE_1)
+                crit_chance += 15.f;
+            //Warrior T8 Protection Bonus (id: 64933): 10% additional critical chance for Devastate (tanks only)
+            if (lvl >= 78 && IsTank() && baseId == DEVASTATE_1)
+                crit_chance += 10.f;
+            //Recklessness: 100% additional critical chance for damaging abilities
+            if (AuraEffect const* eff = me->GetAuraEffect(RECKLESSNESS_1, EFFECT_0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 100.f;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            // apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Impale: 20% crit damage bonus for all abilities
+                if (lvl >= 20)
+                    pctbonus += 0.10f;
+                //Poleaxe Specialization: 5% additional critical damage for all attacks
+                if (lvl >= 30)
+                    if (Item const* weap = GetEquips(attackType))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                pctbonus += 0.025f;
+            }
+
+            //Improved Rend: 20% bonus damage for Rend
+            if (baseId == REND_1)
+                pctbonus += 0.2f;
+            //Improved Whirlwind: 20% bonus damage for Whirlwind
+            if (lvl >= 40 && baseId == WHIRLWIND_1)
+                pctbonus += 0.2f;
+            //Glyph of Mortal Strike: 10% bonus damage for Mortal Strike
+            if (lvl >= 40 && baseId == MORTALSTRIKE_1)
+                pctbonus += 0.1f;
+            //Unrelenting Assault (part 2): 20% bonus damage for Overpower and Revenge
+            if (lvl >= 45 && (baseId == OVERPOWER_1 || baseId == REVENGE_1))
+                pctbonus += 0.2f;
+            //Improved Mortal Strike (part 1): 10% bonus damage for Mortal Strike
+            if (lvl >= 45 && baseId == MORTALSTRIKE_1)
+                pctbonus += 0.1f;
+            //Undending Fury: 10% bonus damage for Whirlwind, Slam and Bloodthirst
+            if (lvl >= 55 && (baseId == WHIRLWIND_1 || baseId == SLAM_1 /*|| baseId == BLOODTHIRST_1*/))
+                pctbonus += 0.1f;
+            //Improved Thunder Clap (part 2): 30% bonus damage for Thunder Clap
+            if (lvl >= 15 && baseId == THUNDER_CLAP_1)
+                pctbonus += 0.3f;
+            //Improved Revenge (part 1): 60% bonus damage for Revenge
+            if (lvl >= 20 && baseId == REVENGE_1)
+                pctbonus += 0.6f;
+            //Gag Order (part 2): 10% bonus damage for Shield Slam
+            if (lvl >= 30 && baseId == SHIELD_SLAM_1)
+                pctbonus += 0.1f;
+            //Improved Shield Slam (id: 38407): 10% bonus damage for Shield Slam
+            //if (lvl >= 50 && baseId == SHIELD_SLAM_1)
+            //    pctbonus += 0.1f;
+            //Shield Slam Damage Up (id: 60173): 10% bonus damage for Shield Slam
+            //if (lvl >= 70 && baseId == SHIELD_SLAM_1)
+            //    pctbonus += 0.1f;
+            //Warrior T10 Protection 2P Bonus (id: 70843): 20% bonus damage for Shield Slam and Shockwave (tanks only)
+            if (lvl >= 78 && IsTank() && (baseId == SHIELD_SLAM_1 || baseId == SHOCKWAVE_1))
+                pctbonus += 0.2f;
+            //One-Handed Weapon Specialization: 10% bonus damage with 1H weapons (for bot - Devastate only)
+            if (lvl >= 35 && baseId == DEVASTATE_1)
+                pctbonus += 0.1f;
+            //Warrior T9 Protection 2P Bonus (id: 67269): 5% bonus damage for Devastate
+            if (lvl >= 77 && baseId == DEVASTATE_1)
+                pctbonus += 0.05f;
+            //Glyph of Mocking Blow: 25% bonus damage for Mocking Blow
+            if (lvl >= 15 && baseId == MOCKING_BLOW_1)
+                pctbonus += 0.25f;
+
+            //Improved Cleave: 120% increased '!bonus damage!' done by Cleave (flat mod)
+            if (lvl >= 25 && baseId == CLEAVE_1)
+            {
+                float bp = spellInfo->Effects[EFFECT_0].BasePoints; //SPELL_EFFECT_WEAPON_DAMAGE (values: 15 - 222)
+                fdamage += bp * 1.2;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Glyph of Bloodrage: -100% health cost for Bloodrage
+            if (lvl >= 10 && baseId == BLOODRAGE_1)
+                pctbonus += 1.0f;
+            //Sword and Board: -100% rage cost for Shield Slam
+            if (lvl >= 55 && baseId == SHIELD_SLAM_1 && me->HasAura(SWORD_AND_BOARD_BUFF))
+                pctbonus += 1.0f;
+            //Glyph of Sweeping Strikes: -100% rage cost for Sweeping Strikes
+            if (lvl >= 30 && baseId == SWEEPING_STRIKES_1)
+                pctbonus += 1.0f;
+            //Glyph of Revenge: -100% rage cost for Heroic Strike
+            if (lvl >= 20 && baseId == HEROIC_STRIKE_1 && me->HasAura(GLYPH_OF_REVENGE_BUFF))
+                pctbonus += 1.0f;
+
+            //flat mods
+            //!1 rage = 10 pts!
+            //Improved Heroic Strike: -3 rage cost for Heroic Strike
+            if (lvl >= 10 && baseId == HEROIC_STRIKE_1)
+                flatbonus += 30;
+            //Bloodthirst and Mortal Strike Discount (id: 37535): -5 rage cost for Bloodthirst and Mortal Strike
+            if (lvl >= 40 && (/*baseId == BLOODTHIRST_1 || */baseId == MORTALSTRIKE_1))
+                flatbonus += 50;
+            //Improved Execute: -5 rage cost for Execute
+            if (lvl >= 25 && baseId == EXECUTE_1)
+                flatbonus += 50;
+            //Improved Thunder Clap (part 1): -4 rage cost for Thunder Clap
+            if (lvl >= 15 && baseId == THUNDER_CLAP_1)
+                flatbonus += 40;
+            //Puncture: -3 rage cost for Sunder Armor and Devastate
+            if (lvl >= 25 && (baseId == SUNDER_1 || baseId == DEVASTATE_1))
+                flatbonus += 30;
+            //Glyph of Shockwave: -3 rage cost for Shockwave
+            if (lvl >= 65 && baseId == SHOCKWAVE_1)
+                flatbonus += 30;
+            //Improved Hamstring (id: 24428): -2 rage cost for Hamstring (for bot Piercing Howl also)
+            if (lvl >= 25 && (baseId == HAMSTRING_1 || baseId == PIERCING_HOWL_1))
+                flatbonus += 20;
+            //Focused Rage: -3 rage cost for all offensive abilities (using rage)
+            if (lvl >= 40 && ((spellInfo->SpellFamilyFlags[0] & 0x6E6E4EEE) || (spellInfo->SpellFamilyFlags[1] & 0x40E664)))
+                flatbonus += 30;
+            //Glyph of Resonating Power: -5 rage cost for Thunder Clap
+            if (lvl >= 15 && baseId == THUNDER_CLAP_1)
+                flatbonus += 50;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Bloodsurge: -100% cast time for Slam
+            if (lvl >= 50 && baseId == SLAM_1 && me->HasAura(BLOODSURGE_BUFF))
+                timebonus += casttime;
+
+            //flat mods
+            //Improved Slam: -1.0 sec cast time for Slam
+            if (lvl >= 40 && baseId == SLAM_1)
+                timebonus += 1000;
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Intensify Rage: -33% cooldown for Bloodrage, Berserker Rage, Recklessness and Death Wish
+            if (lvl >= 40 &&
+                (baseId == BLOODRAGE_1 || baseId == BERSERKERRAGE_1 || baseId == RECKLESSNESS_1 || baseId == DEATHWISH_1))
+                pctbonus += 0.33f;
+
+            //flat mods
+            //Improved Disciplines: -60 sec cooldown for Shield Wall, Retaliation and Recklessness
+            if (lvl >= 35 && (baseId == SHIELD_WALL_1 || baseId == RETALIATION_1 || baseId == RECKLESSNESS_1))
+                timebonus += 60000;
+            //Shield Mastery (part 2): -20 sec cooldown for Shield Block
+            if (lvl >= 20 && baseId == SHIELD_BLOCK_1)
+                timebonus += 20000;
+            //Glyph of Bladestorm: -15 sec cooldown for Bladestorm
+            if (lvl >= 60 && baseId == BLADESTORM_1)
+                timebonus += 15000;
+            //Glyph of Spell Reflection: -1 sec cooldown for Spell Reflection
+            if (lvl >= 65 && baseId == SPELL_REFLECTION_1)
+                timebonus += 1000;
+            //zzzOLDImproved Challenging Shout (id: 12327): -2 min cooldown for Challenging Shout (tanks only)
+            if (lvl >= 30 && IsTank() && baseId == CHALLENGING_SHOUT_1)
+                timebonus += 120000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct bonuses
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            if (lvl >= 40 && baseId == CHARGE_1)
+                pctbonus += 0.07f;
+
+            //flat bonuses
+            //Unrelenting Assault (part 1): -4 sec cooldown for Overpower and Revenge (not for tanks)
+            if (lvl >= 50 && !IsTank() && (baseId == OVERPOWER_1 || baseId == REVENGE_1))
+                timebonus += 4000;
+            //Improved Mortal Strike (part 2): -1 sec cooldown for Mortal Strike
+            if (lvl >= 25 && baseId == MORTALSTRIKE_1)
+                timebonus += 1000;
+            //Warrior T9 2P Bonus (id: 67269): -2 sec cooldown for Taunt (tanks only)
+            if (lvl >= 68 && IsTank() && baseId == TAUNT_1)
+                timebonus += 2000;
+            //Improved Intercept: -10 sec cooldown for Intercept
+            if (lvl >= 30 && baseId == INTERCEPT_1)
+                timebonus += 10000;
+            //Improved Disarm (part 1): -20 sec cooldown for Disarm
+            if (lvl >= 25 && baseId == DISARM_1)
+                timebonus += 20000;
+            //Glyph of Last Stand: -1 min cooldown for Last Stand
+            if (lvl >= 20 && baseId == LAST_STAND_1)
+                timebonus += 60000;
+            //Glyph of Whirlwind: -2 sec cooldown for Whirlwind
+            if (lvl >= 36 && baseId == WHIRLWIND_1)
+                timebonus += 2000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            if (lvl >= 50 && !IsTank() && (baseId == OVERPOWER_1 || baseId == REVENGE_1))
+                timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+        {
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Booming Voice
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+                pctbonus += 1.0f;
+
+            //flat mods
+            //Glyph of Thunder Clap
+            if (spellInfo->SpellFamilyFlags[0] & 0x80)
+                flatbonus += 4.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const
+        {
+            uint32 bonusTargets = 0;
+
+            //Improved Revenge: +1 target (actually 2 in dbc)
+            if (spellInfo->SpellFamilyFlags[0] & 0x400)
+                bonusTargets += 1;
+            //Glyph of Cleaving: +1 target
+            if (spellInfo->SpellFamilyFlags[0] & 0x400000)
+            {
+                bonusTargets += 1;
+                //double for non-tanks
+                if (!IsTank())
+                    bonusTargets += 1;
+            }
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo)
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (!IAmFree())
+            {
+                if (baseId == LAST_STAND_1)
+                    BotWhisper("Last Stand used!");
+                if (baseId == SHIELD_WALL_1)
+                    BotWhisper("Shield Wall used!");
+            }
+
+            if (baseId == EXECUTE_1)
+            {
+                //sudden death
+                if (me->getLevel() >= 50 && rage <= 400)
+                    modrage(10, true);
+                else if (rage > 300)
+                    modrage(-30);
+                else
+                    modrage(0, true);
+            }
+            if (baseId == SLAM_1)
+            {
+                me->RemoveAura(BLOODSURGE_BUFF);
+            }
+            if (baseId == HEROIC_STRIKE_1)
+            {
+                me->RemoveAura(GLYPH_OF_REVENGE_BUFF);
+            }
+            if (baseId == SHIELD_SLAM_1)
+            {
+                me->RemoveAura(SWORD_AND_BOARD_BUFF);
+            }
+            if (baseId == OVERPOWER_1 && !me->HasReactive(REACTIVE_OVERPOWER))
+            {
+                me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
+            }
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            if (baseId == VIGILANCE_1)
+                vigilanceTargetGuid = target->GetGUID();
+
+            if (GetSpell(RECKLESSNESS_1))
+            {
+                //Recklessness: handle charge drop
+                AuraEffect const* reck = me->GetAuraEffect(RECKLESSNESS_1, EFFECT_0, me->GetGUID());
+                if (reck && reck->IsAffectedOnSpell(spell))
+                    reck->GetBase()->DropCharge(AURA_REMOVE_BY_EXPIRE);
+            }
+            if (baseId == PIERCING_HOWL_1)
+            {
+                //Piercing Howl: 4 sec duraion increase (exclude players)
+                if (target->GetTypeId() != TYPEID_PLAYER)
+                {
+                    if (Aura* howl = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = howl->GetDuration() + 4000;
+                        howl->SetDuration(dur);
+                        howl->SetMaxDuration(dur);
+                    }
+                }
+            }
+            if (baseId == BATTLESHOUT_1 || baseId == COMMANDING_SHOUT_1)
+            {
+                if (Aura* shout = target->GetAura(spellId, me->GetGUID()))
+                {
+                    //Glyph of Battle/Command + 2 min duration (8 for bots)
+                    uint32 dur = shout->GetDuration() + 480000;
+                    shout->SetDuration(dur);
+                    shout->SetMaxDuration(dur);
+
+                    if (me->getLevel() >= 15)
+                    {
+                        //Commanding Presence: +25% increased effect (melee AP / HP)
+                        AuraEffect* comm = shout->GetEffect(EFFECT_0);
+                        if (comm)
+                        {
+                            int32 amount = comm->GetAmount();
+                            amount = amount + amount / 4;
+                            comm->ChangeAmount(amount);
+                        }
+                    }
+                }
+            }
+            if (baseId == REVENGE_1)
+            {
+                //zzzOLD Revenge Stun (25% chance): skip players
+                if (me->getLevel() >= 25 && target->GetTypeId() != TYPEID_PLAYER && urand(1,100) <= 25)
+                    me->CastSpell(target, REVENGE_STUN_SPELL, true);
+            }
+            if (baseId == THUNDER_CLAP_1)
+            {
+                //We make it tanking bonus only, to prevent imbalance
+                if (me->getLevel() >= 15 && IsTank())
+                {
+                    AuraEffect* clap = target->GetAuraEffect(spellId, EFFECT_1, me->GetGUID());
+                    if (clap)
+                    {
+                        int32 amount = clap->GetAmount();
+                        //Improved Thunder Clap (part 3): 10% extra slow
+                        amount += (-10);
+                        //Conqueror Thunder Clap Bonus: 50% increased effect
+                        if (me->getLevel() >= 60)
+                            amount = amount + amount / 2;
+
+                        clap->ChangeAmount(amount);
+                    }
+                }
+            }
+            if (baseId == OVERPOWER_1)
+            {
+                me->ClearReactive(REACTIVE_OVERPOWER);
+                //Unrelenting Assault (part 3): reduce spells efficiency on players
+                if (me->getLevel() >= 45 &&
+                    target->GetTypeId() == TYPEID_PLAYER && target->IsNonMeleeSpellCasted(false, false, true))
+                    target->CastSpell(target, UNRELENTING_ASSAULT_SPELL, true);
+            }
+            if (baseId == REND_1)
+            {
+                //Glyph of Rending + 6 sec duration
+                if (Aura* rend = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = rend->GetDuration() + 6000;
+                    rend->SetDuration(dur);
+                    rend->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == INTERVENE_1)
+            {
+                //Glyph of Intervene + 2 bonus charges
+                if (Aura* vene = target->GetAura(spellId, me->GetGUID()))
+                {
+                    vene->SetCharges(vene->GetCharges() + 2);
+                }
+            }
+            if (baseId == VICTORY_RUSH_1)
+            {
+                me->RemoveAura(VICTORIOUS_SPELL);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->getLevel();
+
+            //Stances helper
+            if (spellId == BATTLESTANCE_1 || spellId == DEFENSIVESTANCE_1 || spellId == BERSERKERSTANCE_1)
+            {
+                //stance mastery impl
+                uint32 temprage = 0;
+                uint32 myrage = rage;
+                if (me->getLevel() >= 20)
+                    temprage = myrage > 250 ? 250 : myrage;
+                else if (me->getLevel() >= 15)
+                    temprage = myrage > 100 ? 100 : myrage;
+
+                battleStance = (spellId == BATTLESTANCE_1);
+                defensiveStance = (spellId == DEFENSIVESTANCE_1);
+                berserkerStance = (spellId == BERSERKERSTANCE_1);
+                me->SetPower(POWER_RAGE, temprage);
+                stancetimer = 1000;
+                //Update stength bonus from Improved Berserker Stance
+                if (lvl >= 45)
+                    SetStats(false);
+            }
+            //Improved Berserker Stance: threat mod
+            if (baseId == BERSERKER_STANCE_PASSIVE)
+            {
+                AuraEffect* pass = me->GetAuraEffect(spellId, 2, me->GetGUID());
+                if (pass)
+                    pass->ChangeAmount(pass->GetAmount() - 10);
+            }
+            if (baseId == RETALIATION_1)
+            {
+                //Increase duration by 3 sec and give 10 additional charges to bot
+                if (Aura* ret = me->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = ret->GetDuration() + 3000;
+                    ret->SetDuration(dur);
+                    ret->SetMaxDuration(dur);
+                    ret->SetCharges(ret->GetCharges() + 10);
+                }
+            }
+            if (baseId == BERSERKERRAGE_1)
+            {
+                //Improved Berserker Rage: 20 rage bonus when used
+                if (me->getLevel() >= 35)
+                    me->CastSpell(me, BERSERKER_RAGE_EFFECT, true);
+            }
+            if (baseId == SWORD_AND_BOARD_BUFF)
+            {
+                //Sword And Board: remove Shield Slam cooldown
+                ResetSpellCooldown(SHIELD_SLAM_1);
+            }
+            if (baseId == VIGILANCE_PROC) //confirmed right place
+            {
+                //Vigilance: remove Taunt cooldown
+                ResetSpellCooldown(TAUNT_1);
+            }
+            if (baseId == SHIELD_WALL_1)
+            {
+                //Shield Wall Duration (id: 60175): 3 sec increased Shield Wall duration
+                if (Aura* wall = me->GetAura(spellId))
+                {
+                    int32 dur = wall->GetDuration() + 3000;
+                    wall->SetDuration(dur);
+                    wall->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            stancetimer = 0;
+            ragetimer = 1500;
+            ragetimer2 = 3000;
+            shoutCheckTimer = 5000;
+            shatterCheckTimer = 5000;
+            vigiCheckTimer = 5000;
+
+            vigilanceTargetGuid = 0;
+
+            battleStance = true;
+            defensiveStance = false;
+            berserkerStance = false;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            me->setPowerType(POWER_RAGE);
+            rage = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (stancetimer > diff)                 stancetimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+            if (shoutCheckTimer > diff)             shoutCheckTimer -= diff;
+            if (shatterCheckTimer > diff)           shatterCheckTimer -= diff;
+            if (vigiCheckTimer > diff)              vigiCheckTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(INTIMIDATING_SHOUT_1);
+            InitSpellMap(ENRAGED_REGENERATION_1);
+            InitSpellMap(CHARGE_1);
+            InitSpellMap(OVERPOWER_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(TAUNT_1) : RemoveSpell(TAUNT_1);
+            InitSpellMap(BLOODRAGE_1);
+            InitSpellMap(BERSERKERRAGE_1);
+            InitSpellMap(INTERCEPT_1);
+            InitSpellMap(CLEAVE_1);
+            InitSpellMap(HAMSTRING_1);
+            InitSpellMap(INTERVENE_1);
+            InitSpellMap(WHIRLWIND_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(BLADESTORM_1) : RemoveSpell(BLADESTORM_1);
+            InitSpellMap(BATTLESHOUT_1);
+            InitSpellMap(REND_1);
+            InitSpellMap(EXECUTE_1);
+            InitSpellMap(PUMMEL_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(MORTALSTRIKE_1) : RemoveSpell(MORTALSTRIKE_1);
+            InitSpellMap(SLAM_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(SUNDER_1) : RemoveSpell(SUNDER_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(SWEEPING_STRIKES_1) : RemoveSpell(SWEEPING_STRIKES_1);
+            InitSpellMap(BATTLESTANCE_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(DEFENSIVESTANCE_1) : RemoveSpell(DEFENSIVESTANCE_1);
+   /*Quest*/lvl >= 30 ? InitSpellMap(BERSERKERSTANCE_1) : RemoveSpell(BERSERKERSTANCE_1);
+            InitSpellMap(RECKLESSNESS_1);
+            InitSpellMap(RETALIATION_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(DEATHWISH_1) : RemoveSpell(DEATHWISH_1);
+            InitSpellMap(VICTORY_RUSH_1);
+            InitSpellMap(THUNDER_CLAP_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(LAST_STAND_1) : RemoveSpell(LAST_STAND_1);
+            InitSpellMap(REVENGE_1);
+            InitSpellMap(SHIELD_BLOCK_1);
+            InitSpellMap(SHIELD_SLAM_1);
+            InitSpellMap(SPELL_REFLECTION_1);
+            InitSpellMap(DISARM_1);
+            InitSpellMap(SHIELD_WALL_1);
+            InitSpellMap(SHIELD_BASH_1);
+            InitSpellMap(HEROIC_THROW_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(CONCUSSION_BLOW_1) : RemoveSpell(CONCUSSION_BLOW_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(VIGILANCE_1) : RemoveSpell(VIGILANCE_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(DEVASTATE_1) : RemoveSpell(DEVASTATE_1);
+            InitSpellMap(MOCKING_BLOW_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(SHOCKWAVE_1) : RemoveSpell(SHOCKWAVE_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(PIERCING_HOWL_1) : RemoveSpell(PIERCING_HOWL_1);
+            InitSpellMap(HEROIC_STRIKE_1);
+            InitSpellMap(CHALLENGING_SHOUT_1);
+            InitSpellMap(COMMANDING_SHOUT_1);
+            InitSpellMap(SHATTERING_THROW_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(DEEP_WOUNDS_3, level >= 24 ? 1 : 0);
+            RefreshAura(DEEP_WOUNDS_2, level >= 23 && level < 24 ? 1 : 0);
+            RefreshAura(DEEP_WOUNDS_1, level >= 22 && level < 23 ? 1 : 0);
+            RefreshAura(WC5, level >= 70 ? 1 : 0);
+            RefreshAura(WC4, level >= 68 && level < 70 ? 1 : 0);
+            RefreshAura(WC3, level >= 66 && level < 68 ? 1 : 0);
+            RefreshAura(WC2, level >= 64 && level < 66 ? 1 : 0);
+            RefreshAura(WC1, level >= 62 && level < 64 ? 1 : 0);
+            RefreshAura(FLURRY5, level >= 39 ? 1 : 0);
+            RefreshAura(FLURRY4, level >= 38 && level < 39 ? 1 : 0);
+            RefreshAura(FLURRY3, level >= 37 && level < 38 ? 1 : 0);
+            RefreshAura(FLURRY2, level >= 36 && level < 37 ? 1 : 0);
+            RefreshAura(FLURRY1, level >= 35 && level < 36 ? 1 : 0);
+            RefreshAura(SWORD_SPEC5, level >= 60 ? 2 : level >= 50 ? 1 : 0);
+            RefreshAura(SWORD_SPEC4, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(SWORD_SPEC3, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(SWORD_SPEC2, level >= 35 && level < 40 ? 1 : 0);
+            RefreshAura(SWORD_SPEC1, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(RAMPAGE, level >= 60 ? 1 : 0);
+            RefreshAura(TRAUMA2, level >= 55 ? 1 : 0);
+            RefreshAura(TRAUMA1, level >= 35 && level < 55 ? 1 : 0);
+            RefreshAura(BLOOD_FRENZY, level >= 45 ? 1 : 0);
+            RefreshAura(SECOND_WIND, level >= 40 ? 1 : 0);
+            RefreshAura(TOUGHNESS, level >= 40 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(IMP_HAMSTRING, level >= 40 ? 2 : level >= 35 ? 1 : 0);
+            RefreshAura(SHIELD_SPECIALIZATION, level >= 15 ? 1 : 0);
+            RefreshAura(GAG_ORDER, level >= 30 ? 1 : 0);
+            RefreshAura(IMPROVED_SPELL_REFLECTION, level >= 25 ? 1 : 0);
+            RefreshAura(IMPROVED_DISARM, level >= 25 ? 1 : 0);
+            //RefreshAura(VITALITY, level >= 45 ? 1 : 0);
+            RefreshAura(CRITICAL_BLOCK, level >= 50 ? 1 : 0);
+            RefreshAura(SWORD_AND_BOARD, level >= 55 ? 1 : 0);
+            RefreshAura(ARMORED_TO_THE_TEETH, level >= 20 ? 1 : 0);
+            RefreshAura(ENDLESS_RAGE, level >= 55 ? 1 : 0);
+            RefreshAura(BLOODSURGE, level >= 50 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD3, level >= 30 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD2, level >= 28 && level < 30 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD1, level >= 25 && level < 28 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE3, level >= 30 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE2, level >= 25 && level < 30 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE1, level >= 20 && level < 25 ? 1 : 0);
+            RefreshAura(DUAL_WIELD_SPECIALIZATION, level >= 25 ? 1 : 0);
+            RefreshAura(ONE_HANDED_WEAPON_SPECIALIZATION, level >= 35 ? 1 : 0);
+            RefreshAura(TWO_HANDED_WEAPON_SPECIALIZATION, level >= 25 ? 1 : 0);
+
+            RefreshAura(WARRIOR_T10_4P, level >= 60 ? 1 : 0);
+            RefreshAura(GLYPH_BLOCKING);
+            RefreshAura(GLYPH_DEVASTATE);
+            RefreshAura(GLYPH_EXECUTION);
+            RefreshAura(GLYPH_HEROIC_STRIKE);
+            RefreshAura(GLYPH_REVENGE);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case ENRAGED_REGENERATION_1:
+                case BLOODRAGE_1:
+                case BERSERKERRAGE_1:
+                case BATTLESHOUT_1:
+                case COMMANDING_SHOUT_1:
+                case DEATHWISH_1:
+                    return true;
+                case BATTLESTANCE_1:
+                    return !battleStance;
+                case DEFENSIVESTANCE_1:
+                    return !defensiveStance;
+                case BERSERKERSTANCE_1:
+                    return !berserkerStance;
+                case SWEEPING_STRIKES_1:
+                    return battleStance || berserkerStance;
+                case RETALIATION_1:
+                    return battleStance;
+                case RECKLESSNESS_1:
+                    return berserkerStance;
+                case SHIELD_WALL_1:
+                    return CanBlock() && defensiveStance;
+                case SHIELD_BLOCK_1:
+                    return CanBlock();
+                case LAST_STAND_1:
+                case VIGILANCE_1:
+                    return IsTank();
+                default:
+                    return false;
+            }
+        }
+
+        float GetBotArmorPenetrationCoef() const
+        {
+            float bonus = 0.0f;
+
+            if (battleStance)
+            {
+                bonus += 10.f;
+                //Warrior T10 4P Bonus (part 1): 6% additional armor penetration in Battle Stance
+                if (me->getLevel() >= 75)
+                    bonus += 6.f;
+            }
+
+            //Mace Specialization: 15% armor penetration
+            if (me->getLevel() >= 30)
+                if (Item const* weap = GetEquips(BOT_SLOT_MAINHAND))
+                    if (ItemTemplate const* proto = weap->GetTemplate())
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2)
+                            bonus += 15.f;
+
+            return bonus + bot_ai::GetBotArmorPenetrationCoef();
+        }
+
+    private:
+/*tmrs*/uint32 stancetimer, ragetimer, ragetimer2, shoutCheckTimer, shatterCheckTimer, vigiCheckTimer;
+/*misc*/int32 rage;
+/*misc*/uint64 vigilanceTargetGuid;
+/*misc*/float rageIncomeMult, rageLossMult;
+/*Chck*/bool battleStance, defensiveStance, berserkerStance;
+
+        enum WarriorBaseSpells
+        {
+            INTIMIDATING_SHOUT_1                    = 5246,
+            ENRAGED_REGENERATION_1                  = 55694,
+            CHARGE_1                                = 100,
+            OVERPOWER_1                             = 7384,
+            TAUNT_1                                 = 355,
+            BLOODRAGE_1                             = 2687,
+            BERSERKERRAGE_1                         = 18499,
+            INTERCEPT_1                             = 20252,
+            CLEAVE_1                                = 845,
+            HAMSTRING_1                             = 1715,
+            INTERVENE_1                             = 3411,
+            WHIRLWIND_1                             = 1680,
+            BLADESTORM_1                            = 46924,
+            BATTLESHOUT_1                           = 6673,
+            REND_1                                  = 772,
+            EXECUTE_1                               = 5308,
+            PUMMEL_1                                = 6552,
+  /*Talent*/MORTALSTRIKE_1                          = 12294,
+            SLAM_1                                  = 1464,
+            SUNDER_1                                = 7386,
+  /*Talent*/SWEEPING_STRIKES_1                      = 12328,
+            BATTLESTANCE_1                          = 2457,
+            DEFENSIVESTANCE_1                       = 71,
+            BERSERKERSTANCE_1                       = 2458,
+            RECKLESSNESS_1                          = 1719,
+            RETALIATION_1                           = 20230,
+  /*Talent*/DEATHWISH_1                             = 12292,
+            VICTORY_RUSH_1                          = 34428,
+            THUNDER_CLAP_1                          = 6343,
+  /*Talent*/LAST_STAND_1                            = 12975,
+            REVENGE_1                               = 6572,
+            SHIELD_BLOCK_1                          = 2565,
+            SHIELD_SLAM_1                           = 23922,
+            SPELL_REFLECTION_1                      = 23920,
+            DISARM_1                                = 676,
+            SHIELD_WALL_1                           = 871,
+            SHIELD_BASH_1                           = 72,
+            HEROIC_THROW_1                          = 57755,
+  /*Talent*/CONCUSSION_BLOW_1                       = 12809,
+  /*Talent*/VIGILANCE_1                             = 50720,
+  /*Talent*/DEVASTATE_1                             = 20243,
+            MOCKING_BLOW_1                          = 694,
+            SHOCKWAVE_1                             = 46968,
+            PIERCING_HOWL_1                         = 12323,
+            HEROIC_STRIKE_1                         = 78,
+            CHALLENGING_SHOUT_1                     = 1161,
+            COMMANDING_SHOUT_1                      = 469,
+            SHATTERING_THROW_1                      = 64382
+        };
+        enum WarriorPassives
+        {
+        //Talents
+            DEEP_WOUNDS_1                           = 12834,
+            DEEP_WOUNDS_2                           = 12849,
+            DEEP_WOUNDS_3                           = 12867,
+            WC1  /*WRECKING CREW1*/                 = 46867,
+            WC2  /*WRECKING CREW2*/                 = 56611,
+            WC3  /*WRECKING CREW3*/                 = 56612,
+            WC4  /*WRECKING CREW4*/                 = 56613,
+            WC5  /*WRECKING CREW5*/                 = 56614,
+            FLURRY1                                 = 16256,
+            FLURRY2                                 = 16281,
+            FLURRY3                                 = 16282,
+            FLURRY4                                 = 16283,
+            FLURRY5                                 = 16284,
+            SWORD_SPEC1                             = 12281,
+            SWORD_SPEC2                             = 12812,
+            SWORD_SPEC3                             = 12813,
+            SWORD_SPEC4                             = 12814,
+            SWORD_SPEC5                             = 12815,
+            BLOOD_CRAZE1                            = 16487,
+            BLOOD_CRAZE2                            = 16489,
+            BLOOD_CRAZE3                            = 16492,
+            TASTE_FOR_BLOOD1                        = 56636,
+            TASTE_FOR_BLOOD2                        = 56637,
+            TASTE_FOR_BLOOD3                        = 56638,
+            UNRELENTING_ASSAULT1                    = 46859,
+            UNRELENTING_ASSAULT2                    = 46860,
+            TRAUMA1                                 = 46854,
+            TRAUMA2                                 = 46855,
+            BLOOD_FRENZY                            = 29859,
+            RAMPAGE                                 = 29801,
+            SECOND_WIND                             = 29838,//rank 2
+            TOUGHNESS                               = 12764,//rank 5
+            IMP_HAMSTRING                           = 23695,//rank 3
+            SHIELD_SPECIALIZATION                   = 12727,//rank 5
+            GAG_ORDER                               = 12958,//rank 2
+            IMPROVED_SPELL_REFLECTION               = 59089,//rank 2
+            IMPROVED_DISARM                         = 12804,//rank 2
+            //VITALITY                                = 29144,//rank 3
+            CRITICAL_BLOCK                          = 47296,//rank 3
+            SWORD_AND_BOARD                         = 46953,//rank 3
+            ARMORED_TO_THE_TEETH                    = 61222,//rank 3
+            ENDLESS_RAGE                            = 29623,
+            BLOODSURGE                              = 46915,//rank 3
+            DUAL_WIELD_SPECIALIZATION               = 23588,//rank 5
+            ONE_HANDED_WEAPON_SPECIALIZATION        = 12712,//rank 5
+            TWO_HANDED_WEAPON_SPECIALIZATION        = 16542,//rank 3
+        //other
+            WARRIOR_T10_4P                          = 70844,
+            GLYPH_BLOCKING                          = 58375,
+            GLYPH_DEVASTATE                         = 58388,
+            GLYPH_EXECUTION                         = 58367,
+            GLYPH_HEROIC_STRIKE                     = 58357,
+            GLYPH_REVENGE                           = 58364
+        };
+        enum WarriorSpecial
+        {
+            TASTE_FOR_BLOOD_BUFF                    = 60503,
+            //LAMBS_TO_THE_SLAUGHTER_BUFF             = 84586,
+            SWORD_AND_BOARD_BUFF                    = 50227,
+            BLOODSURGE_BUFF                         = 46916,//"Slam!"
+            GLYPH_OF_REVENGE_BUFF                   = 58363,
+            UNRELENTING_ASSAULT_SPELL               = 64850,
+            VICTORIOUS_SPELL                        = 32216,
+            REVENGE_STUN_SPELL                      = 12798,
+            //COLOSSUS_SMASH_EFFECT                   = 108126,
+            //SWORD_SPECIALIZATION_TRIGGERED          = 16459,
+            VIGILANCE_PROC                          = 50725,
+            BERSERKER_RAGE_EFFECT                   = 23691,//rank 2
+
+            BERSERKER_STANCE_PASSIVE                = 7381
+        };
+    };
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/game/AI/NpcBots/botcommands.cpp b/src/server/game/AI/NpcBots/botcommands.cpp
new file mode 100644
index 0000000..3d8e3f8
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommands.cpp
@@ -0,0 +1,940 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "botdatamgr.h"
+#include "Chat.h"
+#include "Language.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+/*
+Name: script_bot_commands
+%Complete: ???
+Comment: Npc Bot related commands by Trickerer (onlysuffering@gmail.com)
+Category: commandscripts/custom/
+*/
+//RBAC_PERM_GM_COMMANDS = 197
+//RBAC_PERM_PLAYER_COMMANDS = 199
+#define GM_COMMANDS rbac::RBACPermissions(197)
+#define PLAYER_COMMANDS rbac::RBACPermissions(199)
+
+class script_bot_commands : public CommandScript
+{
+private:
+    struct BotInfo
+    {
+        public:
+            BotInfo(uint32 Id, std::string Name, uint8 Race) : id(Id), name(Name), race(Race) {}
+            uint32 id;
+            std::string name;
+            uint8 race;
+        private:
+            BotInfo() {}
+            //BotInfo(BotInfo const&);
+    };
+    static bool sortbots(BotInfo const& p1, BotInfo const& p2)
+    {
+        return p1.id < p2.id;
+    }
+
+public:
+    script_bot_commands() : CommandScript("script_bot_commands") { }
+
+    ChatCommand* GetCommands() const
+    {
+        //static ChatCommand npcbotToggleCommandTable[] =
+        //{
+        //    { "flags",      GM_COMMANDS,            false, &HandleNpcBotToggleFlagsCommand,         "", NULL },
+        //    { NULL,         0,                      false, NULL,                                    "", NULL }
+        //};
+
+        //static ChatCommand npcbotDebugCommandTable[] =
+        //{
+        //    { "raid",       GM_COMMANDS,            false, &HandleNpcBotDebugRaidCommand,           "", NULL },
+        //    { NULL,         0,                      false, NULL,                                    "", NULL }
+        //};
+
+        static ChatCommand npcbotSetCommandTable[] =
+        {
+            { "faction",    GM_COMMANDS,            false, &HandleNpcBotSetFactionCommand,          "", NULL },
+            { "owner",      GM_COMMANDS,            false, &HandleNpcBotSetOwnerCommand,            "", NULL },
+            { NULL,         0,                      false, NULL,                                    "", NULL }
+        };
+
+        static ChatCommand npcbotCommandTable[] =
+        {
+            //{ "debug",      GM_COMMANDS,            false, NULL,                 "", npcbotDebugCommandTable },
+            { "set",        GM_COMMANDS,            false, NULL,                   "", npcbotSetCommandTable },
+            //{ "toggle",     GM_COMMANDS,            false, NULL,                "", npcbotToggleCommandTable },
+            { "add",        GM_COMMANDS,            false, &HandleNpcBotAddCommand,                 "", NULL },
+            { "remove",     GM_COMMANDS,            false, &HandleNpcBotRemoveCommand,              "", NULL },
+            { "spawn",      GM_COMMANDS,            false, &HandleNpcBotSpawnCommand,               "", NULL },
+            { "delete",     GM_COMMANDS,            false, &HandleNpcBotDeleteCommand,              "", NULL },
+            { "lookup",     GM_COMMANDS,            false, &HandleNpcBotLookupCommand,              "", NULL },
+            { "revive",     GM_COMMANDS,            false, &HandleNpcBotReviveCommand,              "", NULL },
+            { "command",    PLAYER_COMMANDS,        false, &HandleNpcBotCommandCommand,             "", NULL },
+            { "info",       PLAYER_COMMANDS,        false, &HandleNpcBotInfoCommand,                "", NULL },
+            { "hide",       PLAYER_COMMANDS,        false, &HandleNpcBotHideCommand,                "", NULL },
+            { "unhide",     PLAYER_COMMANDS,        false, &HandleNpcBotUnhideCommand,              "", NULL },
+            { "show",       PLAYER_COMMANDS,        false, &HandleNpcBotUnhideCommand,              "", NULL },
+            { "recall",     PLAYER_COMMANDS,        false, &HandleNpcBotRecallCommand,              "", NULL },
+            { "kill",       PLAYER_COMMANDS,        false, &HandleNpcBotKillCommand,                "", NULL },
+            { "suicide",    PLAYER_COMMANDS,        false, &HandleNpcBotKillCommand,                "", NULL },
+            { NULL,         0,                      false, NULL,                                    "", NULL }
+        };
+
+        static ChatCommand commandTable[] =
+        {
+            { "npcbot",     PLAYER_COMMANDS,        false, NULL,                      "", npcbotCommandTable },
+            { NULL,         0,                      false, NULL,                                    "", NULL }
+        };
+        return commandTable;
+    }
+
+    //static bool HandleNpcBotDebugRaidCommand(ChatHandler* handler, const char* /*args*/)
+    //{
+    //    Player* owner = handler->GetSession()->GetPlayer();
+    //    Group const* gr = owner->GetGroup();
+    //    if (!owner->HaveBot() || !gr)
+    //    {
+    //        handler->SendSysMessage(".npcbot debug raid");
+    //        handler->SendSysMessage("prints your raid bots info");
+    //        return true;
+    //    }
+    //    if (!gr->isRaidGroup())
+    //    {
+    //        handler->SendSysMessage("only usable in raid");
+    //        return true;
+    //    }
+
+    //    uint8 counter = 0;
+    //    uint8* subBots = new uint8[MAX_RAID_SUBGROUPS];
+    //    memset((void*)subBots, 0, (MAX_RAID_SUBGROUPS)*sizeof(uint8));
+    //    std::ostringstream sstr;
+    //    BotMap const* map = owner->GetBotMgr()->GetBotMap();
+    //    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+    //    {
+    //        Creature* bot = itr->second;
+    //        if (!bot || !gr->IsMember(itr->first))
+    //            continue;
+
+    //        uint8 subGroup = gr->GetMemberGroup(itr->first);
+    //        ++subBots[subGroup];
+    //        sstr << uint32(++counter) << ": " << bot->GetGUIDLow() << " " << bot->GetName()
+    //            << " subgr: " << uint32(subGroup + 1) << "\n";
+    //    }
+
+    //    for (uint8 i = 0; i != MAX_RAID_SUBGROUPS; ++i)
+    //        if (subBots[i] > 0)
+    //            sstr << uint32(subBots[i]) << " bots in subgroup " << uint32(i + 1) << "\n";
+
+    //    handler->SendSysMessage(sstr.str().c_str());
+    //    delete[] subBots;
+    //    return true;
+    //}
+
+    static bool HandleNpcBotHideCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        // Hiding/unhiding bots should be allowed only out of combat
+        // Currenly bots can teleport to master in combat
+        // This creates potential for some serious trolls
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot hide");
+            handler->SendSysMessage("Removes your owned npcbots from world temporarily");
+            //handler->SendSysMessage("You have no bots!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!owner->IsAlive())
+        {
+            handler->GetSession()->SendNotification("You are dead");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetBotMgr()->IsPartyInCombat())
+        {
+            handler->GetSession()->SendNotification(LANG_YOU_IN_COMBAT);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        owner->GetBotMgr()->SetBotsHidden(true);
+        handler->SendSysMessage("Bots hidden");
+        return true;
+    }
+
+    static bool HandleNpcBotUnhideCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot unhide | show");
+            handler->SendSysMessage("Returns your temporarily hidden bots back");
+            //handler->SendSysMessage("You have no bots!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!owner->IsAlive())
+        {
+            handler->GetSession()->SendNotification("You are dead");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetBotMgr()->IsPartyInCombat())
+        {
+            handler->GetSession()->SendNotification(LANG_YOU_IN_COMBAT);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        owner->GetBotMgr()->SetBotsHidden(false);
+        handler->SendSysMessage("Bots unhidden");
+        return true;
+    }
+
+    static bool HandleNpcBotKillCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        uint64 guid = owner->GetTarget();
+        if (!guid || !owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot recall");
+            handler->SendSysMessage("Makes your npcbots just drop dead. If you select yourself ALL your bots will die");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (guid == owner->GetGUID())
+        {
+            owner->GetBotMgr()->KillAllBots();
+            return true;
+        }
+        if (Creature* bot = owner->GetBotMgr()->GetBot(guid))
+        {
+            owner->GetBotMgr()->KillBot(bot);
+            return true;
+        }
+
+        handler->SendSysMessage("You must select one of your bots or yourself");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotRecallCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        uint64 guid = owner->GetTarget();
+        if (!guid || !owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot recall");
+            handler->SendSysMessage("Forces npcbots to move directly on your position. Select a npcbot you want to move or select yourself to move all bots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetBotMgr()->IsPartyInCombat())
+        {
+            handler->GetSession()->SendNotification(LANG_YOU_IN_COMBAT);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (guid == owner->GetGUID())
+        {
+            owner->GetBotMgr()->RecallAllBots();
+            return true;
+        }
+        if (Creature* bot = owner->GetBotMgr()->GetBot(guid))
+        {
+            owner->GetBotMgr()->RecallBot(bot);
+            return true;
+        }
+
+        handler->SendSysMessage("You must select one of your bots or yourself");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    //static bool HandleNpcBotToggleFlagsCommand(ChatHandler* handler, const char* args)
+    //{
+    //    Player* chr = handler->GetSession()->GetPlayer();
+    //    Unit* unit = chr->GetSelectedUnit();
+    //    if (!unit || unit->GetTypeId() != TYPEID_UNIT || !*args)
+    //    {
+    //        handler->SendSysMessage(".npcbot toggle flags #flag");
+    //        handler->SendSysMessage("This is a debug command");
+    //        handler->SetSentErrorMessage(true);
+    //        return false;
+    //    }
+
+    //    const std::string facStr = args;
+    //    int32 flag = (int32)atoi((char*)args);
+
+    //    uint32 setFlags = 0;
+
+    //    switch (flag)
+    //    {
+    //        case 6:
+    //            setFlags = UNIT_FLAG_UNK_6;
+    //            break;
+    //        case 14:
+    //            setFlags = UNIT_FLAG_UNK_14;
+    //            break;
+    //        case 15:
+    //            setFlags = UNIT_FLAG_UNK_15;
+    //            break;
+    //        case 16:
+    //            setFlags = UNIT_FLAG_UNK_16;
+    //            break;
+    //        default:
+    //            break;
+    //    }
+
+    //    if (!setFlags)
+    //        return false;
+
+    //    handler->PSendSysMessage("Toggling flag %u on %s", setFlags, unit->GetName().c_str());
+    //    unit->ToggleFlag(UNIT_FIELD_FLAGS, setFlags);
+    //    return true;
+    //}
+
+    static bool HandleNpcBotSetFactionCommand(ChatHandler* handler, const char* args)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !*args)
+        {
+            handler->SendSysMessage(".npcbot set faction #faction");
+            handler->SendSysMessage("Sets faction for selected npcbot (saved in DB).");
+            handler->SendSysMessage("Use 'a', 'h', 'm' or 'f' as argument to set faction to alliance, horde, monsters (hostile to all) or friends (friendly to all)");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->GetIAmABot() || !bot->IsFreeBot())
+        {
+            handler->SendSysMessage("You must select uncontrolled npcbot.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint32 factionId = 0;
+        const std::string facStr = args;
+        char const* factionChar = facStr.c_str();
+
+        if (factionChar[0] == 'a')
+            factionId = 1802; //Alliance
+        else if (factionChar[0] == 'h')
+            factionId = 1801; //Horde
+        else if (factionChar[0] == 'm')
+            factionId = 14; //Monsters
+        else if (factionChar[0] == 'f')
+            factionId = 35; //Friendly to all
+
+        if (!factionId)
+        {
+            char* pfactionid = handler->extractKeyFromLink((char*)args, "Hfaction");
+            factionId = atoi(pfactionid);
+        }
+
+        if (!sFactionTemplateStore.LookupEntry(factionId))
+        {
+            handler->PSendSysMessage(LANG_WRONG_FACTION, factionId);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_FACTION, &factionId);
+
+        handler->PSendSysMessage("%s's faction set to %u", bot->GetName().c_str(), factionId);
+        bot->GetBotAI()->InitFaction();
+        return true;
+    }
+
+    static bool HandleNpcBotSetOwnerCommand(ChatHandler* handler, const char* args)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !*args)
+        {
+            handler->SendSysMessage(".npcbot set owner #guid | #name");
+            handler->SendSysMessage("Binds selected npcbot to new player owner using guid or name and updates owner in DB");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->GetIAmABot())
+        {
+            handler->SendSysMessage("You must select a npcbot.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (bot->GetBotAI()->GetBotOwnerGuid())
+        {
+            handler->SendSysMessage("This npcbot already has owner");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* characterName_str = strtok((char*)args, " ");
+        if (!characterName_str)
+            return false;
+
+        std::string characterName = characterName_str;
+        uint32 guidlow = (uint32)atoi(characterName_str);
+
+        bool found = false;
+        if (guidlow)
+            found = sObjectMgr->GetPlayerNameByGUID(MAKE_NEW_GUID(guidlow, 0, HIGHGUID_PLAYER), characterName);
+        else
+            guidlow = sObjectMgr->GetPlayerGUIDByName(characterName);
+
+        if (!guidlow || !found)
+        {
+            handler->SendSysMessage("Player not found");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        bot->GetBotAI()->SetBotOwnerGUID(guidlow);
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_OWNER, &guidlow);
+
+        handler->PSendSysMessage("%s's new owner is %s (guidlow: %u)", bot->GetName().c_str(), characterName.c_str(), guidlow);
+        return true;
+    }
+
+    static bool HandleNpcBotLookupCommand(ChatHandler* handler, const char* args)
+    {
+        //this is just a modified '.lookup creature' command
+        if (!*args)
+        {
+            handler->SendSysMessage(".npcbot lookup #class");
+            handler->SendSysMessage("Looks up npcbots by #class, and returns all matches with their creature ID's.");
+            handler->PSendSysMessage("BOT_CLASS_WARRIOR = %u", uint32(BOT_CLASS_WARRIOR));
+            handler->PSendSysMessage("BOT_CLASS_PALADIN = %u", uint32(BOT_CLASS_PALADIN));
+            handler->PSendSysMessage("BOT_CLASS_HUNTER = %u", uint32(BOT_CLASS_HUNTER));
+            handler->PSendSysMessage("BOT_CLASS_ROGUE = %u", uint32(BOT_CLASS_ROGUE));
+            handler->PSendSysMessage("BOT_CLASS_PRIEST = %u", uint32(BOT_CLASS_PRIEST));
+            handler->PSendSysMessage("BOT_CLASS_DEATH_KNIGHT = %u", uint32(BOT_CLASS_DEATH_KNIGHT));
+            handler->PSendSysMessage("BOT_CLASS_SHAMAN = %u", uint32(BOT_CLASS_SHAMAN));
+            handler->PSendSysMessage("BOT_CLASS_MAGE = %u", uint32(BOT_CLASS_MAGE));
+            handler->PSendSysMessage("BOT_CLASS_WARLOCK = %u", uint32(BOT_CLASS_WARLOCK));
+            handler->PSendSysMessage("BOT_CLASS_DRUID = %u", uint32(BOT_CLASS_DRUID));
+            handler->PSendSysMessage("BOT_CLASS_BM = %u", uint32(BOT_CLASS_BM));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* classstr = strtok((char*)args, " ");
+        uint8 botclass = BOT_CLASS_NONE;
+
+        if (classstr)
+            botclass = (uint8)atoi(classstr);
+
+        if (botclass == BOT_CLASS_NONE || botclass >= BOT_CLASS_END)
+        {
+            handler->PSendSysMessage("Unknown bot class %u", uint32(botclass));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Looking for bots of class %u...", uint32(botclass));
+
+        uint8 localeIndex = handler->GetSessionDbLocaleIndex();
+        CreatureTemplateContainer const* ctc = sObjectMgr->GetCreatureTemplates();
+        typedef std::list<BotInfo> BotList;
+        BotList botlist;
+        for (CreatureTemplateContainer::const_iterator itr = ctc->begin(); itr != ctc->end(); ++itr)
+        {
+            uint32 id = itr->second.Entry;
+            if (id < BOT_ENTRY_BEGIN || id > BOT_ENTRY_END)
+                continue;
+
+            uint32 trainer_class = itr->second.trainer_class;
+            uint8 trainer_race = itr->second.trainer_race;
+            if (trainer_class != botclass)
+                continue;
+
+            if (CreatureLocale const* creatureLocale = sObjectMgr->GetCreatureLocale(id))
+            {
+                if (creatureLocale->Name.size() > localeIndex && !creatureLocale->Name[localeIndex].empty())
+                {
+                    botlist.push_back(BotInfo(id, creatureLocale->Name[localeIndex], trainer_race));
+                    continue;
+                }
+            }
+
+            std::string name = itr->second.Name;
+            if (name.empty())
+                continue;
+
+            botlist.push_back(BotInfo(id, name, trainer_race));
+        }
+
+        if (botlist.empty())
+        {
+            handler->SendSysMessage(LANG_COMMAND_NOCREATUREFOUND);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        botlist.sort(&script_bot_commands::sortbots);
+
+        for (BotList::const_iterator itr = botlist.begin(); itr != botlist.end(); ++itr)
+        {
+            uint32 id = itr->id;
+            char const* name = itr->name.c_str();
+            uint8 race = itr->race;
+
+            char const* raceName;
+            switch (race)
+            {
+                case RACE_HUMAN:        raceName = "Human";     break;
+                case RACE_ORC:          raceName = "Orc";       break;
+                case RACE_DWARF:        raceName = "Dwarf";     break;
+                case RACE_NIGHTELF:     raceName = "Night Elf"; break;
+                case RACE_UNDEAD_PLAYER:raceName = "Forsaken";  break;
+                case RACE_TAUREN:       raceName = "Tauren";    break;
+                case RACE_GNOME:        raceName = "Gnome";     break;
+                case RACE_TROLL:        raceName = "Troll";     break;
+                case RACE_BLOODELF:     raceName = "Blood Elf"; break;
+                case RACE_DRAENEI:      raceName = "Draenei";   break;
+                default:                raceName = "Unknown";   break;
+            }
+
+            handler->PSendSysMessage("%d - |cffffffff|Hcreature_entry:%d|h[%s]|h|r %s", id, id, name, raceName);
+        }
+
+        return true;
+    }
+
+    static bool HandleNpcBotDeleteCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot)
+        {
+            handler->SendSysMessage(".npcbot delete");
+            handler->SendSysMessage("Deletes selected npcbot spawn from world and DB");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->IsNPCBot())
+        {
+            handler->SendSysMessage("No npcbot selected");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player const* botowner = bot->GetBotOwner()->ToPlayer())
+            botowner->GetBotMgr()->RemoveBot(bot->GetGUID(), BOT_REMOVE_DISMISS);
+
+        uint32 id = bot->GetEntry();
+
+        NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(id);
+        ASSERT(npcBotData);
+
+        bool found = false;
+        for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            if (npcBotData->equips[i])
+            {
+                found = true;
+                break;
+            }
+        }
+        if (found)
+        {
+            handler->PSendSysMessage("%s still has eqipment assigned. Please remove equips before deleting bot!", bot->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        bot->CombatStop();
+        bot->DeleteFromDB();
+        bot->AddObjectToRemoveList();
+
+        BotDataMgr::UpdateNpcBotData(id, NPCBOT_UPDATE_ERASE);
+
+        handler->SendSysMessage("Npcbot successfully deleted.");
+        return true;
+    }
+
+    static bool HandleNpcBotSpawnCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+        {
+            handler->SendSysMessage(".npcbot spawn");
+            handler->SendSysMessage("Adds new npcbot spawn of given entry in world. You can shift-link the npc");
+            handler->SendSysMessage("Syntax: .npcbot spawn #entry");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* charID = handler->extractKeyFromLink((char*)args, "Hcreature_entry");
+        if (!charID)
+            return false;
+
+        uint32 id = atoi(charID);
+
+        CreatureTemplate const* creInfo = sObjectMgr->GetCreatureTemplate(id);
+
+        if (!creInfo)
+        {
+            handler->PSendSysMessage("creature %u does not exist!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!(creInfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT) || creInfo->Entry >= 70350) //todo: condition for pets
+        {
+            handler->PSendSysMessage("creature %u is not a npcbot!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (BotDataMgr::SelectNpcBotData(id))
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `characters_npcbot` table!", id);
+            handler->SendSysMessage("If you want to move this bot to a new location use '.npc move' command");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_CREATURE_BY_ID);
+        //"SELECT guid FROM creature WHERE id = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res2 = WorldDatabase.Query(stmt);
+        if (res2)
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `creature` table!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* chr = handler->GetSession()->GetPlayer();
+
+        if (Transport* trans = chr->GetTransport())
+        {
+            handler->SendSysMessage("Cannot spawn bots on transport!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        float x = chr->GetPositionX();
+        float y = chr->GetPositionY();
+        float z = chr->GetPositionZ();
+        float o = chr->GetOrientation();
+        Map* map = chr->GetMap();
+
+        if (map->Instanceable())
+        {
+            handler->SendSysMessage("Cannot spawn bots in instances!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* creature = new Creature();
+        if (!creature->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), map, chr->GetPhaseMaskForSpawn(), id, 0, (uint32)0, x, y, z, o))
+        {
+            delete creature;
+            handler->SendSysMessage("Creature is not created!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint16 roleMask = BOT_ROLE_DPS;
+
+        uint8 m_class = creature->GetCreatureTemplate()->trainer_class;
+        if (!(m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE ||
+            m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT ||
+            m_class == CLASS_SHAMAN || m_class == BOT_CLASS_BM))
+            roleMask |= BOT_ROLE_RANGED;
+        if (m_class == CLASS_PRIEST || m_class == CLASS_DRUID ||
+            m_class == CLASS_SHAMAN || m_class == CLASS_PALADIN)
+            roleMask |= BOT_ROLE_HEAL;
+
+        BotDataMgr::AddNpcBotData(id, roleMask, creature->GetCreatureTemplate()->faction_A);
+
+        creature->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), chr->GetPhaseMaskForSpawn());
+
+        uint32 db_guid = creature->GetDBTableGUIDLow();
+        if (!creature->LoadBotCreatureFromDB(db_guid, map))
+        {
+            handler->SendSysMessage("Cannot load npcbot from DB!");
+            handler->SetSentErrorMessage(true);
+            //return false;
+            delete creature;
+            return false;
+        }
+
+        sObjectMgr->AddCreatureToGrid(db_guid, sObjectMgr->GetCreatureData(db_guid));
+
+        handler->SendSysMessage("Npcbot successfully spawned.");
+        return true;
+    }
+
+    static bool HandleNpcBotInfoCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->GetTarget())
+        {
+            handler->SendSysMessage(".npcbot info");
+            handler->SendSysMessage("Lists NpcBots count of each class owned by selected player. You can use this on self and your party members");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* master = owner->GetSelectedPlayer();
+        if (!master)
+        {
+            handler->SendSysMessage("No player selected.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (handler->HasLowerSecurity(master, 0))
+        {
+            handler->SendSysMessage("Invalid target");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!master->HaveBot())
+        {
+            handler->PSendSysMessage("%s has no NpcBots!", master->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Listing NpcBots for %s", master->GetName().c_str());
+        handler->PSendSysMessage("Owned NpcBots: %u", master->GetNpcBotsCount());
+        for (uint8 i = BOT_CLASS_WARRIOR; i != BOT_CLASS_END; ++i)
+        {
+            uint8 count = 0;
+            uint8 alivecount = 0;
+            BotMap const* map = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                if (Creature* cre = itr->second)
+                {
+                    if (cre->GetBotClass() == i)
+                    {
+                        ++count;
+                        if (cre->IsAlive())
+                            ++alivecount;
+                    }
+                }
+            }
+            if (count == 0)
+                continue;
+
+            char const* bclass;
+            if (i >= BOT_CLASS_EX_START)
+            {
+                switch (i)
+                {
+                    //|cffe6cc80|hxxx|h|r
+                    case BOT_CLASS_BM:              bclass = "|cff9d9d9d|hHas Blademaster!|h|r";    break;
+                    default:                        bclass = "wtf";                                 break;
+                }
+                handler->PSendSysMessage("%s (alive: %s)", bclass, (alivecount ? "yes" : "no"));
+            }
+            else
+            {
+                switch (i)
+                {
+                    case BOT_CLASS_WARRIOR:         bclass = "Warriors";        break;
+                    case BOT_CLASS_PALADIN:         bclass = "Paladins";        break;
+                    case BOT_CLASS_MAGE:            bclass = "Mages";           break;
+                    case BOT_CLASS_PRIEST:          bclass = "Priests";         break;
+                    case BOT_CLASS_WARLOCK:         bclass = "Warlocks";        break;
+                    case BOT_CLASS_DRUID:           bclass = "Druids";          break;
+                    case BOT_CLASS_DEATH_KNIGHT:    bclass = "Death Knights";   break;
+                    case BOT_CLASS_ROGUE:           bclass = "Rogues";          break;
+                    case BOT_CLASS_SHAMAN:          bclass = "Shamans";         break;
+                    case BOT_CLASS_HUNTER:          bclass = "Hunters";         break;
+                    default:                        bclass = "Unknown Class";   break;
+                }
+                handler->PSendSysMessage("%s: %u (alive: %u)", bclass, count, alivecount);
+            }
+        }
+        return true;
+    }
+
+    static bool HandleNpcBotCommandCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            handler->SendSysMessage(".npcbot command #[ stand | follow ]");
+            handler->SendSysMessage("Forces npcbots to either follow you or hold position.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* command = strtok((char*)args, " ");
+        int8 state = -1;
+        if (!strncmp(command, "s", 2) || !strncmp(command, "st", 3) || !strncmp(command, "stay", 5) ||
+            !strncmp(command, "stop", 5) || !strncmp(command, "stand", 6))
+            state = COMMAND_STAY;
+        else if (!strncmp(command, "f", 2) || !strncmp(command, "follow", 7) || !strncmp(command, "fol", 4) || !strncmp(command, "fo", 3))
+            state = COMMAND_FOLLOW;
+        if (state >= 0 && owner->HaveBot())
+        {
+            owner->GetBotMgr()->SendBotCommandState(CommandStates(state));
+            std::ostringstream msg;
+            msg << "Bot command state set to '";
+            switch (state)
+            {
+                case 0:  msg << "STAY";    break;
+                case 1:  msg << "FOLLOW";  break;
+                default: msg << "unknown"; break;
+            }
+            msg << "'.";
+            handler->SendSysMessage(msg.str().c_str());
+            return true;
+        }
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotRemoveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* u = owner->GetSelectedUnit();
+        if (!u)
+        {
+            handler->SendSysMessage(".npcbot remove");
+            handler->SendSysMessage("Frees selected npcbot from it's owner. Select player to remove all npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* master = u->ToPlayer();
+        if (master)
+        {
+            if (master->HaveBot())
+            {
+                master->RemoveAllBots(BOT_REMOVE_DISMISS);
+
+                if (!master->HaveBot())
+                {
+                    handler->SendSysMessage("Npcbots were successfully removed");
+                    handler->SetSentErrorMessage(true);
+                    return true;
+                }
+                handler->SendSysMessage("Some npcbots were not removed!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->SendSysMessage("Npcbots are not found!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* cre = u->ToCreature();
+        if (cre && cre->GetIAmABot() && !cre->IsFreeBot())
+        {
+            master = cre->GetBotOwner();
+            master->GetBotMgr()->RemoveBot(cre->GetGUID(), BOT_REMOVE_DISMISS);
+            if (master->GetBotMgr()->GetBot(cre->GetGUID()) == NULL)
+            {
+                handler->SendSysMessage("NpcBot successfully removed");
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->SendSysMessage("NpcBot was NOT removed for some stupid reason!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->SendSysMessage("You must select player or controlled npcbot");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotReviveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* u = owner->GetSelectedUnit();
+        if (!u)
+        {
+            handler->SendSysMessage(".npcbot revive");
+            handler->SendSysMessage("Revives selected npcbot. If player is selected, revives all selected player's npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player* master = u->ToPlayer())
+        {
+            if (!master->HaveBot())
+            {
+                handler->SendSysMessage("%s has no npcbots!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+
+            master->GetBotMgr()->ReviveAllBots();
+            handler->SendSysMessage("Npcbots revived.");
+            return true;
+        }
+        else if (Creature* bot = u->ToCreature())
+        {
+            if (bot->GetBotAI())
+            {
+                BotMgr::ReviveBot(bot);
+                handler->PSendSysMessage("%s revived.", bot->GetName().c_str());
+                return true;
+            }
+        }
+
+        handler->SendSysMessage("You must select player or npcbot.");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotAddCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* cre = owner->GetSelectedUnit();
+
+        if (!cre || cre->GetTypeId() != TYPEID_UNIT)
+        {
+            handler->SendSysMessage(".npcbot add");
+            handler->SendSysMessage("Allows to hire selected uncontrolled bot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = cre->ToCreature();
+        if (!bot || !bot->GetIAmABot() || bot->GetBotAI()->GetBotOwnerGuid())
+        {
+            handler->SendSysMessage("You must select uncontrolled npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        BotMgr* mgr = owner->GetBotMgr();
+        if (!mgr)
+            mgr = new BotMgr(owner);
+
+        if (mgr->AddBot(bot) == BOT_ADD_SUCCESS)
+        {
+            handler->PSendSysMessage("%s is now your npcbot", bot->GetName().c_str());
+            return true;
+        }
+
+        handler->SendSysMessage("NpcBot is NOT added for some reason!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+};
+
+void AddSC_script_bot_commands()
+{
+    new script_bot_commands();
+}
diff --git a/src/server/game/AI/NpcBots/botcommon.h b/src/server/game/AI/NpcBots/botcommon.h
new file mode 100644
index 0000000..b5831c2
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommon.h
@@ -0,0 +1,401 @@
+#ifndef _BOTCOMMON_H
+#define _BOTCOMMON_H
+
+/*
+NpcBot System by Trickerer (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+*/
+
+enum CommonValues
+{
+//MISC
+    BOT_ENTRY_BEGIN                     = 70001,
+    BOT_ENTRY_END                       = 71000,
+    BOT_ICON_ON                         = 9,    //GOSSIP_ICON_BATTLE,
+    BOT_ICON_OFF                        = 7,    //GOSSIP_ICON_TALK,
+    BOT_MAX_CHASE_RANGE                 = 120,  //yds
+    //BOT_EVADE_TIME                      = 3000, //ms
+//COMMON SPELLS
+    MANAPOTION                          = 32453,//"Uses a Holy elixir to heal the caster for 32000"
+    HEALINGPOTION                       = 15504,//"Drinks Holy Elixir to heal the caster"
+    PVPTRINKET                          = 42292,//PvP Trinket no CD
+    BERSERK                             = 46587,//68378,//900%/150%
+///Racials
+    RACIAL_EVERY_MAN_FOR_HIMSELF        = 59752,//pvp trinket effect, instant, 2 min cd
+    RACIAL_BLOOD_FURY_WARLOCK           = 33702,//effect varies, 15 sec, 2 min cd
+    RACIAL_BLOOD_FURY_SHAMAN            = 33697,
+    RACIAL_BLOOD_FURY_OTHERS            = 20572,
+    RACIAL_STONEFORM                    = 20594,//dispell disease, poison, bleed, instant, 2 min cd
+    //RACIAL_FIND_TREASURE                = 2481,
+    RACIAL_SHADOWMELD                   = 58984,//stealth, -threat, instant, 2 min cd
+    RACIAL_WILL_OF_THE_FORSAKEN         = 7744,//dispel charm/fear/sleep, instant, 2 min cd, 45 sec category cd
+    RACIAL_WARSTOMP                     = 20549,//2sec stun, casttime 500, 8yd, 2 min cd
+    RACIAL_ESCAPE_ARTIST                = 20589,//dispel snare/root, instant, 1 min 45 sec cd
+    RACIAL_BERSERKING                   = 26297,//haste all 20%, isntant, 3 min cd
+    RACIAL_ARCANE_TORRENT_DEATHKNIGHT   = 50613,//2sec AoE silence + energize, instant, 2 min cd
+    RACIAL_ARCANE_TORRENT_ROGUE         = 25046,
+    RACIAL_ARCANE_TORRENT_OTHERS        = 28730,
+    RACIAL_GIFT_OF_NAARU_WARRIOR        = 28880,//Hot over 15 sec, instant, 2 min cd
+    RACIAL_GIFT_OF_NAARU_PALADIN        = 59542,
+    RACIAL_GIFT_OF_NAARU_HUNTER         = 59543,
+    RACIAL_GIFT_OF_NAARU_PRIEST         = 59544,
+    RACIAL_GIFT_OF_NAARU_DEATHKNIGHT    = 59545,
+    RACIAL_GIFT_OF_NAARU_SHAMAN         = 59547,
+    RACIAL_GIFT_OF_NAARU_MAGE           = 59548,
+//COMMON CDs
+    POTION_CD                           = 60000,//default 60sec potion cd
+    REGEN_CD                            = 2000, //update hp/mana every X milliseconds
+//COMMON TIMERS
+    ITEM_ENCHANTMENT_EXPIRE_TIMER       = 1 * HOUR * IN_MILLISECONDS,
+//COMMON PASSIVES
+    DAMAGE_REDUCTION                    = 68066,//Vigilance, Blessing of Sanctuary, etc.
+//COMMON GOSSIPS
+    GOSSIP_SERVE_MASTER                 = 70001, //"I live only to serve the master."
+    GOSSIP_NEED_SMTH                    = 70002, //"You need something?"
+    GOSSIP_MURDER                       = 70003,//"Mortals... usually I kill wretches like you at sight"
+    GOSSIP_CLASS_BM                     = 70004,
+    GOSSIP_SENDER_BEGIN                 = 6000,
+    GOSSIP_SENDER_CLASS,
+    GOSSIP_SENDER_CLASS_ACTION,
+    GOSSIP_SENDER_CLASS_ACTION2,
+    GOSSIP_SENDER_CLASS_ACTION3,
+    GOSSIP_SENDER_EQUIPMENT,
+    GOSSIP_SENDER_EQUIPMENT_LIST,
+    GOSSIP_SENDER_EQUIPMENT_SHOW,
+    GOSSIP_SENDER_EQUIPMENT_INFO,
+    GOSSIP_SENDER_UNEQUIP,
+    GOSSIP_SENDER_UNEQUIP_ALL,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BEGIN           = GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_MHAND           = GOSSIP_SENDER_EQUIP_AUTOEQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_NECK,
+    GOSSIP_SENDER_EQUIP_RESET,
+    GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_BEGIN           = GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_MHAND           = GOSSIP_SENDER_EQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_NECK,
+    GOSSIP_SENDER_ROLES_MAIN,
+    GOSSIP_SENDER_ROLES_MAIN_TOGGLE,
+    GOSSIP_SENDER_ROLES_GATHERING,
+    GOSSIP_SENDER_ROLES_GATHERING_TOGGLE,
+    GOSSIP_SENDER_ABILITIES,
+    GOSSIP_SENDER_ABILITIES_USE,
+    GOSSIP_SENDER_ABILITIES_SPECIFICS_LIST,
+    GOSSIP_SENDER_ABILITIES_USAGE_LIST,
+    GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE,
+    GOSSIP_SENDER_USEITEM,
+    GOSSIP_SENDER_USEITEM_USE,
+    GOSSIP_SENDER_HIRE,
+    GOSSIP_SENDER_DISMISS,
+    GOSSIP_SENDER_JOIN_GROUP,
+    GOSSIP_SENDER_LEAVE_GROUP,
+    GOSSIP_SENDER_FORMATION,
+    GOSSIP_SENDER_FORMATION_DISTANCE,
+    GOSSIP_SENDER_TROUBLESHOOTING,
+    GOSSIP_SENDER_TROUBLESHOOTING_FIX,
+    GOSSIP_SENDER_TROUBLESHOOTING_AURA,
+    GOSSIP_SENDER_SCAN,
+    GOSSIP_SENDER_SCAN_OWNER,
+    GOSSIP_SENDER_SCAN_OWNER_ABILITY,
+    GOSSIP_SENDER_DEBUG,
+    GOSSIP_SENDER_DEBUG_ACTION,
+//GOSSIP CONST
+    BOT_GOSSIP_MAX_ITEMS                = 32, // Client limitation 3.3.5 code confirmed
+//COMMON NPCS
+    SHAMAN_EARTH_ELEMENTAL              = 15352,
+    SHAMAN_FIRE_ELEMENTAL               = 15438,
+    //NPC_WORLD_TRIGGER                   = 22515,
+//COMMON GAMEEVENTS
+    GAME_EVENT_WINTER_VEIL              = 2,
+//COMMON MOUNTS SPELLS
+    REINDEER                            = 25859,
+    REINDEER_FLY                        = 44827,
+//COMMON AI MISC VALUES
+    BOTAI_MISC_COMBO_POINTS             = 1,
+    BOTAI_MISC_DAGGER_MAINHAND          = 2,
+    BOTAI_MISC_DAGGER_OFFHAND           = 3,
+    BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH    = 4,
+    BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH    = 5,
+    BOTAI_MISC_ENCHANT_CURRENT_MH       = 6,
+    BOTAI_MISC_ENCHANT_CURRENT_OH       = 7,
+    BOTAI_MISC_ENCHANT_AVAILABLE_1      = 8,
+    BOTAI_MISC_ENCHANT_AVAILABLE_2      = 9,
+    BOTAI_MISC_ENCHANT_AVAILABLE_3      = 10,
+    BOTAI_MISC_ENCHANT_AVAILABLE_4      = 11,
+    BOTAI_MISC_ENCHANT_AVAILABLE_5      = 12,
+    BOTAI_MISC_ENCHANT_AVAILABLE_6      = 13,
+//ADVANCED
+    HONORLESS_TARGET                    = 2479,
+    COSMETIC_TELEPORT_EFFECT            = 52096,//visual instant cast omni
+    //COSMETIC_SMOKING_CORPSE_AURA        = 51201,//black model + fire step (permanent)
+
+////CUSTOM SPELLS
+//ARCHMAGE
+  //modify
+/**/BLIZZARD_VISUAL_PERSISTENT_AURA     = 34167,
+    BLIZZARD_VISUAL_PROC                = 29969,
+
+//BLADEMASTER
+/**/ //- used explicitly within the script
+  //SPELLS
+  //unmodify
+    //SPELL_DEATH_GRIP_JUMP               = 49575,
+/**/SPELL_CRITICAL_STRIKE               = 1132,
+    SPELL_BURNING_BLADE_BLADEMASTER     = 32281,//horde flag visual
+    //SPELL_POSESS                        = 17250,//immunity,invis,stun
+    //SPELL_SELFSTUN                      = 24883,//green smoke, transparency, stun
+    SPELL_STUN_FREEZE_ANIM              = 59123,//stun forever, full stop
+  //modify
+    SPELL_TRANSPARENCY_50               = 44816,
+/**/SPELL_NETHERWALK                    = 31599,
+/**/SPELL_MIRROR_IMAGE_BM               = 69936,//blank spell
+  //SOUNDS
+    SOUND_FREEZE_IMPACT_WINDWALK        = 29,
+    SOUND_AXE_2H_IMPACT_FLESH_CRIT      = 158,
+    SOUND_ABSORB_GET_HIT                = 3334,
+    SOUND_MISS_WHOOSH_2H                = 7081,
+
+//OTHER
+    //MAX_LOOT_ITEMS                      = 18,// Client limitation 3.3.5 code confirmed
+  //unmodify
+    SPELL_VERTEX_COLOR_BLACK            = 39662,//black color model full
+    //SPELL_NIGHTMARE_VULNERABILITY       = 54199,//100% dmg taken, 100% crit chance taken (x4 dmg taken)
+  //modify
+    SPELL_COMBAT_SPECIAL_2H_ATTACK      = 44079 //animation only
+};
+
+enum BotClasses
+{
+    BOT_CLASS_NONE                      = CLASS_NONE,
+    BOT_CLASS_WARRIOR                   = CLASS_WARRIOR,
+    BOT_CLASS_PALADIN                   = CLASS_PALADIN,
+    BOT_CLASS_HUNTER                    = CLASS_HUNTER,
+    BOT_CLASS_ROGUE                     = CLASS_ROGUE,
+    BOT_CLASS_PRIEST                    = CLASS_PRIEST,
+    BOT_CLASS_DEATH_KNIGHT              = CLASS_DEATH_KNIGHT,
+    BOT_CLASS_SHAMAN                    = CLASS_SHAMAN,
+    BOT_CLASS_MAGE                      = CLASS_MAGE,
+    BOT_CLASS_WARLOCK                   = CLASS_WARLOCK,
+    BOT_CLASS_DRUID                     = CLASS_DRUID,
+
+    BOT_CLASS_BM,
+    BOT_CLASS_END
+};
+
+#define BOT_CLASS_EX_START BOT_CLASS_BM
+
+enum BotStances
+{
+    BOT_STANCE_NONE                     = 0,
+    WARRIOR_BATTLE_STANCE               = BOT_CLASS_END,
+    WARRIOR_DEFENSIVE_STANCE,
+    WARRIOR_BERSERKER_STANCE,
+    DEATH_KNIGHT_BLOOD_PRESENCE,
+    DEATH_KNIGHT_FROST_PRESENCE,
+    DEATH_KNIGHT_UNHOLY_PRESENCE,
+    DRUID_BEAR_FORM,
+    DRUID_CAT_FORM,
+    DRUID_MOONKIN_FORM,
+    DRUID_TREE_FORM,
+    DRUID_TRAVEL_FORM,
+    DRUID_AQUATIC_FORM,
+    //DRUID_FLIGHT_FORM //NYI
+};
+
+enum BotRoles
+{
+    BOT_ROLE_NONE                       = 0x000,
+    BOT_ROLE_TANK                       = 0x001,
+    BOT_ROLE_DPS                        = 0x002,
+    BOT_ROLE_HEAL                       = 0x004,
+    BOT_ROLE_RANGED                     = 0x008,
+
+    BOT_ROLE_PARTY                      = 0x010, //hidden
+
+    BOT_ROLE_GATHERING_MINING           = 0x020,
+    BOT_ROLE_GATHERING_HERBALISM        = 0x040,
+    BOT_ROLE_GATHERING_SKINNING         = 0x080,
+    BOT_ROLE_GATHERING_ENGINEERING      = 0x100,
+
+    BOT_MAX_ROLE                        = 0x200,
+
+    BOT_ROLE_MASK_MAIN                  = (BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_HEAL | BOT_ROLE_RANGED),
+    //BOT_ROLE_MASK_MAIN_EX               = (BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_HEAL | BOT_ROLE_RANGED | BOT_ROLE_PARTY),
+    BOT_ROLE_MASK_GATHERING             = (BOT_ROLE_GATHERING_MINING | BOT_ROLE_GATHERING_HERBALISM | BOT_ROLE_GATHERING_SKINNING | BOT_ROLE_GATHERING_ENGINEERING),
+
+    //BOT_ROLE_TANK_MELEE                 = (BOT_ROLE_TANK | BOT_ROLE_DPS),
+    //BOT_ROLE_TANK_RANGED                = (BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_RANGED),
+    //BOT_ROLE_TANK_RANGED_NODPS          = (BOT_ROLE_TANK | BOT_ROLE_RANGED),
+};
+
+enum BotPetTypes
+{
+    PET_TYPE_NONE,
+//Warlock
+    PET_TYPE_IMP,
+    PET_TYPE_VOIDWALKER,
+    PET_TYPE_SUCCUBUS,
+    PET_TYPE_FELHUNTER,
+    PET_TYPE_FELGUARD,
+//Mage
+    //PET_TYPE_WATER_ELEMENTAL,
+//Shaman
+    //PET_TYPE_GHOSTLY_WOLF,
+//Hunter
+    //PET_TYPE_VULTURE,
+
+    MAX_PET_TYPES
+};
+
+enum WarlockBotPets
+{
+    //PET_IMP                     = ,
+    PET_VOIDWALKER              = 70247
+    //PET_SUCCUBUS                =
+};
+
+enum HunterBotPets
+{
+    //PET_VULTURE                 = 70248
+};
+
+enum BotPetsOriginalEntries
+{
+    ORIGINAL_ENTRY_IMP          = 416, //NYI
+    ORIGINAL_ENTRY_VOIDWALKER   = 1860, //NYI
+    ORIGINAL_ENTRY_SUCCUBUS     = 1863, //NYI
+    ORIGINAL_ENTRY_FELHUNTER    = 417, //NYI
+    ORIGINAL_ENTRY_FELGUARD     = 17252 //NYI
+};
+
+enum BotEquipSlot
+{
+    BOT_SLOT_MAINHAND           = 0,
+    BOT_SLOT_OFFHAND            = 1,
+    BOT_SLOT_RANGED             = 2,
+    BOT_SLOT_HEAD               = 3,
+    BOT_SLOT_SHOULDERS          = 4,
+    BOT_SLOT_CHEST              = 5,
+    BOT_SLOT_WAIST              = 6,
+    BOT_SLOT_LEGS               = 7,
+    BOT_SLOT_FEET               = 8,
+    BOT_SLOT_WRIST              = 9,
+    BOT_SLOT_HANDS              = 10,
+    BOT_SLOT_BACK               = 11,
+    BOT_SLOT_BODY               = 12,
+    BOT_SLOT_FINGER1            = 13,
+    BOT_SLOT_FINGER2            = 14,
+    BOT_SLOT_TRINKET1           = 15,
+    BOT_SLOT_TRINKET2           = 16,
+    BOT_SLOT_NECK               = 17,
+    BOT_INVENTORY_SIZE
+};
+
+enum BotStatMods
+{
+    //ItemProtoType.h
+    BOT_STAT_MOD_MANA                       = 0,
+    BOT_STAT_MOD_HEALTH                     = 1,
+    BOT_STAT_MOD_AGILITY                    = 3,
+    BOT_STAT_MOD_STRENGTH                   = 4,
+    BOT_STAT_MOD_INTELLECT                  = 5,
+    BOT_STAT_MOD_SPIRIT                     = 6,
+    BOT_STAT_MOD_STAMINA                    = 7,
+    BOT_STAT_MOD_DEFENSE_SKILL_RATING       = 12,
+    BOT_STAT_MOD_DODGE_RATING               = 13,
+    BOT_STAT_MOD_PARRY_RATING               = 14,
+    BOT_STAT_MOD_BLOCK_RATING               = 15,
+    BOT_STAT_MOD_HIT_MELEE_RATING           = 16,
+    BOT_STAT_MOD_HIT_RANGED_RATING          = 17,
+    BOT_STAT_MOD_HIT_SPELL_RATING           = 18,
+    BOT_STAT_MOD_CRIT_MELEE_RATING          = 19,
+    BOT_STAT_MOD_CRIT_RANGED_RATING         = 20,
+    BOT_STAT_MOD_CRIT_SPELL_RATING          = 21,
+    BOT_STAT_MOD_HIT_TAKEN_MELEE_RATING     = 22,
+    BOT_STAT_MOD_HIT_TAKEN_RANGED_RATING    = 23,
+    BOT_STAT_MOD_HIT_TAKEN_SPELL_RATING     = 24,
+    BOT_STAT_MOD_CRIT_TAKEN_MELEE_RATING    = 25,
+    BOT_STAT_MOD_CRIT_TAKEN_RANGED_RATING   = 26,
+    BOT_STAT_MOD_CRIT_TAKEN_SPELL_RATING    = 27,
+    BOT_STAT_MOD_HASTE_MELEE_RATING         = 28,
+    BOT_STAT_MOD_HASTE_RANGED_RATING        = 29,
+    BOT_STAT_MOD_HASTE_SPELL_RATING         = 30,
+    BOT_STAT_MOD_HIT_RATING                 = 31,
+    BOT_STAT_MOD_CRIT_RATING                = 32,
+    BOT_STAT_MOD_HIT_TAKEN_RATING           = 33,
+    BOT_STAT_MOD_CRIT_TAKEN_RATING          = 34,
+    BOT_STAT_MOD_RESILIENCE_RATING          = 35,
+    BOT_STAT_MOD_HASTE_RATING               = 36,
+    BOT_STAT_MOD_EXPERTISE_RATING           = 37,
+    BOT_STAT_MOD_ATTACK_POWER               = 38,
+    BOT_STAT_MOD_RANGED_ATTACK_POWER        = 39,
+    BOT_STAT_MOD_FERAL_ATTACK_POWER         = 40,
+    BOT_STAT_MOD_SPELL_HEALING_DONE         = 41,                 // deprecated
+    BOT_STAT_MOD_SPELL_DAMAGE_DONE          = 42,                 // deprecated
+    BOT_STAT_MOD_MANA_REGENERATION          = 43,
+    BOT_STAT_MOD_ARMOR_PENETRATION_RATING   = 44,
+    BOT_STAT_MOD_SPELL_POWER                = 45,
+    BOT_STAT_MOD_HEALTH_REGEN               = 46,
+    BOT_STAT_MOD_SPELL_PENETRATION          = 47,
+    BOT_STAT_MOD_BLOCK_VALUE                = 48,
+    //END ItemProtoType.h
+
+    BOT_STAT_MOD_DAMAGE_MIN                 = MAX_ITEM_MOD,
+    BOT_STAT_MOD_DAMAGE_MAX,
+    BOT_STAT_MOD_ARMOR,
+    BOT_STAT_MOD_RESIST_HOLY,
+    BOT_STAT_MOD_RESIST_FIRE,
+    BOT_STAT_MOD_RESIST_NATURE,
+    BOT_STAT_MOD_RESIST_FROST,
+    BOT_STAT_MOD_RESIST_SHADOW,
+    BOT_STAT_MOD_RESIST_ARCANE,
+    BOT_STAT_MOD_EX,
+    MAX_BOT_ITEM_MOD,
+
+    BOT_STAT_MOD_RESISTANCE_START = BOT_STAT_MOD_ARMOR
+};
+
+enum BotAIResetType
+{
+    BOTAI_RESET_INIT                    = 0x01,
+    BOTAI_RESET_DISMISS                 = 0x02,
+    BOTAI_RESET_LOST                    = 0x04,
+    BOTAI_RESET_LOGOUT                  = 0x08,
+
+    BOTAI_RESET_MASK_ABANDON_MASTER     = (BOTAI_RESET_INIT | BOTAI_RESET_DISMISS)
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/botdatamgr.cpp b/src/server/game/AI/NpcBots/botdatamgr.cpp
new file mode 100644
index 0000000..c6d8e34
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdatamgr.cpp
@@ -0,0 +1,294 @@
+#include "botdatamgr.h"
+/*
+Npc Bot Data Manager by Trickerer (onlysuffering@gmail.com)
+NpcBots DB Data management
+%Complete: ???
+*/
+
+typedef UNORDERED_MAP<uint32 /*entry*/, NpcBotData* /*botData*/> NpcBotDataMap;
+NpcBotDataMap _botsData;
+
+bool allBotsLoaded = false;
+
+//BotDataMgr::~BotDataMgr()
+//{
+//    while (!_botsData.empty())
+//    {
+//        NpcBotData* ndata = _botsData.begin()->second;
+//        _botsData.erase(_botsData.begin());
+//        delete ndata;
+//    }
+//}
+
+void BotDataMgr::LoadNpcBots()
+{
+    uint32 botoldMSTime = getMSTime();
+
+    //                                                     1      2      3       4        5          6          7            8            9             10         11          12        13
+    QueryResult result = CharacterDatabase.Query("SELECT entry, owner, roles, faction, equipMhEx, equipOhEx, equipRhEx, equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet,"
+    //       14          15         16         17          18             19             20            21            22
+        "equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck FROM characters_npcbot");
+
+    if (!result)
+    {
+        TC_LOG_INFO("server.loading", ">> Spawned 0 npcbots. Table `characters_npcbot` is empty!");
+        return;
+    }
+
+    uint32 botcounter = 0;
+    uint32 datacounter = 0;
+    std::list<uint32> botgrids;
+    QueryResult infores;
+    Field* field;
+    CreatureTemplate const* proto;
+    NpcBotData* botData;
+    std::list<uint32> entryList;
+
+    do
+    {
+        field = result->Fetch();
+        uint8 index = 0;
+        uint32 entry = field[  index].GetUInt32();
+        entryList.push_back(entry);
+
+        //load data
+        botData = new NpcBotData(0, 0);
+        botData->owner =            field[++index].GetUInt32();
+        botData->roles =            field[++index].GetUInt16();
+        botData->faction =          field[++index].GetUInt32();
+
+        for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            botData->equips[i] = field[++index].GetUInt32();
+
+        _botsData[entry] = botData;
+        ++datacounter;
+
+    } while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u bot data entries", datacounter);
+
+    for (std::list<uint32>::const_iterator itr = entryList.begin(); itr != entryList.end(); ++itr)
+    {
+        uint32 entry = *itr;
+        proto = sObjectMgr->GetCreatureTemplate(entry);
+        if (!proto)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot find creature_template entry for npcbot (id: %u)!", entry);
+            continue;
+        }
+        //                                      1    2       3           4           5            6
+        infores = WorldDatabase.PQuery("SELECT guid, map, position_x, position_y"/*, position_z, orientation*/" FROM creature WHERE id = %u", entry);
+        if (!infores)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot spawn npcbot %s (id: %u), not found in `creature` table!", proto->Name.c_str(), entry);
+            continue;
+        }
+
+        field = infores->Fetch();
+        uint32 tableGuid = field[0].GetUInt32();
+        uint32 mapId = uint32(field[1].GetUInt16());
+        float pos_x = field[2].GetFloat();
+        float pos_y = field[3].GetFloat();
+        //float pos_z = field[4].GetFloat();
+        //float ori = field[5].GetFloat();
+
+        CellCoord c = Trinity::ComputeCellCoord(pos_x, pos_y);
+        GridCoord g = Trinity::ComputeGridCoord(pos_x, pos_y);
+        ASSERT(c.IsCoordValid() && "Invalid Cell coord!");
+        ASSERT(g.IsCoordValid() && "Invalid Grid coord!");
+        Map* map = sMapMgr->CreateBaseMap(mapId);
+        map->LoadGrid(pos_x, pos_y);
+        Creature* bot = map->GetCreature(MAKE_NEW_GUID(tableGuid, entry, HIGHGUID_UNIT));
+        ASSERT(bot);
+        //debug
+        //if (!bot->IsAlive())
+        //{
+        //    bot->Respawn();
+        //    bot->ResetBotAI(1);
+        //}
+
+        TC_LOG_DEBUG("server.loading", ">> Spawned npcbot %s (id: %u, map: %u, grid: %u, cell: %u)", proto->Name.c_str(), entry, mapId, g.GetId(), c.GetId());
+        botgrids.push_back(g.GetId());
+        ++botcounter;
+    }
+
+    botgrids.unique();
+    TC_LOG_INFO("server.loading", ">> Spawned %u npcbot(s) within %u grid(s) in %u ms", botcounter, botgrids.size(), GetMSTimeDiffToNow(botoldMSTime));
+
+    allBotsLoaded = true;
+}
+
+void BotDataMgr::AddNpcBotData(uint32 entry, uint16 roles, uint32 faction)
+{
+    //botData must be allocated explicitly
+    NpcBotDataMap::iterator itr = _botsData.find(entry);
+    if (itr == _botsData.end())
+    {
+        NpcBotData* botData = new NpcBotData(roles, faction);
+        _botsData[entry] = botData;
+
+        PreparedStatement* bstmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+        //"INSERT INTO characters_npcbot (entry, roles) VALUES (?, ?)", CONNECTION_ASYNCH
+        bstmt->setUInt32(0, entry);
+        bstmt->setUInt16(1, roles);
+        CharacterDatabase.Execute(bstmt);
+
+        //move this
+        BotDataMgr::UpdateNpcBotData(entry, NPCBOT_UPDATE_FACTION, &(botData->faction));
+        return;
+    }
+
+    TC_LOG_ERROR("sql.sql", "BotMgr::AddNpcBotData(): trying to add new data but entry already exists! entry = %u", entry);
+}
+NpcBotData const* BotDataMgr::SelectNpcBotData(uint32 entry)
+{
+    NpcBotDataMap::const_iterator itr = _botsData.find(entry);
+    return itr != _botsData.end() ? itr->second : NULL;
+}
+void BotDataMgr::UpdateNpcBotData(uint32 entry, NpcBotDataUpdateType updateType, void* data)
+{
+    NpcBotDataMap::iterator itr = _botsData.find(entry);
+    if (itr == _botsData.end())
+        return;
+
+    PreparedStatement* bstmt;
+    switch (updateType)
+    {
+        case NPCBOT_UPDATE_OWNER:
+            itr->second->owner = *(uint32*)(data);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+            //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+            bstmt->setUInt32(0, itr->second->owner);
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        case NPCBOT_UPDATE_ROLES:
+            itr->second->roles = *(uint16*)(data);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_ROLES);
+            //"UPDATE character_npcbot SET roles = ? WHERE entry = ?", CONNECTION_ASYNC
+            bstmt->setUInt16(0, itr->second->roles);
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        case NPCBOT_UPDATE_FACTION:
+            itr->second->faction = *(uint32*)(data);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_FACTION);
+            //"UPDATE characters_npcbot SET faction = ? WHERE entry = ?", CONNECTION_ASYNCH
+            bstmt->setUInt32(0, itr->second->faction);
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        case NPCBOT_UPDATE_EQUIPS:
+        {
+            Item** items = (Item**)(data);
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(entry, id);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_EQUIP);
+            //"UPDATE character_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?,
+            //equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE entry = ?", CONNECTION_ASYNC
+            PreparedStatement* stmt;
+            uint8 k;
+            for (k = BOT_SLOT_MAINHAND; k != BOT_INVENTORY_SIZE; ++k)
+            {
+                itr->second->equips[k] = items[k] ? items[k]->GetGUIDLow() : 0;
+                if (Item const* botitem = items[k])
+                {
+                    bool standard = false;
+                    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+                    {
+                        if (einfo->ItemEntry[i] == botitem->GetEntry())
+                        {
+                            itr->second->equips[k] = 0;
+                            bstmt->setUInt32(k, 0);
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+
+                    uint8 index = 0;
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_ITEM_INSTANCE);
+                    //REPLACE INTO item_instance (itemEntry, owner_guid, creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, guid)
+                    //VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC : 0-13
+                    stmt->setUInt32(  index, botitem->GetEntry());
+                    stmt->setUInt32(++index, GUID_LOPART(botitem->GetOwnerGUID()));
+                    stmt->setUInt32(++index, GUID_LOPART(botitem->GetUInt64Value(ITEM_FIELD_CREATOR)));
+                    stmt->setUInt32(++index, GUID_LOPART(botitem->GetUInt64Value(ITEM_FIELD_GIFTCREATOR)));
+                    stmt->setUInt32(++index, botitem->GetCount());
+                    stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_DURATION));
+
+                    std::ostringstream ssSpells;
+                    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                        ssSpells << botitem->GetSpellCharges(i) << ' ';
+                    stmt->setString(++index, ssSpells.str());
+
+                    stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_FLAGS));
+
+                    std::ostringstream ssEnchants;
+                    for (uint8 i = 0; i < MAX_ENCHANTMENT_SLOT; ++i)
+                    {
+                        ssEnchants << botitem->GetEnchantmentId(EnchantmentSlot(i)) << ' ';
+                        ssEnchants << botitem->GetEnchantmentDuration(EnchantmentSlot(i)) << ' ';
+                        ssEnchants << botitem->GetEnchantmentCharges(EnchantmentSlot(i)) << ' ';
+                    }
+                    stmt->setString(++index, ssEnchants.str());
+
+                    stmt->setInt16 (++index, botitem->GetItemRandomPropertyId());
+                    stmt->setUInt16(++index, botitem->GetUInt32Value(ITEM_FIELD_DURABILITY));
+                    stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME));
+                    stmt->setString(++index, botitem->GetText());
+                    stmt->setUInt32(++index, botitem->GetGUIDLow());
+
+                    trans->Append(stmt);
+
+                    Item::DeleteFromInventoryDB(trans, botitem->GetGUIDLow()); //prevent duplicates
+
+                    bstmt->setUInt32(k, botitem->GetGUIDLow());
+                }
+                else
+                    bstmt->setUInt32(k, uint32(0));
+            }
+
+            bstmt->setUInt32(k, entry);
+            trans->Append(bstmt);
+            CharacterDatabase.CommitTransaction(trans);
+            break;
+        }
+        case NPCBOT_UPDATE_ERASE:
+        {
+            NpcBotDataMap::iterator itr = _botsData.find(entry);
+            ASSERT(itr != _botsData.end());
+            delete itr->second;
+            _botsData.erase(itr);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT);
+            //"DELETE FROM characters_npcbot WHERE entry = ?", CONNECTION_ASYNC
+            bstmt->setUInt32(0, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        }
+    }
+}
+void BotDataMgr::UpdateNpcBotDataAll(uint32 playerGuid, NpcBotDataUpdateType updateType, void* data)
+{
+    PreparedStatement* bstmt;
+    switch (updateType)
+    {
+        case NPCBOT_UPDATE_OWNER:
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER_ALL);
+            //"UPDATE characters_npcbot SET owner = ? WHERE owner = ?", CONNECTION_ASYNC
+            bstmt->setUInt32(0, *(uint32*)(data));
+            bstmt->setUInt32(1, playerGuid);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        //case NPCBOT_UPDATE_ROLES:
+        //case NPCBOT_UPDATE_FACTION:
+        //case NPCBOT_UPDATE_EQUIPS:
+        default:
+            break;
+    }
+}
diff --git a/src/server/game/AI/NpcBots/botdatamgr.h b/src/server/game/AI/NpcBots/botdatamgr.h
new file mode 100644
index 0000000..9f73493
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdatamgr.h
@@ -0,0 +1,49 @@
+#ifndef _BOTDATAMGR_H
+#define _BOTDATAMGR_H
+
+#include "botcommon.h"
+
+enum NpcBotDataUpdateType
+{
+    NPCBOT_UPDATE_OWNER                 = 1,
+    NPCBOT_UPDATE_ROLES,
+    NPCBOT_UPDATE_FACTION,
+    NPCBOT_UPDATE_EQUIPS,
+    NPCBOT_UPDATE_ERASE,
+    NPCBOT_UPDATE_END
+};
+
+struct NpcBotData
+{
+    friend class BotDataMgr;
+public:
+    uint32 owner;
+    uint16 roles;
+    uint32 faction;
+    uint32 equips[BOT_INVENTORY_SIZE];
+
+private:
+    explicit NpcBotData(uint16 iroles, uint32 ifaction) : owner(0), roles(iroles), faction(ifaction)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            equips[i] = 0;
+    }
+    NpcBotData(NpcBotData const&);
+};
+
+class BotDataMgr
+{
+    public:
+        static void LoadNpcBots();
+
+        static void AddNpcBotData(uint32 entry, uint16 roles, uint32 faction);
+        static NpcBotData const* SelectNpcBotData(uint32 entry);
+        static void UpdateNpcBotData(uint32 entry, NpcBotDataUpdateType updateType, void* data = NULL);
+        static void UpdateNpcBotDataAll(uint32 playerGuid, NpcBotDataUpdateType updateType, void* data = NULL);
+    private:
+        BotDataMgr() {}
+        //~BotDataMgr();
+        BotDataMgr(BotDataMgr const&);
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/botmgr.cpp b/src/server/game/AI/NpcBots/botmgr.cpp
new file mode 100644
index 0000000..42572c2
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botmgr.cpp
@@ -0,0 +1,877 @@
+#include "bot_ai.h"
+#include "bot_Events.h"
+#include "botmgr.h"
+#include "botdatamgr.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GroupMgr.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "Language.h"
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "SpellAuras.h"
+/*
+Npc Bot Manager by Trickerer (onlysuffering@gmail.com)
+Player NpcBots management
+%Complete: ???
+*/
+
+//config
+uint8 _basefollowdist;
+uint8 _maxNpcBots;
+uint8 _maxClassNpcBots;
+uint8 _xpReductionNpcBots;
+uint8 _healTargetIconFlags;
+uint32 _npcBotsCost;
+bool _enableNpcBots;
+bool _enableNpcBotsDungeons;
+bool _enableNpcBotsRaids;
+bool _enableNpcBotsBGs;
+bool _enableNpcBotsArenas;
+bool _enableDungeonFinder;
+bool _limitNpcBotsDungeons;
+bool _limitNpcBotsRaids;
+bool _botPvP;
+float _mult_dmg_melee;
+float _mult_dmg_spell;
+float _mult_healing;
+
+bool __firstload = true;
+
+BotMgr::BotMgr(Player* const master) : _owner(master)
+{
+    //LoadConfig(); already loaded (MapManager.cpp)
+    _followdist = _basefollowdist;
+    _botsHidden = false;
+
+    master->SetBotMgr(this);
+}
+BotMgr::~BotMgr() { }
+
+void BotMgr::Initialize()
+{
+    LoadConfig();
+
+    if (!_enableNpcBots)
+        return;
+
+    TC_LOG_INFO("server.loading", "Starting NpcBot system...");
+    BotDataMgr::LoadNpcBots();
+}
+
+void BotMgr::LoadConfig(bool force)
+{
+    if (__firstload)
+        __firstload = false;
+    else if (!force)
+        return;
+
+    _enableNpcBots          = sConfigMgr->GetBoolDefault("NpcBot.Enable", true);
+    _maxNpcBots             = sConfigMgr->GetIntDefault("NpcBot.MaxBots", 1);
+    _maxClassNpcBots        = sConfigMgr->GetIntDefault("NpcBot.MaxBotsPerClass", 1);
+    _basefollowdist         = sConfigMgr->GetIntDefault("NpcBot.BaseFollowDistance", 30);
+    _xpReductionNpcBots     = sConfigMgr->GetIntDefault("NpcBot.XpReduction", 0);
+    _healTargetIconFlags    = sConfigMgr->GetIntDefault("NpcBot.HealTargetIconsMask", 0);
+    _mult_dmg_melee         = sConfigMgr->GetFloatDefault("NpcBot.Mult.Damage.Melee", 1.0);
+    _mult_dmg_spell         = sConfigMgr->GetFloatDefault("NpcBot.Mult.Damage.Spell", 1.0);
+    _mult_healing           = sConfigMgr->GetFloatDefault("NpcBot.Mult.Healing", 1.0);
+    _enableNpcBotsDungeons  = sConfigMgr->GetBoolDefault("NpcBot.Enable.Dungeon", true);
+    _enableNpcBotsRaids     = sConfigMgr->GetBoolDefault("NpcBot.Enable.Raid", false);
+    _enableNpcBotsBGs       = sConfigMgr->GetBoolDefault("NpcBot.Enable.BG", false);
+    _enableNpcBotsArenas    = sConfigMgr->GetBoolDefault("NpcBot.Enable.Arena", false);
+    _enableDungeonFinder    = sConfigMgr->GetBoolDefault("NpcBot.Enable.DungeonFinder", true);
+    _limitNpcBotsDungeons   = sConfigMgr->GetBoolDefault("NpcBot.Limit.Dungeon", true);
+    _limitNpcBotsRaids      = sConfigMgr->GetBoolDefault("NpcBot.Limit.Raid", true);
+    _npcBotsCost            = sConfigMgr->GetIntDefault("NpcBot.Cost", 1000000);
+    _botPvP                 = sConfigMgr->GetBoolDefault("NpcBot.PvP", true);
+
+    //limits
+    _mult_dmg_melee         = std::max(_mult_dmg_melee, 0.1f);
+    _mult_dmg_spell         = std::max(_mult_dmg_spell, 0.1f);
+    _mult_healing           = std::max(_mult_healing,   0.1f);
+    _mult_dmg_melee         = std::min(_mult_dmg_melee, 10.f);
+    _mult_dmg_spell         = std::min(_mult_dmg_spell, 10.f);
+    _mult_healing           = std::min(_mult_healing,   10.f);
+}
+
+uint8 BotMgr::GetNpcBotsCount() const
+{
+    //if (!inWorldOnly)
+        return _bots.size();
+
+    //CRITICAL SECTION
+    //inWorldOnly is only for one-shot cases (opcodes, etc.)
+    //maybe convert to (bot && bot->isInWorld()) ?
+    //uint8 count = 0;
+    //for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    //    if (ObjectAccessor::GetObjectInWorld(itr->first, (Creature*)NULL))
+    //        ++count;
+    //return count;
+}
+
+uint8 BotMgr::GetNpcBotsCountByRole(uint16 roles) const
+{
+    uint8 count = 0;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (itr->second && (roles & itr->second->GetBotRoles()))
+            ++count;
+    return count;
+}
+
+uint8 BotMgr::GetNpcBotSlotByRole(uint16 roles, Creature const* bot) const
+{
+    uint8 count = 0;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (itr->second && (roles & itr->second->GetBotRoles()))
+        {
+            ++count;
+            if (itr->second == bot)
+                return count;
+        }
+    }
+    return 1;
+}
+
+bool BotMgr::IsNpcBotModEnabled()
+{
+    return _enableNpcBots;
+}
+
+bool BotMgr::IsNpcBotDungeonFinderEnabled()
+{
+    return _enableDungeonFinder;
+}
+
+uint8 BotMgr::GetNpcBotXpReduction()
+{
+    return _xpReductionNpcBots;
+}
+
+uint8 BotMgr::GetMaxNpcBots()
+{
+    return _maxNpcBots <= MAXRAIDSIZE - 1 ? _maxNpcBots : MAXRAIDSIZE - 1;
+}
+
+bool BotMgr::LimitBots(Map const* map)
+{
+    if (_limitNpcBotsDungeons && map->IsNonRaidDungeon())
+        return true;
+    if (_limitNpcBotsRaids && map->IsRaid())
+        return true;
+
+    return false;
+}
+
+void BotMgr::Update(uint32 diff)
+{
+    //remove temp bots from bot map before updating it
+    while (!_removeList.empty())
+    {
+        std::list<uint64>::iterator itr = _removeList.begin();
+
+        BotMap::iterator bitr = _bots.find(*itr);
+        ASSERT(bitr != _bots.end());
+        _bots.erase(bitr);
+
+        _removeList.erase(itr);
+    }
+
+    if (!HaveBot())
+        return;
+
+    //uint64 guid;
+    Creature* bot;
+    bot_minion_ai* ai;
+    bool partyCombat = IsPartyInCombat();
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        //guid = itr->first;
+        bot = itr->second;
+        ai = bot->GetBotMinionAI();
+
+        if (ai->IAmFree())
+            continue;
+
+        if (!bot->IsInWorld())
+        {
+            ai->CommonTimers(diff);
+            continue;
+        }
+
+        if (partyCombat == false)
+            ai->UpdateReviveTimer(diff);
+
+        bot->SetCanUpdate(true);
+        bot->IsAIEnabled = true;
+
+        if (ai->GetReviveTimer() <= diff)
+        {
+            if (!bot->IsAlive() && _owner->IsAlive() && !_owner->IsInCombat() && !_owner->IsBeingTeleported() && !_owner->InArena() &&
+                !_owner->IsInFlight() && !_owner->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH) &&
+                !_owner->HasInvisibilityAura() && !_owner->HasStealthAura())
+            {
+                _reviveBot(bot);
+                continue;
+            }
+
+            ai->SetReviveTimer(urand(1000, 5000));
+        }
+
+        if (_owner->IsAlive() && bot->IsAlive() && !ai->IsTempBot() && !ai->IsDuringTeleport() &&
+            (RestrictBots(bot, false) ||
+            bot->GetMap() != _owner->GetMap() ||
+            (bot->GetBotCommandState() != COMMAND_STAY && _owner->GetDistance(bot) > SIZE_OF_GRIDS)))
+        {
+            //_owner->m_Controlled.erase(bot);
+            TeleportBot(bot, _owner->GetMap(), _owner);
+            continue;
+        }
+
+        bot->Update(diff);
+        bot->SetCanUpdate(false);
+
+        if (Creature* pet = bot->GetBotsPet())
+        {
+            pet->SetCanUpdate(true);
+            pet->IsAIEnabled = true;
+            pet->Update(diff);
+            pet->SetCanUpdate(false);
+        }
+    }
+}
+
+bool BotMgr::RestrictBots(Creature const* bot, bool add) const
+{
+    if (!_owner->FindMap())
+        return true;
+
+    if (_owner->IsInFlight())
+        return true;
+
+    if (_botsHidden)
+        return true;
+
+    Map const* currMap = _owner->GetMap();
+
+    if ((!_enableNpcBotsBGs && currMap->IsBattleground()) ||
+        (!_enableNpcBotsArenas && currMap->IsBattleArena()) ||
+        (!_enableNpcBotsDungeons && currMap->IsNonRaidDungeon()) ||
+        (!_enableNpcBotsRaids && currMap->IsRaid()))
+        return true;
+
+    if (LimitBots(currMap))
+    {
+        //if bot is not in instance group - deny (only if trying to teleport to instance)
+        if (add)
+            if (!_owner->GetGroup() || !_owner->GetGroup()->IsMember(bot->GetGUID()))
+                return true;
+
+        InstanceMap const* map = currMap->ToInstanceMap();
+        if (map->GetPlayersCountExceptGMs() + uint32(add) > map->GetMaxPlayers())
+            return true;
+    }
+
+    return false;
+}
+
+bool BotMgr::IsPartyInCombat() const
+{
+    if (_owner->IsInCombat())
+        return true;
+
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (itr->second->IsInCombat())
+            return true;
+        if (Creature const* pet = itr->second->GetBotsPet())
+            if (pet->IsInCombat())
+                return true;
+    }
+
+    return false;
+}
+
+void BotMgr::_reviveBot(Creature* bot)
+{
+    if (bot->IsAlive())
+        return;
+
+    if (!bot->GetBotAI()->IAmFree())
+        bot->Relocate(bot->GetBotOwner());
+
+    bot->SetUInt32Value(UNIT_NPC_FLAGS, bot->GetCreatureTemplate()->npcflag);
+    bot->ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
+    bot->RemoveFlag(UNIT_FIELD_FLAGS, uint32(-1));
+    bot->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+    bot->setDeathState(ALIVE);
+    //bot->GetBotAI()->Reset();
+    bot->GetBotAI()->SetShouldUpdateStats();
+
+    bot->SetHealth(bot->GetMaxHealth() / 4); //25% of max health
+    if (bot->GetMaxPower(POWER_MANA) > 1)
+        bot->SetPower(POWER_MANA, bot->GetMaxPower(POWER_MANA) / 4); //25% of max mana
+
+    if (!bot->GetBotAI()->IAmFree())
+        bot->SetBotCommandState(COMMAND_FOLLOW, true);
+}
+
+Creature* BotMgr::GetBot(uint64 guid) const
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    return itr != _bots.end() ? itr->second : NULL;
+}
+
+void BotMgr::OnOwnerSetGameMaster(bool on)
+{
+    Creature* bot;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        bot = itr->second;
+        if (!bot)
+            continue;
+
+        bot->setFaction(_owner->getFaction());
+        bot->getHostileRefManager().setOnlineOfflineState(!on);
+        bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1)); //pvp state
+
+        if (on && bot->IsInWorld())
+            bot->CombatStop(true);
+    }
+}
+
+void BotMgr::OnTeleportFar(uint32 mapId, float x, float y, float z, float ori)
+{
+    Map* newMap = sMapMgr->CreateBaseMap(mapId);
+    Creature* bot;
+    Position pos;
+    pos.Relocate(x, y, z, ori);
+
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        bot = itr->second;
+        ASSERT(bot && "BotMgr::OnTeleportFar(): bot does not exist!!!");
+
+        if (bot->IsTempBot())
+            continue;
+
+        //_owner->m_Controlled.erase(bot);
+        TeleportBot(bot, newMap, &pos);
+    }
+}
+
+void BotMgr::_teleportBot(Creature* bot, Map* newMap, float x, float y, float z, float ori)
+{
+    ASSERT(bot->GetBotAI());
+    bot->GetBotAI()->AbortTeleport();
+
+    bot->SetBotsPetDied();
+    bot->GetBotAI()->UnsummonAll();
+    bot->GetBotAI()->KillEvents(true);
+
+    if (bot->IsInWorld())
+    {
+        //bot->MonsterWhisper("teleport...", bot->GetBotAI()->GetBotOwnerGuid());
+        bot->CastSpell(bot, COSMETIC_TELEPORT_EFFECT, true);
+    }
+
+    bot->IsAIEnabled = false;
+    //UnitAI* oldAI = bot->GetAI();
+    //bot->SetAI(NULL);
+
+    //if (bot->IsFreeBot() || bot->GetBotOwner()->GetSession()->isLogingOut())
+    //{
+    //    bot->FarTeleportTo(newMap, x, y, z, ori);
+
+    //    //bot->SetAI(oldAI);
+    //    bot->IsAIEnabled = true;
+    //    return;
+    //}
+
+    ////start Unit::CleanupBeforeRemoveFromMap()
+    bot->InterruptNonMeleeSpells(true);
+    if (bot->IsInWorld())
+        bot->RemoveFromWorld();
+
+    ASSERT(bot->GetGUID());
+
+    // A unit may be in removelist and not in world, but it is still in grid
+    // and may have some references during delete
+    //RemoveAllAuras();
+    bot->RemoveAllGameObjects();
+
+    //if (finalCleanup)
+    //    m_cleanupDone = true;
+
+    bot->m_Events.KillAllEvents(false);                      // non-delatable (currently casted spells) will not deleted now but it will deleted at call in Map::RemoveAllObjectsInRemoveList
+    bot->CombatStop();
+    bot->ClearComboPointHolders();
+    //bot->DeleteThreatList();
+    bot->getHostileRefManager().setOnlineOfflineState(false);
+    //bot->GetMotionMaster()->Clear(false);                    // remove different non-standard movement generators.
+    //end Unit::CleanupBeforeRemoveFromMap()
+
+    //bot->CleanupBeforeRemoveFromMap(false);
+
+    bot->BotStopMovement();
+
+    if (Map* mymap = bot->FindMap())
+        mymap->RemoveFromMap(bot, false);
+
+    if (bot->IsFreeBot()/* || bot->GetBotOwner()->GetSession()->isLogingOut()*/)
+    {
+        //bot->FarTeleportTo(newMap, x, y, z, ori);
+
+        //Creature::FarTeleportTo()
+        //{
+        //CleanupBeforeRemoveFromMap(false); //done above
+        //GetMap()->RemoveFromMap(this, false); //done above
+        //Relocate(X, Y, Z, O);
+        //SetMap(map);
+        //GetMap()->AddToMap(this);
+        //}
+        bot->Relocate(x, y, z, ori);
+        bot->SetMap(newMap);
+        bot->GetMap()->AddToMap(bot);
+        //end Creature::FarTeleportTo()
+
+        //bot->SetAI(oldAI);
+        bot->IsAIEnabled = true;
+        return;
+    }
+
+    //update group member online state
+    if (Group* gr = bot->GetBotOwner()->GetGroup())
+        if (gr->IsMember(bot->GetGUID()))
+            gr->SendUpdate();
+
+    //bot->Relocate(x, y, z);
+    TeleportFinishEvent* finishEvent = new TeleportFinishEvent(bot->GetBotMinionAI()/*, newMap->GetId(), newMap->GetInstanceId(), x, y, z, ori*/);
+    bot->GetBotAI()->GetEvents()->AddEvent(finishEvent, bot->GetBotAI()->GetEvents()->CalculateTime(urand(5000, 8000)));
+    bot->GetBotMinionAI()->SetTeleportFinishEvent(finishEvent);
+}
+
+void BotMgr::TeleportBot(Creature* bot, Map* newMap, Position* pos)
+{
+    _teleportBot(bot, newMap, pos->GetPositionX(), pos->GetPositionY(), pos->GetPositionZ(), pos->GetOrientation());
+}
+
+void BotMgr::CleanupsBeforeBotDelete(uint64 guid, uint8 removetype)
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    ASSERT(itr != _bots.end() && "Trying to remove bot which does not belong to this botmgr(b)!!");
+    ASSERT(_owner->IsInWorld() && "Trying to remove bot while not in world(b)!!");
+
+    Creature* bot = itr->second;
+
+    //don't allow removing bots while they are teleporting
+    if (!bot->IsInWorld())
+    {
+        bot->GetBotAI()->AbortTeleport();
+        //if (!bot->IsInWorld())
+        //{
+        //    TC_LOG_ERROR("entities.player", "BotMgr::CleanupsBeforeBotDelete(): Failed to abort %s's teleport! Still out of world!", bot->GetName().c_str());
+        //    ASSERT(false);
+        //}
+    }
+
+    //if player is logging out group will be disbanded (and bots removed) normal way
+    //WorldSession.cpp:: if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+    if (!_owner->GetSession()->PlayerLogout())
+        RemoveBotFromGroup(bot, removetype); //Is this code never executed?
+
+    //remove any summons
+    bot->SetBotsPetDied();
+    bot->GetBotAI()->UnsummonAll();
+
+    ASSERT(bot->GetOwnerGUID() == _owner->GetGUID());
+    bot->SetOwnerGUID(0);
+    //_owner->m_Controlled.erase(bot);
+    bot->m_ControlledByPlayer = false;
+    bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+    bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, 0);
+    bot->SetCreatorGUID(0);
+}
+
+void BotMgr::_addBotToRemoveList(uint64 guid)
+{
+    _removeList.push_back(guid);
+}
+
+void BotMgr::RemoveAllBots(uint8 removetype)
+{
+    while (!_bots.empty())
+        RemoveBot(_bots.begin()->first, removetype);
+}
+//Bot is being abandoned by player
+void BotMgr::RemoveBot(uint64 guid, uint8 removetype)
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    ASSERT(itr != _bots.end() && "Trying to remove bot which does not belong to this botmgr(a)!!");
+    ASSERT(_owner->IsInWorld() && "Trying to remove bot while not in world(a)!!");
+
+    //trying to remove temp bot second time means removing all bots
+    //just erase from bots because already cleaned up
+    for (std::list<uint64>::iterator it = _removeList.begin(); it != _removeList.end(); ++it)
+    {
+        if (*it == guid)
+        {
+            _removeList.erase(it);
+            _bots.erase(itr);
+            return;
+        }
+    }
+
+    Creature* bot = itr->second;
+    CleanupsBeforeBotDelete(guid);
+
+    ////remove control bar
+    //if (GetNpcBotsCount() <= 1 && !_owner->GetPetGUID() && _owner->m_Controlled.empty())
+    //    _owner->SendRemoveControlBar();
+
+    if (bot->GetBotAI()->IsTempBot())
+    {
+        //bot->GetBotAI()->OnBotDespawn(bot); //send to self
+        _addBotToRemoveList(guid);
+        return;
+    }
+
+    _bots.erase(itr);
+
+    bot->GetBotAI()->ResetBotAI(removetype == BOT_REMOVE_DISMISS ? BOTAI_RESET_DISMISS : BOTAI_RESET_LOGOUT);
+
+    bot->setFaction(bot->GetCreatureTemplate()->faction_A);
+    bot->SetLevel(bot->GetCreatureTemplate()->minlevel);
+
+    if (removetype == BOT_REMOVE_DISMISS)
+    {
+        uint32 newOwner = 0;
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_OWNER, &newOwner);
+    }
+
+    bot->AI()->Reset();
+}
+
+BotAddResult BotMgr::AddBot(Creature* bot, bool takeMoney)
+{
+    ASSERT(bot->IsNPCBot());
+    ASSERT(bot->GetBotAI() != NULL);
+
+    bool temporary = bot->GetBotAI()->IsTempBot();
+
+    if (!_enableNpcBots)
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.SendSysMessage("NpcBot system is currently disabled. Please contact administration.");
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_DISABLED;
+    }
+    if (GetBot(bot->GetGUID()))
+        return BOT_ADD_ALREADY_HAVE; //Silent error, intended
+    if (!bot->GetBotAI()->IAmFree())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("%s will not join you, already has master: %s",
+            bot->GetName().c_str(), bot->GetBotOwner()->GetName().c_str());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_NOT_AVAILABLE;
+    }
+    if (bot->GetBotAI()->IsDuringTeleport())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("%s cannot join you while about to teleport", bot->GetName().c_str());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_BUSY;
+    }
+    if (!temporary && _owner->GetNpcBotsCount() >= GetMaxNpcBots())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("Youre exceed max npcbots (%u)", GetMaxNpcBots());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_MAX_EXCEED;
+    }
+    if (!temporary && HaveBot() && _maxClassNpcBots)
+    {
+        uint8 count = 0;
+        for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+            if (itr->second->GetBotClass() == bot->GetBotClass())
+                ++count;
+
+        if (count >= _maxClassNpcBots)
+        {
+            ChatHandler ch(_owner->GetSession());
+            ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, _maxClassNpcBots);
+            //ch.SetSentErrorMessage(true);
+            return BOT_ADD_MAX_CLASS_EXCEED;
+        }
+    }
+    //Map* curMap = _owner->GetMap();
+    //if (!temporary && LimitBots(curMap))
+    //{
+    //    InstanceMap* map = curMap->ToInstanceMap();
+    //    uint32 count = map->GetPlayersCountExceptGMs();
+    //    if (count >= map->GetMaxPlayers())
+    //    {
+    //        ChatHandler ch(_owner->GetSession());
+    //        ch.PSendSysMessage("Instance players limit exceed (%u of %u)", count, map->GetMaxPlayers());
+    //        //ch.SetSentErrorMessage(true);
+    //        return BOT_ADD_INSTANCE_LIMIT;
+    //    }
+    //}
+    if (!temporary && takeMoney)
+    {
+        uint32 cost = GetNpcBotCost(_owner->getLevel(), bot);
+        if (!_owner->HasEnoughMoney(cost))
+        {
+            ChatHandler ch(_owner->GetSession());
+            std::string str = "You don't have enough money (";
+            str += GetNpcBotCostStr(_owner->getLevel(), bot);
+            str += ")!";
+            ch.SendSysMessage(str.c_str());
+            //ch.SetSentErrorMessage(true);
+            return BOT_ADD_CANT_AFFORD;
+        }
+
+        _owner->ModifyMoney(-(int32(cost)));
+    }
+
+    bot->SetBotsPetDied();
+    bot->GetBotAI()->UnsummonAll();
+
+    _bots[bot->GetGUID()] = bot;
+
+    bot->SetBotOwner(_owner);
+    bot->SetCreatorGUID(_owner->GetGUID()); //needed in case of FFAPVP
+
+    ASSERT(!bot->GetOwnerGUID());
+    bot->SetOwnerGUID(_owner->GetGUID());
+    //_owner->m_Controlled.insert(bot);
+    bot->m_ControlledByPlayer = true;
+    bot->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+    bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+    bot->setFaction(_owner->getFaction());
+
+    bot->GetBotAI()->Reset();
+
+    if (!temporary)
+    {
+        bot->SetBotCommandState(COMMAND_FOLLOW, true);
+        if (bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+            AddBotToGroup(bot);
+
+        uint32 newOwner = _owner->GetGUIDLow();
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_OWNER, &newOwner);
+    }
+
+    return BOT_ADD_SUCCESS;
+}
+
+bool BotMgr::AddBotToGroup(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    Group* gr = _owner->GetGroup();
+    if (gr)
+    {
+        if (gr->IsMember(bot->GetGUID()))
+            return true;
+
+        if (gr->IsFull())
+        {
+            if (!gr->isRaidGroup()) //non-raid group is full
+                gr->ConvertToRaid();
+            else
+                return false;
+        }
+    }
+    else
+    {
+        gr = new Group;
+        if (!gr->Create(_owner))
+        {
+            delete gr;
+            return false;
+        }
+        sGroupMgr->AddGroup(gr);
+    }
+
+    if (gr->AddMember((Player*)bot))
+    {
+        if (!bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+            bot->GetBotAI()->ToggleRole(BOT_ROLE_PARTY, true);
+
+        bot->GetBotAI()->CancelBoot();
+        return true;
+    }
+
+    return false;
+}
+
+bool BotMgr::RemoveBotFromGroup(Creature* bot, uint8 removetype)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    Group* gr = _owner->GetGroup();
+    if (!gr || !gr->IsMember(bot->GetGUID()))
+        return false;
+
+    if (bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+        bot->GetBotAI()->ToggleRole(BOT_ROLE_PARTY, true);
+
+    //debug
+    //if (gr->RemoveMember(bot->GetGUID()))
+    //    TC_LOG_ERROR("entities.player", "RemoveBotFromGroup(): bot %s removed from group", bot->GetName().c_str());
+    //else
+    //    TC_LOG_ERROR("entities.player", "RemoveBotFromGroup(): RemoveMember() returned FALSE on bot %s", bot->GetName().c_str());
+
+    gr->RemoveMember(bot->GetGUID());
+
+    Map* map = _owner->FindMap();
+    gr = _owner->GetGroup(); //check if group has been deleted
+    if (map && map->IsDungeon() && removetype != BOT_REMOVE_DISMISS && (!gr || !gr->IsMember(bot->GetGUID()))) //make sure bot is removed from group
+    {
+        ChatHandler(_owner->GetSession()).PSendSysMessage("Your bot %s has been removed from your group and will be teleported out of the instance in 60 seconds if not invited back", bot->GetName().c_str());
+
+        if (gr && _owner->GetGUID() != gr->GetLeaderGUID())
+            if (Player* leader = ObjectAccessor::FindPlayer(gr->GetLeaderGUID()))
+                ChatHandler(leader->GetSession()).PSendSysMessage("Bot %s has been removed from your group and will be teleported out of the instance in 60 seconds if not invited back", bot->GetName().c_str());
+
+        bot->GetBotAI()->StartBoot();
+    }
+
+    return true;
+}
+
+bool BotMgr::RemoveAllBotsFromGroup()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        RemoveBotFromGroup(itr->second);
+
+    return true;
+}
+
+uint32 BotMgr::GetNpcBotCost(uint8 level, Creature const* creature)
+{
+    //assuming default 100000
+    //level 1: 1000
+    //11 : 1666
+    //15 : 8333
+    //20 : 16666
+    //30 : 33333
+    //40 : 50000
+    //rest is linear
+    if (!creature || !creature->GetBotAI())
+        return std::min<uint32>(std::max<uint32>((_npcBotsCost * (level - 10)) / (DEFAULT_MAX_LEVEL - 20), 1000), (_npcBotsCost * level) / DEFAULT_MAX_LEVEL);
+
+    uint32 base;
+    switch (creature->GetBotAI()->GetBotClass())
+    {
+        case BOT_CLASS_BM:
+            //base = GetNpcBotCost(level, NULL) * 9;
+            //base = 100000; //10 gold
+            //break;
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_SHAMAN:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_DRUID:
+        default:
+            base = 0;
+            break;
+    }
+
+    return base + GetNpcBotCost(level, NULL);
+}
+
+std::string BotMgr::GetNpcBotCostStr(uint8 level, Creature const* creature)
+{
+    std::ostringstream money;
+
+    if (uint32 cost = GetNpcBotCost(level, creature))
+    {
+        uint32 gold = uint32(cost / GOLD);
+        cost -= (gold * GOLD);
+        uint32 silver = uint32(cost / SILVER);
+        cost -= (silver * SILVER);
+
+        if (gold != 0)
+            money << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver != 0)
+            money << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        if (cost)
+            money << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+    }
+
+    return money.str();
+}
+
+void BotMgr::ReviveAllBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        _reviveBot(itr->second);
+}
+
+void BotMgr::SendBotCommandState(CommandStates state)
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        itr->second->SetBotCommandState(state, true);
+}
+
+void BotMgr::RecallAllBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (itr->second->IsInWorld() && itr->second->IsAlive() && !bot_ai::CCed(itr->second, true))
+            itr->second->GetMotionMaster()->MovePoint(_owner->GetMapId(), *_owner, false);
+}
+
+void BotMgr::RecallBot(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    if (bot->IsInWorld() && bot->IsAlive() && !bot_ai::CCed(bot, true))
+        bot->GetMotionMaster()->MovePoint(_owner->GetMapId(), *_owner, false);
+}
+
+void BotMgr::KillAllBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (itr->second->IsInWorld() && itr->second->IsAlive())
+            itr->second->Kill(itr->second);
+}
+
+void BotMgr::KillBot(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    if (bot->IsInWorld() && bot->IsAlive())
+        bot->Kill(bot);
+}
+
+void BotMgr::SetBotsShouldUpdateStats()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        itr->second->GetBotAI()->SetShouldUpdateStats();
+}
+
+void BotMgr::UpdatePhaseForBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (!itr->second->IsInWorld())
+            itr->second->SetPhaseMask(_owner->GetPhaseMask(), false);
+    }
+}
+
+void BotMgr::UpdatePvPForBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        itr->second->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+}
diff --git a/src/server/game/AI/NpcBots/botmgr.h b/src/server/game/AI/NpcBots/botmgr.h
new file mode 100644
index 0000000..aa012a4
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botmgr.h
@@ -0,0 +1,119 @@
+#ifndef _BOTMGR_H
+#define _BOTMGR_H
+
+class Creature;
+class Map;
+class Player;
+
+struct Position;
+
+enum BotAddResult
+{
+    BOT_ADD_DISABLED                    = 0x001,
+    BOT_ADD_ALREADY_HAVE                = 0x002,
+    BOT_ADD_MAX_EXCEED                  = 0x004,
+    BOT_ADD_MAX_CLASS_EXCEED            = 0x008,
+    BOT_ADD_CANT_AFFORD                 = 0x010,
+    BOT_ADD_INSTANCE_LIMIT              = 0x020,
+    BOT_ADD_BUSY                        = 0x040,
+    BOT_ADD_NOT_AVAILABLE               = 0x080,
+
+    BOT_ADD_SUCCESS                     = 0x100,
+
+    BOT_ADD_FATAL                       = (BOT_ADD_DISABLED | BOT_ADD_CANT_AFFORD | BOT_ADD_MAX_EXCEED | BOT_ADD_MAX_CLASS_EXCEED)
+};
+
+enum BotRemoveType
+{
+    BOT_REMOVE_LOGOUT                   = 0,
+    BOT_REMOVE_DISMISS                  = 1,
+    BOT_REMOVE_HIDE                     = 2, //NYI
+    BOT_REMOVE_UNSUMMON                 = 3,
+    BOT_REMOVE_BY_DEFAULT               = BOT_REMOVE_LOGOUT
+};
+
+typedef UNORDERED_MAP<uint64 /*guid*/, Creature* /*bot*/> BotMap;
+
+class BotMgr
+{
+    public:
+        BotMgr(Player* const master);
+        ~BotMgr();
+
+        Player* GetOwner() const { return _owner; }
+
+        BotMap const* GetBotMap() const { return &_bots; }
+        BotMap* GetBotMap() { return &_bots; }
+
+        static bool IsNpcBotModEnabled();
+        static bool IsNpcBotDungeonFinderEnabled();
+
+        static void Initialize();
+        static void ReloadConfig() { LoadConfig(true); }
+        static void LoadConfig(bool force = false);
+
+        void Update(uint32 diff);
+
+        Creature* GetBot(uint64 guid) const;
+        bool HaveBot() const { return !_bots.empty(); }
+        uint8 GetNpcBotsCount() const;
+        uint8 GetNpcBotsCountByRole(uint16 roles) const;
+        uint8 GetNpcBotSlotByRole(uint16 roles, Creature const* bot) const;
+        static uint8 GetMaxNpcBots();
+        static uint8 GetNpcBotXpReduction();
+        static bool LimitBots(Map const* map);
+        bool RestrictBots(Creature const* bot, bool add) const;
+        bool IsPartyInCombat() const;
+
+        static uint32 GetNpcBotCost(uint8 level, Creature const* creature);
+        static std::string GetNpcBotCostStr(uint8 level, Creature const* creature);
+
+        void OnTeleportFar(uint32 mapId, float x, float y, float z, float ori = 0.f);
+        void OnOwnerSetGameMaster(bool on);
+        void ReviveAllBots();
+        void SendBotCommandState(CommandStates state);
+        void RecallAllBots();
+        void RecallBot(Creature* bot);
+        void KillAllBots();
+        void KillBot(Creature* bot);
+
+        void CleanupsBeforeBotDelete(uint64 guid, uint8 removetype = BOT_REMOVE_LOGOUT);
+        void RemoveAllBots(uint8 removetype = BOT_REMOVE_LOGOUT);
+        void RemoveBot(uint64 guid, uint8 removetype = BOT_REMOVE_LOGOUT);
+        BotAddResult AddBot(Creature* bot, bool takeMoney = false);
+        bool AddBotToGroup(Creature* bot);
+        bool RemoveBotFromGroup(Creature* bot, uint8 removetype = BOT_REMOVE_LOGOUT);
+        bool RemoveAllBotsFromGroup();
+
+        uint8 GetBotFollowDist() const { return _followdist; }
+        void SetBotFollowDist(uint8 dist) { _followdist = dist; }
+
+        void SetBotsHidden(bool hidden) { _botsHidden = hidden; }
+
+        void SetBotsShouldUpdateStats();
+        void UpdatePhaseForBots();
+        void UpdatePvPForBots();
+
+        static void ReviveBot(Creature* bot) { _reviveBot(bot); }
+
+        //TELEPORT BETWEEN MAPS
+        //CONFIRMEND UNSAFE (charmer,owner)
+        static void TeleportBot(Creature* bot, Map* newMap, Position* pos);
+
+    private:
+        static void _teleportBot(Creature* bot, Map* newMap, float x, float y, float z, float ori = 0.f);
+
+        static void _reviveBot(Creature* bot);
+
+        void _addBotToRemoveList(uint64 guid);
+
+        Player* const _owner;
+        BotMap _bots;
+        std::list<uint64> _removeList;
+
+        uint8 _followdist;
+
+        bool _botsHidden;
+};
+
+#endif
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index be39972..84047c4 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -130,6 +130,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/NpcBots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
diff --git a/src/server/game/DataStores/DBCStores.cpp b/src/server/game/DataStores/DBCStores.cpp
index 1fc2c3e..e79c8d4 100644
--- a/src/server/game/DataStores/DBCStores.cpp
+++ b/src/server/game/DataStores/DBCStores.cpp
@@ -115,7 +115,7 @@ DBCStorage <HolidaysEntry>                sHolidaysStore(Holidaysfmt);
 DBCStorage <ItemEntry>                    sItemStore(Itemfmt);
 DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore(ItemBagFamilyfmt);
 //DBCStorage <ItemCondExtCostsEntry> sItemCondExtCostsStore(ItemCondExtCostsEntryfmt);
-//DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt); -- not used currently
+DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt);
 DBCStorage <ItemExtendedCostEntry> sItemExtendedCostStore(ItemExtendedCostEntryfmt);
 DBCStorage <ItemLimitCategoryEntry> sItemLimitCategoryStore(ItemLimitCategoryEntryfmt);
 DBCStorage <ItemRandomPropertiesEntry> sItemRandomPropertiesStore(ItemRandomPropertiesfmt);
@@ -362,7 +362,7 @@ void LoadDBCStores(const std::string& dataPath)
 
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemStore,                   dbcPath, "Item.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemBagFamilyStore,          dbcPath, "ItemBagFamily.dbc");
-    //LoadDBC(dbcCount, availableDbcLocales, bad_dbc_files, sItemDisplayInfoStore,        dbcPath, "ItemDisplayInfo.dbc");     -- not used currently
+    LoadDBC(availableDbcLocales, bad_dbc_files, sItemDisplayInfoStore,        dbcPath, "ItemDisplayInfo.dbc");
     //LoadDBC(dbcCount, availableDbcLocales, bad_dbc_files, sItemCondExtCostsStore,       dbcPath, "ItemCondExtCosts.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemExtendedCostStore,       dbcPath, "ItemExtendedCost.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemLimitCategoryStore,      dbcPath, "ItemLimitCategory.dbc");
diff --git a/src/server/game/DataStores/DBCStores.h b/src/server/game/DataStores/DBCStores.h
index 808ebb7..c8ec812 100644
--- a/src/server/game/DataStores/DBCStores.h
+++ b/src/server/game/DataStores/DBCStores.h
@@ -123,7 +123,7 @@ extern DBCStorage <GtRegenMPPerSptEntry>         sGtRegenMPPerSptStore;
 extern DBCStorage <HolidaysEntry>                sHolidaysStore;
 extern DBCStorage <ItemEntry>                    sItemStore;
 extern DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore;
-//extern DBCStorage <ItemDisplayInfoEntry>      sItemDisplayInfoStore; -- not used currently
+extern DBCStorage <ItemDisplayInfoEntry>         sItemDisplayInfoStore;
 extern DBCStorage <ItemExtendedCostEntry>        sItemExtendedCostStore;
 extern DBCStorage <ItemLimitCategoryEntry>       sItemLimitCategoryStore;
 extern DBCStorage <ItemRandomPropertiesEntry>    sItemRandomPropertiesStore;
diff --git a/src/server/game/DataStores/DBCStructure.h b/src/server/game/DataStores/DBCStructure.h
index 0c1f6af..4090807 100644
--- a/src/server/game/DataStores/DBCStructure.h
+++ b/src/server/game/DataStores/DBCStructure.h
@@ -1126,7 +1126,7 @@ struct ItemDisplayInfoEntry
     uint32      ID;                                         // 0        m_ID
                                                             // 1        m_modelName[2]
                                                             // 2        m_modelTexture[2]
-                                                            // 3        m_inventoryIcon
+    char*       InventoryIcon;                              // 3        m_inventoryIcon
                                                             // 4        m_geosetGroup[3]
                                                             // 5        m_flags
                                                             // 6        m_spellVisualID
diff --git a/src/server/game/DataStores/DBCfmt.h b/src/server/game/DataStores/DBCfmt.h
index 0066db2..6c7ef36 100644
--- a/src/server/game/DataStores/DBCfmt.h
+++ b/src/server/game/DataStores/DBCfmt.h
@@ -71,7 +71,7 @@ char const GtRegenMPPerSptfmt[] = "f";
 char const Holidaysfmt[] = "niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiixxsiix";
 char const Itemfmt[] = "niiiiiii";
 char const ItemBagFamilyfmt[] = "nxxxxxxxxxxxxxxxxx";
-//char const ItemDisplayTemplateEntryfmt[] = "nxxxxxxxxxxixxxxxxxxxxx";
+char const ItemDisplayTemplateEntryfmt[] = "nxxxxsxxxxxxxxxxxxxxxxxxx";
 //char const ItemCondExtCostsEntryfmt[] = "xiii";
 char const ItemExtendedCostEntryfmt[] = "niiiiiiiiiiiiiix";
 char const ItemLimitCategoryEntryfmt[] = "nxxxxxxxxxxxxxxxxxii";
diff --git a/src/server/game/DungeonFinding/LFGMgr.cpp b/src/server/game/DungeonFinding/LFGMgr.cpp
index 783511c..5d8705b 100644
--- a/src/server/game/DungeonFinding/LFGMgr.cpp
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp
@@ -34,6 +34,12 @@
 #include "GameEventMgr.h"
 #include "WorldSession.h"
 
+//npcbot
+#include "botcommon.h"
+#include "botmgr.h"
+#include "Chat.h"
+//end npcbot
+
 namespace lfg
 {
 
@@ -504,6 +510,46 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
                         joinData.result = LFG_JOIN_USING_BG_SYSTEM;
                     ++memberCount;
                     players.insert(plrg->GetGUID());
+
+                    //npcbot
+                    if (!plrg->HaveBot())
+                        continue;
+                    //add npcbots
+                    BotMap const* map = plrg->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        if (!grp->IsMember(itr->first))
+                            continue;
+
+                        //disabled in config
+                        if (!BotMgr::IsNpcBotDungeonFinderEnabled())
+                        {
+                            (ChatHandler(plrg->GetSession())).SendSysMessage("Using npcbots in Dungeon Finder is restricted. Contact your administration.");
+
+                            if (plrg->GetGUID() != grp->GetLeaderGUID())
+                                if (Player* leader = ObjectAccessor::FindPlayer(grp->GetLeaderGUID()))
+                                    (ChatHandler(leader->GetSession())).PSendSysMessage("There is a npcbot in your group (owner: %s). Using npcbots in Dungeon Finder is restricted. Contact your administration.",
+                                        plrg->GetName().c_str());
+
+                            joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
+                            break;
+                        }
+
+                        if (Creature* bot = ObjectAccessor::GetObjectInWorld(itr->first, (Creature*)NULL))
+                        {
+                            //if (!(bot->GetBotRoles() & ( 1 | 2 | 4 ))) //(BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_HEAL)
+                            //{
+                            //    //no valid roles - reqs are not met
+                            //    (ChatHandler(plrg->GetSession())).PSendSysMessage("Your bot %s does not have any viable roles assigned.", bot->GetName().c_str());
+                            //    joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
+                            //    continue;
+                            //}
+
+                            ++memberCount;
+                            players.insert(itr->first);
+                        }
+                    }
+                    //end npcbot
                 }
             }
 
@@ -600,6 +646,9 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
         SetState(gguid, LFG_STATE_ROLECHECK);
         // Send update to player
         LfgUpdateData updateData = LfgUpdateData(LFG_UPDATETYPE_JOIN_QUEUE, dungeons, comment);
+        //npcbot
+        std::map<uint64, uint8> brolemap;
+        //end npcbot
         for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
         {
             if (Player* plrg = itr->GetSource())
@@ -613,10 +662,57 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
                 if (!debugNames.empty())
                     debugNames.append(", ");
                 debugNames.append(plrg->GetName());
+
+                //npcbot
+                if (!plrg->HaveBot())
+                    continue;
+                //add npcbots
+                BotMap const* map = plrg->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    uint64 bguid = itr->first;
+                    if (players.find(bguid) == players.end() || !grp->IsMember(bguid))
+                        continue;
+
+                    Creature* bot = ObjectAccessor::GetObjectInWorld(bguid, (Creature*)NULL);
+                    if (!bot)
+                        continue;
+
+                    SetState(bguid, LFG_STATE_ROLECHECK);
+                    if (!isContinue)
+                        SetSelectedDungeons(bguid, dungeons);
+                    roleCheck.roles[bguid] = 0;
+                    if (!debugNames.empty())
+                        debugNames.append(", ");
+                    debugNames.append(bot->GetName());
+
+                    //fill possible roles (as if player selected all roles possible for class)
+                    uint8 broles = PLAYER_ROLE_DAMAGE;
+                    if (bot->GetBotClass() == CLASS_WARRIOR || bot->GetBotClass() == CLASS_PALADIN ||
+                        bot->GetBotClass() == CLASS_DEATH_KNIGHT || bot->GetBotClass() == CLASS_DRUID ||
+                        (bot->GetBotRoles() & BOT_ROLE_TANK))
+                        broles |= PLAYER_ROLE_TANK;
+                    if (bot->GetBotClass() == CLASS_PRIEST || bot->GetBotClass() == CLASS_DRUID ||
+                        bot->GetBotClass() == CLASS_SHAMAN || bot->GetBotClass() == CLASS_PALADIN ||
+                        (bot->GetBotRoles() & BOT_ROLE_HEAL))
+                        broles |= PLAYER_ROLE_HEALER;
+                    //remove unneeded / occupied roles so players can go with role they choose
+                    if (roles & PLAYER_ROLE_TANK)
+                        broles &= ~PLAYER_ROLE_TANK;
+                    if (roles & PLAYER_ROLE_HEALER)
+                        broles &= ~PLAYER_ROLE_HEALER;
+
+                    brolemap[bguid] = broles;
+                }
+                //end npcbot
             }
         }
         // Update leader role
         UpdateRoleCheck(gguid, guid, roles);
+        //npcbot - update bots' roles
+        for (std::map<uint64, uint8>::const_iterator it = brolemap.begin(); it != brolemap.end(); ++it)
+            UpdateRoleCheck(gguid, it->first, it->second);
+        //end npcbot
     }
     else                                                   // Add player to queue
     {
@@ -947,6 +1043,48 @@ void LFGMgr::MakeNewGroup(LfgProposal const& proposal)
         if (!player)
             continue;
 
+        //npcbot - handle player's bots
+        if (player->HaveBot())
+        {
+            Group* group = player->GetGroup();
+            if (group && group != grp)
+                Player::RemoveFromGroup(group, pguid);
+
+            if (!grp)
+            {
+                grp = new Group();
+                grp->ConvertToLFG();
+                grp->Create(player);
+                uint64 gguid = grp->GetGUID();
+                SetState(gguid, LFG_STATE_PROPOSAL);
+                sGroupMgr->AddGroup(grp);
+            }
+            else if (group != grp)
+                grp->AddMember(player);
+
+            grp->SetLfgRoles(pguid, proposal.players.find(pguid)->second.role);
+
+            // Add the cooldown spell if queued for a random dungeon
+            if (dungeon->type == LFG_TYPE_RANDOM)
+                player->CastSpell(player, LFG_SPELL_DUNGEON_COOLDOWN, false);
+
+            for (LfgGuidList::const_iterator itr2 = players.begin(); itr2 != players.end(); ++itr2)
+            {
+                uint64 bguid = (*itr2);
+                if (IS_PLAYER_GUID(bguid))
+                    continue;
+                Creature* bot = player->GetBotMgr()->GetBot(bguid);
+                if (!bot)
+                    continue;
+
+                player->GetBotMgr()->AddBotToGroup(bot);
+                grp->SetLfgRoles(bguid, proposal.players.find(bguid)->second.role);
+            }
+
+            continue;
+        }
+        //end npcbot
+
         Group* group = player->GetGroup();
         if (group && group != grp)
             group->RemoveMember(player->GetGUID());
@@ -1014,6 +1152,29 @@ void LFGMgr::UpdateProposal(uint32 proposalId, uint64 guid, bool accept)
     if (itProposalPlayer == proposal.players.end())
         return;
 
+    //npcbot - player accepted proposal
+    //make its bots accept too
+    if (accept && IS_PLAYER_GUID(guid))
+    {
+        if (Player* player = ObjectAccessor::GetObjectInOrOutOfWorld(guid, (Player*)NULL))
+        {
+            if (player->HaveBot())
+            {
+                for (LfgProposalPlayerContainer::const_iterator itPlayers = proposal.players.begin(); itPlayers != proposal.players.end(); ++itPlayers)
+                {
+                    uint64 bguid = itPlayers->first;
+                    if (IS_PLAYER_GUID(bguid))
+                        continue;
+                    if (!player->GetBotMgr()->GetBot(bguid))
+                        continue;
+
+                    UpdateProposal(proposalId, bguid, accept);
+                }
+            }
+        }
+    }
+    //end npcbot
+
     LfgProposalPlayer& player = itProposalPlayer->second;
     player.accept = LfgAnswer(accept);
 
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index d927af3..4817a83 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -54,6 +54,10 @@
 
 #include "Transport.h"
 
+//npcbot
+#include "bot_ai.h"
+//end npcbot
+
 TrainerSpell const* TrainerSpellData::Find(uint32 spell_id) const
 {
     TrainerSpellMap::const_iterator itr = spellList.find(spell_id);
@@ -166,6 +170,13 @@ m_creatureInfo(NULL), m_creatureData(NULL), m_path_id(0), m_formation(NULL)
     TriggerJustRespawned = false;
     m_isTempWorldObject = false;
     _focusSpell = NULL;
+
+    //bot
+    m_creature_owner = NULL;
+    m_bots_pet = NULL;
+    bot_AI = NULL;
+    m_canUpdate = true;
+    //end bot
 }
 
 Creature::~Creature()
@@ -443,6 +454,15 @@ bool Creature::UpdateEntry(uint32 Entry, uint32 team, const CreatureData* data)
 
 void Creature::Update(uint32 diff)
 {
+    //npcbot: update helper
+    if (bot_AI)
+    {
+        if (!m_canUpdate)
+            return;
+        bot_AI->CommonTimers(diff);
+    }
+    //end npcbot
+
     if (IsAIEnabled && TriggerJustRespawned)
     {
         TriggerJustRespawned = false;
@@ -465,6 +485,10 @@ void Creature::Update(uint32 diff)
             break;
         case DEAD:
         {
+            //npcbot
+            if (bot_AI)
+                break;
+            //end npcbot
             time_t now = time(NULL);
             if (m_respawnTime <= now)
             {
@@ -495,6 +519,14 @@ void Creature::Update(uint32 diff)
             if (m_deathState != CORPSE)
                 break;
 
+            //npcbot: update dead bots
+            if (bot_AI)
+            {
+                bot_AI->UpdateDeadAI(diff);
+                break;
+            }
+            //end npcbot
+
             if (m_groupLootTimer && lootingGroupLowGUID)
             {
                 if (m_groupLootTimer <= diff)
@@ -520,6 +552,9 @@ void Creature::Update(uint32 diff)
 
             // creature can be dead after Unit::Update call
             // CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
+            //npcbot - skip dead state for bots (handled by AI)
+            if (!bot_AI)
+            //end npcbot
             if (!IsAlive())
                 break;
 
@@ -541,8 +576,15 @@ void Creature::Update(uint32 diff)
                 // do not allow the AI to be changed during update
                 m_AI_locked = true;
                 i_AI->UpdateAI(diff);
+                //bot
+                if (!bot_AI)
+                //end bot
                 m_AI_locked = false;
             }
+            //npcbot - Update evade mode AI
+            else if (bot_AI)
+                bot_AI->UpdateAI(diff);
+            //end npcbot
 
             // creature can be dead after UpdateAI call
             // CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
@@ -571,6 +613,9 @@ void Creature::Update(uint32 diff)
 
             if (getPowerType() == POWER_ENERGY)
             {
+                //npcbot: do not regenerate energy here
+                if (!IsNPCBot())
+                //end npcbot
                 if (!IsVehicle() || GetVehicleKit()->GetVehicleInfo()->m_powerType != POWER_PYRITE)
                     Regenerate(POWER_ENERGY);
             }
@@ -595,6 +640,11 @@ void Creature::Update(uint32 diff)
 
 void Creature::RegenerateMana()
 {
+    //npcbot - manual regen enabled
+    if (IsNPCBot())
+        return;
+    //end npcbot
+
     uint32 curValue = GetPower(POWER_MANA);
     uint32 maxValue = GetMaxPower(POWER_MANA);
 
@@ -630,6 +680,11 @@ void Creature::RegenerateMana()
 
 void Creature::RegenerateHealth()
 {
+    //npcbot - manual regen enabled
+    if (IsNPCBot())
+        return;
+    //end npcbot
+
     if (!isRegeneratingHealth())
         return;
 
@@ -1251,6 +1306,23 @@ bool Creature::LoadCreatureFromDB(uint32 guid, Map* map, bool addToMap)
 
     m_creatureData = data;
 
+    //npcbot
+    if (IsNPCBot())
+    {
+        //prevent loading npcbot twice (grid unload/load case)
+        if (sWorld->GetMaxPlayerCount() > 0)
+            return false;
+
+        TC_LOG_INFO("entities.unit", "Creature: loading npcbot %s (id: %u)", GetName().c_str(), GetEntry());
+        ASSERT(!IsInWorld());
+        SetByteValue(UNIT_FIELD_BYTES_0, 0, GetCreatureTemplate()->trainer_race); //set race
+
+        //don't allow removing dead bot's corpse
+        m_corpseDelay = std::numeric_limits<uint32>::max();
+        setActive(true);
+    }
+    //end npcbot
+
     if (addToMap && !GetMap()->AddToMap(this))
         return false;
     return true;
@@ -1258,6 +1330,11 @@ bool Creature::LoadCreatureFromDB(uint32 guid, Map* map, bool addToMap)
 
 void Creature::LoadEquipment(int8 id, bool force /*= true*/)
 {
+    //npcbot: prevent loading equipment for bots
+    if (IsNPCBot())
+        return;
+    //end npcbot
+
     if (id == 0)
     {
         if (force)
@@ -2115,6 +2192,16 @@ void Creature::SetInCombatWithZone()
 
 uint32 Creature::GetShieldBlockValue() const                  //dunno mob block value
 {
+    //npcbot - bot block value is fully calculated into botAI
+    if (bot_AI)
+    {
+        uint32 blockValue = bot_AI->GetShieldBlockValue();
+        blockValue += GetTotalAuraModifier(SPELL_AURA_MOD_SHIELD_BLOCKVALUE);
+        blockValue *= GetTotalAuraMultiplier(SPELL_AURA_MOD_SHIELD_BLOCKVALUE_PCT);
+        return uint32(blockValue);
+    }
+    //end npcbot
+
     return (getLevel()/2 + uint32(GetStat(STAT_STRENGTH)/20));
 }
 
@@ -2164,6 +2251,11 @@ uint32 Creature::GetCreatureSpellCooldownDelay(uint32 spellId) const
 
 bool Creature::HasSpellCooldown(uint32 spell_id) const
 {
+    //npcbot - get spell cooldown from botAI
+    if (bot_AI)
+        return !bot_AI->IsSpellReady(sSpellMgr->GetSpellInfo(spell_id)->GetFirstRankSpell()->Id, bot_AI->GetLastDiff(), false);
+    //end npcbot
+
     CreatureSpellCooldowns::const_iterator itr = m_CreatureSpellCooldowns.find(spell_id);
     return (itr != m_CreatureSpellCooldowns.end() && itr->second > time(NULL)) || HasCategoryCooldown(spell_id);
 }
@@ -2191,13 +2283,31 @@ void Creature::ProhibitSpellSchool(SpellSchoolMask idSchoolMask, uint32 unTimeMs
         if (spellInfo->PreventionType != SPELL_PREVENTION_TYPE_SILENCE)
             continue;
 
-        if ((idSchoolMask & spellInfo->GetSchoolMask()) && GetCreatureSpellCooldownDelay(unSpellId) < unTimeMs)
+        if ((idSchoolMask & spellInfo->GetSchoolMask()) && GetCreatureSpellCooldownDelay(unSpellId) < unTimeMs/IN_MILLISECONDS)
         {
             _AddCreatureSpellCooldown(unSpellId, curTime + unTimeMs/IN_MILLISECONDS);
             if (UnitAI* ai = GetAI())
                 ai->SpellInterrupted(unSpellId, unTimeMs);
         }
     }
+
+    //current spell is not yet interrupted
+    //add cooldown to assigned spell
+    //spell is being casted currently - no need to check school or current cd
+    for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_MAX_SPELL; ++i)
+    {
+        Spell const* spell = GetCurrentSpell(i);
+        if (spell && spell->getState() != SPELL_STATE_DELAYED)
+        {
+            _AddCreatureSpellCooldown(spell->GetSpellInfo()->Id, curTime + unTimeMs/IN_MILLISECONDS);
+            break;
+        }
+    }
+
+    //npcbot - call custom spell interruption hook
+    if (bot_AI)
+        bot_AI->OnBotSpellInterrupted(idSchoolMask, unTimeMs);
+    //end npcbot
 }
 
 bool Creature::HasSpell(uint32 spellID) const
@@ -2629,6 +2739,11 @@ void Creature::UpdateMovementFlags()
     if (!isInAir)
         RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING);
 
+    //npcbot: swim flag fix
+    if (bot_AI)
+        SetSwim((GetCreatureTemplate()->InhabitType & INHABIT_WATER) && IsInWater() && (!HasAuraType(SPELL_AURA_WATER_WALK) || IsUnderWater()));
+    else
+    //end npcbot
     SetSwim(GetCreatureTemplate()->InhabitType & INHABIT_WATER && IsInWater());
 }
 
@@ -2691,3 +2806,383 @@ void Creature::ReleaseFocus(Spell const* focusSpell)
         ClearUnitState(UNIT_STATE_ROTATING);
 }
 
+//NPCBOT
+bool Creature::LoadBotCreatureFromDB(uint32 guid, Map* map, bool addToMap)
+{
+    CreatureData const* data = sObjectMgr->GetCreatureData(guid);
+
+    if (!data)
+    {
+        TC_LOG_ERROR("sql.sql", "Bot creature (GUID: %u) not found in table `creature`, can't load. ", guid);
+        return false;
+    }
+
+    m_DBTableGuid = guid;
+    ASSERT(map->GetInstanceId() == 0);
+    if (map->GetCreature(MAKE_NEW_GUID(guid, data->id, HIGHGUID_UNIT)))
+        return false;
+
+    uint16 team = 0;
+    if (!Create(guid, map, data->phaseMask, data->id, 0, team, data->posX, data->posY, data->posZ, data->orientation, data))
+        return false;
+
+    //We should set first home position, because then AI calls home movement
+    SetHomePosition(data->posX, data->posY, data->posZ, data->orientation);
+
+    m_respawnradius = data->spawndist;
+
+    m_respawnDelay = data->spawntimesecs;
+    m_deathState = ALIVE;
+
+    m_respawnTime  = GetMap()->GetCreatureRespawnTime(m_DBTableGuid);
+    if (m_respawnTime)                          // respawn on Update
+    {
+        m_deathState = DEAD;
+        if (CanFly())
+        {
+            float tz = map->GetHeight(GetPhaseMask(), data->posX, data->posY, data->posZ, false);
+            if (data->posZ - tz > 0.1f)
+                Relocate(data->posX, data->posY, tz);
+        }
+    }
+
+    uint32 curhealth;
+
+    if (!m_regenHealth)
+    {
+        curhealth = data->curhealth;
+        if (curhealth)
+        {
+            curhealth = uint32(curhealth*_GetHealthMod(GetCreatureTemplate()->rank));
+            if (curhealth < 1)
+                curhealth = 1;
+        }
+        SetPower(POWER_MANA, data->curmana);
+    }
+    else
+    {
+        curhealth = GetMaxHealth();
+        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+    }
+
+    SetHealth(m_deathState == ALIVE ? curhealth : 0);
+
+    // checked at creature_template loading
+    m_defaultMovementType = MovementGeneratorType(data->movementType);
+
+    m_creatureData = data;
+
+    TC_LOG_INFO("entities.unit", "Creature: loading npcbot %s (id: %u)", GetName().c_str(), GetEntry());
+    ASSERT(!IsInWorld());
+    SetByteValue(UNIT_FIELD_BYTES_0, 0, GetCreatureTemplate()->trainer_race); //set race
+
+    //don't allow removing dead bot's corpse
+    m_corpseDelay = std::numeric_limits<uint32>::max();
+    setActive(true);
+
+    if (addToMap && !GetMap()->AddToMap(this))
+        return false;
+    return true;
+}
+
+uint8 Creature::GetBotClass() const
+{
+    return bot_AI ? bot_AI->GetBotClass() : getClass();
+}
+
+Player* Creature::GetBotOwner() const
+{
+    return bot_AI ? bot_AI->GetBotOwner() : NULL;
+}
+
+void Creature::SetBotOwner(Player* newowner)
+{
+    if (bot_AI)
+        bot_AI->SetBotOwner(newowner);
+}
+
+bool Creature::IsNPCBot() const
+{
+    return GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT;
+}
+
+bool Creature::IsFreeBot() const
+{
+    return bot_AI && bot_AI->IAmFree();
+}
+
+void Creature::SetBotsPetDied()
+{
+    if (!m_bots_pet)
+        return;
+
+    m_bots_pet->SetCharmerGUID(0);
+    m_bots_pet->SetCreatureOwner(NULL);
+    //m_bots_pet->GetBotPetAI()->SetCreatureOwner(NULL);
+    //GetBotOwner()->SetMinion((Minion*)m_bots_pet, false);
+    //m_bots_pet->SetIAmABot(false);
+    m_bots_pet->CleanupsBeforeDelete();
+    m_bots_pet->AddObjectToRemoveList();
+    m_bots_pet = NULL;
+}
+
+uint16 Creature::GetBotRoles() const
+{
+    return bot_AI ? bot_AI->GetBotRoles() : 0;
+}
+
+void Creature::SetBotCommandState(CommandStates st, bool force)
+{
+    if (bot_AI)
+        bot_AI->SetBotCommandState(st, force);
+}
+
+CommandStates Creature::GetBotCommandState() const
+{
+    return bot_AI ? bot_AI->GetBotCommandState() : COMMAND_ABANDON;
+}
+//Bot damage mods
+void Creature::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo);
+}
+void Creature::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+}
+void Creature::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+void Creature::ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierHeal(victim, heal, spellInfo, damagetype, stack);
+}
+void Creature::ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotCritMultiplierAll(victim, crit_chance, spellInfo, schoolMask, attackType);
+}
+void Creature::ApplyCreatureSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellCostMods(spellInfo, cost);
+}
+void Creature::ApplyCreatureSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellCastTimeMods(spellInfo, casttime);
+}
+void Creature::ApplyCreatureSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellRadiusMods(spellInfo, radius);
+}
+void Creature::ApplyCreatureSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellRangeMods(spellInfo, maxrange);
+}
+void Creature::ApplyCreatureSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellMaxTargetsMods(spellInfo, targets);
+}
+void Creature::ApplyCreatureSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellChanceOfSuccessMods(spellInfo, chance);
+}
+
+bool Creature::GetIAmABot() const
+{
+    return bot_AI && bot_AI->IsMinionAI();
+}
+bool Creature::GetIAmABotsPet() const
+{
+    return bot_AI && bot_AI->IsPetAI();
+}
+
+bot_minion_ai* Creature::GetBotMinionAI() const
+{
+    return bot_AI ? bot_AI->ToMinionAI() : NULL;
+}
+bot_pet_ai* Creature::GetBotPetAI() const
+{
+    return bot_AI ? bot_AI->ToPetAI() : NULL;
+}
+
+void Creature::OnBotSummon(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotSummon(summon);
+}
+void Creature::OnBotDespawn(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotDespawn(summon);
+}
+
+void Creature::BotStopMovement()
+{
+    if (IsInWorld())
+    {
+        GetMotionMaster()->Clear();
+        GetMotionMaster()->MoveIdle();
+    }
+    StopMoving();
+    DisableSpline();
+}
+
+void Creature::ResetBotAI(uint8 resetType)
+{
+    if (bot_AI)
+        bot_AI->ResetBotAI(resetType);
+}
+
+bool Creature::CanParry() const
+{
+    return bot_AI ? bot_AI->CanParry() : true;
+}
+bool Creature::CanDodge() const
+{
+    return bot_AI ? bot_AI->CanDodge() : true;
+}
+bool Creature::CanBlock() const
+{
+    return bot_AI ? bot_AI->CanBlock() : true;
+}
+bool Creature::CanCrit() const
+{
+    return bot_AI ? bot_AI->CanCrit() : true;
+}
+bool Creature::CanMiss() const
+{
+    return bot_AI ? bot_AI->CanMiss() : true;
+}
+
+float Creature::GetCreatureParryChance() const
+{
+    return bot_AI ? bot_AI->GetBotParryChance() : 5.0f;
+}
+float Creature::GetCreatureDodgeChance() const
+{
+    return bot_AI ? bot_AI->GetBotDodgeChance() : 5.0f;
+}
+float Creature::GetCreatureBlockChance() const
+{
+    return bot_AI ? bot_AI->GetBotBlockChance() : 5.0f;
+}
+float Creature::GetCreatureCritChance() const
+{
+    return bot_AI ? bot_AI->GetBotCritChance() : 0.0f;
+}
+float Creature::GetCreatureMissChance() const
+{
+    return bot_AI ? bot_AI->GetBotMissChance() : 5.0f;
+}
+float Creature::GetCreatureArmorPenetrationCoef() const
+{
+    return bot_AI ? bot_AI->GetBotArmorPenetrationCoef() : 0.0f;
+}
+float Creature::GetCreatureDamageTakenMod() const
+{
+    return bot_AI ? bot_AI->GetBotDamageTakenMod() : 1.0f;
+}
+uint32 Creature::GetCreatureExpertise() const
+{
+    return bot_AI ? bot_AI->GetBotExpertise() : 0;
+}
+uint32 Creature::GetCreatureSpellPenetration() const
+{
+    return bot_AI ? bot_AI->GetBotSpellPenetration() : 0;
+}
+uint32 Creature::GetCreatureSpellPower() const
+{
+    return bot_AI ? bot_AI->GetBotSpellPower() : 0;
+}
+uint32 Creature::GetCreatureDefense() const
+{
+    return bot_AI ? bot_AI->GetBotDefense() : GetMaxSkillValueForLevel();
+}
+int32 Creature::GetCreatureResistanceBonus(SpellSchoolMask mask) const
+{
+    return bot_AI ? bot_AI->GetBotResistanceBonus(mask) : 0;
+}
+
+uint8 Creature::GetCreatureComboPoints() const
+{
+    return bot_AI ? bot_AI->GetBotComboPoints() : 0;
+}
+
+float Creature::GetCreatureAmmoDPS() const
+{
+    return bot_AI ? bot_AI->GetBotAmmoDPS() : 0.0f;
+}
+
+bool Creature::IsCreatureImmuneToSpell(SpellInfo const* spellInfo) const
+{
+    return bot_AI && bot_AI->IsBotImmuneToSpell(spellInfo);
+}
+
+bool Creature::IsTempBot() const
+{
+    return bot_AI && bot_AI->IsTempBot();
+}
+
+MeleeHitOutcome Creature::BotRollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const
+{
+    return bot_AI ? bot_AI->BotRollCustomMeleeOutcomeAgainst(victim, attType) : RollMeleeOutcomeAgainst(victim, attType);
+}
+
+void Creature::CastCreatureItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx)
+{
+    if (bot_AI)
+        bot_AI->CastBotItemCombatSpell(target, attType, procVictim, procEx);
+}
+
+void Creature::OnSpellGo(Spell const* spell)
+{
+    if (bot_AI)
+        bot_AI->OnBotSpellGo(spell);
+}
+
+void Creature::AddBotSpellCooldown(uint32 spellId, uint32 cooldown)
+{
+    if (bot_AI)
+        bot_AI->SetSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id, cooldown);
+}
+void Creature::ReleaseBotSpellCooldown(uint32 spellId)
+{
+    if (bot_AI)
+        bot_AI->ReleaseSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id);
+}
+
+//equips
+Item* Creature::GetBotEquips(uint8 slot) const
+{
+    return bot_AI && bot_AI->IsMinionAI() ? bot_AI->GetMinionAI()->GetEquips(slot) : NULL;
+}
+Item* Creature::GetBotEquipsByGuid(uint64 itemGuid) const
+{
+    return bot_AI && bot_AI->IsMinionAI() ? bot_AI->GetMinionAI()->GetEquipsByGuid(itemGuid) : NULL;
+}
+
+//static
+bool Creature::IsBotCustomSpell(uint32 spellId)
+{
+    return bot_ai::IsBotCustomSpell(spellId);
+}
+
+//advanced
+bool Creature::IsQuestBot() const
+{
+    return
+        m_creatureInfo->Entry >= 71000 && m_creatureInfo->Entry < 72000 &&
+        (m_creatureInfo->unit_flags2 & UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+}
+//END NPCBOT
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index cab00be..91c998b 100644
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -37,6 +37,11 @@ class Player;
 class SpellInfo;
 class WorldSession;
 
+// npcbot
+class bot_ai;
+class bot_minion_ai;
+class bot_pet_ai;
+
 enum CreatureFlagsExtra
 {
     CREATURE_FLAG_EXTRA_INSTANCE_BIND   = 0x00000001,       // creature kill bind instance with killer and killer's group
@@ -54,6 +59,7 @@ enum CreatureFlagsExtra
     CREATURE_FLAG_EXTRA_NO_SKILLGAIN    = 0x00040000,       // creature won't increase weapon skills
     CREATURE_FLAG_EXTRA_TAUNT_DIMINISH  = 0x00080000,       // Taunt is a subject to diminishing returns on this creautre
     CREATURE_FLAG_EXTRA_ALL_DIMINISH    = 0x00100000,       // Creature is subject to all diminishing returns as player are
+    CREATURE_FLAG_EXTRA_NPCBOT          = 0x04000000,       // custom flag for NPCBots (not confirmed safe)
     CREATURE_FLAG_EXTRA_DUNGEON_BOSS    = 0x10000000        // creature is a dungeon boss (SET DYNAMICALLY, DO NOT ADD IN DB)
 };
 
@@ -62,6 +68,7 @@ enum CreatureFlagsExtra
     CREATURE_FLAG_EXTRA_NO_CRUSH | CREATURE_FLAG_EXTRA_NO_XP_AT_KILL | CREATURE_FLAG_EXTRA_TRIGGER | \
     CREATURE_FLAG_EXTRA_NO_TAUNT | CREATURE_FLAG_EXTRA_WORLDEVENT | CREATURE_FLAG_EXTRA_NO_CRIT | \
     CREATURE_FLAG_EXTRA_NO_SKILLGAIN | CREATURE_FLAG_EXTRA_TAUNT_DIMINISH | CREATURE_FLAG_EXTRA_ALL_DIMINISH | \
+    CREATURE_FLAG_EXTRA_NPCBOT | \
     CREATURE_FLAG_EXTRA_GUARD)
 
 #define MAX_KILL_CREDIT 2
@@ -676,6 +683,84 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         void FocusTarget(Spell const* focusSpell, WorldObject const* target);
         void ReleaseFocus(Spell const* focusSpell);
 
+        //Bot commands
+        bool LoadBotCreatureFromDB(uint32 guid, Map* map, bool addToMap = true);
+        Player* GetBotOwner() const;
+        void SetBotOwner(Player* newowner);
+        Creature* GetCreatureOwner() const { return m_creature_owner; }
+        void SetCreatureOwner(Creature* newCreOwner) { m_creature_owner = newCreOwner; }
+        Creature* GetBotsPet() const { return m_bots_pet; }
+        void SetBotsPetDied();
+        void SetBotsPet(Creature* newpet) { /*ASSERT (!m_bots_pet);*/ m_bots_pet = newpet; }
+        bool IsNPCBot() const;
+        bool IsFreeBot() const;
+        bool GetIAmABot() const;
+        bool GetIAmABotsPet() const;
+        uint8 GetBotClass() const;
+        uint16 GetBotRoles() const;
+        bot_ai* GetBotAI() const { return bot_AI; }
+        bot_minion_ai* GetBotMinionAI() const;
+        bot_pet_ai* GetBotPetAI() const;
+        void SetBotAI(bot_ai* ai) { bot_AI = ai; }
+        void SetBotCommandState(CommandStates st, bool force = false);
+        CommandStates GetBotCommandState() const;
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+        void ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const;
+        void ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const;
+        void ApplyCreatureSpellCostMods(SpellInfo const* spellInfo, int32& cost) const;
+        void ApplyCreatureSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const;
+        void ApplyCreatureSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const;
+        void ApplyCreatureSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const;
+        void ApplyCreatureSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const;
+        void ApplyCreatureSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const;
+        void OnBotSummon(Creature* summon);
+        void OnBotDespawn(Creature* summon);
+        void SetCanUpdate(bool can) { m_canUpdate = can; }
+        void BotStopMovement();
+        void ResetBotAI(uint8 resetType = 0);
+
+        bool CanParry() const;
+        bool CanDodge() const;
+        bool CanBlock() const;
+        bool CanCrit() const;
+        bool CanMiss() const;
+
+        float GetCreatureParryChance() const;
+        float GetCreatureDodgeChance() const;
+        float GetCreatureBlockChance() const;
+        float GetCreatureCritChance() const;
+        float GetCreatureMissChance() const;
+        float GetCreatureArmorPenetrationCoef() const;
+        float GetCreatureDamageTakenMod() const;
+        uint32 GetCreatureExpertise() const;
+        uint32 GetCreatureSpellPenetration() const;
+        uint32 GetCreatureSpellPower() const;
+        uint32 GetCreatureDefense() const;
+        int32 GetCreatureResistanceBonus(SpellSchoolMask mask) const;
+        uint8 GetCreatureComboPoints() const;
+        float GetCreatureAmmoDPS() const;
+
+        bool IsCreatureImmuneToSpell(SpellInfo const* spellInfo) const;
+        bool IsTempBot() const;
+
+        MeleeHitOutcome BotRollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const;
+
+        void CastCreatureItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx);
+
+        void OnSpellGo(Spell const* spell);
+        void AddBotSpellCooldown(uint32 spellId, uint32 cooldown);
+        void ReleaseBotSpellCooldown(uint32 spellId);
+
+        Item* GetBotEquips(uint8 slot) const;
+        Item* GetBotEquipsByGuid(uint64 itemGuid) const;
+
+        static bool IsBotCustomSpell(uint32 spellId);
+        //advanced
+        bool IsQuestBot() const;
+        //End Bot commands
+
     protected:
         bool CreateFromProto(uint32 guidlow, uint32 Entry, uint32 vehId, uint32 team, const CreatureData* data = NULL);
         bool InitEntry(uint32 entry, uint32 team=ALLIANCE, const CreatureData* data=NULL);
@@ -726,6 +811,13 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         bool CanAlwaysSee(WorldObject const* obj) const;
 
     private:
+        //bot system
+        Creature* m_creature_owner;
+        Creature* m_bots_pet;
+        bot_ai* bot_AI;
+        bool m_canUpdate;
+        //end bot system
+
         void ForcedDespawn(uint32 timeMSToDespawn = 0);
 
         //WaypointMovementGenerator vars
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index 9fee6b8..cd398a5 100644
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -194,6 +194,18 @@ void TempSummon::InitStats(uint32 duration)
     if (!m_Properties)
         return;
 
+    //npcbot: skip deleting/reassigning player totems
+    //normally no creatorGUID is assigned at this point, perform full check anyway for compatibilty reasons
+    bool botTotemCast = false;
+    if (m_Properties->Slot && m_Properties->Slot >= SUMMON_SLOT_TOTEM && m_Properties->Slot < MAX_TOTEM_SLOT &&
+        GetCreatorGUID() && IS_CREATURE_GUID(GetCreatorGUID()))
+    {
+        Unit* bot = sObjectAccessor->FindUnit(GetCreatorGUID());
+        if (bot && bot->ToCreature()->IsNPCBot())
+            botTotemCast = true;
+    }
+    if (!botTotemCast)
+    //end npcbot
     if (owner)
     {
         if (uint32 slot = m_Properties->Slot)
@@ -253,6 +265,19 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+    //npcbot
+    //if (IsNPCBot())
+    //{
+    //    //TC_LOG_ERROR("entities.player", "TempSummon::UnSummon(): Trying to unsummon Bot %s (guidLow: %u owner: %s)", GetName().c_str(), GetGUIDLow(), GetBotOwner()->GetName().c_str());
+    //    if (IsTempBot())
+    //        if (IS_CREATURE_GUID(GetCreatorGUID()))
+    //            if (Unit* bot = sObjectAccessor->FindUnit(GetCreatorGUID()))
+    //                if (bot->ToCreature()->IsNPCBot())
+    //                    bot->ToCreature()->OnBotDespawn(this);
+    //    return;
+    //}
+    //end npcbots
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index 675504c..79a5947 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -1118,6 +1118,11 @@ void WorldObject::setActive(bool on)
     if (GetTypeId() == TYPEID_PLAYER)
         return;
 
+    //bot
+    if (on == false && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        return;
+    //end bot
+
     m_isActive = on;
 
     if (!IsInWorld())
@@ -2210,6 +2215,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summoner);
             break;
         case UNIT_MASK_TOTEM:
+            //npcbot: totem emul step 1
+            if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->IsNPCBot())
+                summon = new Totem(properties, summoner->ToCreature()->GetBotOwner());
+            else
+            //end npcbot
             summon = new Totem(properties, summoner);
             break;
         case UNIT_MASK_MINION:
@@ -2223,6 +2233,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
         return NULL;
     }
 
+    //npcbot: totem emul step 2
+    if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->IsNPCBot())
+        summon->SetCreatorGUID(summoner->GetGUID()); // see TempSummon::InitStats()
+    //end npcbot
+
     summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, spellId);
 
     summon->SetHomePosition(pos);
@@ -2231,6 +2246,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
     AddToMap(summon->ToCreature());
     summon->InitSummon();
 
+    //npcbot: totem emul step 3
+    if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->IsNPCBot())
+        summoner->ToCreature()->OnBotSummon(summon);
+    //end npcbot
+
     //ObjectAccessor::UpdateObjectVisibility(summon);
 
     return summon;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 91e2e9f..1422c0f 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -78,6 +78,11 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+//npcbot
+#include "botmgr.h"
+#include "botdatamgr.h"
+//end npcbot
+
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
 #define PLAYER_SKILL_INDEX(x)       (PLAYER_SKILL_INFO_1_1 + ((x)*3))
@@ -520,6 +525,17 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
             AddPct(xp, (*i)->GetAmount());
 
+        //npcbot 4.2.2.1. Apply NpcBot XP reduction
+        if (player->GetNpcBotsCount() > 1)
+        {
+            if (uint8 xp_reduction = BotMgr::GetNpcBotXpReduction())
+            {
+                uint32 ratePct = std::max<int32>(100 - ((player->GetNpcBotsCount() - 1) * xp_reduction), 10);
+                xp = xp * ratePct / 100;
+            }
+        }
+        //end npcbot
+
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
         if (Pet* pet = player->GetPet())
@@ -859,6 +875,10 @@ Player::Player(WorldSession* session): Unit(true)
 
     m_ChampioningFaction = 0;
 
+    /////////////// Bot System //////////////////
+    _botMgr = NULL;
+    ///////////// End Bot System ////////////////
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
         m_powerFraction[i] = 0;
 
@@ -913,6 +933,14 @@ Player::~Player()
     delete m_achievementMgr;
     delete m_reputationMgr;
 
+    //npcbot
+    if (_botMgr)
+    {
+        delete _botMgr;
+        _botMgr = NULL;
+    }
+    //end npcbot
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1833,6 +1861,11 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && IsAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    //NpcBot mod: Update
+    if (_botMgr)
+        _botMgr->Update(p_time);
+    //end Npcbot
 }
 
 void Player::setDeathState(DeathState s)
@@ -2261,6 +2294,11 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
             if (pet)
                 UnsummonPetTemporaryIfAny();
 
+            //bot: teleport npcbots
+            if (HaveBot())
+                _botMgr->OnTeleportFar(mapid, x, y, z, orientation);
+            //end bot
+
             // remove all dyn objects
             RemoveAllDynObjects();
 
@@ -2444,6 +2482,32 @@ void Player::RemoveFromWorld()
     }
 }
 
+//BOT
+bool Player::HaveBot() const
+{
+    return _botMgr && _botMgr->HaveBot();
+}
+
+uint8 Player::GetNpcBotsCount() const
+{
+    return HaveBot() ? _botMgr->GetNpcBotsCount() : 0;
+}
+
+uint8 Player::GetBotFollowDist() const
+{
+    return _botMgr ? _botMgr->GetBotFollowDist() : 30;
+}
+
+void Player::RemoveAllBots(uint8 removetype)
+{
+    if (HaveBot()) _botMgr->RemoveAllBots(removetype);
+}
+void Player::UpdatePhaseForBots()
+{
+    if (HaveBot()) _botMgr->UpdatePhaseForBots();
+}
+//END BOT
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2719,6 +2783,12 @@ Creature* Player::GetNPCIfCanInteractWith(uint64 guid, uint32 npcflagmask)
     if (creature->GetCharmerGUID())
         return NULL;
 
+    //npcbot
+    if ((creature->IsQuestBot() || creature->IsNPCBot()) &&
+        creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
+        return creature;
+    //end npcbot
+
     // not enemy
     if (creature->IsHostileTo(this))
         return NULL;
@@ -2854,6 +2924,11 @@ void Player::SetGameMaster(bool on)
         m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
     }
 
+    //npcbot: pet is handled already, bots are not, so do it
+    if (HaveBot())
+        _botMgr->OnOwnerSetGameMaster(on);
+    //end npcbot
+
     UpdateObjectVisibility();
 }
 
@@ -2925,6 +3000,34 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (group)
     {
+        //npcbot - player is being removed from group - remove bots from that group
+        if (Player* player = ObjectAccessor::FindPlayer(guid))
+        {
+            if (player->HaveBot())
+            {
+                uint8 players = 0;
+                Group::MemberSlotList const& members = group->GetMemberSlots();
+                for (Group::member_citerator itr = members.begin(); itr!= members.end(); ++itr)
+                {
+                    if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
+                        ++players;
+                }
+
+                //remove npcbots and set up new group if needed
+                player->GetBotMgr()->RemoveAllBotsFromGroup();
+                group = player->GetGroup();
+                if (!group)
+                    return; //group has been disbanded
+            }
+        }
+        //npcbot - bot is being removed from group - find master and remove bot through botmap
+        else if (Creature* bot = ObjectAccessor::GetObjectInOrOutOfWorld(guid, (Creature*)NULL))
+        {
+            ASSERT(!bot->IsFreeBot());
+            bot->GetBotOwner()->GetBotMgr()->RemoveBotFromGroup(bot, false);
+            return;
+        }
+        //end npcbot
         group->RemoveMember(guid, method, kicker, reason);
         group = NULL;
     }
@@ -3107,6 +3210,11 @@ void Player::GiveLevel(uint8 level)
             }
 
     sScriptMgr->OnPlayerLevelChanged(this, oldLevel);
+
+    //npcbot: force bots to update stats
+    if (HaveBot())
+        _botMgr->SetBotsShouldUpdateStats();
+    //end npcbot
 }
 
 void Player::InitTalentForLevel()
@@ -4978,6 +5086,12 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
             trans->Append(stmt);
 
             CharacterDatabase.CommitTransaction(trans);
+
+            //npcbot - erase npcbots
+            uint32 newOwner = 0;
+            BotDataMgr::UpdateNpcBotDataAll(guid, NPCBOT_UPDATE_OWNER, &newOwner);
+            //end npcbot
+
             break;
         }
         // The character gets unlinked from the account, the name gets freed up and appears as deleted ingame
@@ -7207,6 +7321,10 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
         }
         else
         {
+            //npcbot - honor for bots
+            if (!victim->ToCreature()->GetIAmABot()) //exclude pets
+            //TODO: honor rate
+            //end npcbot
             if (!victim->ToCreature()->IsRacialLeader())
                 return false;
 
@@ -21669,6 +21787,11 @@ void Player::UpdatePvP(bool state, bool override)
         pvpInfo.EndTimer = time(NULL);
         SetPvP(state);
     }
+
+    //npcbot: update pvp flags for bots
+    if (HaveBot())
+        _botMgr->UpdatePvPForBots();
+    //end npcbot
 }
 
 bool Player::HasSpellCooldown(uint32 spell_id) const
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 6aa19b5..f85de48 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -52,6 +52,10 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
+// NpcBot mod
+class BotMgr;
+// end NpcBot mod
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2296,6 +2300,20 @@ class Player : public Unit, public GridObject<Player>
         std::string GetMapAreaAndZoneString();
         std::string GetCoordsMapAreaAndZoneString();
 
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        void SetBotMgr(BotMgr* mgr) { ASSERT (!_botMgr); _botMgr = mgr; }
+        BotMgr* GetBotMgr() const { return _botMgr; }
+        bool HaveBot() const;
+        uint8 GetNpcBotsCount() const;
+        uint8 GetBotFollowDist() const;
+        void RemoveAllBots(uint8 removetype = 0);
+        void UpdatePhaseForBots();
+        /*********************************************************/
+        /***                 END BOT SYSTEM                    ***/
+        /*********************************************************/
+
     protected:
         // Gamemaster whisper whitelist
         WhisperListContainer WhisperList;
@@ -2557,6 +2575,14 @@ class Player : public Unit, public GridObject<Player>
         uint8 m_grantableLevels;
 
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        BotMgr* _botMgr;
+        /*********************************************************/
+        /***                END BOT SYSTEM                     ***/
+        /*********************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Totem/Totem.cpp b/src/server/game/Entities/Totem/Totem.cpp
index ddea24c..67b39c9 100644
--- a/src/server/game/Entities/Totem/Totem.cpp
+++ b/src/server/game/Entities/Totem/Totem.cpp
@@ -143,6 +143,13 @@ void Totem::UnSummon(uint32 msTime)
         }
     }
 
+    //npcbot: send SummonedCreatureDespawn()
+    if (IS_CREATURE_GUID(GetCreatorGUID()))
+        if (Unit* bot = sObjectAccessor->FindUnit(GetCreatorGUID()))
+            if (bot->ToCreature()->IsNPCBot())
+                bot->ToCreature()->OnBotDespawn(this);
+    //end npcbot
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index d2b7fc6..0fd6eb3 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -1050,11 +1050,40 @@ void Creature::UpdateDamagePhysical(WeaponAttackType attType)
     float total_pct   = GetModifierValue(unitMod, TOTAL_PCT);
     float dmg_multiplier = GetCreatureTemplate()->dmg_multiplier;
 
+    //npcbot: support for feral form
+    if (IsNPCBot() && IsInFeralForm())
+    {
+        float att_speed = GetAPMultiplier(attType, false);
+        uint8 lvl = getLevel();
+        if (lvl > 60) lvl = 60;
+
+        weapon_mindamage = lvl*0.85f*att_speed;
+        weapon_maxdamage = lvl*1.25f*att_speed;
+    }
+    else
+    //end npcbot
     if (!CanUseAttackType(attType))
     {
-        weapon_mindamage = 0;
-        weapon_maxdamage = 0;
+        // Main hand melee is always usable, but disarm reduces damage drastically
+        if (attType == BASE_ATTACK)
+        {
+            weapon_mindamage *= 0.25f;
+            weapon_maxdamage *= 0.25f;
+        }
+        else
+        {
+            weapon_mindamage = 0;
+            weapon_maxdamage = 0;
+        }
+    }
+    //npcbot: support for ammo
+    else if (attType == RANGED_ATTACK)
+    {
+        float att_speed = GetAPMultiplier(attType, false);
+        weapon_mindamage += GetCreatureAmmoDPS() * att_speed;
+        weapon_maxdamage += GetCreatureAmmoDPS() * att_speed;
     }
+    //end npcbot
 
     float mindamage = ((base_value + weapon_mindamage) * dmg_multiplier * base_pct + total_value) * total_pct;
     float maxdamage = ((base_value + weapon_maxdamage) * dmg_multiplier * base_pct + total_value) * total_pct;
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 343adec..479d655 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -61,6 +61,10 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 #include <math.h>
 
 float baseMoveSpeed[MAX_MOVE_TYPE] =
@@ -342,6 +346,23 @@ void Unit::Update(uint32 p_time)
                 m_CombatTimer -= p_time;
         }
     }
+    //npcbot: update combat timer also for npcbots
+    if (IsInCombat() && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+    {
+        if (m_HostileRefManager.isEmpty())
+        {
+            if (m_CombatTimer <= p_time)
+            {
+                ClearInCombat();
+                for (uint8 i = SUMMON_SLOT_TOTEM; i != MAX_TOTEM_SLOT; ++i)
+                    if (uint64 totemGuid = m_SummonSlot[i])
+                        if (Unit* totem = sObjectAccessor->FindUnit(m_SummonSlot[i]))
+                            totem->ClearInCombat();
+            }
+            else
+                m_CombatTimer -= p_time;
+        }
+    }
 
     // not implemented before 3.0.2
     if (uint32 base_att = getAttackTimer(BASE_ATTACK))
@@ -842,6 +863,15 @@ void Unit::CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo
         return;
     }
 
+    //npcbot
+    if (Creature::IsBotCustomSpell(spellInfo->Id) && !(ToCreature() && ToCreature()->IsNPCBot()))
+    {
+        TC_LOG_ERROR("entities.unit", "CastSpell: NpcBot system custom spell %u by caster: %s %u), aborted. Please report",
+            spellInfo->Id, (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+    //end npcbot
+
     /// @todo this is a workaround - not needed anymore, but required for some scripts :(
     if (!originalCaster && triggeredByAura)
         originalCaster = triggeredByAura->GetCasterGUID();
@@ -993,6 +1023,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_RANGED:
         case SPELL_DAMAGE_CLASS_MELEE:
         {
+            //Npcbot mod: apply bot damage mods
+            if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+                ToCreature()->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
+            //End NpcBot
+
             // Physical Damage
             if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
             {
@@ -1050,6 +1085,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_NONE:
         case SPELL_DAMAGE_CLASS_MAGIC:
         {
+            //Npcbot mod: apply bot damage mods
+            if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+                ToCreature()->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
+            //End NpcBot
+
             // If crit add critical bonus
             if (crit)
             {
@@ -1175,8 +1215,18 @@ void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* dam
     else
         damageInfo->damage = damage;
 
+    //NpcBot mod: check custom melee outcome
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        damageInfo->hitOutCome = ToCreature()->BotRollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
+    else
+    //End NpcBot
     damageInfo->hitOutCome = RollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
 
+    //NpcBot mod: apply bot damage mods
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->ApplyBotDamageMultiplierMelee(damage, *damageInfo);
+    //End NpcBot
+
     switch (damageInfo->hitOutCome)
     {
         case MELEE_HIT_EVADE:
@@ -1327,6 +1377,9 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
         victim->HandleEmoteCommand(EMOTE_ONESHOT_PARRY_SHIELD);
 
     if (damageInfo->TargetState == VICTIMSTATE_PARRY)
+    //npcbot - implement CREATURE_FLAG_EXTRA_NO_PARRY_HASTEN (TC sup)
+    if (!(GetTypeId() == TYPEID_UNIT && ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_PARRY_HASTEN))
+    //end npcbot
     {
         // Get attack timers
         float offtime  = float(victim->getAttackTimer(OFF_ATTACK));
@@ -1392,6 +1445,10 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
 
     if (GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->CastItemCombatSpell(victim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);
+    //npcbot - CastItemCombatSpell for bots
+    else if (ToCreature()->IsNPCBot())
+        ToCreature()->CastCreatureItemCombatSpell(victim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);
+    //end npcbot
 
     // Do effect if any damage done to target
     if (damageInfo->damage)
@@ -1535,6 +1592,15 @@ uint32 Unit::CalcArmorReducedDamage(Unit* victim, const uint32 damage, SpellInfo
         armor -= std::min(armorPen, maxArmorPen);
     }
 
+    //npcbot: armor penetration modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+    {
+        // SPELL_AURA_MOD_ARMOR_PENETRATION_PCT is handled in class mods
+        // No cap
+        armor -= CalculatePct(armor, ToCreature()->GetCreatureArmorPenetrationCoef());
+    }
+    //end npcbot
+
     if (armor < 0.0f)
         armor = 0.0f;
 
@@ -1578,6 +1644,12 @@ uint32 Unit::CalcSpellResistance(Unit* victim, SpellSchoolMask schoolMask, Spell
 
     if (Player const* player = ToPlayer())
         baseVictimResistance -= player->GetSpellPenetrationItemMod();
+    //npcbot - spell resist and spell penetration for bots
+    else if (ToCreature()->IsNPCBot())
+        baseVictimResistance -= ToCreature()->GetCreatureSpellPenetration();
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBot())
+        baseVictimResistance += victim->ToCreature()->GetCreatureResistanceBonus(schoolMask);
+    //end npcbot
 
     // Resistance can't be lower then 0
     int32 victimResistance = std::max<int32>(baseVictimResistance, 0);
@@ -2036,11 +2108,24 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackT
     {
         TC_LOG_DEBUG("entities.unit", "RollMeleeOutcomeAgainst: attack came from behind and victim was a player.");
     }
+    //npcbot - bots cannot dodge if attacker is behind
+    else if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBot() && !victim->HasInArc(M_PI, this) && !victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    {
+        //TC_LOG_DEBUG("entities.unit", "RollMeleeOutcomeAgainst: attack came from behind and victim was a bot.");
+    }
+    //end npcbot
     else
     {
         // Reduce dodge chance by attacker expertise rating
         if (GetTypeId() == TYPEID_PLAYER)
             dodge_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);
+        //npcbot - manual expertise instead of auras
+        else if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        {
+            dodge_chance -= ToCreature()->GetCreatureExpertise() * 25;
+            dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+        }
+        //end npcbot
         else
             dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
 
@@ -2068,6 +2153,13 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackT
         // Reduce parry chance by attacker expertise rating
         if (GetTypeId() == TYPEID_PLAYER)
             parry_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);
+        //npcbot - manual expertise instead of auras
+        else if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        {
+            parry_chance -= ToCreature()->GetCreatureExpertise() * 25;
+            parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+        }
+        //end npcbot
         else
             parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
 
@@ -2109,6 +2201,9 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackT
     }
 
     // Max 40% chance to score a glancing blow against mobs that are higher level (can do only players and pets and not with ranged weapon)
+    //npcbot - no glances
+    if (!(victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBot()))
+    //end npcbot
     if (attType != RANGED_ATTACK &&
         (GetTypeId() == TYPEID_PLAYER || ToCreature()->IsPet()) &&
         victim->GetTypeId() != TYPEID_PLAYER && !victim->ToCreature()->IsPet() &&
@@ -2666,6 +2761,10 @@ uint32 Unit::GetDefenseSkillValue(Unit const* target) const
         value += uint32(ToPlayer()->GetRatingBonusValue(CR_DEFENSE_SKILL));
         return value;
     }
+    //npcbot - defense
+    else if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        return ToCreature()->GetCreatureDefense();
+    //end npcbot
     else
         return GetUnitMeleeSkill(target);
 }
@@ -2684,6 +2783,10 @@ float Unit::GetUnitDodgeChance() const
         else
         {
             float dodge = 5.0f;
+            //npcbot - custom dodge chance instead of bunch of auras and remove base chance
+            if (ToCreature()->IsNPCBot())
+                dodge = ToCreature()->GetCreatureDodgeChance();
+            //end npcbot
             dodge += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
             return dodge > 0.0f ? dodge : 0.0f;
         }
@@ -2713,6 +2816,11 @@ float Unit::GetUnitParryChance() const
     {
         if (GetCreatureType() == CREATURE_TYPE_HUMANOID)
         {
+            //npcbot - custom parry chance instead of bunch of auras
+            if (ToCreature()->IsNPCBot())
+                chance = ToCreature()->GetCreatureParryChance();
+            else
+            //end npcbot
             chance = 5.0f;
             chance += GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
         }
@@ -2727,6 +2835,8 @@ float Unit::GetUnitMissChance(WeaponAttackType attType) const
 
     if (Player const* player = ToPlayer())
         miss_chance += player->GetMissPercentageFromDefence();
+    if (Creature const* creature = ToCreature())
+        miss_chance += (creature->GetCreatureDefense() - getLevel() * 5) * 0.04f;
 
     if (attType == RANGED_ATTACK)
         miss_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_HIT_CHANCE);
@@ -2759,6 +2869,10 @@ float Unit::GetUnitBlockChance() const
         else
         {
             float block = 5.0f;
+            //npcbot - custom block chance instead of bunch of auras and remove base chance
+            if (ToCreature()->IsNPCBot())
+                block = ToCreature()->GetCreatureBlockChance();
+            //end npcbot
             block += GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);
             return block > 0.0f ? block : 0.0f;
         }
@@ -2790,6 +2904,11 @@ float Unit::GetUnitCriticalChance(WeaponAttackType attackType, const Unit* victi
     }
     else
     {
+        //npcbot - custom crit chance instead of bunch of auras and remove base chance
+        if (ToCreature()->IsNPCBot())
+            crit = ToCreature()->GetCreatureCritChance();
+        else
+        //end npcbot
         crit = 5.0f;
         crit += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
         crit += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
@@ -5138,6 +5257,11 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
     Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
         ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
 
+    //npcbot: find bot equips
+    if (!castItem && GetTypeId() == TYPEID_UNIT && ToCreature()->GetIAmABot())
+        castItem = ToCreature()->GetBotEquipsByGuid(triggeredByAura->GetBase()->GetCastItemGUID());
+    //end npcbot
+
     uint32 triggered_spell_id = 0;
     uint32 cooldown_spell_id = 0; // for random trigger, will be one of the triggered spell to avoid repeatable triggers
                                   // otherwise, it's the triggered_spell_id by default
@@ -6064,6 +6188,12 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                     // Check cooldown of heal spell cooldown
                     if (GetTypeId() == TYPEID_PLAYER && !ToPlayer()->HasSpellCooldown(34299))
                         CastCustomSpell(this, 60889, &basepoints1, 0, 0, true, 0, triggeredByAura);
+
+                    //npcbot - proc for bot
+                    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot() && !ToCreature()->HasSpellCooldown(34299))
+                        CastCustomSpell(this, 60889, &basepoints1, 0, 0, true, 0, triggeredByAura);
+                    //end npcbot
+
                     break;
                 }
                 // Healing Touch (Dreamwalker Raiment set)
@@ -6161,6 +6291,14 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                     if (procSpell->SpellVisual[0] != 32)
                         return false;
 
+                    //npcbot: support for Item - Druid T10 Restoration 4P Bonus (Rejuvenation)
+                    if (victim != this && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+                    {
+                        CastCustomSpell(70691, SPELLVALUE_BASE_POINT0, damage, victim, true);
+                        return true;
+                    }
+                    //end npcbot
+
                     Player* caster = ToPlayer();
                     if (!caster)
                         return false;
@@ -6189,6 +6327,31 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                 triggered_spell_id = isWrathSpell ? 48518 : 48517;
                 break;
             }
+
+            //npcbot - Eclipse for bot
+            if (dummySpell->SpellIconID == 2856 && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+            {
+                if (!procSpell || effIndex != 0)
+                    return false;
+
+                bool isWrathSpell = (procSpell->SpellFamilyFlags[0] & 1);
+
+                if (!roll_chance_f(dummySpell->ProcChance * (isWrathSpell ? 0.6f : 1.0f)))
+                    return false;
+
+                target = this;
+                if (target->HasAura(isWrathSpell ? 48517 : 48518))
+                    return false;
+
+                triggered_spell_id = isWrathSpell ? 48518 : 48517;
+
+                if (ToCreature()->HasSpellCooldown(triggered_spell_id))
+                    return false;
+
+                break;
+            }
+            //end npcbot
+
             break;
         }
         case SPELLFAMILY_ROGUE:
@@ -6255,6 +6418,28 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                     if (!procSpell)
                         return false;
 
+                    //npcbot: calc amount
+                    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+                    {
+                        if (procSpell->SpellFamilyFlags[2] & 0x200)
+                        {
+                            if (!victim)
+                                return false;
+                            if (AuraEffect const* pEff = victim->GetAuraEffect(SPELL_AURA_PERIODIC_DUMMY, SPELLFAMILY_HUNTER, 0x0, 0x80000000, 0x0, GetGUID()))
+                                basepoints0 = pEff->GetSpellInfo()->CalcPowerCost(this, SpellSchoolMask(pEff->GetSpellInfo()->SchoolMask)) * 4/10/3;
+                        }
+                        else
+                            basepoints0 = procSpell->CalcPowerCost(this, SpellSchoolMask(procSpell->SchoolMask)) * 4/10;
+
+                        if (basepoints0 <= 0)
+                            return false;
+
+                        target = this;
+                        triggered_spell_id = 34720;
+                        break;
+                    }
+                    //end npcbot
+
                     Spell* spell = ToPlayer()->m_spellModTakingSpell;
 
                     // Disable charge drop because of Lock and Load
@@ -6335,6 +6520,57 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                     return false;
                 triggered_spell_id = 0;
                 Unit* beaconTarget = NULL;
+
+                //npcbot: handle bot-casted case (bot is non-free, only casted on party/raid)
+                if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBot())
+                {
+                    Player const* owner = victim->ToCreature()->GetBotOwner();
+                    if (Group const* gr = owner->GetGroup())
+                    {
+                        for (GroupReference const* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            if (Player* player = itr->GetSource())
+                            {
+                                if (player->GetAura(53563, victim->GetGUID()))
+                                {
+                                    if (player == this)
+                                        return false;
+
+                                    beaconTarget = player;
+                                    basepoints0 = int32(damage);
+                                    triggered_spell_id = procSpell->IsRankOf(sSpellMgr->GetSpellInfo(635)) ? 53652 : 53654;
+                                    break;
+                                }
+
+                                if (!player->HaveBot())
+                                    continue;
+
+                                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                                {
+                                    if (!gr->IsMember(itr->first))
+                                        continue;
+
+                                    Unit* u = itr->second;
+                                    if (u->IsAlive() && u->GetAura(53563, victim->GetGUID()))
+                                    {
+                                        if (u == this)
+                                            return false;
+
+                                        beaconTarget = u;
+                                        basepoints0 = int32(damage);
+                                        triggered_spell_id = procSpell->IsRankOf(sSpellMgr->GetSpellInfo(635)) ? 53652 : 53654;
+                                        break;
+                                    }
+                                }
+                                if (beaconTarget)
+                                    break;
+                            }
+                        }
+                    }
+                }
+                else
+                //end npcbot
                 if (GetTypeId() != TYPEID_PLAYER)
                 {
                     beaconTarget = triggeredByAura->GetBase()->GetCaster();
@@ -6363,6 +6599,29 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                                     triggered_spell_id = procSpell->IsRankOf(sSpellMgr->GetSpellInfo(635)) ? 53652 : 53654;
                                     break;
                                 }
+
+                                //npcbot: party with npcbots, heal cast on player case
+                                if (!member->HaveBot())
+                                    continue;
+
+                                BotMap const* map = member->GetBotMgr()->GetBotMap();
+                                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                                {
+                                    if (!group->IsMember(itr->first))
+                                        continue;
+
+                                    Unit* u = itr->second;
+                                    if (u->IsAlive() && u->GetAura(53563, victim->GetGUID()))
+                                    {
+                                        beaconTarget = u;
+                                        basepoints0 = int32(damage);
+                                        triggered_spell_id = procSpell->IsRankOf(sSpellMgr->GetSpellInfo(635)) ? 53652 : 53654;
+                                        break;
+                                    }
+                                }
+                                if (beaconTarget)
+                                    break;
+                                //end npcbot
                             }
                         }
                     }
@@ -6737,6 +6996,77 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                 // Windfury Weapon (Passive) 1-8 Ranks
                 case 33757:
                 {
+                    //npcbot: handle bot enchant
+                    if (Creature* bot = ToCreature())
+                    {
+                        if (!bot->GetIAmABot() || !castItem || !victim || !victim->IsAlive())
+                            return false;
+
+                        //dummySpell->Id must be init'ed
+                        if (cooldown && bot->HasSpellCooldown(dummySpell->Id))
+                            return false;
+
+                        if (triggeredByAura->GetBase() && castItem->GetGUID() != triggeredByAura->GetBase()->GetCastItemGUID())
+                            return false;
+
+                        WeaponAttackType attType = bot->GetBotEquips(0/*BOT_SLOT_MAINHAND*/) == castItem ? BASE_ATTACK : OFF_ATTACK;
+                        if ((attType != BASE_ATTACK && attType != OFF_ATTACK)
+                            || (attType == BASE_ATTACK && procFlag & PROC_FLAG_DONE_OFFHAND_ATTACK)
+                            || (attType == OFF_ATTACK && procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK))
+                             return false;
+
+                        uint32 chance = 20;
+                        if (getLevel() >= 30)
+                            chance += 2;
+
+                        Item const* addWeapon = bot->GetBotEquips(attType == BASE_ATTACK ? 1/*BOT_SLOT_OFFHAND*/ : 0/*BOT_SLOT_MAINHAND*/);
+                        uint32 enchant_id_add = addWeapon ? addWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) : 0;
+                        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id_add);
+                        if (pEnchant && pEnchant->spellid[0] == dummySpell->Id)
+                            chance += 14;
+
+                        if (!roll_chance_i(chance))
+                            return false;
+
+                        uint32 spellId;
+                        switch (castItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+                        {
+                            case 283: spellId =  8232; break;   // 1 Rank
+                            case 284: spellId =  8235; break;   // 2 Rank
+                            case 525: spellId = 10486; break;   // 3 Rank
+                            case 1669:spellId = 16362; break;   // 4 Rank
+                            case 2636:spellId = 25505; break;   // 5 Rank
+                            case 3785:spellId = 58801; break;   // 6 Rank
+                            case 3786:spellId = 58803; break;   // 7 Rank
+                            case 3787:spellId = 58804; break;   // 8 Rank
+                            default:
+                            {
+                                TC_LOG_ERROR("entities.unit", "Unit::HandleDummyAuraProc (bot): non handled item enchantment (rank?) %u for spell id: %u (Windfury)",
+                                    castItem->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)), dummySpell->Id);
+                                return false;
+                            }
+                        }
+
+                        SpellInfo const* windfurySpellInfo = sSpellMgr->GetSpellInfo(spellId);
+                        if (!windfurySpellInfo)
+                        {
+                            TC_LOG_ERROR("entities.unit", "Unit::HandleDummyAuraProc (bot): non-existing spell id: %u (Windfury)", spellId);
+                            return false;
+                        }
+
+                        int32 extra_attack_power = CalculateSpellDamage(victim, windfurySpellInfo, 1);
+                        basepoints0 = int32(extra_attack_power / 14.0f * GetAttackTime(attType) / 1000);
+                        triggered_spell_id = (procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK) ? 25504 : 33750;
+
+                        if (cooldown)
+                            bot->AddBotSpellCooldown(dummySpell->Id, cooldown * IN_MILLISECONDS);
+
+                        for (uint32 i = 0; i != 2; ++i)
+                            CastCustomSpell(victim, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
+
+                        return true;
+                    }
+
                     Player* player = ToPlayer();
                     if (!player || !castItem || !castItem->IsEquipped() || !victim || !victim->IsAlive())
                         return false;
@@ -7434,6 +7764,11 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
     if (cooldown_spell_id == 0)
         cooldown_spell_id = triggered_spell_id;
 
+    //npcbot: check bot cd
+    if (cooldown && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot() && ToCreature()->HasSpellCooldown(cooldown_spell_id))
+        return false;
+    //end npcbot
+
     if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(cooldown_spell_id))
         return false;
 
@@ -7445,6 +7780,11 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
     if (cooldown && GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->AddSpellCooldown(cooldown_spell_id, 0, time(NULL) + cooldown);
 
+    //npcbot: add cd for bots
+    if (cooldown && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->AddBotSpellCooldown(cooldown_spell_id, cooldown * IN_MILLISECONDS);
+    //end npcbot
+
     return true;
 }
 
@@ -8189,6 +8529,24 @@ bool Unit::HandleProcTriggerSpell(Unit* victim, uint32 damage, AuraEffect* trigg
         case 12849:
         case 12867:
         {
+            //npcbot: Deep Wounds for bots
+            if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+            {
+                // now compute approximate weapon damage by formula from wowwiki.com
+                Item const* item = ToCreature()->GetBotEquips((procFlags & PROC_FLAG_DONE_OFFHAND_ATTACK) ? 1/*BOT_SLOT_OFFHAND*/ : 0/*BOT_SLOT_MAINHAND*/);
+                if (!item)
+                    return false;
+
+                ItemTemplate const* weapon = item->GetTemplate();
+
+                float weaponDPS = weapon->getDPS();
+                float attackPowerDPS = GetTotalAttackPowerValue(BASE_ATTACK) / 14.0f;
+                float weaponSpeed = float(weapon->Delay) / 1000.0f;
+                basepoints0 = int32((weaponDPS + attackPowerDPS) * weaponSpeed);
+                break;
+            }
+            //end npcbot
+
             if (GetTypeId() != TYPEID_PLAYER)
                 return false;
 
@@ -8362,6 +8720,20 @@ bool Unit::HandleProcTriggerSpell(Unit* victim, uint32 damage, AuraEffect* trigg
             if (!target)
                 return false;
 
+            //npcbot: handle for bots
+            if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBot())
+            {
+                if (cooldown && target->ToCreature()->HasSpellCooldown(trigger_spell_id))
+                    return false;
+
+                target->CastSpell(target, trigger_spell_id, true, castItem, triggeredByAura);
+
+                if (cooldown)
+                    target->ToCreature()->AddBotSpellCooldown(trigger_spell_id, cooldown * IN_MILLISECONDS);
+                return true;
+            }
+            //end npcbot
+
             if (cooldown && target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->HasSpellCooldown(trigger_spell_id))
                 return false;
 
@@ -8544,6 +8916,11 @@ bool Unit::HandleProcTriggerSpell(Unit* victim, uint32 damage, AuraEffect* trigg
         }
     }
 
+    //npcbot: check bot cd
+    if (cooldown && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot() && ToCreature()->HasSpellCooldown(trigger_spell_id))
+        return false;
+    //end npcbot
+
     if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(trigger_spell_id))
         return false;
 
@@ -8559,6 +8936,11 @@ bool Unit::HandleProcTriggerSpell(Unit* victim, uint32 damage, AuraEffect* trigg
     if (cooldown && GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->AddSpellCooldown(trigger_spell_id, 0, time(NULL) + cooldown);
 
+    //npcbot: add cd for bots
+    if (cooldown && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->AddBotSpellCooldown(trigger_spell_id, cooldown * IN_MILLISECONDS);
+    //end npcbot
+
     return true;
 }
 
@@ -8653,6 +9035,11 @@ bool Unit::HandleOverrideClassScriptAuraProc(Unit* victim, uint32 /*damage*/, Au
         return false;
     }
 
+    //npcbot: check bot cd
+    if (cooldown && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot() && ToCreature()->HasSpellCooldown(triggered_spell_id))
+        return false;
+    //end npcbot
+
     if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(triggered_spell_id))
         return false;
 
@@ -8661,6 +9048,11 @@ bool Unit::HandleOverrideClassScriptAuraProc(Unit* victim, uint32 /*damage*/, Au
     if (cooldown && GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, time(NULL) + cooldown);
 
+    //npcbot: add cd for bots
+    if (cooldown && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->AddBotSpellCooldown(triggered_spell_id, cooldown * IN_MILLISECONDS);
+    //end npcbot
+
     return true;
 }
 
@@ -8982,6 +9374,9 @@ bool Unit::Attack(Unit* victim, bool meleeAttack)
     //    ToCreature()->SetCombatStartPosition(GetPositionX(), GetPositionY(), GetPositionZ());
 
     if (GetTypeId() == TYPEID_UNIT && !ToCreature()->IsPet())
+    //npcbot - not for npcbots either
+    if (!ToCreature()->IsNPCBot())
+    //end npcbot
     {
         // should not let player enter combat by right clicking target - doesn't helps
         SetInCombatWith(victim);
@@ -9065,6 +9460,15 @@ void Unit::CombatStopWithPets(bool includingCast)
 
     for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
         (*itr)->CombatStop(includingCast);
+
+    //npcbot: combatstop for bots
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->HaveBot())
+    {
+        BotMap const* map = ToPlayer()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            itr->second->CombatStop(includingCast);
+    }
+    //end npcbot
 }
 
 bool Unit::isAttackingPlayer() const
@@ -10295,6 +10699,11 @@ uint32 Unit::SpellDamageBonusTaken(Unit* caster, SpellInfo const* spellProto, ui
     // multiplicative bonus, for example Dispersion + Shadowform (0.10*0.85=0.085)
     TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, spellProto->GetSchoolMask());
 
+    //npcbot - damage taken modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        TakenTotalMod *= ToCreature()->GetCreatureDamageTakenMod();
+    //end npcbot
+
     //.. taken pct: dummy auras
     AuraEffectList const& mDummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
     for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
@@ -10378,6 +10787,11 @@ int32 Unit::SpellBaseDamageBonusDone(SpellSchoolMask schoolMask) const
 {
     int32 DoneAdvertisedBenefit = 0;
 
+    //npcbot: apply bot spellpower
+    if (schoolMask && !(schoolMask & SPELL_SCHOOL_MASK_NORMAL) && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        DoneAdvertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     AuraEffectList const& mDamageDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
     for (AuraEffectList::const_iterator i = mDamageDone.begin(); i != mDamageDone.end(); ++i)
         if (((*i)->GetMiscValue() & schoolMask) != 0 &&
@@ -10430,6 +10844,9 @@ bool Unit::isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMas
     //! Mobs can't crit with spells. Player Totems can
     //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
     if (IS_CREATURE_GUID(GetGUID()) && !(IsTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && GetEntry() != 15438)
+        //npcbot - allow bots to crit
+        if (!ToCreature()->IsNPCBot())
+        //end npcbot
         return false;
 
     // not critting spell
@@ -10617,6 +11034,11 @@ bool Unit::isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMas
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRITICAL_CHANCE, crit_chance);
 
+    //npcbot - apply bot spell crit mods
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->ApplyBotCritMultiplierAll(victim, crit_chance, spellProto, schoolMask, attackType);
+    //end npcbot
+
     crit_chance = crit_chance > 0.0f ? crit_chance : 0.0f;
     if (roll_chance_f(crit_chance))
         return true;
@@ -10841,6 +11263,11 @@ uint32 Unit::SpellHealingBonusDone(Unit* victim, SpellInfo const* spellProto, ui
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
 
+    //npcbot - healing bonus done for bots
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->ApplyBotDamageMultiplierHeal(victim, heal, spellProto, damagetype, stack);
+    //end npcbot
+
     return uint32(std::max(heal, 0.0f));
 }
 
@@ -10958,6 +11385,11 @@ int32 Unit::SpellBaseHealingBonusDone(SpellSchoolMask schoolMask) const
         if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & schoolMask) != 0)
             advertisedBenefit += (*i)->GetAmount();
 
+    //npcbot: apply bot spellpower to healing
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        advertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     // Healing bonus of spirit, intellect and strength
     if (GetTypeId() == TYPEID_PLAYER)
     {
@@ -11049,6 +11481,11 @@ bool Unit::IsImmunedToSpell(SpellInfo const* spellInfo) const
     if (spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
         return false;
 
+    //npcbot - check 'magic immunity' state and other
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot() && ToCreature()->IsCreatureImmuneToSpell(spellInfo))
+        return true;
+    //end npcbot
+
     if (spellInfo->Dispel)
     {
         SpellImmuneList const& dispelList = m_spellImmune[IMMUNITY_DISPEL];
@@ -11348,6 +11785,11 @@ uint32 Unit::MeleeDamageBonusTaken(Unit* attacker, uint32 pdamage, WeaponAttackT
     // ..taken
     TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, attacker->GetMeleeDamageSchoolMask());
 
+    //npcbot - damage taken modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        TakenTotalMod *= ToCreature()->GetCreatureDamageTakenMod();
+    //end npcbot
+
     // .. taken pct (special attacks)
     if (spellProto)
     {
@@ -11688,6 +12130,12 @@ void Unit::SetInCombatState(bool PvP, Unit* enemy)
     if (PvP)
         m_CombatTimer = 5000;
 
+    ////npcbot - if combat with npcbot or its pet set extended timer
+    //if (PvP &&((GetTypeId() == TYPEID_UNIT && ToCreature()->IsFreeBot()) ||
+    //    (enemy->GetTypeId() == TYPEID_UNIT && enemy->ToCreature()->IsFreeBot())))
+    //    m_CombatTimer += 5000;
+    ////end npcbot
+
     if (IsInCombat() || HasUnitState(UNIT_STATE_EVADE))
         return;
 
@@ -11728,6 +12176,15 @@ void Unit::SetInCombatState(bool PvP, Unit* enemy)
         (*itr)->SetInCombatState(PvP, enemy);
         (*itr)->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
     }
+
+    //npcbot: combatstop for bots
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->HaveBot())
+    {
+        BotMap const* map = ToPlayer()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            itr->second->SetInCombatState(PvP, enemy);
+    }
+    //end npcbot
 }
 
 void Unit::ClearInCombat()
@@ -11795,6 +12252,11 @@ bool Unit::_IsValidAttackTarget(Unit const* target, SpellInfo const* bySpell, Wo
         || (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->IsGameMaster()))
         return false;
 
+    //npcbot: can't attack unit if controlled by a GM (bots, pets, possible others)
+    if (target->IsControlledByPlayer() && target->getFaction() == 35)
+        return false;
+    //end npcbot
+
     // can't attack own vehicle or passenger
     if (m_vehicle)
         if (IsOnVehicle(target) || m_vehicle->GetBase()->IsOnVehicle(target))
@@ -12107,6 +12569,12 @@ bool Unit::IsAlwaysVisibleFor(WorldObject const* seer) const
                 if (ownerPlayer->IsGroupVisibleFor(seerPlayer))
                     return true;
 
+    //npcbot - bots are always visible for owner
+    if (Creature const* bot = ToCreature())
+        if (bot->GetBotAI() && seer->GetGUID() == bot->GetBotOwner()->GetGUID())
+            return true;
+    //end npcbot
+
     return false;
 }
 
@@ -12473,6 +12941,11 @@ bool Unit::CanHaveThreatList(bool skipAliveCheck) const
     if (HasUnitTypeMask(UNIT_MASK_MINION | UNIT_MASK_GUARDIAN | UNIT_MASK_CONTROLABLE_GUARDIAN) && IS_PLAYER_GUID(((Pet*)this)->GetOwnerGUID()))
         return false;
 
+    //npcbot - npcbots and their pets cannot have threatlist
+    if (ToCreature()->IsNPCBot())
+        return false;
+    //end npcbot
+
     return true;
 }
 
@@ -12739,6 +13212,11 @@ int32 Unit::CalcSpellDuration(SpellInfo const* spellProto)
 {
     uint8 comboPoints = m_movedPlayer ? m_movedPlayer->GetComboPoints() : 0;
 
+    //npcbot: combo points support for spell duration
+    if (!comboPoints && !m_movedPlayer && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        comboPoints = ToCreature()->GetCreatureComboPoints();
+    //end npcbot
+
     int32 minduration = spellProto->GetDuration();
     int32 maxduration = spellProto->GetMaxDuration();
 
@@ -12862,6 +13340,11 @@ void Unit::ModSpellCastTime(SpellInfo const* spellProto, int32 & castTime, Spell
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CASTING_TIME, castTime, spell);
 
+    //npcbot - apply bot spell cast time mods
+    if (castTime > 0 && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->ApplyCreatureSpellCastTimeMods(spellProto, castTime);
+    //end npcbot
+
     if (!(spellProto->Attributes & (SPELL_ATTR0_ABILITY|SPELL_ATTR0_TRADESPELL)) && ((GetTypeId() == TYPEID_PLAYER && spellProto->SpellFamilyName) || GetTypeId() == TYPEID_UNIT))
         castTime = int32(float(castTime) * GetFloatValue(UNIT_MOD_CAST_SPEED));
     else if (spellProto->Attributes & SPELL_ATTR0_REQ_AMMO && !(spellProto->AttributesEx2 & SPELL_ATTR2_AUTOREPEAT_FLAG))
@@ -13036,6 +13519,18 @@ uint32 Unit::GetCreatureType() const
             return CREATURE_TYPE_HUMANOID;
     }
     else
+    //npcbot: support for druid's shapeshifting
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetIAmABot())
+    {
+        ShapeshiftForm form = GetShapeshiftForm();
+        SpellShapeshiftEntry const* ssEntry = sSpellShapeshiftStore.LookupEntry(form);
+        if (ssEntry && ssEntry->creatureType > 0)
+            return ssEntry->creatureType;
+        else
+            return CREATURE_TYPE_HUMANOID;
+    }
+    else
+    //end npcbot
         return ToCreature()->GetCreatureTemplate()->type;
 }
 
@@ -13988,6 +14483,14 @@ void Unit::ProcDamageAndSpellFor(bool isVictim, Unit* target, uint32 procFlag, u
                     ModifyAuraState(AURA_STATE_DEFENSE, true);
                     StartReactiveTimer(REACTIVE_DEFENSE);
                 }
+                //npcbot - update reactives for bots (victim)
+                if ((procExtra & PROC_EX_PARRY) && GetTypeId() == TYPEID_UNIT &&
+                    ToCreature()->IsNPCBot() && ToCreature()->GetBotClass() == CLASS_HUNTER)
+                {
+                    ModifyAuraState(AURA_STATE_HUNTER_PARRY, true);
+                    StartReactiveTimer(REACTIVE_HUNTER_PARRY);
+                }
+                //end npcbot
             }
             else // For attacker
             {
@@ -13997,6 +14500,14 @@ void Unit::ProcDamageAndSpellFor(bool isVictim, Unit* target, uint32 procFlag, u
                     ToPlayer()->AddComboPoints(target, 1);
                     StartReactiveTimer(REACTIVE_OVERPOWER);
                 }
+
+                //npcbot - update reactives for bots (attacker)
+                if ((procExtra & (PROC_EX_DODGE | PROC_EX_PARRY)) && GetTypeId() == TYPEID_UNIT &&
+                    ToCreature()->IsNPCBot() && ToCreature()->GetBotClass() == CLASS_WARRIOR)
+                {
+                    StartReactiveTimer(REACTIVE_OVERPOWER);
+                }
+                //end npcbot
             }
         }
     }
@@ -14098,6 +14609,11 @@ void Unit::ProcDamageAndSpellFor(bool isVictim, Unit* target, uint32 procFlag, u
         if (prepare && GetTypeId() == TYPEID_PLAYER && i->spellProcEvent && i->spellProcEvent->cooldown)
             cooldown = i->spellProcEvent->cooldown;
 
+        //npcbot: Cooldown for npcbots too
+        if (prepare && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot() && i->spellProcEvent && i->spellProcEvent->cooldown)
+            cooldown = i->spellProcEvent->cooldown;
+        //end npcbot
+
         // Note: must SetCantProc(false) before return
         if (spellInfo->AttributesEx3 & SPELL_ATTR3_DISABLE_PROC)
             SetCantProc(true);
@@ -14542,6 +15058,29 @@ void Unit::ClearComboPointHolders()
     }
 }
 
+//npcbot
+void Unit::ClearReactive(ReactiveType reactive)
+{
+    m_reactiveTimer[reactive] = 0;
+
+    switch (reactive)
+    {
+        case REACTIVE_DEFENSE:
+            if (HasAuraState(AURA_STATE_DEFENSE))
+                ModifyAuraState(AURA_STATE_DEFENSE, false);
+            break;
+        case REACTIVE_HUNTER_PARRY:
+            if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
+                ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
+            break;
+        case REACTIVE_OVERPOWER:
+            if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)
+                ToPlayer()->ClearComboPoints();
+            break;
+    }
+}
+//end npcbot
+
 void Unit::ClearAllReactives()
 {
     for (uint8 i = 0; i < MAX_REACTIVE; ++i)
@@ -14650,6 +15189,9 @@ uint32 Unit::GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectTyp
 {
     // Not apply this to creature casted spells with casttime == 0
     if (CastingTime == 0 && GetTypeId() == TYPEID_UNIT && !ToCreature()->IsPet())
+        //npcbot - skip bots
+        if (!ToCreature()->IsNPCBot())
+        //endnpcbot
         return 3500;
 
     if (CastingTime > 7000) CastingTime = 7000;
@@ -15037,6 +15579,12 @@ bool Unit::IsTriggeredAtSpellProcEvent(Unit* victim, Aura* aura, SpellInfo const
     {
         modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CHANCE_OF_SUCCESS, chance);
     }
+    //npcbot: apply chance of success spellmods for bots
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+    {
+        ToCreature()->ApplyCreatureSpellChanceOfSuccessMods(spellProto, chance);
+    }
+    //end npcbot
     return roll_chance_f(chance);
 }
 
@@ -15286,6 +15834,9 @@ void Unit::Kill(Unit* victim, bool durabilityLoss)
 
         // only if not player and not controlled by player pet. And not at BG
         if ((durabilityLoss && !player && !victim->ToPlayer()->InBattleground()) || (player && sWorld->getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP)))
+        //npcbot - bots should not cause durability loss unless rampaging around
+        if (player || !ToCreature()->GetBotAI() || ToCreature()->GetBotOwner()->GetGUIDLow() == GetGUIDLow())
+        //end npcbot
         {
             TC_LOG_DEBUG("entities.unit", "We are dead, losing %f percent durability", sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH));
             plrVictim->DurabilityLossAll(sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH), false);
@@ -16229,6 +16780,21 @@ float Unit::MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, i
     //calculate miss chance
     float missChance = victim->GetUnitMissChance(attType);
 
+    //npcbot - custom miss chance instead of bunch of auras, extra miss chance against bots
+    //bot can have extra miss chance for attackers
+    //but if attacker is also a bot and cannot miss then return this extra miss chance
+    //float evasion = 0.0f;
+
+    //if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBot())
+    //    evasion = victim->ToCreature()->GetCreatureEvasion();
+    //if (GetTypeId() == TYPEID_UNIT && !ToCreature()->CanMiss())
+    //    return evasion;
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        missChance += ToCreature()->GetCreatureMissChance();
+
+    //missChance += evasion;
+    //end npcbot
+
     if (!spellId && haveOffhandWeapon())
         missChance += 19;
 
@@ -16257,6 +16823,11 @@ float Unit::MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, i
     else
         missChance -= m_modMeleeHitChance;
 
+    //npcbot - limit chance from 30% to 60% if evasion is here
+    //if (evasion > 0.0f && missChance < evasion)
+    //    missChance = evasion;
+    //end npcbot
+
     // Limit miss chance from 0 to 60%
     if (missChance < 0.0f)
         return 0.0f;
@@ -16316,6 +16887,11 @@ void Unit::SetPhaseMask(uint32 newPhaseMask, bool update)
         if ((*itr)->GetTypeId() == TYPEID_UNIT)
             (*itr)->SetPhaseMask(newPhaseMask, true);
 
+    //npcbot: update for temporarily uncontrolled bots (teleport, taxi)
+    if (GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->UpdatePhaseForBots();
+    //end npcbot
+
     for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
         if (m_SummonSlot[i])
             if (Creature* summon = GetMap()->GetCreature(m_SummonSlot[i]))
@@ -16563,6 +17139,183 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form) const
                 break;
         }
     }
+    else if (ToCreature() && ToCreature()->GetBotOwner() && ToCreature()->GetBotOwner()->ToPlayer())
+    {
+        //this has to be modified after implementation of bots' appearances which will include player bytes emulation
+        Player const* player = ToCreature()->GetBotOwner();
+        //let's make druids look according to player but base model must be selected based on our race
+        switch (form)
+        {
+            case FORM_CAT:
+                // Based on master's Hair color
+                if (getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 7: // Violet
+                        case 8:
+                            return 29405;
+                        case 3: // Light Blue
+                            return 29406;
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29407;
+                        case 4: // White
+                            return 29408;
+                        default: // original - Dark Blue
+                            return 892;
+                    }
+                }
+                // Based on master's Skin color
+                else if (getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male master
+                    if (getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 12: // White
+                            case 13:
+                            case 14:
+                            case 18: // Completly White
+                                return 29409;
+                            case 9: // Light Brown
+                            case 10:
+                            case 11:
+                                return 29410;
+                            case 6: // Brown
+                            case 7:
+                            case 8:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3: // Dark Grey
+                            case 4:
+                            case 5:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                    // Female master
+                    else switch (skinColor)
+                    {
+                        case 10: // White
+                            return 29409;
+                        case 6: // Light Brown
+                        case 7:
+                            return 29410;
+                        case 4: // Brown
+                        case 5:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                else if (Player::TeamForRace(getRace()) == ALLIANCE)
+                    return 892;
+                else
+                    return 8571;
+            case FORM_DIREBEAR:
+            case FORM_BEAR:
+                // Based on Hair color
+                if (getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29413; // 29415?
+                        case 6: // Dark Blue
+                            return 29414;
+                        case 4: // White
+                            return 29416;
+                        case 3: // Light Blue
+                            return 29417;
+                        default: // original - Violet
+                            return 2281;
+                    }
+                }
+                // Based on Skin color
+                else if (getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                            case 2:
+                                return 29418;
+                            case 3: // White
+                            case 4:
+                            case 5:
+                            case 12:
+                            case 13:
+                            case 14:
+                                return 29419;
+                            case 9: // Light Brown/Grey
+                            case 10:
+                            case 11:
+                            case 15:
+                            case 16:
+                            case 17:
+                                return 29420;
+                            case 18: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                    // Female
+                    else switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                            return 29418;
+                        case 2: // White
+                        case 3:
+                            return 29419;
+                        case 6: // Light Brown/Grey
+                        case 7:
+                        case 8:
+                        case 9:
+                            return 29420;
+                        case 10: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                else if (Player::TeamForRace(getRace()) == ALLIANCE)
+                    return 2281;
+                else
+                    return 2289;
+            case FORM_FLIGHT:
+                if (Player::TeamForRace(getRace()) == ALLIANCE)
+                    return 20857;
+                return 20872;
+            case FORM_FLIGHT_EPIC:
+                if (Player::TeamForRace(getRace()) == ALLIANCE)
+                    return 21243;
+                return 21244;
+            default:
+                break;
+        }
+    }
 
     uint32 modelid = 0;
     SpellShapeshiftEntry const* formEntry = sSpellShapeshiftStore.LookupEntry(form);
@@ -17196,6 +17949,15 @@ void Unit::StopAttackFaction(uint32 faction_id)
 
     for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
             (*itr)->StopAttackFaction(faction_id);
+
+    //npcbot: stopattackfaction for bots
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->HaveBot())
+    {
+        BotMap const* map = ToPlayer()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            itr->second->StopAttackFaction(faction_id);
+    }
+    //end npcbot
 }
 
 void Unit::OutDebugInfo() const
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index e8a318d..f8b33e8 100644
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -2128,6 +2128,9 @@ class Unit : public WorldObject
         time_t GetLastDamagedTime() const { return _lastDamagedTime; }
         void SetLastDamagedTime(time_t val) { _lastDamagedTime = val; }
 
+        bool HasReactive(ReactiveType reactive) const { return m_reactiveTimer[reactive] > 0; }
+        void ClearReactive(ReactiveType reactive);
+
     protected:
         explicit Unit (bool isWorldObject);
 
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 3d56225..691a1c9 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -7736,6 +7736,82 @@ SkillRangeType GetSkillRangeType(SkillLineEntry const* pSkill, bool racial)
     }
 }
 
+void ObjectMgr::LoadCreatureOutfits()
+{
+    uint32 oldMSTime = getMSTime();
+
+    _creatureOutfitStore.clear();                           // for reload case (test only)
+
+    //                                                 0     1      2      3     4     5       6           7
+    QueryResult result = WorldDatabase.Query("SELECT entry, race, gender, skin, face, hair, haircolor, facialhair, "
+        //8       9        10    11     12     13    14     15     16     17     18
+        "head, shoulders, body, chest, waist, legs, feet, wrists, hands, back, tabard FROM creature_template_outfits");
+
+    if (!result)
+    {
+        TC_LOG_ERROR("server.loading", ">> Loaded 0 creature outfits. DB table `creature_template_outfits` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 i = 0;
+        uint32 entry     = fields[i++].GetUInt32();
+
+        if (!GetCreatureTemplate(entry))
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits`, but not in `creature_template`!", entry);
+            continue;
+        }
+
+        CreatureOutfit co; // const, shouldnt be changed after saving
+        co.race          = fields[i++].GetUInt8();
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(co.race);
+        if (!rEntry)
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has incorrect race (%u).", entry, uint32(co.race));
+            continue;
+        }
+        co.gender        = fields[i++].GetUInt8();
+        // Set correct displayId
+        switch (co.gender)
+        {
+            case GENDER_FEMALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_f;
+                break;
+            case GENDER_MALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_m;
+                break;
+            default:
+                TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has invalid gender %u", entry, uint32(co.gender));
+                continue;
+        }
+        _creatureTemplateStore[entry].Modelid2 = 0;
+        _creatureTemplateStore[entry].Modelid3 = 0;
+        _creatureTemplateStore[entry].Modelid4 = 0;
+        _creatureTemplateStore[entry].unit_flags2 |= UNIT_FLAG2_MIRROR_IMAGE; // Needed so client requests mirror packet
+
+        co.skin          = fields[i++].GetUInt8();
+        co.face          = fields[i++].GetUInt8();
+        co.hair          = fields[i++].GetUInt8();
+        co.haircolor     = fields[i++].GetUInt8();
+        co.facialhair    = fields[i++].GetUInt8();
+        for (uint32 j = 0; j != MAX_CREATURE_OUTFIT_DISPLAYS; ++j)
+            co.outfit[j] = fields[i+j].GetUInt32();
+
+        _creatureOutfitStore[entry] = co;
+
+        ++count;
+    }
+    while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u creature outfits in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
 void ObjectMgr::LoadGameTele()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index bf835ed..1d130f8 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -144,6 +144,21 @@ struct GameTele
 
 typedef UNORDERED_MAP<uint32, GameTele > GameTeleContainer;
 
+#define MAX_CREATURE_OUTFIT_DISPLAYS 11
+struct CreatureOutfit
+{
+    uint8 race;
+    uint8 gender;
+    uint8 face;
+    uint8 skin;
+    uint8 hair;
+    uint8 facialhair;
+    uint8 haircolor;
+    uint32 outfit[MAX_CREATURE_OUTFIT_DISPLAYS];
+};
+
+typedef UNORDERED_MAP<uint32, CreatureOutfit > CreatureOutfitContainer;
+
 enum ScriptsType
 {
     SCRIPTS_FIRST = 1,
@@ -966,6 +981,7 @@ class ObjectMgr
 
         void LoadNPCSpellClickSpells();
 
+        void LoadCreatureOutfits();
         void LoadGameTele();
 
         void LoadGossipMenu();
@@ -1166,6 +1182,8 @@ class ObjectMgr
         bool AddGameTele(GameTele& data);
         bool DeleteGameTele(std::string const& name);
 
+        CreatureOutfitContainer const& GetCreatureOutfitMap() const { return _creatureOutfitStore; }
+
         TrainerSpellData const* GetNpcTrainerSpells(uint32 entry) const
         {
             CacheTrainerSpellContainer::const_iterator  iter = _cacheTrainerSpellStore.find(entry);
@@ -1310,6 +1328,8 @@ class ObjectMgr
         PageTextContainer _pageTextStore;
         InstanceTemplateContainer _instanceTemplateStore;
 
+        CreatureOutfitContainer _creatureOutfitStore;
+
     private:
         void LoadScripts(ScriptsType type);
         void CheckScripts(ScriptsType type, std::set<int32>& ids);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 272fd89..02309cd 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -106,6 +106,12 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    //npcbot - set loot mode on create
+    //TC_LOG_ERROR("entities.player", "Group::Create(): new group with leader %s", leader->GetName().c_str());
+    if (leader->HaveBot()) //player + npcbot so set to free-for-all on create
+        m_lootMethod = FREE_FOR_ALL;
+    else
+    //end npcbot
     if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
 
@@ -361,6 +367,11 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
+    //npcbot - check if trying to add bot
+    //TC_LOG_ERROR("entities.player", "Group::AddMember(): new member %s", player->GetName().c_str());
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
+    //end npcbot
     player->SetGroupInvite(NULL);
     if (player->GetGroup())
     {
@@ -376,6 +387,9 @@ bool Group::AddMember(Player* player)
     InstanceGroupBind* bind = GetBoundInstance(player);
     if (bind && bind->save->GetInstanceId() == player->GetInstanceId())
         player->m_InstanceValid = true;
+    //npcbot
+    }
+    //end npcbot
 
     if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
     {
@@ -401,6 +415,10 @@ bool Group::AddMember(Player* player)
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
+    //npcbot - check 2
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
+    //end npcbot
     if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
     {
         // reset the new member's instances, unless he is currently in one of them
@@ -476,6 +494,9 @@ bool Group::AddMember(Player* player)
 
     if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
         m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    //npcbot
+    }
+    //end npcbot
 
     return true;
 }
@@ -490,6 +511,35 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod& method /*= GROUP_REMOV
     if (isLFGGroup() && method == GROUP_REMOVEMETHOD_KICK)
         return m_memberSlots.size();
 
+    //npcbot: skip group size check before removing a bot
+    if (!IS_PLAYER_GUID(guid))
+    {
+        // Remove bot from group in DB
+        if (!isBGGroup() && !isBFGroup())
+        {
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_MEMBER);
+            stmt->setUInt32(0, GUID_LOPART(guid));
+            CharacterDatabase.Execute(stmt);
+            DelinkMember(guid);
+        }
+        // Update subgroup
+        member_witerator slot = _getMemberWSlot(guid);
+        if (slot != m_memberSlots.end())
+        {
+            SubGroupCounterDecrease(slot->group);
+            m_memberSlots.erase(slot);
+        }
+
+        SendUpdate();
+
+        //there were only 1 player and 1 bot
+        if (GetMembersCount() < 2)
+            Disband();
+
+        return true;
+    }
+    else
+    //end npcbot
     // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG/BF allow 1 member group)
     if (GetMembersCount() > ((isBGGroup() || isLFGGroup() || isBFGroup()) ? 1u : 2u))
     {
@@ -599,6 +649,9 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod& method /*= GROUP_REMOV
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot: prevent group from being disbanded due to checking only players count
+        if (GetMembersCount() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index 0f55aba..b859d56 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -307,6 +307,9 @@ class Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        //Bot
+        uint64 const *GetTargetIcons() const { return m_targetIcons; }
+
     protected:
         bool _setMembersGroup(uint64 guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index b264b0d..d4c6bd1 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -566,8 +566,38 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
     if (!unit)
         return;
 
+    //bot
+    if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        CreatureOutfitContainer const& outfits = sObjectMgr->GetCreatureOutfitMap();
+        CreatureOutfitContainer::const_iterator it = outfits.find(unit->GetEntry());
+        if (it != outfits.end())
+        {
+            WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+            data << uint64(guid);
+            data << uint32(unit->GetNativeDisplayId()); // displayId
+            data << uint8(it->second.race);             // race
+            data << uint8(it->second.gender);           // gender
+            data << uint8(unit->getClass());            // class
+            data << uint8(it->second.skin);             // skin
+            data << uint8(it->second.face);             // face
+            data << uint8(it->second.hair);             // hair
+            data << uint8(it->second.haircolor);        // haircolor
+            data << uint8(it->second.facialhair);       // facialhair
+            data << uint32(0);                          // guildId
+
+            // item displays
+            for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
+                data << uint32(it->second.outfit[i]);
+
+            SendPacket(&data);
+            return;
+        }
+    }
+
     if (!unit->HasAuraType(SPELL_AURA_CLONE_CASTER))
         return;
+    //end bot
 
     // Get creator of the unit (SPELL_AURA_CLONE_CASTER does not stack)
     Unit* creator = unit->GetAuraEffectsByType(SPELL_AURA_CLONE_CASTER).front()->GetCaster();
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 6f99ee0..d54078e 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -36,6 +36,10 @@
 #include "Vehicle.h"
 #include "VMapFactory.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 u_map_magic MapMagic        = { {'M','A','P','S'} };
 u_map_magic MapVersionMagic = { {'v','1','.','3'} };
 u_map_magic MapAreaMagic    = { {'A','R','E','A'} };
@@ -2487,6 +2491,21 @@ uint32 Map::GetPlayersCountExceptGMs() const
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
         if (!itr->GetSource()->IsGameMaster())
+            //npcbot - count npcbots as group members (event if not in group)
+            if (itr->GetSource()->HaveBot() && BotMgr::LimitBots(this))
+            {
+                ++count;
+                BotMap const* botmap = itr->GetSource()->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = botmap->begin(); itr != botmap->end(); ++itr)
+                {
+                    Creature* cre = itr->second;
+                    if (!cre || !cre->IsInWorld() || cre->FindMap() != this || cre->IsTempBot())
+                        continue;
+                    ++count;
+                }
+            }
+            else
+            //end npcbot
             ++count;
     return count;
 }
@@ -2553,6 +2572,10 @@ void Map::AddToActive(Creature* c)
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->incUnloadActiveLock();
+        //bot
+        else if (c->GetIAmABot())
+            EnsureGridLoadedForActiveObject(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())), c);
+        //end bot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
@@ -2584,6 +2607,10 @@ void Map::RemoveFromActive(Creature* c)
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->decUnloadActiveLock();
+        //bot
+        else if (c->GetIAmABot())
+            EnsureGridLoaded(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())));
+        //end bot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
diff --git a/src/server/game/Maps/MapManager.cpp b/src/server/game/Maps/MapManager.cpp
index 2e034f5..ab902ec 100644
--- a/src/server/game/Maps/MapManager.cpp
+++ b/src/server/game/Maps/MapManager.cpp
@@ -37,6 +37,10 @@
 #include "WorldSession.h"
 #include "Opcodes.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 extern GridState* si_GridStates[];                          // debugging code, should be deleted some day
 
 MapManager::MapManager()
@@ -62,6 +66,10 @@ void MapManager::Initialize()
     // Start mtmaps if needed.
     if (num_threads > 0 && m_updater.activate(num_threads) == -1)
         abort();
+
+    //npcbot: load bots
+    BotMgr::Initialize();
+    //end npcbot
 }
 
 void MapManager::InitializeVisibilityDistanceInfo()
diff --git a/src/server/game/Movement/MotionMaster.cpp b/src/server/game/Movement/MotionMaster.cpp
index 6085571..16b89a7 100644
--- a/src/server/game/Movement/MotionMaster.cpp
+++ b/src/server/game/Movement/MotionMaster.cpp
@@ -367,6 +367,20 @@ void MotionMaster::MoveJump(float x, float y, float z, float speedXY, float spee
 {
     TC_LOG_DEBUG("misc", "Unit (GUID: %u) jump to point (X: %f Y: %f Z: %f)", _owner->GetGUIDLow(), x, y, z);
 
+    //npcbot
+    if (_owner->GetTypeId() == TYPEID_UNIT && _owner->ToCreature()->IsNPCBot())
+    {
+        Movement::MoveSplineInit init(_owner);
+        init.MoveTo(x, y, z);
+        init.SetParabolic(speedZ/*max_height*/, 0);
+        init.SetOrientationFixed(true);
+        init.SetVelocity(speedXY);
+        init.Launch();
+        Mutate(new EffectMovementGenerator(0), MOTION_SLOT_CONTROLLED);
+        return;
+    }
+    //end npcbot
+
     float moveTimeHalf = speedZ / Movement::gravity;
     float max_height = -Movement::computeFallElevation(moveTimeHalf, false, -speedZ);
 
diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.cpp b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
index 8daafc4..e80117f 100644
--- a/src/server/game/OutdoorPvP/OutdoorPvP.cpp
+++ b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
@@ -308,6 +308,23 @@ bool OPvPCapturePoint::Update(uint32 diff)
     if (!fact_diff)
         return false;
 
+    //npcbots - count bots as players but 2 times less affect and only if there is a players difference
+    uint32 botsCount[2];
+
+    for (uint8 team = 0; team != 2; ++team)
+    {
+        botsCount[team] = 0;
+
+        for (PlayerSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        {
+            if (Player* player = ObjectAccessor::FindPlayer(*itr))
+                botsCount[team] += player->GetNpcBotsCount();
+        }
+    }
+
+    fact_diff += 0.5f * ((float)botsCount[0] - (float)botsCount[1]) * diff / OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL;
+    //end npcbot
+
     uint32 Challenger = 0;
     float maxDiff = m_maxSpeed * diff;
 
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 3b340f8..dc4bb3e 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1434,6 +1434,22 @@ void AddBattlegroundScripts()
 
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
+//Bots
+void AddSC_death_knight_bot();
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_blademaster_bot();
+void AddSC_script_bot_commands();
+//advanced
+//void AddSC_BotQuests_chapter1();
+//end Bots
 
 #endif
 
@@ -1441,6 +1457,22 @@ void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
+    //Bots
+    AddSC_death_knight_bot();
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_blademaster_bot();
+    AddSC_script_bot_commands();
+    //advanced
+    //AddSC_BotQuests_chapter1();
+    //end Bots
 
 #endif
 }
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 82cc1c9..c6c65ef 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -436,6 +436,10 @@ void WorldSession::LogoutPlayer(bool save)
     m_playerLogout = true;
     m_playerSave = save;
 
+    //npcbot - free all bots and remove from botmap
+    _player->RemoveAllBots();
+    //end npcbots
+
     if (_player)
     {
         if (uint64 lguid = _player->GetLootGUID())
diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
index 2a6d530..b2cf555 100644
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
@@ -794,6 +794,25 @@ void AuraEffect::UpdatePeriodic(Unit* caster)
                         case 49472: // Drink Coffee
                         case 57073:
                         case 61830:
+                            //npcbot: fix normal drink spells for bots
+                            if (caster && caster->GetTypeId() == TYPEID_UNIT)
+                            {
+                                if (AuraEffect* aurEff = GetBase()->GetEffect(0))
+                                {
+                                    if (aurEff->GetAuraType() != SPELL_AURA_MOD_POWER_REGEN)
+                                    {
+                                        m_isPeriodic = false;
+                                        TC_LOG_ERROR("spells", "Aura %d structure has been changed - first aura is no longer SPELL_AURA_MOD_POWER_REGEN", GetId());
+                                    }
+                                    else
+                                    {
+                                        aurEff->ChangeAmount(GetAmount());
+                                        m_isPeriodic = false;
+                                    }
+                                }
+                                break;
+                            }
+                            //end npcbot
                             if (!caster || caster->GetTypeId() != TYPEID_PLAYER)
                                 return;
                             // Get SPELL_AURA_MOD_POWER_REGEN aura from spell
@@ -4646,6 +4665,11 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
                     if (target->GetTypeId() == TYPEID_PLAYER)
                         if (Unit* spellTarget = ObjectAccessor::GetUnit(*target, target->ToPlayer()->GetComboTarget()))
                             target->CastSpell(spellTarget, 51699, true);
+                    //npcbot: handle for bots
+                    if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBot())
+                        if (Unit* spellTarget = target->GetVictim())
+                            target->CastSpell(spellTarget, 51699, true);
+                    //end npcbot
                    break;
                 case 71563:
                     if (Aura* newAura = target->AddAura(71564, target))
diff --git a/src/server/game/Spells/Auras/SpellAuras.cpp b/src/server/game/Spells/Auras/SpellAuras.cpp
index efacdd1..8fb17a8 100644
--- a/src/server/game/Spells/Auras/SpellAuras.cpp
+++ b/src/server/game/Spells/Auras/SpellAuras.cpp
@@ -419,6 +419,10 @@ void Aura::_ApplyForTarget(Unit* target, Unit* caster, AuraApplication * auraApp
             caster->ToPlayer()->AddSpellAndCategoryCooldowns(m_spellInfo, castItem ? castItem->GetEntry() : 0, NULL, true);
         }
     }
+    //npcbot: infinity cd for bots
+    if (caster && m_spellInfo->IsCooldownStartedOnEvent() && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        caster->ToCreature()->AddBotSpellCooldown(m_spellInfo->Id, std::numeric_limits<uint32>::max());
+    //end npcbot
 }
 
 void Aura::_UnapplyForTarget(Unit* target, Unit* caster, AuraApplication * auraApp)
@@ -450,6 +454,10 @@ void Aura::_UnapplyForTarget(Unit* target, Unit* caster, AuraApplication * auraA
             // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existed cases)
             caster->ToPlayer()->SendCooldownEvent(GetSpellInfo());
     }
+    //npcbot: release cd state for bots
+    if (caster && m_spellInfo->IsCooldownStartedOnEvent() && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        caster->ToCreature()->ReleaseBotSpellCooldown(m_spellInfo->Id);
+    //end npcbot
 }
 
 // removes aura from all targets
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index c6ac5c2..6fa2af0 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -1594,6 +1594,11 @@ void Spell::SelectImplicitChainTargets(SpellEffIndex effIndex, SpellImplicitTarg
     if (Player* modOwner = m_caster->GetSpellModOwner())
         modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_JUMP_TARGETS, maxTargets, this);
 
+    //npcbot - apply bot spell max targets mods
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+        m_caster->ToCreature()->ApplyCreatureSpellMaxTargetsMods(m_spellInfo, maxTargets);
+    //end npcbot
+
     if (maxTargets > 1)
     {
         // mark damage multipliers as used
@@ -2528,6 +2533,13 @@ void Spell::DoAllEffectOnTarget(TargetInfo* target)
             if (caster->GetTypeId() == TYPEID_PLAYER && (m_spellInfo->Attributes & SPELL_ATTR0_STOP_ATTACK_TARGET) == 0 &&
                (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
                 caster->ToPlayer()->CastItemCombatSpell(unitTarget, m_attackType, procVictim, procEx);
+
+            //npcbot - CastItemCombatSpell for bots
+            if (caster->GetTypeId() == TYPEID_UNIT &&
+                caster->ToCreature()->IsNPCBot() && !(m_spellInfo->Attributes & SPELL_ATTR0_STOP_ATTACK_TARGET) &&
+               (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
+               caster->ToCreature()->CastCreatureItemCombatSpell(unitTarget, m_attackType, procVictim, procEx);
+            //end npcbot
         }
 
 
@@ -3547,7 +3559,16 @@ void Spell::SendSpellCooldown()
 {
     Player* _player = m_caster->ToPlayer();
     if (!_player)
+    {
+        Creature* _creature = m_caster->ToCreature();
+        if (_creature && !_creature->IsPet() && !_creature->IsGuardian() && !_creature->IsNPCBot())
+        {
+            //TC_LOG_ERROR("spells", "Adding spell CD of %s (normal): %u", m_spellInfo->SpellName[0], uint32(m_spellInfo->GetRecoveryTime()/IN_MILLISECONDS));
+            _creature->AddCreatureSpellCooldown(m_spellInfo->Id);
+        }
+
         return;
+    }
 
     // mana/health/etc potions, disabled by client (until combat out as declarate)
     if (m_CastItem && (m_CastItem->IsPotion() || m_spellInfo->IsCooldownStartedOnEvent()))
@@ -3719,6 +3740,9 @@ void Spell::finish(bool ok)
 
     // Stop Attack for some spells
     if (m_spellInfo->Attributes & SPELL_ATTR0_STOP_ATTACK_TARGET)
+    //npcbot - disable for npcbots
+    if (!(m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot()))
+    //end npcbot
         m_caster->AttackStop();
 }
 
@@ -3924,6 +3948,11 @@ void Spell::SendSpellStart()
 
 void Spell::SendSpellGo()
 {
+    //npcbot - hook for spellcast finish
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+        m_caster->ToCreature()->OnSpellGo(this);
+    //end npcbot
+
     // not send invisible spell casting
     if (!IsNeedSendToClient())
         return;
@@ -4432,6 +4461,26 @@ void Spell::TakePower()
                     }
     }
 
+    //npcbot: handle SPELLMOD_SPELL_COST_REFUND_ON_FAIL (druid Primal Precision)
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot() && m_caster->ToCreature()->GetBotClass() == CLASS_DRUID)
+    {
+        if (powerType == POWER_ENERGY/* || powerType == POWER_RAGE || powerType == POWER_RUNE*/)
+            if (uint64 targetGUID = m_targets.GetUnitTargetGUID())
+                for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                    if (ihit->targetGUID == targetGUID)
+                    {
+                        if (ihit->missCondition != SPELL_MISS_NONE)
+                        {
+                            hit = false;
+                            //Primal Precision: 80% refund
+                            if ((m_spellInfo->SpellFamilyFlags[0] & 800000) || (m_spellInfo->SpellFamilyFlags[1] & 10000080))
+                                m_powerCost = m_powerCost / 5;
+                        }
+                        break;
+                    }
+    }
+    //end npcbot
+
     if (powerType == POWER_RUNE)
     {
         TakeRunePower(hit);
@@ -4747,6 +4796,19 @@ SpellCastResult Spell::CheckCast(bool strict)
         }
     }
 
+    if (m_caster->GetTypeId() == TYPEID_UNIT && !m_spellInfo->IsPassive() && !m_caster->ToCreature()->IsNPCBot())
+    {
+        //TC_LOG_ERROR("spells", "%s checks cd on %s, curtime %u", m_caster->GetName().c_str(), m_spellInfo->SpellName[0], time(NULL) % 10000);
+        if (m_caster->ToCreature()->HasSpellCooldown(m_spellInfo->Id))
+        {
+            //TC_LOG_ERROR("spells", "%s has cd of %u on %s", m_caster->GetName().c_str(), m_caster->ToCreature()->GetCreatureSpellCooldownDelay(m_spellInfo->Id), m_spellInfo->SpellName[0]);
+            if (m_triggeredByAuraSpell)
+                return SPELL_FAILED_DONT_REPORT;
+            else
+                return SPELL_FAILED_NOT_READY;
+        }
+    }
+
     if (m_spellInfo->AttributesEx7 & SPELL_ATTR7_IS_CHEAT_SPELL && !m_caster->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS))
     {
         m_customError = SPELL_CUSTOM_ERROR_GM_ONLY;
@@ -5786,6 +5848,11 @@ SpellCastResult Spell::CheckRange(bool strict)
     if (Player* modOwner = m_caster->GetSpellModOwner())
         modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, max_range, this);
 
+    //npcbot: apply range mods
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+        m_caster->ToCreature()->ApplyCreatureSpellRangeMods(m_spellInfo, max_range);
+    //end npcbot
+
     if (target && target != m_caster)
     {
         if (range_type == SPELL_RANGE_MELEE)
@@ -6862,6 +6929,13 @@ SpellCastResult Spell::CanOpenLock(uint32 effIndex, uint32 lockId, SkillType& sk
                     skillValue = m_CastItem || m_caster->GetTypeId()!= TYPEID_PLAYER ?
                         0 : m_caster->ToPlayer()->GetSkillValue(skillId);
 
+                    //npcbot: use bot skill if cast through gossip
+                    if (m_originalCasterGUID)
+                        if (Unit const* unit = sObjectAccessor->FindUnit(m_originalCasterGUID))
+                            if (unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->GetBotClass() == CLASS_ROGUE)
+                                skillValue = std::max<int32>(skillValue, int32(unit->getLevel() * 5));
+                    //end npcbot
+
                     // skill bonus provided by casting spell (mostly item spells)
                     // add the effect base points modifier from the spell casted (cheat lock / skeleton key etc.)
                     if (m_spellInfo->Effects[effIndex].TargetA.GetTarget() == TARGET_GAMEOBJECT_ITEM_TARGET || m_spellInfo->Effects[effIndex].TargetB.GetTarget() == TARGET_GAMEOBJECT_ITEM_TARGET)
diff --git a/src/server/game/Spells/Spell.h b/src/server/game/Spells/Spell.h
index 927ecd3..14ec724 100644
--- a/src/server/game/Spells/Spell.h
+++ b/src/server/game/Spells/Spell.h
@@ -455,6 +455,7 @@ class Spell
 
         UsedSpellMods m_appliedMods;
 
+        int32 GetTimer() const { return m_timer; }
         int32 GetCastTime() const { return m_casttime; }
         bool IsAutoRepeat() const { return m_autoRepeat; }
         void SetAutoRepeat(bool rep) { m_autoRepeat = rep; }
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index 868dc3f..60138b7 100644
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -497,6 +497,17 @@ void Spell::EffectSchoolDMG(SpellEffIndex effIndex)
                     damage += int32(energy * multiple);
                     damage += int32(CalculatePct(m_caster->ToPlayer()->GetComboPoints() * ap, 7));
                 }
+                //npcbot: Ferocious Bite support
+                else if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot() && (m_spellInfo->SpellFamilyFlags[0] & 0x800000) && m_spellInfo->SpellVisual[0] == 6587)
+                {
+                    // converts each extra point of energy into ($f1+$AP/410) additional damage
+                    float ap = m_caster->GetTotalAttackPowerValue(BASE_ATTACK);
+                    float multiple = ap / 410 + m_spellInfo->Effects[effIndex].DamageMultiplier;
+                    int32 energy = -(m_caster->ModifyPower(POWER_ENERGY, -30));
+                    damage += int32(energy * multiple);
+                    damage += int32(CalculatePct(m_caster->ToCreature()->GetCreatureComboPoints() * ap, 7));
+                }
+                //end npcbot
                 // Wrath
                 else if (m_spellInfo->SpellFamilyFlags[0] & 0x00000001)
                 {
@@ -556,6 +567,52 @@ void Spell::EffectSchoolDMG(SpellEffIndex effIndex)
                                 damage += combo * 40;
                         }
                     }
+                    //npcbot: Envenom support
+                    else if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+                    {
+                        // consume from stack dozes not more that have combo-points
+                        if (uint8 combo = m_caster->ToCreature()->GetCreatureComboPoints())
+                        {
+                            // Lookup for Deadly poison (only attacker applied)
+                            if (AuraEffect const* aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x00010000, 0, 0, m_caster->GetGUID()))
+                            {
+                                // count consumed deadly poison doses at target
+                                bool needConsume = true;
+                                uint32 spellId = aurEff->GetId();
+
+                                uint32 doses = aurEff->GetBase()->GetStackAmount();
+                                if (doses > combo)
+                                    doses = combo;
+
+                                // Master Poisoner
+                                Unit::AuraEffectList const& auraList = player->GetAuraEffectsByType(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK);
+                                for (Unit::AuraEffectList::const_iterator iter = auraList.begin(); iter != auraList.end(); ++iter)
+                                {
+                                    if ((*iter)->GetSpellInfo()->SpellFamilyName == SPELLFAMILY_ROGUE && (*iter)->GetSpellInfo()->SpellIconID == 1960)
+                                    {
+                                        uint32 chance = (*iter)->GetSpellInfo()->Effects[EFFECT_2].CalcValue(m_caster);
+
+                                        if (chance && roll_chance_i(chance))
+                                            needConsume = false;
+
+                                        break;
+                                    }
+                                }
+
+                                if (needConsume)
+                                    for (uint32 i = 0; i < doses; ++i)
+                                        unitTarget->RemoveAuraFromStack(spellId, m_caster->GetGUID());
+
+                                damage *= doses;
+                                damage += int32(player->GetTotalAttackPowerValue(BASE_ATTACK) * 0.09f * combo);
+                            }
+
+                            // Eviscerate and Envenom Bonus Damage (item set effect)
+                            if (m_caster->HasAura(37169))
+                                damage += combo * 40;
+                        }
+                    }
+                    //end npcbot
                 }
                 // Eviscerate
                 else if (m_spellInfo->SpellFamilyFlags[0] & 0x00020000)
@@ -572,6 +629,20 @@ void Spell::EffectSchoolDMG(SpellEffIndex effIndex)
                                 damage += combo*40;
                         }
                     }
+                    //npcbot: Eviscerate support
+                    else if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+                    {
+                        if (uint32 combo = m_caster->ToCreature()->GetCreatureComboPoints())
+                        {
+                            float ap = m_caster->GetTotalAttackPowerValue(BASE_ATTACK);
+                            damage += irand(int32(ap * combo * 0.03f), int32(ap * combo * 0.07f));
+
+                            // Eviscerate and Envenom Bonus Damage (item set effect)
+                            if (m_caster->HasAura(37169))
+                                damage += combo*40;
+                        }
+                    }
+                    //end npcbot
                 }
                 break;
             }
@@ -617,6 +688,22 @@ void Spell::EffectSchoolDMG(SpellEffIndex effIndex)
                             damage += int32(caster->GetAmmoDPS() * weaponTemplate->Delay * 0.001f);
                         }
                     }
+                    //npcbot: calculate bot weapon dmage
+                    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+                    {
+                        if (Item* item = m_caster->ToCreature()->GetBotEquips(2/*BOT_SLOT_RANGED*/))
+                        {
+                            ItemTemplate const* weaponTemplate = item->GetTemplate();
+                            float dmg_min = weaponTemplate->Damage[0].DamageMin;
+                            float dmg_max = weaponTemplate->Damage[0].DamageMax;
+                            if (dmg_max == 0.0f && dmg_min > dmg_max)
+                                damage += int32(dmg_min);
+                            else
+                                damage += irand(int32(dmg_min), int32(dmg_max));
+                            damage += int32(m_caster->ToCreature()->GetCreatureAmmoDPS() * weaponTemplate->Delay * 0.001f);
+                        }
+                    }
+                    //end npcbot
                 }
                 break;
             }
@@ -3236,6 +3323,14 @@ void Spell::EffectWeaponDmg(SpellEffIndex effIndex)
                     if (Item* item = m_caster->ToPlayer()->GetWeaponForAttack(m_attackType, true))
                         if (item->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)
                             totalDamagePercentMod *= 1.5f;
+
+                //npcbot: handle bot weapons
+                // 50% more damage with daggers
+                if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+                    if (Item const* weapon = m_caster->ToCreature()->GetBotEquips(m_attackType))
+                        if (weapon->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)
+                            totalDamagePercentMod *= 1.5f;
+                //end npcbot
             }
             // Mutilate (for each hand)
             else if (m_spellInfo->SpellFamilyFlags[1] & 0x6)
@@ -3514,6 +3609,7 @@ void Spell::EffectInterruptCast(SpellEffIndex effIndex)
             {
                 if (m_originalCaster)
                 {
+                    //TC_LOG_ERROR("spells", "Prohibiting %s's %s and schools for %u", unitTarget->GetName().c_str(), m_spellInfo->SpellName[0], m_spellInfo->GetDuration());
                     int32 duration = m_spellInfo->GetDuration();
                     unitTarget->ProhibitSpellSchool(curSpellInfo->GetSchoolMask(), unitTarget->ModSpellDuration(m_spellInfo, unitTarget, duration, false, 1 << effIndex));
                 }
diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
index 6b54df2..927602e 100644
--- a/src/server/game/Spells/SpellInfo.cpp
+++ b/src/server/game/Spells/SpellInfo.cpp
@@ -447,6 +447,13 @@ int32 SpellEffectInfo::CalcValue(Unit const* caster, int32 const* bp, Unit const
                 if (float comboDamage = PointsPerComboPoint)
                     value += comboDamage* comboPoints;
 
+        //npcbot: bonus amount from combo points
+        if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+            if (uint8 comboPoints = caster->ToCreature()->GetCreatureComboPoints())
+                if (float comboDamage = PointsPerComboPoint)
+                    value += comboDamage * comboPoints;
+        //end npcbot
+
         value = caster->ApplyEffectModifiers(_spellInfo, _effIndex, value);
 
         // amount multiplication based on caster's level
@@ -546,6 +553,11 @@ float SpellEffectInfo::CalcRadius(Unit* caster, Spell* spell) const
         radius = std::min(radius, RadiusEntry->RadiusMax);
         if (Player* modOwner = caster->GetSpellModOwner())
             modOwner->ApplySpellMod(_spellInfo->Id, SPELLMOD_RADIUS, radius, spell);
+
+        //npcbot - apply bot spell radius mods
+        if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+            caster->ToCreature()->ApplyCreatureSpellRadiusMods(_spellInfo, radius);
+        //end npcbot
     }
 
     return radius;
@@ -2212,6 +2224,11 @@ int32 SpellInfo::CalcPowerCost(Unit const* caster, SpellSchoolMask schoolMask) c
         }
     }
 
+    //npcbot - apply bot spell cost mods
+    if (powerCost > 0 && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        caster->ToCreature()->ApplyCreatureSpellCostMods(this, powerCost);
+    //end npcbot
+
     // PCT mod from user auras by school
     powerCost = int32(powerCost * (1.0f + caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER + school)));
     if (powerCost < 0)
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index d8dc19c..3aea810 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -1431,6 +1431,9 @@ void World::SetInitialWorldSettings()
     TC_LOG_INFO("server.loading", "Loading Creature templates...");
     sObjectMgr->LoadCreatureTemplates();
 
+    TC_LOG_INFO("server.loading", "Loading Creature template outfits...");     // must be after LoadCreatureTemplates
+    sObjectMgr->LoadCreatureOutfits();
+
     TC_LOG_INFO("server.loading", "Loading Equipment templates...");           // must be after LoadCreatureTemplates
     sObjectMgr->LoadEquipmentTemplates();
 
diff --git a/src/server/scripts/Spells/spell_hunter.cpp b/src/server/scripts/Spells/spell_hunter.cpp
index b93efe3..75b96a1 100644
--- a/src/server/scripts/Spells/spell_hunter.cpp
+++ b/src/server/scripts/Spells/spell_hunter.cpp
@@ -751,6 +751,22 @@ class spell_hun_sniper_training : public SpellScriptLoader
 
             void HandleUpdatePeriodic(AuraEffect* aurEff)
             {
+                //npcbot: handle creatures, remove dead trigger
+                if (!GetUnitOwner()->IsAlive())
+                    return;
+                if (Creature const* bot = GetUnitOwner()->ToCreature())
+                {
+                    if (!bot->IsNPCBot())
+                        return;
+
+                    int32 baseAmount = aurEff->GetBaseAmount();
+                    int32 amount = bot->isMoving() ?
+                    bot->CalculateSpellDamage(bot, GetSpellInfo(), aurEff->GetEffIndex(), &baseAmount) :
+                    aurEff->GetAmount() - 1;
+                    aurEff->SetAmount(amount);
+                    return;
+                }
+                //end npcbot
                 if (Player* playerTarget = GetUnitOwner()->ToPlayer())
                 {
                     int32 baseAmount = aurEff->GetBaseAmount();
diff --git a/src/server/scripts/Spells/spell_paladin.cpp b/src/server/scripts/Spells/spell_paladin.cpp
index 18d3e07..35a06c5 100644
--- a/src/server/scripts/Spells/spell_paladin.cpp
+++ b/src/server/scripts/Spells/spell_paladin.cpp
@@ -102,6 +102,12 @@ class spell_pal_ardent_defender : public SpellScriptLoader
             {
                 healPct = GetSpellInfo()->Effects[EFFECT_1].CalcValue();
                 absorbPct = GetSpellInfo()->Effects[EFFECT_0].CalcValue();
+
+                //npcbot - allow for npcbots
+                if (GetUnitOwner()->GetTypeId() == TYPEID_UNIT && GetUnitOwner()->ToCreature()->IsNPCBot())
+                    return true;
+                //end npcbot
+
                 return GetUnitOwner()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -116,6 +122,41 @@ class spell_pal_ardent_defender : public SpellScriptLoader
                 Unit* victim = GetTarget();
                 int32 remainingHealth = victim->GetHealth() - dmgInfo.GetDamage();
                 uint32 allowedHealth = victim->CountPctFromMaxHealth(35);
+
+                //npcbot - calc for bots
+                if (victim->GetTypeId() == TYPEID_UNIT/* && victim->ToCreature()->IsNPCBot()*/)
+                {
+                    if (remainingHealth <= 0 && !victim->ToCreature()->HasSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
+                    {
+                        // Cast healing spell, completely avoid damage
+                        absorbAmount = dmgInfo.GetDamage();
+
+                        uint32 defenseSkillValue = victim->GetDefenseSkillValue();
+                        // Max heal when defense skill denies critical hits from raid bosses
+                        // Formula: max defense at level + 140 (raiting from gear)
+                        uint32 reqDefForMaxHeal  = victim->getLevel() * 5 + 140;
+                        float pctFromDefense = (defenseSkillValue >= reqDefForMaxHeal)
+                            ? 1.0f
+                            : float(defenseSkillValue) / float(reqDefForMaxHeal);
+
+                        int32 healAmount = int32(victim->CountPctFromMaxHealth(int32(healPct * pctFromDefense)));
+                        victim->CastCustomSpell(victim, PAL_SPELL_ARDENT_DEFENDER_HEAL, &healAmount, NULL, NULL, true, NULL, aurEff);
+                        victim->ToCreature()->_AddCreatureSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL, time(NULL) + 120);
+                        victim->ToCreature()->AddBotSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL, 120 * IN_MILLISECONDS);
+                    }
+                    else if (remainingHealth < int32(allowedHealth))
+                    {
+                        // Reduce damage that brings us under 35% (or full damage if we are already under 35%) by x%
+                        uint32 damageToReduce = (victim->GetHealth() < allowedHealth)
+                            ? dmgInfo.GetDamage()
+                            : allowedHealth - remainingHealth;
+                        absorbAmount = CalculatePct(damageToReduce, absorbPct);
+                    }
+
+                    return;
+                }
+                //end npcbot
+
                 // If damage kills us
                 if (remainingHealth <= 0 && !victim->ToPlayer()->HasSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
                 {
@@ -364,6 +405,23 @@ class spell_pal_divine_sacrifice : public SpellScriptLoader
 
                 if (Unit* caster = GetCaster())
                 {
+                    //npcbot: handle for bots
+                    if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+                    {
+                        Player const* owner = caster->ToCreature()->GetBotOwner();
+                        if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+                            return false;
+
+                        if (owner->GetGroup())
+                            groupSize = owner->GetGroup()->GetMembersCount();
+                        else
+                            groupSize = 1;
+
+                        remainingAmount = (caster->CountPctFromMaxHealth(GetSpellInfo()->Effects[EFFECT_2].CalcValue(caster)) * groupSize);
+                        minHpPct = GetSpellInfo()->Effects[EFFECT_1].CalcValue(caster);
+                        return true;
+                    }
+                    //end npcbot
                     if (caster->GetTypeId() == TYPEID_PLAYER)
                     {
                         if (caster->ToPlayer()->GetGroup())
@@ -781,6 +839,31 @@ class spell_pal_improved_aura : public SpellScriptLoader
             {
                 Unit* target = GetTarget();
                 if (!target->GetOwnedAura(_spellId))
+                    //npcbot - spellmod for bots
+                    if (IS_CREATURE_GUID(GetCasterGUID()) && GetCaster()->ToCreature()->IsNPCBot())
+                    {
+                        int32 bp1 = 0;
+                        int32 bp2 = 0;
+
+                        switch (_spellId)
+                        {
+                            case SPELL_PALADIN_IMPROVED_CONCENTRACTION_AURA:
+                                bp1 = 30;
+                                bp2 = 30;
+                                break;
+                            case SPELL_PALADIN_IMPROVED_DEVOTION_AURA:
+                                bp1 = 6;
+                                break;
+                            case SPELL_PALADIN_SANCTIFIED_RETRIBUTION_AURA:
+                                bp1 = 3;
+                                bp2 = 3;
+                                break;
+                        }
+
+                        target->CastCustomSpell(target, _spellId, NULL, &bp1, &bp2, true);
+                    }
+                    else
+                    //end npcbot
                     target->CastSpell(target, _spellId, true);
             }
 
@@ -997,6 +1080,9 @@ class spell_pal_righteous_defense : public SpellScriptLoader
             {
                 Unit* caster = GetCaster();
                 if (caster->GetTypeId() != TYPEID_PLAYER)
+                //npcbot: this player check makes no sense
+                if (!(caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot()))
+                //end npcbot
                     return SPELL_FAILED_DONT_REPORT;
 
                 if (Unit* target = GetExplTargetUnit())
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index 0d3da30..a1a9cb8 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -413,6 +413,7 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load() OVERRIDE
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot()) return true;
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -455,6 +456,8 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Player* caster = GetCaster()->ToPlayer();
+                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot())
+                    caster = (Player*)GetCaster();
                 if (Unit* target = GetExplTargetUnit())
                     if (!caster->IsFriendlyTo(target) && !caster->IsValidAttackTarget(target))
                         return SPELL_FAILED_BAD_TARGETS;
@@ -596,6 +599,7 @@ class spell_pri_renew : public SpellScriptLoader
 
             bool Load() OVERRIDE
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/scripts/Spells/spell_rogue.cpp b/src/server/scripts/Spells/spell_rogue.cpp
index 6e88fb7..913071a 100644
--- a/src/server/scripts/Spells/spell_rogue.cpp
+++ b/src/server/scripts/Spells/spell_rogue.cpp
@@ -114,6 +114,10 @@ class spell_rog_cheat_death : public SpellScriptLoader
             bool Load() OVERRIDE
             {
                 absorbChance = GetSpellInfo()->Effects[EFFECT_0].CalcValue();
+                //npcbot
+                if (GetUnitOwner()->GetTypeId() == TYPEID_UNIT && GetUnitOwner()->ToCreature()->IsNPCBot())
+                    return true;
+                //end npcbot
                 return GetUnitOwner()->ToPlayer();
             }
 
@@ -125,6 +129,26 @@ class spell_rog_cheat_death : public SpellScriptLoader
 
             void Absorb(AuraEffect* /*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
             {
+                //npcbot
+                if (Creature* bot = GetTarget()->ToCreature())
+                {
+                    if (!bot->IsNPCBot() || dmgInfo.GetDamage() < bot->GetHealth() || bot->HasSpellCooldown(SPELL_ROGUE_CHEAT_DEATH_COOLDOWN))
+                        return;
+
+                    bot->CastSpell(bot, SPELL_ROGUE_CHEAT_DEATH_COOLDOWN, true);
+                    bot->AddBotSpellCooldown(SPELL_ROGUE_CHEAT_DEATH_COOLDOWN, 60000);
+
+                    uint32 health10 = bot->CountPctFromMaxHealth(10);
+
+                    if (bot->GetHealth() > health10)
+                        absorbAmount = dmgInfo.GetDamage() - bot->GetHealth() + health10;
+                    else
+                        absorbAmount = dmgInfo.GetDamage();
+
+                    return;
+                }
+                //end npcbot
+
                 Player* target = GetTarget()->ToPlayer();
                 if (dmgInfo.GetDamage() < target->GetHealth() || target->HasSpellCooldown(SPELL_ROGUE_CHEAT_DEATH_COOLDOWN) ||  !roll_chance_i(absorbChance))
                     return;
@@ -418,6 +442,10 @@ class spell_rog_rupture : public SpellScriptLoader
             bool Load() OVERRIDE
             {
                 Unit* caster = GetCaster();
+                //npcbot
+                if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+                    return true;
+                //end npcbot
                 return caster && caster->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -437,6 +465,18 @@ class spell_rog_rupture : public SpellScriptLoader
                         0.0375f         // 5 points: ${($m1 + $b1*5 + 0.0375 * $AP) * 8} damage over 16 secs
                     };
 
+                    //npcbot
+                    if (caster->GetTypeId() == TYPEID_UNIT)
+                    {
+                        uint8 cp = caster->ToCreature()->GetCreatureComboPoints();
+                        if (cp > 5)
+                            cp = 5;
+
+                        amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) * attackpowerPerCombo[cp]);
+                        return;
+                    }
+                    //end npcbot
+
                     uint8 cp = caster->ToPlayer()->GetComboPoints();
                     if (cp > 5)
                         cp = 5;
diff --git a/src/server/scripts/Spells/spell_shaman.cpp b/src/server/scripts/Spells/spell_shaman.cpp
index eb71731..9bdb620 100644
--- a/src/server/scripts/Spells/spell_shaman.cpp
+++ b/src/server/scripts/Spells/spell_shaman.cpp
@@ -360,6 +360,16 @@ class spell_sha_earthbind_totem : public SpellScriptLoader
             {
                 if (!GetCaster())
                     return;
+
+                //npcbot: workaround for bots
+                if (uint64 creatorGuid = GetCaster()->GetCreatorGUID())
+                    if (!IS_PLAYER_GUID(creatorGuid))
+                        if (Creature const* bot = ObjectAccessor::GetObjectInWorld(creatorGuid, (Creature*)NULL))
+                            if (AuraEffect const* aur = bot->GetDummyAuraEffect(SPELLFAMILY_SHAMAN, 2289, 0))
+                                if (roll_chance_i(aur->GetBaseAmount()))
+                                    return GetTarget()->CastSpell((Unit*)NULL, SPELL_SHAMAN_TOTEM_EARTHEN_POWER, true);
+                //end npcbot
+
                 if (Player* owner = GetCaster()->GetCharmerOrOwnerPlayerOrPlayerItself())
                     if (AuraEffect* aur = owner->GetDummyAuraEffect(SPELLFAMILY_SHAMAN, 2289, 0))
                         if (roll_chance_i(aur->GetBaseAmount()))
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.cpp b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
index da99d6c..5b21d33 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
@@ -600,4 +600,19 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_UPD_CHAR_PET_SLOT_BY_ID, "UPDATE character_pet SET slot = ? WHERE owner = ? AND id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_ID, "DELETE FROM character_pet WHERE id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_SLOT, "DELETE FROM character_pet WHERE owner = ? AND (slot = ? OR slot > ?)", CONNECTION_ASYNC);
+
+    // Bot
+    PrepareStatement(CHAR_UPD_NPCBOT_OWNER, "UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_OWNER_ALL, "UPDATE characters_npcbot SET owner = ? WHERE owner = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_ROLES, "UPDATE characters_npcbot SET roles = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE, "SELECT ii.creatorGuid, ii.giftCreatorGuid, ii.count, ii.duration, ii.charges, ii.flags, ii.enchantments, ii.randomPropertyId, ii.durability, ii.playedTime, ii.text, ii.guid, ii.itemEntry, ii.owner_guid "
+        "FROM item_instance ii JOIN characters_npcbot cn ON ii.guid IN "
+        "(cn.equipMhEx, cn.equipOhEx, cn.equipRhEx, cn.equipHead, cn.equipShoulders, cn.equipChest, cn.equipWaist, cn.equipLegs, cn.equipFeet, cn.equipWrist, cn.equipHands, cn.equipBack, cn.equipBody, cn.equipFinger1, cn.equipFinger2, cn.equipTrinket1, cn.equipTrinket2, cn.equipNeck) "
+        "WHERE cn.entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_EQUIP, "UPDATE characters_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, "
+        "equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?, equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_NPCBOT, "DELETE FROM characters_npcbot WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_NPCBOT, "INSERT INTO characters_npcbot (entry, roles) VALUES (?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_FACTION, "UPDATE characters_npcbot SET faction = ? WHERE entry = ?", CONNECTION_ASYNC);
+    // End Bot
 }
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.h b/src/server/shared/Database/Implementation/CharacterDatabase.h
index aa47fb5..f9e0dbc 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.h
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.h
@@ -532,6 +532,17 @@ enum CharacterDatabaseStatements
     CHAR_DEL_ITEMCONTAINER_MONEY,
     CHAR_INS_ITEMCONTAINER_MONEY,
 
+    // Bot
+    CHAR_UPD_NPCBOT_OWNER,
+    CHAR_UPD_NPCBOT_OWNER_ALL,
+    CHAR_UPD_NPCBOT_ROLES,
+    CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE,
+    CHAR_UPD_NPCBOT_EQUIP,
+    CHAR_DEL_NPCBOT,
+    CHAR_INS_NPCBOT,
+    CHAR_UPD_NPCBOT_FACTION,
+    // End Bot
+
     MAX_CHARACTERDATABASE_STATEMENTS
 };
 
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 4e594fc..f08fb78 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2816,3 +2816,118 @@ PacketSpoof.BanDuration = 86400
 
 #
 ###################################################################################################
+
+
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#    NpcBot.Enable
+#        Description: Enable NpcBot system
+#        Default:   1 - enable
+#                   0 - disable
+
+NpcBot.Enable = 1
+
+#    NpcBot.MaxBots
+#        Description: Maximum number of bots allowed for players.
+#        Default:   1
+#        Recommend: 1-2
+#        Max:       4
+
+NpcBot.MaxBots = 1
+
+#    NpcBot.MaxBotsPerClass
+#        Description: Maximum bots of each class allowed for players.
+#        Default:   1
+#                   0 - no limit
+
+NpcBot.MaxBotsPerClass = 1
+
+#    NpcBot.BaseFollowDistance
+#        Description: Default bot follow distance.
+#        Note: This parameter determines bots' formation size, distance at which bots will chase and attack enemies.
+#        Note2: This parameter is set for each player at login.
+#        Default:   30
+
+NpcBot.BaseFollowDistance = 30
+
+#    NpcBot.XpReduction
+#        Description: XP percent penalty for each bot used starting with second.
+#        Example: 3 bots, xp reduction is 20: ((3-1)*20) = 40%, 60% exp gained only.
+#        Note: Maximum overall xp reduction is 90%.
+#        Default:   0
+
+NpcBot.XpReduction = 0
+
+#    NpcBot.HealTargetIconsMask
+#        Description: Icon number bitmask which bots use to search for additional targets to heal (out of party).
+#        Note: Many creatures cannot accept heal.
+#        Example: to check Star, Triangle and Square we need 1 + 8 + 32 = 41.
+#        Default:   0 (Disable)
+#                   1 - Star
+#                   2 - Circle
+#                   4 - Diamond
+#                   8 - Triangle
+#                   16 - Moon
+#                   32 - Square
+#                   64 - Cross
+#                   128 - Skull
+
+NpcBot.HealTargetIconsMask = 0
+
+#    NpcBot.Mult.Damage.Melee
+#    NpcBot.Mult.Damage.Spell
+#    NpcBot.Mult.Healing
+#        Description: Multipliers for bots' damage and healing. Allows to balance bots vs players.
+#        Minimum:   0.1
+#        Maximum:  10.0
+#        Default:   1.0
+
+NpcBot.Mult.Damage.Melee = 1.0
+NpcBot.Mult.Damage.Spell = 1.0
+NpcBot.Mult.Healing      = 1.0
+
+#    NpcBot.Enable.Dungeon
+#    NpcBot.Enable.Raid
+#    NpcBot.Enable.BG
+#    NpcBot.Enable.Arena
+#    NpcBot.Enable.DungeonFinder
+#        Description: Allow bots to enter PvE/PvP areas and Dungeon Finder query
+#        Default:   1 - (NpcBot.Enable.Dungeon)
+#                   0 - (NpcBot.Enable.Raid)
+#                   0 - (NpcBot.Enable.BG)
+#                   0 - (NpcBot.Enable.Arena)
+#                   1 - (NpcBot.Enable.DungeonFinder)
+
+NpcBot.Enable.Dungeon       = 1
+NpcBot.Enable.Raid          = 0
+NpcBot.Enable.BG            = 0
+NpcBot.Enable.Arena         = 0
+NpcBot.Enable.DungeonFinder = 1
+
+#    NpcBot.Limit.Dungeon
+#    NpcBot.Limit.Raid
+#        Description: Enable/Disable instance players limitation rules for bots.
+#        Default:   1 - (NpcBot.Limit.Dungeon)
+#                   1 - (NpcBot.Limit.Raid)
+
+NpcBot.Limit.Dungeon = 1
+NpcBot.Limit.Raid    = 1
+
+#    NpcBot.Cost
+#        Description: Bot recruitment cost (in copper).
+#        Note: This value is for level 80 characters.
+#              Cost is reduced for lower levels by simple formula: (cost * level / 80).
+#        Default:   1000000 (100 gold, 1g25s at level 1)
+
+NpcBot.Cost = 1000000
+
+#    NpcBot.PvP
+#        Description: Allow bots to attack player-controlled units (players, pets, bots, etc.)
+#        Note: This rule only applies to player-controlled bots
+#        Default:   1
+
+NpcBot.PvP = 1
+
+#
+###################################################################################################
-- 
2.10.0.windows.1

